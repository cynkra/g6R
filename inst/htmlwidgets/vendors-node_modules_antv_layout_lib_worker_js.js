/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@antv/event-emitter/esm/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/event-emitter/esm/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var WILDCARD = '*';
/* event-emitter */
var EventEmitter = /** @class */ (function () {
    function EventEmitter() {
        this._events = {};
    }
    /**
     * 监听一个事件
     * @param evt
     * @param callback
     * @param once
     */
    EventEmitter.prototype.on = function (evt, callback, once) {
        if (!this._events[evt]) {
            this._events[evt] = [];
        }
        this._events[evt].push({
            callback: callback,
            once: !!once,
        });
        return this;
    };
    /**
     * 监听一个事件一次
     * @param evt
     * @param callback
     */
    EventEmitter.prototype.once = function (evt, callback) {
        return this.on(evt, callback, true);
    };
    /**
     * 触发一个事件
     * @param evt
     * @param args
     */
    EventEmitter.prototype.emit = function (evt) {
        var _this = this;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var events = this._events[evt] || [];
        var wildcardEvents = this._events[WILDCARD] || [];
        // 实际的处理 emit 方法
        var doEmit = function (es) {
            var length = es.length;
            for (var i = 0; i < length; i++) {
                if (!es[i]) {
                    continue;
                }
                var _a = es[i], callback = _a.callback, once = _a.once;
                if (once) {
                    es.splice(i, 1);
                    if (es.length === 0) {
                        delete _this._events[evt];
                    }
                    length--;
                    i--;
                }
                callback.apply(_this, args);
            }
        };
        doEmit(events);
        doEmit(wildcardEvents);
    };
    /**
     * 取消监听一个事件，或者一个channel
     * @param evt
     * @param callback
     */
    EventEmitter.prototype.off = function (evt, callback) {
        if (!evt) {
            // evt 为空全部清除
            this._events = {};
        }
        else {
            if (!callback) {
                // evt 存在，callback 为空，清除事件所有方法
                delete this._events[evt];
            }
            else {
                // evt 存在，callback 存在，清除匹配的
                var events = this._events[evt] || [];
                var length_1 = events.length;
                for (var i = 0; i < length_1; i++) {
                    if (events[i].callback === callback) {
                        events.splice(i, 1);
                        length_1--;
                        i--;
                    }
                }
                if (events.length === 0) {
                    delete this._events[evt];
                }
            }
        }
        return this;
    };
    /* 当前所有的事件 */
    EventEmitter.prototype.getEvents = function () {
        return this._events;
    };
    return EventEmitter;
}());
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (EventEmitter);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/graphlib/esm/graph.js":
/*!**************************************************!*\
  !*** ./node_modules/@antv/graphlib/esm/graph.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Graph: () => (/* binding */ Graph)
/* harmony export */ });
/* harmony import */ var _antv_event_emitter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/event-emitter */ "./node_modules/@antv/event-emitter/esm/index.js");
/* harmony import */ var _graphView__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./graphView */ "./node_modules/@antv/graphlib/esm/graphView.js");
/* harmony import */ var _utils_traverse__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/traverse */ "./node_modules/@antv/graphlib/esm/utils/traverse.js");



class Graph extends _antv_event_emitter__WEBPACK_IMPORTED_MODULE_0__["default"] {
    nodeMap = new Map();
    edgeMap = new Map();
    inEdgesMap = new Map();
    outEdgesMap = new Map();
    bothEdgesMap = new Map();
    treeIndices = new Map();
    changes = [];
    batchCount = 0;
    /**
     * This function is called with a {@link GraphChangedEvent} each time a graph change happened.
     *
     * `event.changes` contains all the graph changes in order since last `onChanged`.
     */
    onChanged = () => {
        // Do nothing.
    };
    /**
     * Create a new Graph instance.
     * @param options - The options to initialize a graph. See {@link GraphOptions}.
     *
     * ```ts
     * const graph = new Graph({
     *   // Optional, initial nodes.
     *   nodes: [
     *     // Each node has a unique ID.
     *     { id: 'A', foo: 1 },
     *     { id: 'B', foo: 1 },
     *   ],
     *   // Optional, initial edges.
     *   edges: [
     *     { id: 'C', source: 'B', target: 'B', weight: 1 },
     *   ],
     *   // Optional, called with a GraphChangedEvent.
     *   onChanged: (event) => {
     *     console.log(event);
     *   }
     * });
     * ```
     */
    constructor(options) {
        super();
        if (!options)
            return;
        if (options.nodes)
            this.addNodes(options.nodes);
        if (options.edges)
            this.addEdges(options.edges);
        if (options.tree)
            this.addTree(options.tree);
        if (options.onChanged)
            this.onChanged = options.onChanged;
    }
    /**
     * Batch several graph changes into one.
     *
     * Make several changes, but dispatch only one ChangedEvent at the end of batch:
     * ```ts
     * graph.batch(() => {
     *   graph.addNodes([]);
     *   graph.addEdges([]);
     * });
     * ```
     *
     * Batches can be nested. Only the outermost batch will dispatch a ChangedEvent:
     * ```ts
     * graph.batch(() => {
     *   graph.addNodes([]);
     *   graph.batch(() => {
     *     graph.addEdges([]);
     *   });
     * });
     * ```
     */
    batch = (fn) => {
        this.batchCount += 1;
        fn();
        this.batchCount -= 1;
        if (!this.batchCount) {
            this.commit();
        }
    };
    /**
     * Reset changes and dispatch a ChangedEvent.
     */
    commit() {
        const changes = this.changes;
        this.changes = [];
        const event = {
            graph: this,
            changes,
        };
        this.emit('changed', event);
        this.onChanged(event);
    }
    /**
     * Reduce the number of ordered graph changes by dropping or merging unnecessary changes.
     *
     * For example, if we update a node and remove it in a batch:
     *
     * ```ts
     * graph.batch(() => {
     *   graph.updateNodeData('A', 'foo', 2);
     *   graph.removeNode('A');
     * });
     * ```
     *
     * We get 2 atomic graph changes like
     *
     * ```ts
     * [
     *   { type: 'NodeDataUpdated', id: 'A', propertyName: 'foo', oldValue: 1, newValue: 2 },
     *   { type: 'NodeRemoved', value: { id: 'A', data: { foo: 2 } },
     * ]
     * ```
     *
     * Since node 'A' has been removed, we actually have no need to handle with NodeDataUpdated change.
     *
     * `reduceChanges()` here helps us remove such changes.
     */
    reduceChanges(changes) {
        let mergedChanges = [];
        changes.forEach((change) => {
            switch (change.type) {
                case 'NodeRemoved': {
                    // NodeAdded: A added.
                    // NodeDataUpdated: A changed.
                    // TreeStructureChanged: A's parent changed.
                    // NodeRemoved: A removed. 👈🏻 Since A was removed, above three changes may be ignored.
                    let isNewlyAdded = false;
                    mergedChanges = mergedChanges.filter((pastChange) => {
                        if (pastChange.type === 'NodeAdded') {
                            const sameId = pastChange.value.id === change.value.id;
                            if (sameId) {
                                isNewlyAdded = true;
                            }
                            return !sameId;
                        }
                        else if (pastChange.type === 'NodeDataUpdated') {
                            return pastChange.id !== change.value.id;
                        }
                        else if (pastChange.type === 'TreeStructureChanged') {
                            return pastChange.nodeId !== change.value.id;
                        }
                        return true;
                    });
                    if (!isNewlyAdded) {
                        mergedChanges.push(change);
                    }
                    break;
                }
                case 'EdgeRemoved': {
                    // EdgeAdded: A added.
                    // EdgeDataUpdated: A changed.
                    // EdgeDataUpdated: A's source/target changed.
                    // EdgeRemoved: A removed. 👈🏻 Since A was removed, above three changes may be ignored.
                    let isNewlyAdded = false;
                    mergedChanges = mergedChanges.filter((pastChange) => {
                        if (pastChange.type === 'EdgeAdded') {
                            const sameId = pastChange.value.id === change.value.id;
                            if (sameId) {
                                isNewlyAdded = true;
                            }
                            return !sameId;
                        }
                        else if (pastChange.type === 'EdgeDataUpdated' ||
                            pastChange.type === 'EdgeUpdated') {
                            return pastChange.id !== change.value.id;
                        }
                        return true;
                    });
                    if (!isNewlyAdded) {
                        mergedChanges.push(change);
                    }
                    break;
                }
                case 'NodeDataUpdated':
                case 'EdgeDataUpdated':
                case 'EdgeUpdated': {
                    // NodeDataUpdated: { id: A, propertyName: 'foo', oldValue: 1, newValue: 2 }.
                    // NodeDataUpdated: { id: A, propertyName: 'foo', oldValue: 2, newValue: 3 }.
                    // 👆 Could be merged as { id: A, propertyName: 'foo', oldValue: 1, newValue: 3 }.
                    const index = mergedChanges.findIndex((pastChange) => {
                        return (pastChange.type === change.type &&
                            pastChange.id === change.id &&
                            (change.propertyName === undefined ||
                                pastChange.propertyName === change.propertyName));
                    });
                    const existingChange = mergedChanges[index];
                    if (existingChange) {
                        if (change.propertyName !== undefined) {
                            // The incoming change is of the same property of existing change.
                            existingChange.newValue = change.newValue;
                        }
                        else {
                            // The incoming change is a whole data override.
                            mergedChanges.splice(index, 1);
                            mergedChanges.push(change);
                        }
                    }
                    else {
                        mergedChanges.push(change);
                    }
                    break;
                }
                case 'TreeStructureDetached': {
                    // TreeStructureAttached
                    // TreeStructureChanged
                    // TreeStructureDetached 👈🏻 Since the tree struct was detached, above 2 changes may be ignored.
                    mergedChanges = mergedChanges.filter((pastChange) => {
                        if (pastChange.type === 'TreeStructureAttached') {
                            return pastChange.treeKey !== change.treeKey;
                        }
                        else if (pastChange.type === 'TreeStructureChanged') {
                            return pastChange.treeKey !== change.treeKey;
                        }
                        return true;
                    });
                    mergedChanges.push(change);
                    break;
                }
                case 'TreeStructureChanged': {
                    const existingChange = mergedChanges.find((pastChange) => {
                        return (pastChange.type === 'TreeStructureChanged' &&
                            pastChange.treeKey === change.treeKey &&
                            pastChange.nodeId === change.nodeId);
                    });
                    if (existingChange) {
                        existingChange.newParentId =
                            change.newParentId;
                    }
                    else {
                        mergedChanges.push(change);
                    }
                    break;
                }
                default:
                    mergedChanges.push(change);
                    break;
            }
        });
        return mergedChanges;
    }
    // ================= Node =================
    checkNodeExistence(id) {
        this.getNode(id);
    }
    /**
     * Check if a node exists in the graph.
     * @group NodeMethods
     */
    hasNode(id) {
        return this.nodeMap.has(id);
    }
    /**
     * Tell if two nodes are neighbors.
     * @group NodeMethods
     */
    areNeighbors(firstNodeId, secondNodeId) {
        return this.getNeighbors(secondNodeId).some((neighbor) => neighbor.id === firstNodeId);
    }
    /**
     * Get the node data with given ID.
     * @group NodeMethods
     */
    getNode(id) {
        const node = this.nodeMap.get(id);
        if (!node) {
            throw new Error('Node not found for id: ' + id);
        }
        return node;
    }
    /**
     * Given a node ID, find all edges of the node.
     * @param id - ID of the node
     * @param direction - Edge direction, defaults to 'both'.
     * @group NodeMethods
     */
    getRelatedEdges(id, direction) {
        this.checkNodeExistence(id);
        if (direction === 'in') {
            const inEdges = this.inEdgesMap.get(id);
            return Array.from(inEdges);
        }
        else if (direction === 'out') {
            const outEdges = this.outEdgesMap.get(id);
            return Array.from(outEdges);
        }
        else {
            const bothEdges = this.bothEdgesMap.get(id);
            return Array.from(bothEdges);
        }
    }
    /**
     * Get the degree of the given node.
     * @group NodeMethods
     */
    getDegree(id, direction) {
        return this.getRelatedEdges(id, direction).length;
    }
    /**
     * Get all successors of the given node.
     */
    getSuccessors(id) {
        const outEdges = this.getRelatedEdges(id, 'out');
        const targets = outEdges.map((edge) => this.getNode(edge.target));
        return Array.from(new Set(targets));
    }
    /**
     * Get all predecessors of the given node.
     */
    getPredecessors(id) {
        const inEdges = this.getRelatedEdges(id, 'in');
        const sources = inEdges.map((edge) => this.getNode(edge.source));
        return Array.from(new Set(sources));
    }
    /**
     * Given a node ID, find its neighbors.
     * @param id - ID of the node
     * @group NodeMethods
     */
    getNeighbors(id) {
        const predecessors = this.getPredecessors(id);
        const successors = this.getSuccessors(id);
        return Array.from(new Set([...predecessors, ...successors]));
    }
    doAddNode(node) {
        if (this.hasNode(node.id)) {
            throw new Error('Node already exists: ' + node.id);
        }
        this.nodeMap.set(node.id, node);
        this.inEdgesMap.set(node.id, new Set());
        this.outEdgesMap.set(node.id, new Set());
        this.bothEdgesMap.set(node.id, new Set());
        this.treeIndices.forEach((tree) => {
            tree.childrenMap.set(node.id, new Set());
        });
        this.changes.push({ type: 'NodeAdded', value: node });
    }
    /**
     * Add all nodes of the given array, or iterable, into the graph.
     * @group NodeMethods
     */
    addNodes(nodes) {
        this.batch(() => {
            for (const node of nodes) {
                this.doAddNode(node);
            }
        });
    }
    /**
     * Add a single node into the graph.
     * @group NodeMethods
     */
    addNode(node) {
        this.addNodes([node]);
    }
    doRemoveNode(id) {
        const node = this.getNode(id);
        const bothEdges = this.bothEdgesMap.get(id);
        bothEdges?.forEach((edge) => this.doRemoveEdge(edge.id));
        this.nodeMap.delete(id);
        this.treeIndices.forEach((tree) => {
            tree.childrenMap.get(id)?.forEach((child) => {
                tree.parentMap.delete(child.id);
            });
            const parent = tree.parentMap.get(id);
            if (parent)
                tree.childrenMap.get(parent.id)?.delete(node);
            tree.parentMap.delete(id);
            tree.childrenMap.delete(id);
        });
        this.bothEdgesMap.delete(id);
        this.inEdgesMap.delete(id);
        this.outEdgesMap.delete(id);
        this.changes.push({ type: 'NodeRemoved', value: node });
    }
    /**
     * Remove nodes and their attached edges from the graph.
     * @group NodeMethods
     */
    removeNodes(idList) {
        this.batch(() => {
            idList.forEach((id) => this.doRemoveNode(id));
        });
    }
    /**
     * Remove a single node and its attached edges from the graph.
     * @group NodeMethods
     */
    removeNode(id) {
        this.removeNodes([id]);
    }
    updateNodeDataProperty(id, propertyName, value) {
        const node = this.getNode(id);
        this.batch(() => {
            const oldValue = node.data[propertyName];
            const newValue = value;
            node.data[propertyName] = newValue;
            this.changes.push({
                type: 'NodeDataUpdated',
                id,
                propertyName,
                oldValue,
                newValue,
            });
        });
    }
    /**
     * Like Object.assign, merge all properties of `path` to the node data.
     * @param id Node ID.
     * @param patch A data object to merge.
     */
    mergeNodeData(id, patch) {
        this.batch(() => {
            Object.entries(patch).forEach(([propertyName, value]) => {
                this.updateNodeDataProperty(id, propertyName, value);
            });
        });
    }
    updateNodeData(...args) {
        const id = args[0];
        const node = this.getNode(id);
        if (typeof args[1] === 'string') {
            // id, propertyName, value
            this.updateNodeDataProperty(id, args[1], args[2]);
            return;
        }
        let data;
        if (typeof args[1] === 'function') {
            // id, update
            const update = args[1];
            data = update(node.data);
        }
        else if (typeof args[1] === 'object') {
            // id, data
            data = args[1];
        }
        this.batch(() => {
            const oldValue = node.data;
            const newValue = data;
            node.data = data;
            this.changes.push({
                type: 'NodeDataUpdated',
                id,
                oldValue,
                newValue,
            });
        });
    }
    // ================= Edge =================
    checkEdgeExistence(id) {
        if (!this.hasEdge(id)) {
            throw new Error('Edge not found for id: ' + id);
        }
    }
    /**
     * Check if an edge exists in the graph.
     * @group NodeMethods
     */
    hasEdge(id) {
        return this.edgeMap.has(id);
    }
    /**
     * Get the edge data with given ID.
     * @group EdgeMethods
     */
    getEdge(id) {
        this.checkEdgeExistence(id);
        return this.edgeMap.get(id);
    }
    /**
     * Get the edge, the source node, and the target node by an edge ID.
     * @group EdgeMethods
     */
    getEdgeDetail(id) {
        const edge = this.getEdge(id);
        return {
            edge,
            source: this.getNode(edge.source),
            target: this.getNode(edge.target),
        };
    }
    doAddEdge(edge) {
        if (this.hasEdge(edge.id)) {
            throw new Error('Edge already exists: ' + edge.id);
        }
        this.checkNodeExistence(edge.source);
        this.checkNodeExistence(edge.target);
        this.edgeMap.set(edge.id, edge);
        const inEdges = this.inEdgesMap.get(edge.target);
        const outEdges = this.outEdgesMap.get(edge.source);
        const bothEdgesOfSource = this.bothEdgesMap.get(edge.source);
        const bothEdgesOfTarget = this.bothEdgesMap.get(edge.target);
        inEdges.add(edge);
        outEdges.add(edge);
        bothEdgesOfSource.add(edge);
        bothEdgesOfTarget.add(edge);
        this.changes.push({ type: 'EdgeAdded', value: edge });
    }
    /**
     * Add all edges of the given iterable(an array, a set, etc.) into the graph.
     * @group EdgeMethods
     */
    addEdges(edges) {
        this.batch(() => {
            for (const edge of edges) {
                this.doAddEdge(edge);
            }
        });
    }
    /**
     * Add a single edge pointing from `source` to `target` into the graph.
     *
     * ```ts
     * graph.addNode({ id: 'NodeA' });
     * graph.addNode({ id: 'NodeB' });
     * graph.addEdge({ id: 'EdgeA', source: 'NodeA', target: 'NodeB' });
     * ```
     *
     * If `source` or `target` were not found in the current graph, it throws an Error.
     * @group EdgeMethods
     */
    addEdge(edge) {
        this.addEdges([edge]);
    }
    doRemoveEdge(id) {
        const edge = this.getEdge(id);
        const outEdges = this.outEdgesMap.get(edge.source);
        const inEdges = this.inEdgesMap.get(edge.target);
        const bothEdgesOfSource = this.bothEdgesMap.get(edge.source);
        const bothEdgesOfTarget = this.bothEdgesMap.get(edge.target);
        outEdges.delete(edge);
        inEdges.delete(edge);
        bothEdgesOfSource.delete(edge);
        bothEdgesOfTarget.delete(edge);
        this.edgeMap.delete(id);
        this.changes.push({ type: 'EdgeRemoved', value: edge });
    }
    /**
     * Remove edges whose id was included in the given id list.
     * @group EdgeMethods
     */
    removeEdges(idList) {
        this.batch(() => {
            idList.forEach((id) => this.doRemoveEdge(id));
        });
    }
    /**
     * Remove a single edge of the given id.
     * @group EdgeMethods
     */
    removeEdge(id) {
        this.removeEdges([id]);
    }
    /**
     * Change the source of an edge. The source must be found in current graph.
     * @group EdgeMethods
     */
    updateEdgeSource(id, source) {
        const edge = this.getEdge(id);
        this.checkNodeExistence(source);
        const oldSource = edge.source;
        const newSource = source;
        this.outEdgesMap.get(oldSource).delete(edge);
        this.bothEdgesMap.get(oldSource).delete(edge);
        this.outEdgesMap.get(newSource).add(edge);
        this.bothEdgesMap.get(newSource).add(edge);
        edge.source = source;
        this.batch(() => {
            this.changes.push({
                type: 'EdgeUpdated',
                id,
                propertyName: 'source',
                oldValue: oldSource,
                newValue: newSource,
            });
        });
    }
    /**
     * Change the target of an edge. The target must be found in current graph.
     * @group EdgeMethods
     */
    updateEdgeTarget(id, target) {
        const edge = this.getEdge(id);
        this.checkNodeExistence(target);
        const oldTarget = edge.target;
        const newTarget = target;
        this.inEdgesMap.get(oldTarget).delete(edge);
        this.bothEdgesMap.get(oldTarget).delete(edge);
        this.inEdgesMap.get(newTarget).add(edge);
        this.bothEdgesMap.get(newTarget).add(edge);
        edge.target = target;
        this.batch(() => {
            this.changes.push({
                type: 'EdgeUpdated',
                id,
                propertyName: 'target',
                oldValue: oldTarget,
                newValue: newTarget,
            });
        });
    }
    updateEdgeDataProperty(id, propertyName, value) {
        const edge = this.getEdge(id);
        this.batch(() => {
            const oldValue = edge.data[propertyName];
            const newValue = value;
            edge.data[propertyName] = newValue;
            this.changes.push({
                type: 'EdgeDataUpdated',
                id,
                propertyName,
                oldValue,
                newValue,
            });
        });
    }
    updateEdgeData(...args) {
        const id = args[0];
        const edge = this.getEdge(id);
        if (typeof args[1] === 'string') {
            // id, propertyName, value
            this.updateEdgeDataProperty(id, args[1], args[2]);
            return;
        }
        let data;
        if (typeof args[1] === 'function') {
            // id, update
            const update = args[1];
            data = update(edge.data);
        }
        else if (typeof args[1] === 'object') {
            // id, data
            data = args[1];
        }
        this.batch(() => {
            const oldValue = edge.data;
            const newValue = data;
            edge.data = data;
            this.changes.push({
                type: 'EdgeDataUpdated',
                id,
                oldValue,
                newValue,
            });
        });
    }
    /**
     * @group EdgeMethods
     */
    mergeEdgeData(id, patch) {
        this.batch(() => {
            Object.entries(patch).forEach(([propertyName, value]) => {
                this.updateEdgeDataProperty(id, propertyName, value);
            });
        });
    }
    // ================= Tree =================
    checkTreeExistence(treeKey) {
        if (!this.hasTreeStructure(treeKey)) {
            throw new Error('Tree structure not found for treeKey: ' + treeKey);
        }
    }
    hasTreeStructure(treeKey) {
        return this.treeIndices.has(treeKey);
    }
    /**
     * Attach a new tree structure representing the hierarchy of all nodes in the graph.
     * @param treeKey A unique key of the tree structure. You can attach multiple tree structures with different keys.
     *
     * ```ts
     * const graph = new Graph({
     *   nodes: [{ id: 1 }, { id: 2 }, { id: 3 }],
     * });
     * graph.attachTreeStructure('Inheritance');
     * graph.setParent(2, 1, 'Inheritance');
     * graph.setParent(3, 1, 'Inheritance');
     * graph.getRoots('Inheritance'); // [1]
     * graph.getChildren(1, 'Inheritance'); // [2,3]
     * ```
     * @group TreeMethods
     */
    attachTreeStructure(treeKey) {
        if (this.treeIndices.has(treeKey)) {
            // Already attached.
            return;
        }
        this.treeIndices.set(treeKey, {
            parentMap: new Map(),
            childrenMap: new Map(),
        });
        this.batch(() => {
            this.changes.push({
                type: 'TreeStructureAttached',
                treeKey,
            });
        });
    }
    /**
     * Detach the tree structure of the given tree key from the graph.
     *
     * ```ts
     * graph.detachTreeStructure('Inheritance');
     * graph.getRoots('Inheritance'); // Error!
     * ```
     * @group TreeMethods
     */
    detachTreeStructure(treeKey) {
        this.checkTreeExistence(treeKey);
        this.treeIndices.delete(treeKey);
        this.batch(() => {
            this.changes.push({
                type: 'TreeStructureDetached',
                treeKey,
            });
        });
    }
    /**
     * Traverse the given tree data, add each node into the graph, then attach the tree structure.
     *
     * ```ts
     * graph.addTree({
     *   id: 1,
     *   children: [
     *     { id: 2 },
     *     { id: 3 },
     *   ],
     * }, 'Inheritance');
     * graph.getRoots('Inheritance'); // [1]
     * graph.getChildren(1, 'Inheritance'); // [2, 3]
     * graph.getAllNodes(); // [1, 2, 3]
     * graph.getAllEdges(); // []
     * ```
     * @group TreeMethods
     */
    addTree(tree, treeKey) {
        this.batch(() => {
            this.attachTreeStructure(treeKey);
            // Add Nodes
            const nodes = [];
            const stack = Array.isArray(tree) ? tree : [tree];
            while (stack.length) {
                const node = stack.shift();
                nodes.push(node);
                if (node.children) {
                    stack.push(...node.children);
                }
            }
            this.addNodes(nodes);
            // Set parent for each child node.
            nodes.forEach((parent) => {
                parent.children?.forEach((child) => {
                    this.setParent(child.id, parent.id, treeKey);
                });
            });
        });
    }
    /**
     * Get the root nodes of an attached tree structure.
     *
     * Consider a graph with the following tree structure attached:
     * ```
     * Tree structure:
     *    O     3
     *   / \    |
     *  1   2   4
     * ```
     * `graph.getRoots()` takes all nodes without a parent, therefore [0, 3] was returned.
     *
     * Newly added nodes are also unparented. So they are counted as roots.
     * ```ts
     * graph.addNode({ id: 5 });
     * graph.getRoots(); // [0, 3, 5]
     * ```
     *
     * Here is how the tree structure looks like:
     * ```
     * Tree structure:
     *    O     3  5
     *   / \    |
     *  1   2   4
     * ```
     *
     * By setting a parent, a root node no more be a root.
     * ```ts
     * graph.setParent(5, 2);
     * graph.getRoots(); // [0, 3]
     * ```
     *
     * The tree structure now becomes:
     * ```
     * Tree structure:
     *    O     3
     *   / \    |
     *  1   2   4
     *      |
     *      5
     * ```
     *
     * Removing a node forces its children to be unparented, or roots.
     * ```ts
     * graph.removeNode(0);
     * graph.getRoots(); // [1, 2, 3]
     * ```
     *
     * You might draw the the structure as follow:
     * ```
     * Tree structure:
     *  1   2  3
     *      |  |
     *      5  4
     * ```
     * @group TreeMethods
     */
    getRoots(treeKey) {
        this.checkTreeExistence(treeKey);
        return this.getAllNodes().filter((node) => !this.getParent(node.id, treeKey));
    }
    /**
     * Given a node ID and an optional tree key, get the children of the node in the specified tree structure.
     * @group TreeMethods
     */
    getChildren(id, treeKey) {
        this.checkNodeExistence(id);
        this.checkTreeExistence(treeKey);
        const tree = this.treeIndices.get(treeKey);
        const children = tree.childrenMap.get(id);
        return Array.from(children || []);
    }
    /**
     * Given a node ID and an optional tree key, get the parent of the node in the specified tree structure.
     * If the given node is one of the tree roots, this returns null.
     * @group TreeMethods
     */
    getParent(id, treeKey) {
        this.checkNodeExistence(id);
        this.checkTreeExistence(treeKey);
        const tree = this.treeIndices.get(treeKey);
        return tree.parentMap.get(id) || null;
    }
    /**
     * Returns an array of all the ancestor nodes, staring from the parent to the root.
     */
    getAncestors(id, treeKey) {
        const ancestors = [];
        let current = this.getNode(id);
        let parent;
        // eslint-disable-next-line no-cond-assign
        while ((parent = this.getParent(current.id, treeKey))) {
            ancestors.push(parent);
            current = parent;
        }
        return ancestors;
    }
    /**
     * Set node parent. If this operation causes a circle, it fails with an error.
     * @param id - ID of the child node.
     * @param parent - ID of the parent node. If it is undefined or null, means unset parent for node with id.
     * @param treeKey - Which tree structure the relation is applied to.
     * @group TreeMethods
     */
    setParent(id, parent, treeKey) {
        this.checkTreeExistence(treeKey);
        const tree = this.treeIndices.get(treeKey);
        if (!tree)
            return;
        const node = this.getNode(id);
        const oldParent = tree.parentMap.get(id);
        // Same parent id as old one, skip
        if (oldParent?.id === parent)
            return;
        // New parent is undefined or null, unset parent for the node
        if (parent === undefined || parent === null) {
            if (oldParent) {
                tree.childrenMap.get(oldParent.id)?.delete(node);
            }
            tree.parentMap.delete(id);
            return;
        }
        const newParent = this.getNode(parent);
        // Set parent
        tree.parentMap.set(id, newParent);
        // Set children
        if (oldParent) {
            tree.childrenMap.get(oldParent.id)?.delete(node);
        }
        let children = tree.childrenMap.get(newParent.id);
        if (!children) {
            children = new Set();
            tree.childrenMap.set(newParent.id, children);
        }
        children.add(node);
        this.batch(() => {
            this.changes.push({
                type: 'TreeStructureChanged',
                treeKey,
                nodeId: id,
                oldParentId: oldParent?.id,
                newParentId: newParent.id,
            });
        });
    }
    dfsTree(id, fn, treeKey) {
        const navigator = (nodeId) => this.getChildren(nodeId, treeKey);
        return (0,_utils_traverse__WEBPACK_IMPORTED_MODULE_1__.doDFS)(this.getNode(id), new Set(), fn, navigator);
    }
    bfsTree(id, fn, treeKey) {
        const navigator = (nodeId) => this.getChildren(nodeId, treeKey);
        return (0,_utils_traverse__WEBPACK_IMPORTED_MODULE_1__.doBFS)([this.getNode(id)], new Set(), fn, navigator);
    }
    // ================= Graph =================
    /**
     * Get all nodes in the graph as an array.
     */
    getAllNodes() {
        return Array.from(this.nodeMap.values());
    }
    /**
     * Get all edges in the graph as an array.
     */
    getAllEdges() {
        return Array.from(this.edgeMap.values());
    }
    bfs(id, fn, direction = 'out') {
        const navigator = {
            in: this.getPredecessors.bind(this),
            out: this.getSuccessors.bind(this),
            both: this.getNeighbors.bind(this),
        }[direction];
        return (0,_utils_traverse__WEBPACK_IMPORTED_MODULE_1__.doBFS)([this.getNode(id)], new Set(), fn, navigator);
    }
    dfs(id, fn, direction = 'out') {
        const navigator = {
            in: this.getPredecessors.bind(this),
            out: this.getSuccessors.bind(this),
            both: this.getNeighbors.bind(this),
        }[direction];
        return (0,_utils_traverse__WEBPACK_IMPORTED_MODULE_1__.doDFS)(this.getNode(id), new Set(), fn, navigator);
    }
    clone() {
        // Make a shallow copy of nodes and edges.
        const newNodes = this.getAllNodes().map((oldNode) => {
            return { ...oldNode, data: { ...oldNode.data } };
        });
        const newEdges = this.getAllEdges().map((oldEdge) => {
            return { ...oldEdge, data: { ...oldEdge.data } };
        });
        // Create a new graph with shallow copied nodes and edges.
        const newGraph = new Graph({
            nodes: newNodes,
            edges: newEdges,
        });
        // Add tree indices.
        this.treeIndices.forEach(({ parentMap: oldParentMap, childrenMap: oldChildrenMap }, treeKey) => {
            const parentMap = new Map();
            oldParentMap.forEach((parent, key) => {
                parentMap.set(key, newGraph.getNode(parent.id));
            });
            const childrenMap = new Map();
            oldChildrenMap.forEach((children, key) => {
                childrenMap.set(key, new Set(Array.from(children).map((n) => newGraph.getNode(n.id))));
            });
            newGraph.treeIndices.set(treeKey, {
                parentMap: parentMap,
                childrenMap: childrenMap,
            });
        });
        return newGraph;
    }
    toJSON() {
        return JSON.stringify({
            nodes: this.getAllNodes(),
            edges: this.getAllEdges(),
            // FIXME: And tree structures?
        });
    }
    createView(options) {
        return new _graphView__WEBPACK_IMPORTED_MODULE_2__.GraphView({
            graph: this,
            ...options,
        });
    }
}
//# sourceMappingURL=graph.js.map

/***/ }),

/***/ "./node_modules/@antv/graphlib/esm/graphView.js":
/*!******************************************************!*\
  !*** ./node_modules/@antv/graphlib/esm/graphView.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GraphView: () => (/* binding */ GraphView)
/* harmony export */ });
/* harmony import */ var _utils_traverse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/traverse */ "./node_modules/@antv/graphlib/esm/utils/traverse.js");

const defaultFilter = () => true;
class GraphView {
    graph;
    nodeFilter;
    edgeFilter;
    // caches
    cacheEnabled;
    inEdgesMap = new Map();
    outEdgesMap = new Map();
    bothEdgesMap = new Map();
    allNodesMap = new Map();
    allEdgesMap = new Map();
    constructor(options) {
        this.graph = options.graph;
        const nodeFilter = options.nodeFilter || defaultFilter;
        const edgeFilter = options.edgeFilter || defaultFilter;
        this.nodeFilter = nodeFilter;
        this.edgeFilter = (edge) => {
            const { source, target } = this.graph.getEdgeDetail(edge.id);
            if (!nodeFilter(source) || !nodeFilter(target)) {
                return false;
            }
            return edgeFilter(edge, source, target);
        };
        if (options.cache === 'auto') {
            this.cacheEnabled = true;
            this.startAutoCache();
        }
        else if (options.cache === 'manual') {
            this.cacheEnabled = true;
        }
        else {
            this.cacheEnabled = false;
        }
    }
    /**
     * Clear all cache data. Therefore `getAllNodes()` will return `[]`.
     * If you want to disable caching, use `graphView.cacheEnabled = false` instead.
     */
    clearCache = () => {
        this.inEdgesMap.clear();
        this.outEdgesMap.clear();
        this.bothEdgesMap.clear();
        this.allNodesMap.clear();
        this.allEdgesMap.clear();
    };
    /**
     * Fully refresh all cache data to the current graph state.
     */
    refreshCache = () => {
        this.clearCache();
        this.updateCache(this.graph.getAllNodes().map((node) => node.id));
    };
    /**
     * Instead of a fully refreshment, this method partially update the cache data by specifying
     * involved(added, removed, updated) nodes. It's more efficient when handling small changes
     * on a large graph.
     */
    updateCache = (involvedNodeIds) => {
        const involvedEdgeIds = new Set();
        involvedNodeIds.forEach((id) => {
            // Collect all involved old edges.
            const oldEdgesSet = this.bothEdgesMap.get(id);
            if (oldEdgesSet) {
                oldEdgesSet.forEach((edge) => involvedEdgeIds.add(edge.id));
            }
            if (!this.hasNode(id)) {
                // When an involved node becomes unvisitable:
                // 1. Delete its related edges cache.
                this.inEdgesMap.delete(id);
                this.outEdgesMap.delete(id);
                this.bothEdgesMap.delete(id);
                // 2. Delete it from the allNodesMap.
                this.allNodesMap.delete(id);
            }
            else {
                // When an involved node becomes or stays visitable:
                // 1. Collect its new edges.
                const inEdges = this.graph
                    .getRelatedEdges(id, 'in')
                    .filter(this.edgeFilter);
                const outEdges = this.graph
                    .getRelatedEdges(id, 'out')
                    .filter(this.edgeFilter);
                const bothEdges = Array.from(new Set([...inEdges, ...outEdges]));
                bothEdges.forEach((edge) => involvedEdgeIds.add(edge.id));
                // 2. Update its related edges cache.
                this.inEdgesMap.set(id, inEdges);
                this.outEdgesMap.set(id, outEdges);
                this.bothEdgesMap.set(id, bothEdges);
                // 3. Add to allNodesMap.
                this.allNodesMap.set(id, this.graph.getNode(id));
            }
        });
        // Update allEdgesMap.
        involvedEdgeIds.forEach((id) => {
            if (this.hasEdge(id)) {
                this.allEdgesMap.set(id, this.graph.getEdge(id));
            }
            else {
                this.allEdgesMap.delete(id);
            }
        });
    };
    startAutoCache() {
        this.refreshCache();
        this.graph.on('changed', this.handleGraphChanged);
    }
    stopAutoCache() {
        this.graph.off('changed', this.handleGraphChanged);
    }
    handleGraphChanged = (event) => {
        // Collect all involved nodes.
        const involvedNodeIds = new Set();
        event.changes.forEach((change) => {
            switch (change.type) {
                case 'NodeAdded':
                    involvedNodeIds.add(change.value.id);
                    break;
                case 'NodeDataUpdated':
                    involvedNodeIds.add(change.id);
                    break;
                case 'EdgeAdded':
                    involvedNodeIds.add(change.value.source);
                    involvedNodeIds.add(change.value.target);
                    break;
                case 'EdgeUpdated':
                    if (change.propertyName === 'source' ||
                        change.propertyName === 'target') {
                        involvedNodeIds.add(change.oldValue);
                        involvedNodeIds.add(change.newValue);
                    }
                    break;
                case 'EdgeDataUpdated':
                    if (event.graph.hasEdge(change.id)) {
                        const edge = event.graph.getEdge(change.id);
                        involvedNodeIds.add(edge.source);
                        involvedNodeIds.add(edge.target);
                    }
                    break;
                case 'EdgeRemoved':
                    involvedNodeIds.add(change.value.source);
                    involvedNodeIds.add(change.value.target);
                    break;
                case 'NodeRemoved':
                    involvedNodeIds.add(change.value.id);
                    break;
                default:
                    break;
            }
        });
        // Update their caches.
        this.updateCache(involvedNodeIds);
    };
    // ================= Node =================
    checkNodeExistence(id) {
        this.getNode(id);
    }
    hasNode(id) {
        if (!this.graph.hasNode(id))
            return false;
        const node = this.graph.getNode(id);
        return this.nodeFilter(node);
    }
    areNeighbors(firstNodeId, secondNodeId) {
        this.checkNodeExistence(firstNodeId);
        return this.getNeighbors(secondNodeId).some((neighbor) => neighbor.id === firstNodeId);
    }
    getNode(id) {
        const node = this.graph.getNode(id);
        if (!this.nodeFilter(node)) {
            throw new Error('Node not found for id: ' + id);
        }
        return node;
    }
    getRelatedEdges(id, direction) {
        this.checkNodeExistence(id);
        if (this.cacheEnabled) {
            if (direction === 'in') {
                return this.inEdgesMap.get(id);
            }
            else if (direction === 'out') {
                return this.outEdgesMap.get(id);
            }
            else {
                return this.bothEdgesMap.get(id);
            }
        }
        const edges = this.graph.getRelatedEdges(id, direction);
        return edges.filter(this.edgeFilter);
    }
    getDegree(id, direction) {
        return this.getRelatedEdges(id, direction).length;
    }
    getSuccessors(id) {
        const outEdges = this.getRelatedEdges(id, 'out');
        const targets = outEdges.map((edge) => this.getNode(edge.target));
        return Array.from(new Set(targets));
    }
    getPredecessors(id) {
        const inEdges = this.getRelatedEdges(id, 'in');
        const sources = inEdges.map((edge) => this.getNode(edge.source));
        return Array.from(new Set(sources));
    }
    getNeighbors(id) {
        const predecessors = this.getPredecessors(id);
        const successors = this.getSuccessors(id);
        return Array.from(new Set([...predecessors, ...successors]));
    }
    // ================= Edge =================
    hasEdge(id) {
        if (!this.graph.hasEdge(id))
            return false;
        const edge = this.graph.getEdge(id);
        return this.edgeFilter(edge);
    }
    getEdge(id) {
        const edge = this.graph.getEdge(id);
        if (!this.edgeFilter(edge)) {
            throw new Error('Edge not found for id: ' + id);
        }
        return edge;
    }
    getEdgeDetail(id) {
        const edge = this.getEdge(id);
        return {
            edge,
            source: this.getNode(edge.source),
            target: this.getNode(edge.target),
        };
    }
    // ================= Tree =================
    hasTreeStructure(treeKey) {
        return this.graph.hasTreeStructure(treeKey);
    }
    getRoots(treeKey) {
        return this.graph.getRoots(treeKey).filter(this.nodeFilter);
    }
    getChildren(id, treeKey) {
        this.checkNodeExistence(id);
        return this.graph.getChildren(id, treeKey).filter(this.nodeFilter);
    }
    getParent(id, treeKey) {
        this.checkNodeExistence(id);
        const parent = this.graph.getParent(id, treeKey);
        if (!parent || !this.nodeFilter(parent))
            return null;
        return parent;
    }
    // ================= Graph =================
    getAllNodes() {
        if (this.cacheEnabled) {
            return Array.from(this.allNodesMap.values());
        }
        return this.graph.getAllNodes().filter(this.nodeFilter);
    }
    getAllEdges() {
        if (this.cacheEnabled) {
            return Array.from(this.allEdgesMap.values());
        }
        return this.graph.getAllEdges().filter(this.edgeFilter);
    }
    bfs(id, fn, direction = 'out') {
        const navigator = {
            in: this.getPredecessors.bind(this),
            out: this.getSuccessors.bind(this),
            both: this.getNeighbors.bind(this),
        }[direction];
        (0,_utils_traverse__WEBPACK_IMPORTED_MODULE_0__.doBFS)([this.getNode(id)], new Set(), fn, navigator);
    }
    dfs(id, fn, direction = 'out') {
        const navigator = {
            in: this.getPredecessors.bind(this),
            out: this.getSuccessors.bind(this),
            both: this.getNeighbors.bind(this),
        }[direction];
        (0,_utils_traverse__WEBPACK_IMPORTED_MODULE_0__.doDFS)(this.getNode(id), new Set(), fn, navigator);
    }
}
//# sourceMappingURL=graphView.js.map

/***/ }),

/***/ "./node_modules/@antv/graphlib/esm/utils/traverse.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/graphlib/esm/utils/traverse.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   doBFS: () => (/* binding */ doBFS),
/* harmony export */   doDFS: () => (/* binding */ doDFS)
/* harmony export */ });
function doBFS(queue, visited, fn, navigator) {
    while (queue.length) {
        const node = queue.shift();
        const abort = fn(node);
        if (abort) {
            return true;
        }
        visited.add(node.id);
        navigator(node.id).forEach((n) => {
            if (!visited.has(n.id)) {
                visited.add(n.id);
                queue.push(n);
            }
        });
    }
    return false;
}
function doDFS(node, visited, fn, navigator) {
    const abort = fn(node);
    if (abort) {
        return true;
    }
    visited.add(node.id);
    for (const n of navigator(node.id)) {
        if (!visited.has(n.id)) {
            if (doDFS(n, visited, fn, navigator)) {
                return true;
            }
        }
    }
    return false;
}
//# sourceMappingURL=traverse.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre.js":
/*!*****************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AntVDagreLayout: () => (/* binding */ AntVDagreLayout)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _antv_graphlib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/graphlib */ "./node_modules/@antv/graphlib/esm/graph.js");
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/is-number.js");
/* harmony import */ var _antv_dagre_layout__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./antv-dagre/layout */ "./node_modules/@antv/layout/lib/antv-dagre/layout.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/lib/util/function.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/lib/util/object.js");
/* harmony import */ var _util_size__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/size */ "./node_modules/@antv/layout/lib/util/size.js");






const DEFAULTS_LAYOUT_OPTIONS = {
    rankdir: 'TB',
    nodesep: 50,
    ranksep: 50,
    edgeLabelSpace: true,
    ranker: 'tight-tree',
    controlPoints: false,
    radial: false,
    focusNode: null, // radial 为 true 时生效，关注的节点
};
/**
 * <zh/> AntV 实现的 Dagre 布局
 *
 * <en/> AntV implementation of Dagre layout
 */
class AntVDagreLayout {
    constructor(options = {}) {
        this.options = options;
        this.id = 'antv-dagre';
        this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS), options);
    }
    /**
     * Return the positions of nodes and edges(if needed).
     */
    execute(graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            return this.genericDagreLayout(false, graph, options);
        });
    }
    /**
     * To directly assign the positions to the nodes.
     */
    assign(graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            yield this.genericDagreLayout(true, graph, options);
        });
    }
    genericDagreLayout(assign, graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            const mergedOptions = Object.assign(Object.assign({}, this.options), options);
            const { nodeSize, align, rankdir = 'TB', ranksep, nodesep, ranksepFunc, nodesepFunc, edgeLabelSpace, ranker, nodeOrder, begin, controlPoints, radial, sortByCombo, 
            // focusNode,
            preset, } = mergedOptions;
            const g = new _antv_graphlib__WEBPACK_IMPORTED_MODULE_1__.Graph({
                tree: [],
            });
            const ranksepfunc = (0,_util__WEBPACK_IMPORTED_MODULE_2__.formatNumberFn)(ranksep || 50, ranksepFunc);
            const nodesepfunc = (0,_util__WEBPACK_IMPORTED_MODULE_2__.formatNumberFn)(nodesep || 50, nodesepFunc);
            let horisep = nodesepfunc;
            let vertisep = ranksepfunc;
            if (rankdir === 'LR' || rankdir === 'RL') {
                horisep = ranksepfunc;
                vertisep = nodesepfunc;
            }
            const nodeSizeFunc = (0,_util__WEBPACK_IMPORTED_MODULE_2__.formatSizeFn)(10, nodeSize, false);
            // copy graph to g
            const nodes = graph.getAllNodes();
            const edges = graph.getAllEdges();
            nodes.forEach((node) => {
                const size = (0,_util_size__WEBPACK_IMPORTED_MODULE_3__.parseSize)(nodeSizeFunc(node));
                const verti = vertisep(node);
                const hori = horisep(node);
                const width = size[0] + 2 * hori;
                const height = size[1] + 2 * verti;
                const layer = node.data.layer;
                if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_4__["default"])(layer)) {
                    // 如果有layer属性，加入到node的label中
                    g.addNode({
                        id: node.id,
                        data: { width, height, layer },
                    });
                }
                else {
                    g.addNode({
                        id: node.id,
                        data: { width, height },
                    });
                }
            });
            if (sortByCombo) {
                g.attachTreeStructure('combo');
                nodes.forEach((node) => {
                    const { parentId } = node.data;
                    if (parentId === undefined)
                        return;
                    if (g.hasNode(parentId)) {
                        g.setParent(node.id, parentId, 'combo');
                    }
                });
            }
            edges.forEach((edge) => {
                // dagrejs Wiki https://github.com/dagrejs/dagre/wiki#configuring-the-layout
                g.addEdge({
                    id: edge.id,
                    source: edge.source,
                    target: edge.target,
                    data: {
                        weight: edge.data.weight || 1,
                    },
                });
            });
            let prevGraph = undefined;
            if (preset === null || preset === void 0 ? void 0 : preset.length) {
                prevGraph = new _antv_graphlib__WEBPACK_IMPORTED_MODULE_1__.Graph({
                    nodes: preset,
                });
            }
            (0,_antv_dagre_layout__WEBPACK_IMPORTED_MODULE_5__.layout)(g, {
                prevGraph,
                edgeLabelSpace,
                keepNodeOrder: !!nodeOrder,
                nodeOrder: nodeOrder || [],
                acyclicer: 'greedy',
                ranker,
                rankdir,
                nodesep,
                align,
            });
            const layoutTopLeft = [0, 0];
            if (begin) {
                let minX = Infinity;
                let minY = Infinity;
                g.getAllNodes().forEach((node) => {
                    if (minX > node.data.x)
                        minX = node.data.x;
                    if (minY > node.data.y)
                        minY = node.data.y;
                });
                g.getAllEdges().forEach((edge) => {
                    var _a;
                    (_a = edge.data.points) === null || _a === void 0 ? void 0 : _a.forEach((point) => {
                        if (minX > point.x)
                            minX = point.x;
                        if (minY > point.y)
                            minY = point.y;
                    });
                });
                layoutTopLeft[0] = begin[0] - minX;
                layoutTopLeft[1] = begin[1] - minY;
            }
            const isHorizontal = rankdir === 'LR' || rankdir === 'RL';
            if (radial) {
                // const focusId = (isString(focusNode) ? focusNode : focusNode?.id) as ID;
                // const focusLayer = focusId ? g.getNode(focusId)?.data._rank as number : 0;
                // const layers: any[] = [];
                // const dim = isHorizontal ? "y" : "x";
                // const sizeDim = isHorizontal ? "height" : "width";
                // // 找到整个图作为环的坐标维度（dim）的最大、最小值，考虑节点宽度
                // let min = Infinity;
                // let max = -Infinity;
                // g.getAllNodes().forEach((node) => {
                //   const currentNodesep = nodesepfunc(node);
                //   if (focusLayer === 0) {
                //     if (!layers[node.data._rank!]) {
                //       layers[node.data._rank!] = {
                //         nodes: [],
                //         totalWidth: 0,
                //         maxSize: -Infinity,
                //       };
                //     }
                //     layers[node.data._rank!].nodes.push(node);
                //     layers[node.data._rank!].totalWidth += currentNodesep * 2 + node.data[sizeDim]!;
                //     if (
                //       layers[node.data._rank!].maxSize < Math.max(node.data.width!, node.data.height!)
                //     ) {
                //       layers[node.data._rank!].maxSize = Math.max(node.data.width!, node.data.height!);
                //     }
                //   } else {
                //     const diffLayer = node.data._rank! - focusLayer!;
                //     if (diffLayer === 0) {
                //       if (!layers[diffLayer]) {
                //         layers[diffLayer] = {
                //           nodes: [],
                //           totalWidth: 0,
                //           maxSize: -Infinity,
                //         };
                //       }
                //       layers[diffLayer].nodes.push(node);
                //       layers[diffLayer].totalWidth += currentNodesep * 2 + node.data[sizeDim]!;
                //       if (
                //         layers[diffLayer].maxSize < Math.max(node.data.width!, node.data.height!)
                //       ) {
                //         layers[diffLayer].maxSize = Math.max(node.data.width!, node.data.height!);
                //       }
                //     } else {
                //       const diffLayerAbs = Math.abs(diffLayer);
                //       if (!layers[diffLayerAbs]) {
                //         layers[diffLayerAbs] = {
                //           left: [],
                //           right: [],
                //           totalWidth: 0,
                //           maxSize: -Infinity,
                //         };
                //       }
                //       layers[diffLayerAbs].totalWidth +=
                //         currentNodesep * 2 + node.data[sizeDim]!;
                //       if (
                //         layers[diffLayerAbs].maxSize < Math.max(node.data.width!, node.data.height!)
                //       ) {
                //         layers[diffLayerAbs].maxSize = Math.max(
                //           node.data.width!,
                //           node.data.height!
                //         );
                //       }
                //       if (diffLayer < 0) {
                //         layers[diffLayerAbs].left.push(node);
                //       } else {
                //         layers[diffLayerAbs].right.push(node);
                //       }
                //     }
                //   }
                //   const leftPos = node.data[dim]! - node.data[sizeDim]! / 2 - currentNodesep;
                //   const rightPos = node.data[dim]! + node.data[sizeDim]! / 2 + currentNodesep;
                //   if (leftPos < min) min = leftPos;
                //   if (rightPos > max) max = rightPos;
                // });
                // // const padding = (max - min) * 0.1; // TODO
                // // 初始化为第一圈的半径，后面根据每层 ranksep 叠加
                // let radius = ranksep || 50; // TODO;
                // const radiusMap: any = {};
                // // 扩大最大最小值范围，以便为环上留出接缝处的空隙
                // const rangeLength = (max - min) / 0.9;
                // const range = [
                //   (min + max - rangeLength) * 0.5,
                //   (min + max + rangeLength) * 0.5,
                // ];
                // // 根据半径、分布比例，计算节点在环上的位置，并返回该组节点中最大的 ranksep 值
                // const processNodes = (
                //   layerNodes: any,
                //   radius: number,
                //   propsMaxRanksep = -Infinity,
                //   arcRange = [0, 1]
                // ) => {
                //   let maxRanksep = propsMaxRanksep;
                //   layerNodes.forEach((node: any) => {
                //     const coord = g.node(node);
                //     radiusMap[node] = radius;
                //     // 获取变形为 radial 后的直角坐标系坐标
                //     const { x: newX, y: newY } = getRadialPos(
                //       coord![dim]!,
                //       range,
                //       rangeLength,
                //       radius,
                //       arcRange
                //     );
                //     // 将新坐标写入源数据
                //     const i = nodes.findIndex((it) => it.id === node);
                //     if (!nodes[i]) return;
                //     nodes[i].x = newX + dBegin[0];
                //     nodes[i].y = newY + dBegin[1];
                //     // @ts-ignore: pass layer order to data for increment layout use
                //     nodes[i]._order = coord._order;
                //     // 找到本层最大的一个 ranksep，作为下一层与本层的间隙，叠加到下一层的半径上
                //     const currentNodeRanksep = ranksepfunc(nodes[i]);
                //     if (maxRanksep < currentNodeRanksep) maxRanksep = currentNodeRanksep;
                //   });
                //   return maxRanksep;
                // };
                // let isFirstLevel = true;
                // const lastLayerMaxNodeSize = 0;
                // layers.forEach((layerNodes) => {
                //   if (
                //     !layerNodes?.nodes?.length &&
                //     !layerNodes?.left?.length &&
                //     !layerNodes?.right?.length
                //   ) {
                //     return;
                //   }
                //   // 第一层只有一个节点，直接放在圆心，初始半径设定为 0
                //   if (isFirstLevel && layerNodes.nodes.length === 1) {
                //     // 将新坐标写入源数据
                //     const i = nodes.findIndex((it) => it.id === layerNodes.nodes[0]);
                //     if (i <= -1) return;
                //     nodes[i].x = dBegin[0];
                //     nodes[i].y = dBegin[1];
                //     radiusMap[layerNodes.nodes[0]] = 0;
                //     radius = ranksepfunc(nodes[i]);
                //     isFirstLevel = false;
                //     return;
                //   }
                //   // 为接缝留出空隙，半径也需要扩大
                //   radius = Math.max(radius, layerNodes.totalWidth / (2 * Math.PI)); // / 0.9;
                //   let maxRanksep = -Infinity;
                //   if (focusLayer === 0 || layerNodes.nodes?.length) {
                //     maxRanksep = processNodes(
                //       layerNodes.nodes,
                //       radius,
                //       maxRanksep,
                //       [0, 1]
                //     ); // 0.8
                //   } else {
                //     const leftRatio =
                //       layerNodes.left?.length /
                //       (layerNodes.left?.length + layerNodes.right?.length);
                //     maxRanksep = processNodes(layerNodes.left, radius, maxRanksep, [
                //       0,
                //       leftRatio,
                //     ]); // 接缝留出 0.05 的缝隙
                //     maxRanksep = processNodes(layerNodes.right, radius, maxRanksep, [
                //       leftRatio + 0.05,
                //       1,
                //     ]); // 接缝留出 0.05 的缝隙
                //   }
                //   radius += maxRanksep;
                //   isFirstLevel = false;
                //   lastLayerMaxNodeSize - layerNodes.maxSize;
                // });
                // g.edges().forEach((edge: any) => {
                //   const coord = g.edge(edge);
                //   const i = edges.findIndex((it) => {
                //     const source = getEdgeTerminal(it, "source");
                //     const target = getEdgeTerminal(it, "target");
                //     return source === edge.v && target === edge.w;
                //   });
                //   if (i <= -1) return;
                //   if (
                //     self.edgeLabelSpace &&
                //     self.controlPoints &&
                //     edges[i].type !== "loop"
                //   ) {
                //     const otherDim = dim === "x" ? "y" : "x";
                //     const controlPoints = coord?.points?.slice(
                //       1,
                //       coord.points.length - 1
                //     );
                //     const newControlPoints: Point[] = [];
                //     const sourceOtherDimValue = g.node(edge.v)?.[otherDim]!;
                //     const otherDimDist =
                //       sourceOtherDimValue - g.node(edge.w)?.[otherDim]!;
                //     const sourceRadius = radiusMap[edge.v];
                //     const radiusDist = sourceRadius - radiusMap[edge.w];
                //     controlPoints?.forEach((point: any) => {
                //       // 根据该边的起点、终点半径，及起点、终点、控制点位置关系，确定该控制点的半径
                //       const cRadius =
                //         ((point[otherDim] - sourceOtherDimValue) / otherDimDist) *
                //           radiusDist +
                //         sourceRadius;
                //       // 获取变形为 radial 后的直角坐标系坐标
                //       const newPos = getRadialPos(
                //         point[dim],
                //         range,
                //         rangeLength,
                //         cRadius
                //       );
                //       newControlPoints.push({
                //         x: newPos.x + dBegin[0],
                //         y: newPos.y + dBegin[1],
                //       });
                //     });
                //     edges[i].controlPoints = newControlPoints;
                //   }
                // });
            }
            else {
                const layerCoords = new Set();
                const isInvert = rankdir === 'BT' || rankdir === 'RL';
                const layerCoordSort = isInvert
                    ? (a, b) => b - a
                    : (a, b) => a - b;
                g.getAllNodes().forEach((node) => {
                    // let ndata: any = this.nodeMap[node];
                    // if (!ndata) {
                    //   ndata = combos?.find((it) => it.id === node);
                    // }
                    // if (!ndata) return;
                    // ndata.x = node.data.x! + dBegin[0];
                    // ndata.y = node.data.y! + dBegin[1];
                    // //  pass layer order to data for increment layout use
                    // ndata._order = node.data._order;
                    // layerCoords.add(isHorizontal ? ndata.x : ndata.y);
                    node.data.x = node.data.x + layoutTopLeft[0];
                    node.data.y = node.data.y + layoutTopLeft[1];
                    layerCoords.add(isHorizontal ? node.data.x : node.data.y);
                });
                const layerCoordsArr = Array.from(layerCoords).sort(layerCoordSort);
                // pre-define the isHorizontal related functions to avoid redundant calc in interations
                const isDifferentLayer = isHorizontal
                    ? (point1, point2) => point1.x !== point2.x
                    : (point1, point2) => point1.y !== point2.y;
                const filterControlPointsOutOfBoundary = isHorizontal
                    ? (ps, point1, point2) => {
                        const max = Math.max(point1.y, point2.y);
                        const min = Math.min(point1.y, point2.y);
                        return ps.filter((point) => point.y <= max && point.y >= min);
                    }
                    : (ps, point1, point2) => {
                        const max = Math.max(point1.x, point2.x);
                        const min = Math.min(point1.x, point2.x);
                        return ps.filter((point) => point.x <= max && point.x >= min);
                    };
                g.getAllEdges().forEach((edge, i) => {
                    var _a;
                    // const i = edges.findIndex((it) => {
                    //   return it.source === edge.source && it.target === edge.target;
                    // });
                    // if (i <= -1) return;
                    if (edgeLabelSpace && controlPoints && edge.data.type !== 'loop') {
                        edge.data.controlPoints = getControlPoints((_a = edge.data.points) === null || _a === void 0 ? void 0 : _a.map(({ x, y }) => ({
                            x: x + layoutTopLeft[0],
                            y: y + layoutTopLeft[1],
                        })), g.getNode(edge.source), g.getNode(edge.target), layerCoordsArr, isHorizontal, isDifferentLayer, filterControlPointsOutOfBoundary);
                    }
                });
            }
            // calculated nodes as temporary result
            let layoutNodes = [];
            // layout according to the original order in the data.nodes
            layoutNodes = g
                .getAllNodes()
                .map((node) => (0,_util__WEBPACK_IMPORTED_MODULE_6__.cloneFormatData)(node));
            const layoutEdges = g.getAllEdges();
            if (assign) {
                layoutNodes.forEach((node) => {
                    graph.mergeNodeData(node.id, {
                        x: node.data.x,
                        y: node.data.y,
                    });
                });
                layoutEdges.forEach((edge) => {
                    graph.mergeEdgeData(edge.id, {
                        controlPoints: edge.data.controlPoints,
                    });
                });
            }
            const result = {
                nodes: layoutNodes,
                edges: layoutEdges,
            };
            return result;
        });
    }
}
/**
 * Format controlPoints to avoid polylines crossing nodes
 * @param points
 * @param sourceNode
 * @param targetNode
 * @param layerCoordsArr
 * @param isHorizontal
 * @returns
 */
const getControlPoints = (points, sourceNode, targetNode, layerCoordsArr, isHorizontal, isDifferentLayer, filterControlPointsOutOfBoundary) => {
    let controlPoints = (points === null || points === void 0 ? void 0 : points.slice(1, points.length - 1)) || []; // 去掉头尾
    // 酌情增加控制点，使折线不穿过跨层的节点
    if (sourceNode && targetNode) {
        let { x: sourceX, y: sourceY } = sourceNode.data;
        let { x: targetX, y: targetY } = targetNode.data;
        if (isHorizontal) {
            sourceX = sourceNode.data.y;
            sourceY = sourceNode.data.x;
            targetX = targetNode.data.y;
            targetY = targetNode.data.x;
        }
        // 为跨层级的边增加第一个控制点。忽略垂直的/横向的边。
        // 新控制点 = {
        //   x: 终点x,
        //   y: (起点y + 下一层y) / 2,   #下一层y可能不等于终点y
        // }
        if (targetY !== sourceY && sourceX !== targetX) {
            const sourceLayer = layerCoordsArr.indexOf(sourceY);
            const sourceNextLayerCoord = layerCoordsArr[sourceLayer + 1];
            if (sourceNextLayerCoord) {
                const firstControlPoint = controlPoints[0];
                const insertStartControlPoint = (isHorizontal
                    ? {
                        x: (sourceY + sourceNextLayerCoord) / 2,
                        y: (firstControlPoint === null || firstControlPoint === void 0 ? void 0 : firstControlPoint.y) || targetX,
                    }
                    : {
                        x: (firstControlPoint === null || firstControlPoint === void 0 ? void 0 : firstControlPoint.x) || targetX,
                        y: (sourceY + sourceNextLayerCoord) / 2,
                    });
                // 当新增的控制点不存在（!=当前第一个控制点）时添加
                if (!firstControlPoint ||
                    isDifferentLayer(firstControlPoint, insertStartControlPoint)) {
                    controlPoints.unshift(insertStartControlPoint);
                }
            }
            const targetLayer = layerCoordsArr.indexOf(targetY);
            const layerDiff = Math.abs(targetLayer - sourceLayer);
            if (layerDiff === 1) {
                controlPoints = filterControlPointsOutOfBoundary(controlPoints, sourceNode.data, targetNode.data);
                // one controlPoint at least
                if (!controlPoints.length) {
                    controlPoints.push((isHorizontal
                        ? {
                            x: (sourceY + targetY) / 2,
                            y: sourceX,
                        }
                        : {
                            x: sourceX,
                            y: (sourceY + targetY) / 2,
                        }));
                }
            }
            else if (layerDiff > 1) {
                const targetLastLayerCoord = layerCoordsArr[targetLayer - 1];
                if (targetLastLayerCoord) {
                    const lastControlPoints = controlPoints[controlPoints.length - 1];
                    const insertEndControlPoint = (isHorizontal
                        ? {
                            x: (targetY + targetLastLayerCoord) / 2,
                            y: (lastControlPoints === null || lastControlPoints === void 0 ? void 0 : lastControlPoints.y) || targetX,
                        }
                        : {
                            x: (lastControlPoints === null || lastControlPoints === void 0 ? void 0 : lastControlPoints.x) || sourceX,
                            y: (targetY + targetLastLayerCoord) / 2,
                        });
                    // 当新增的控制点不存在（!=当前最后一个控制点）时添加
                    if (!lastControlPoints ||
                        isDifferentLayer(lastControlPoints, insertEndControlPoint)) {
                        controlPoints.push(insertEndControlPoint);
                    }
                }
            }
        }
    }
    return controlPoints;
};
//# sourceMappingURL=antv-dagre.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre/acyclic.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre/acyclic.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   run: () => (/* binding */ run),
/* harmony export */   undo: () => (/* binding */ undo)
/* harmony export */ });
/* harmony import */ var _greedy_fas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./greedy-fas */ "./node_modules/@antv/layout/lib/antv-dagre/greedy-fas.js");

const run = (g, acyclicer) => {
    const weightFn = (g) => {
        return (e) => e.data.weight || 1;
    };
    const fas = acyclicer === 'greedy' ? (0,_greedy_fas__WEBPACK_IMPORTED_MODULE_0__.greedyFAS)(g, weightFn(g)) : dfsFAS(g);
    fas === null || fas === void 0 ? void 0 : fas.forEach((e) => {
        const label = e.data;
        g.removeEdge(e.id);
        label.forwardName = e.data.name;
        label.reversed = true;
        g.addEdge({
            id: e.id,
            source: e.target,
            target: e.source,
            data: Object.assign({}, label),
        });
    });
};
const dfsFAS = (g) => {
    const fas = [];
    const stack = {};
    const visited = {};
    const dfs = (v) => {
        if (visited[v]) {
            return;
        }
        visited[v] = true;
        stack[v] = true;
        g.getRelatedEdges(v, 'out').forEach((e) => {
            if (stack[e.target]) {
                fas.push(e);
            }
            else {
                dfs(e.target);
            }
        });
        delete stack[v];
    };
    g.getAllNodes().forEach((n) => dfs(n.id));
    return fas;
};
const undo = (g) => {
    g.getAllEdges().forEach((e) => {
        const label = e.data;
        if (label.reversed) {
            g.removeEdge(e.id);
            const forwardName = label.forwardName;
            delete label.reversed;
            delete label.forwardName;
            g.addEdge({
                id: e.id,
                source: e.target,
                target: e.source,
                data: Object.assign(Object.assign({}, label), { forwardName }),
            });
        }
    });
};

//# sourceMappingURL=acyclic.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre/add-border-segments.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre/add-border-segments.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addBorderSegments: () => (/* binding */ addBorderSegments)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/lib/antv-dagre/util.js");

const addBorderSegments = (g) => {
    const dfs = (v) => {
        const children = g.getChildren(v);
        const node = g.getNode(v);
        if (children === null || children === void 0 ? void 0 : children.length) {
            children.forEach((child) => dfs(child.id));
        }
        if (node.data.hasOwnProperty('minRank')) {
            node.data.borderLeft = [];
            node.data.borderRight = [];
            for (let rank = node.data.minRank, maxRank = node.data.maxRank + 1; rank < maxRank; rank += 1) {
                addBorderNode(g, 'borderLeft', '_bl', v, node, rank);
                addBorderNode(g, 'borderRight', '_br', v, node, rank);
            }
        }
    };
    g.getRoots().forEach((child) => dfs(child.id));
};
const addBorderNode = (g, prop, prefix, sg, sgNode, rank) => {
    const label = { rank, borderType: prop, width: 0, height: 0 };
    // @ts-ignore
    const prev = sgNode.data[prop][rank - 1];
    const curr = (0,_util__WEBPACK_IMPORTED_MODULE_0__.addDummyNode)(g, 'border', label, prefix);
    // @ts-ignore
    sgNode.data[prop][rank] = curr;
    g.setParent(curr, sg);
    if (prev) {
        g.addEdge({
            id: `e${Math.random()}`,
            source: prev,
            target: curr,
            data: { weight: 1 },
        });
    }
};
//# sourceMappingURL=add-border-segments.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre/coordinate-system.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre/coordinate-system.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   adjust: () => (/* binding */ adjust),
/* harmony export */   undo: () => (/* binding */ undo)
/* harmony export */ });
const adjust = (g, rankdir) => {
    const rd = rankdir.toLowerCase();
    if (rd === 'lr' || rd === 'rl') {
        swapWidthHeight(g);
    }
};
const undo = (g, rankdir) => {
    const rd = rankdir.toLowerCase();
    if (rd === 'bt' || rd === 'rl') {
        reverseY(g);
    }
    if (rd === 'lr' || rd === 'rl') {
        swapXY(g);
        swapWidthHeight(g);
    }
};
const swapWidthHeight = (g) => {
    g.getAllNodes().forEach((v) => {
        swapWidthHeightOne(v);
    });
    g.getAllEdges().forEach((e) => {
        swapWidthHeightOne(e);
    });
};
const swapWidthHeightOne = (node) => {
    const w = node.data.width;
    node.data.width = node.data.height;
    node.data.height = w;
};
const reverseY = (g) => {
    g.getAllNodes().forEach((v) => {
        reverseYOne(v.data);
    });
    g.getAllEdges().forEach((edge) => {
        var _a;
        (_a = edge.data.points) === null || _a === void 0 ? void 0 : _a.forEach((point) => reverseYOne(point));
        if (edge.data.hasOwnProperty('y')) {
            reverseYOne(edge.data);
        }
    });
};
const reverseYOne = (node) => {
    if (node === null || node === void 0 ? void 0 : node.y) {
        node.y = -node.y;
    }
};
const swapXY = (g) => {
    g.getAllNodes().forEach((v) => {
        swapXYOne(v.data);
    });
    g.getAllEdges().forEach((edge) => {
        var _a;
        (_a = edge.data.points) === null || _a === void 0 ? void 0 : _a.forEach((point) => swapXYOne(point));
        if (edge.data.hasOwnProperty('x')) {
            swapXYOne(edge.data);
        }
    });
};
const swapXYOne = (node) => {
    const x = node.x;
    node.x = node.y;
    node.y = x;
};

//# sourceMappingURL=coordinate-system.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre/data/list.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre/data/list.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ List)
/* harmony export */ });
const filterOutLinks = (k, v) => {
    if (k !== 'next' && k !== 'prev') {
        return v;
    }
};
const unlink = (entry) => {
    entry.prev.next = entry.next;
    entry.next.prev = entry.prev;
    delete entry.next;
    delete entry.prev;
};
class List {
    constructor() {
        const shortcut = {};
        shortcut.prev = shortcut;
        shortcut.next = shortcut.prev;
        this.shortcut = shortcut;
    }
    dequeue() {
        const shortcut = this.shortcut;
        const entry = shortcut.prev;
        if (entry && entry !== shortcut) {
            unlink(entry);
            return entry;
        }
    }
    enqueue(entry) {
        const shortcut = this.shortcut;
        if (entry.prev && entry.next) {
            unlink(entry);
        }
        entry.next = shortcut.next;
        shortcut.next.prev = entry;
        shortcut.next = entry;
        entry.prev = shortcut;
    }
    toString() {
        const strs = [];
        const sentinel = this.shortcut;
        let curr = sentinel.prev;
        while (curr !== sentinel) {
            strs.push(JSON.stringify(curr, filterOutLinks));
            curr = curr === null || curr === void 0 ? void 0 : curr.prev;
        }
        return `[${strs.join(', ')}]`;
    }
}
//# sourceMappingURL=list.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre/greedy-fas.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre/greedy-fas.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   greedyFAS: () => (/* binding */ greedyFAS)
/* harmony export */ });
/* harmony import */ var _antv_graphlib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/graphlib */ "./node_modules/@antv/graphlib/esm/graph.js");
/* harmony import */ var _data_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./data/list */ "./node_modules/@antv/layout/lib/antv-dagre/data/list.js");
/*
 * A greedy heuristic for finding a feedback arc set for a graph. A feedback
 * arc set is a set of edges that can be removed to make a graph acyclic.
 * The algorithm comes from: P. Eades, X. Lin, and W. F. Smyth, "A fast and
 * effective heuristic for the feedback arc set problem." This implementation
 * adjusts that from the paper to allow for weighted edges.
 *
 * @see https://github.com/dagrejs/dagre/blob/master/lib/greedy-fas.js
 */


class List extends _data_list__WEBPACK_IMPORTED_MODULE_0__["default"] {
}
const DEFAULT_WEIGHT_FN = () => 1;
const greedyFAS = (g, weightFn) => {
    var _a;
    if (g.getAllNodes().length <= 1)
        return [];
    const state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);
    const results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);
    return (_a = results
        .map((e) => g.getRelatedEdges(e.v, 'out').filter(({ target }) => target === e.w))) === null || _a === void 0 ? void 0 : _a.flat();
};
const doGreedyFAS = (g, buckets, zeroIdx) => {
    let results = [];
    const sources = buckets[buckets.length - 1];
    const sinks = buckets[0];
    let entry;
    while (g.getAllNodes().length) {
        while ((entry = sinks.dequeue())) {
            removeNode(g, buckets, zeroIdx, entry);
        }
        while ((entry = sources.dequeue())) {
            removeNode(g, buckets, zeroIdx, entry);
        }
        if (g.getAllNodes().length) {
            for (let i = buckets.length - 2; i > 0; --i) {
                entry = buckets[i].dequeue();
                if (entry) {
                    results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));
                    break;
                }
            }
        }
    }
    return results;
};
const removeNode = (g, buckets, zeroIdx, entry, collectPredecessors) => {
    var _a, _b;
    const results = [];
    if (g.hasNode(entry.v)) {
        (_a = g.getRelatedEdges(entry.v, 'in')) === null || _a === void 0 ? void 0 : _a.forEach((edge) => {
            const weight = edge.data.weight;
            const uEntry = g.getNode(edge.source);
            if (collectPredecessors) {
                // this result not really care about in or out
                results.push({ v: edge.source, w: edge.target, in: 0, out: 0 });
            }
            if (uEntry.data.out === undefined)
                uEntry.data.out = 0;
            // @ts-ignore
            uEntry.data.out -= weight;
            assignBucket(buckets, zeroIdx, Object.assign({ v: uEntry.id }, uEntry.data));
        });
        (_b = g.getRelatedEdges(entry.v, 'out')) === null || _b === void 0 ? void 0 : _b.forEach((edge) => {
            const weight = edge.data.weight;
            const w = edge.target;
            const wEntry = g.getNode(w);
            if (wEntry.data.in === undefined)
                wEntry.data.in = 0;
            // @ts-ignore
            wEntry.data.in -= weight;
            assignBucket(buckets, zeroIdx, Object.assign({ v: wEntry.id }, wEntry.data));
        });
        g.removeNode(entry.v);
    }
    return collectPredecessors ? results : undefined;
};
const buildState = (g, weightFn) => {
    const fasGraph = new _antv_graphlib__WEBPACK_IMPORTED_MODULE_1__.Graph();
    let maxIn = 0;
    let maxOut = 0;
    g.getAllNodes().forEach((v) => {
        fasGraph.addNode({
            id: v.id,
            data: { v: v.id, in: 0, out: 0 },
        });
    });
    // Aggregate weights on nodes, but also sum the weights across multi-edges
    // into a single edge for the fasGraph.
    g.getAllEdges().forEach((e) => {
        const edge = fasGraph
            .getRelatedEdges(e.source, 'out')
            .find((edge) => edge.target === e.target);
        const weight = (weightFn === null || weightFn === void 0 ? void 0 : weightFn(e)) || 1;
        if (!edge) {
            fasGraph.addEdge({
                id: e.id,
                source: e.source,
                target: e.target,
                data: {
                    weight,
                },
            });
        }
        else {
            fasGraph.updateEdgeData(edge === null || edge === void 0 ? void 0 : edge.id, Object.assign(Object.assign({}, edge.data), { weight: edge.data.weight + weight }));
        }
        // @ts-ignore
        maxOut = Math.max(maxOut, (fasGraph.getNode(e.source).data.out += weight));
        // @ts-ignore
        maxIn = Math.max(maxIn, (fasGraph.getNode(e.target).data.in += weight));
    });
    const buckets = [];
    const rangeMax = maxOut + maxIn + 3;
    for (let i = 0; i < rangeMax; i++) {
        buckets.push(new List());
    }
    const zeroIdx = maxIn + 1;
    fasGraph.getAllNodes().forEach((v) => {
        assignBucket(buckets, zeroIdx, Object.assign({ v: v.id }, fasGraph.getNode(v.id).data));
    });
    return { buckets, zeroIdx, graph: fasGraph };
};
const assignBucket = (buckets, zeroIdx, entry) => {
    if (!entry.out) {
        buckets[0].enqueue(entry);
    }
    else if (!entry['in']) {
        buckets[buckets.length - 1].enqueue(entry);
    }
    else {
        buckets[entry.out - entry['in'] + zeroIdx].enqueue(entry);
    }
};
//# sourceMappingURL=greedy-fas.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre/layout.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre/layout.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   layout: () => (/* binding */ layout)
/* harmony export */ });
/* harmony import */ var _antv_graphlib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @antv/graphlib */ "./node_modules/@antv/graphlib/esm/graph.js");
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/is-nil.js");
/* harmony import */ var _acyclic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./acyclic */ "./node_modules/@antv/layout/lib/antv-dagre/acyclic.js");
/* harmony import */ var _add_border_segments__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./add-border-segments */ "./node_modules/@antv/layout/lib/antv-dagre/add-border-segments.js");
/* harmony import */ var _coordinate_system__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./coordinate-system */ "./node_modules/@antv/layout/lib/antv-dagre/coordinate-system.js");
/* harmony import */ var _nesting_graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nesting-graph */ "./node_modules/@antv/layout/lib/antv-dagre/nesting-graph.js");
/* harmony import */ var _normalize__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./normalize */ "./node_modules/@antv/layout/lib/antv-dagre/normalize.js");
/* harmony import */ var _order__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./order */ "./node_modules/@antv/layout/lib/antv-dagre/order/index.js");
/* harmony import */ var _order_init_data_order__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./order/init-data-order */ "./node_modules/@antv/layout/lib/antv-dagre/order/init-data-order.js");
/* harmony import */ var _parent_dummy_chains__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parent-dummy-chains */ "./node_modules/@antv/layout/lib/antv-dagre/parent-dummy-chains.js");
/* harmony import */ var _position__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./position */ "./node_modules/@antv/layout/lib/antv-dagre/position/index.js");
/* harmony import */ var _rank__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./rank */ "./node_modules/@antv/layout/lib/antv-dagre/rank/index.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/lib/antv-dagre/util.js");













// const graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
// const graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
// const graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
const layout = (g, options) => {
    const { edgeLabelSpace, keepNodeOrder, prevGraph, rankdir, ranksep } = options;
    // 如果在原图基础上修改，继承原图的order结果
    if (!keepNodeOrder && prevGraph) {
        inheritOrder(g, prevGraph);
    }
    const layoutGraph = buildLayoutGraph(g);
    // 控制是否为边的label留位置（这会影响是否在边中间添加dummy node）
    if (!!edgeLabelSpace) {
        options.ranksep = makeSpaceForEdgeLabels(layoutGraph, {
            rankdir,
            ranksep,
        });
    }
    let dimension;
    // TODO: 暂时处理层级设置不正确时的异常报错，提示设置正确的层级
    try {
        dimension = runLayout(layoutGraph, options);
    }
    catch (e) {
        if (e.message === 'Not possible to find intersection inside of the rectangle') {
            console.error("The following error may be caused by improper layer setting, please make sure your manual layer setting does not violate the graph's structure:\n", e);
            return;
        }
        throw e;
    }
    updateInputGraph(g, layoutGraph);
    return dimension;
};
const runLayout = (g, options) => {
    const { acyclicer, ranker, rankdir = 'tb', nodeOrder, keepNodeOrder, align, nodesep = 50, edgesep = 20, ranksep = 50, } = options;
    removeSelfEdges(g);
    (0,_acyclic__WEBPACK_IMPORTED_MODULE_0__.run)(g, acyclicer);
    const { nestingRoot, nodeRankFactor } = (0,_nesting_graph__WEBPACK_IMPORTED_MODULE_1__.run)(g);
    (0,_rank__WEBPACK_IMPORTED_MODULE_2__.rank)((0,_util__WEBPACK_IMPORTED_MODULE_3__.asNonCompoundGraph)(g), ranker);
    injectEdgeLabelProxies(g);
    (0,_util__WEBPACK_IMPORTED_MODULE_3__.removeEmptyRanks)(g, nodeRankFactor);
    (0,_nesting_graph__WEBPACK_IMPORTED_MODULE_1__.cleanup)(g, nestingRoot);
    (0,_util__WEBPACK_IMPORTED_MODULE_3__.normalizeRanks)(g);
    assignRankMinMax(g);
    removeEdgeLabelProxies(g);
    const dummyChains = [];
    (0,_normalize__WEBPACK_IMPORTED_MODULE_4__.run)(g, dummyChains);
    (0,_parent_dummy_chains__WEBPACK_IMPORTED_MODULE_5__.parentDummyChains)(g, dummyChains);
    (0,_add_border_segments__WEBPACK_IMPORTED_MODULE_6__.addBorderSegments)(g);
    if (keepNodeOrder) {
        (0,_order_init_data_order__WEBPACK_IMPORTED_MODULE_7__.initDataOrder)(g, nodeOrder);
    }
    (0,_order__WEBPACK_IMPORTED_MODULE_8__.order)(g, keepNodeOrder);
    insertSelfEdges(g);
    (0,_coordinate_system__WEBPACK_IMPORTED_MODULE_9__.adjust)(g, rankdir);
    (0,_position__WEBPACK_IMPORTED_MODULE_10__.position)(g, {
        align,
        nodesep,
        edgesep,
        ranksep,
    });
    positionSelfEdges(g);
    removeBorderNodes(g);
    (0,_normalize__WEBPACK_IMPORTED_MODULE_4__.undo)(g, dummyChains);
    fixupEdgeLabelCoords(g);
    (0,_coordinate_system__WEBPACK_IMPORTED_MODULE_9__.undo)(g, rankdir);
    const { width, height } = translateGraph(g);
    assignNodeIntersects(g);
    reversePointsForReversedEdges(g);
    (0,_acyclic__WEBPACK_IMPORTED_MODULE_0__.undo)(g);
    return { width, height };
};
/**
 * 继承上一个布局中的order，防止翻转
 * TODO: 暂时没有考虑涉及层级变动的布局，只保证原来布局层级和相对顺序不变
 */
const inheritOrder = (currG, prevG) => {
    currG.getAllNodes().forEach((n) => {
        const node = currG.getNode(n.id);
        if (prevG.hasNode(n.id)) {
            const prevNode = prevG.getNode(n.id);
            node.data.fixorder = prevNode.data._order;
            delete prevNode.data._order;
        }
        else {
            delete node.data.fixorder;
        }
    });
};
/*
 * Copies final layout information from the layout graph back to the input
 * graph. This process only copies whitelisted attributes from the layout graph
 * to the input graph, so it serves as a good place to determine what
 * attributes can influence layout.
 */
const updateInputGraph = (inputGraph, layoutGraph) => {
    inputGraph.getAllNodes().forEach((v) => {
        var _a;
        const inputLabel = inputGraph.getNode(v.id);
        if (inputLabel) {
            const layoutLabel = layoutGraph.getNode(v.id);
            inputLabel.data.x = layoutLabel.data.x;
            inputLabel.data.y = layoutLabel.data.y;
            inputLabel.data._order = layoutLabel.data.order;
            inputLabel.data._rank = layoutLabel.data.rank;
            if ((_a = layoutGraph.getChildren(v.id)) === null || _a === void 0 ? void 0 : _a.length) {
                inputLabel.data.width = layoutLabel.data.width;
                inputLabel.data.height = layoutLabel.data.height;
            }
        }
    });
    inputGraph.getAllEdges().forEach((e) => {
        const inputLabel = inputGraph.getEdge(e.id);
        const layoutLabel = layoutGraph.getEdge(e.id);
        inputLabel.data.points = layoutLabel ? layoutLabel.data.points : [];
        if (layoutLabel && layoutLabel.data.hasOwnProperty('x')) {
            inputLabel.data.x = layoutLabel.data.x;
            inputLabel.data.y = layoutLabel.data.y;
        }
    });
    // inputGraph.graph().width = layoutGraph.graph().width;
    // inputGraph.graph().height = layoutGraph.graph().height;
};
const nodeNumAttrs = ['width', 'height', 'layer', 'fixorder']; // 需要传入layer, fixOrder作为参数参考
const nodeDefaults = { width: 0, height: 0 };
const edgeNumAttrs = ['minlen', 'weight', 'width', 'height', 'labeloffset'];
const edgeDefaults = {
    minlen: 1,
    weight: 1,
    width: 0,
    height: 0,
    labeloffset: 10,
    labelpos: 'r',
};
const edgeAttrs = ['labelpos'];
/*
 * Constructs a new graph from the input graph, which can be used for layout.
 * This process copies only whitelisted attributes from the input graph to the
 * layout graph. Thus this function serves as a good place to determine what
 * attributes can influence layout.
 */
const buildLayoutGraph = (inputGraph) => {
    const g = new _antv_graphlib__WEBPACK_IMPORTED_MODULE_11__.Graph({ tree: [] });
    inputGraph.getAllNodes().forEach((v) => {
        const node = canonicalize(inputGraph.getNode(v.id).data);
        const defaultNode = Object.assign(Object.assign({}, nodeDefaults), node);
        const defaultAttrs = selectNumberAttrs(defaultNode, nodeNumAttrs);
        if (!g.hasNode(v.id)) {
            g.addNode({
                id: v.id,
                data: Object.assign({}, defaultAttrs),
            });
        }
        const parent = inputGraph.hasTreeStructure('combo')
            ? inputGraph.getParent(v.id, 'combo')
            : inputGraph.getParent(v.id);
        if (!(0,_antv_util__WEBPACK_IMPORTED_MODULE_12__["default"])(parent)) {
            if (!g.hasNode(parent.id)) {
                g.addNode(Object.assign({}, parent));
            }
            g.setParent(v.id, parent.id);
        }
    });
    inputGraph.getAllEdges().forEach((e) => {
        const edge = canonicalize(inputGraph.getEdge(e.id).data);
        const pickedProperties = {};
        edgeAttrs === null || edgeAttrs === void 0 ? void 0 : edgeAttrs.forEach((key) => {
            if (edge[key] !== undefined)
                pickedProperties[key] = edge[key];
        });
        g.addEdge({
            id: e.id,
            source: e.source,
            target: e.target,
            data: Object.assign({}, edgeDefaults, selectNumberAttrs(edge, edgeNumAttrs), pickedProperties),
        });
    });
    return g;
};
/*
 * This idea comes from the Gansner paper: to account for edge labels in our
 * layout we split each rank in half by doubling minlen and halving ranksep.
 * Then we can place labels at these mid-points between nodes.
 *
 * We also add some minimal padding to the width to push the label for the edge
 * away from the edge itself a bit.
 */
const makeSpaceForEdgeLabels = (g, options) => {
    const { ranksep = 0, rankdir } = options;
    g.getAllNodes().forEach((node) => {
        if (!isNaN(node.data.layer)) {
            if (!node.data.layer)
                node.data.layer = 0;
        }
    });
    g.getAllEdges().forEach((edge) => {
        var _a;
        edge.data.minlen *= 2;
        if (((_a = edge.data.labelpos) === null || _a === void 0 ? void 0 : _a.toLowerCase()) !== 'c') {
            if (rankdir === 'TB' || rankdir === 'BT') {
                edge.data.width += edge.data.labeloffset;
            }
            else {
                edge.data.height += edge.data.labeloffset;
            }
        }
    });
    return ranksep / 2;
};
/*
 * Creates temporary dummy nodes that capture the rank in which each edge's
 * label is going to, if it has one of non-zero width and height. We do this
 * so that we can safely remove empty ranks while preserving balance for the
 * label's position.
 */
const injectEdgeLabelProxies = (g) => {
    g.getAllEdges().forEach((e) => {
        if (e.data.width && e.data.height) {
            const v = g.getNode(e.source);
            const w = g.getNode(e.target);
            const label = {
                e,
                rank: (w.data.rank - v.data.rank) / 2 + v.data.rank,
            };
            (0,_util__WEBPACK_IMPORTED_MODULE_3__.addDummyNode)(g, 'edge-proxy', label, '_ep');
        }
    });
};
const assignRankMinMax = (g) => {
    let maxRank = 0;
    g.getAllNodes().forEach((node) => {
        var _a, _b;
        if (node.data.borderTop) {
            node.data.minRank = (_a = g.getNode(node.data.borderTop)) === null || _a === void 0 ? void 0 : _a.data.rank;
            node.data.maxRank = (_b = g.getNode(node.data.borderBottom)) === null || _b === void 0 ? void 0 : _b.data.rank;
            maxRank = Math.max(maxRank, node.data.maxRank || -Infinity);
        }
    });
    return maxRank;
};
const removeEdgeLabelProxies = (g) => {
    g.getAllNodes().forEach((node) => {
        if (node.data.dummy === 'edge-proxy') {
            g.getEdge(node.data.e.id).data.labelRank = node.data.rank;
            g.removeNode(node.id);
        }
    });
};
const translateGraph = (g, options) => {
    let minX;
    let maxX = 0;
    let minY;
    let maxY = 0;
    const { marginx: marginX = 0, marginy: marginY = 0 } = options || {};
    const getExtremes = (attrs) => {
        if (!attrs.data)
            return;
        const x = attrs.data.x;
        const y = attrs.data.y;
        const w = attrs.data.width;
        const h = attrs.data.height;
        if (!isNaN(x) && !isNaN(w)) {
            if (minX === undefined) {
                minX = x - w / 2;
            }
            minX = Math.min(minX, x - w / 2);
            maxX = Math.max(maxX, x + w / 2);
        }
        if (!isNaN(y) && !isNaN(h)) {
            if (minY === undefined) {
                minY = y - h / 2;
            }
            minY = Math.min(minY, y - h / 2);
            maxY = Math.max(maxY, y + h / 2);
        }
    };
    g.getAllNodes().forEach((v) => {
        getExtremes(v);
    });
    g.getAllEdges().forEach((e) => {
        if (e === null || e === void 0 ? void 0 : e.data.hasOwnProperty('x')) {
            getExtremes(e);
        }
    });
    minX -= marginX;
    minY -= marginY;
    g.getAllNodes().forEach((node) => {
        node.data.x -= minX;
        node.data.y -= minY;
    });
    g.getAllEdges().forEach((edge) => {
        var _a;
        (_a = edge.data.points) === null || _a === void 0 ? void 0 : _a.forEach((p) => {
            p.x -= minX;
            p.y -= minY;
        });
        if (edge.data.hasOwnProperty('x')) {
            edge.data.x -= minX;
        }
        if (edge.data.hasOwnProperty('y')) {
            edge.data.y -= minY;
        }
    });
    return {
        width: maxX - minX + marginX,
        height: maxY - minY + marginY,
    };
};
const assignNodeIntersects = (g) => {
    g.getAllEdges().forEach((e) => {
        const nodeV = g.getNode(e.source);
        const nodeW = g.getNode(e.target);
        let p1;
        let p2;
        if (!e.data.points) {
            e.data.points = [];
            p1 = { x: nodeW.data.x, y: nodeW.data.y };
            p2 = { x: nodeV.data.x, y: nodeV.data.y };
        }
        else {
            p1 = e.data.points[0];
            p2 = e.data.points[e.data.points.length - 1];
        }
        e.data.points.unshift((0,_util__WEBPACK_IMPORTED_MODULE_3__.intersectRect)(nodeV.data, p1));
        e.data.points.push((0,_util__WEBPACK_IMPORTED_MODULE_3__.intersectRect)(nodeW.data, p2));
    });
};
const fixupEdgeLabelCoords = (g) => {
    g.getAllEdges().forEach((edge) => {
        if (edge.data.hasOwnProperty('x')) {
            if (edge.data.labelpos === 'l' || edge.data.labelpos === 'r') {
                edge.data.width -= edge.data.labeloffset;
            }
            switch (edge.data.labelpos) {
                case 'l':
                    edge.data.x -= edge.data.width / 2 + edge.data.labeloffset;
                    break;
                case 'r':
                    edge.data.x += edge.data.width / 2 + edge.data.labeloffset;
                    break;
            }
        }
    });
};
const reversePointsForReversedEdges = (g) => {
    g.getAllEdges().forEach((edge) => {
        var _a;
        if (edge.data.reversed) {
            (_a = edge.data.points) === null || _a === void 0 ? void 0 : _a.reverse();
        }
    });
};
const removeBorderNodes = (g) => {
    g.getAllNodes().forEach((v) => {
        var _a, _b, _c;
        if ((_a = g.getChildren(v.id)) === null || _a === void 0 ? void 0 : _a.length) {
            const node = g.getNode(v.id);
            const t = g.getNode(node.data.borderTop);
            const b = g.getNode(node.data.borderBottom);
            const l = g.getNode(node.data.borderLeft[((_b = node.data.borderLeft) === null || _b === void 0 ? void 0 : _b.length) - 1]);
            const r = g.getNode(node.data.borderRight[((_c = node.data.borderRight) === null || _c === void 0 ? void 0 : _c.length) - 1]);
            node.data.width = Math.abs((r === null || r === void 0 ? void 0 : r.data.x) - (l === null || l === void 0 ? void 0 : l.data.x)) || 10;
            node.data.height = Math.abs((b === null || b === void 0 ? void 0 : b.data.y) - (t === null || t === void 0 ? void 0 : t.data.y)) || 10;
            node.data.x = ((l === null || l === void 0 ? void 0 : l.data.x) || 0) + node.data.width / 2;
            node.data.y = ((t === null || t === void 0 ? void 0 : t.data.y) || 0) + node.data.height / 2;
        }
    });
    g.getAllNodes().forEach((n) => {
        if (n.data.dummy === 'border') {
            g.removeNode(n.id);
        }
    });
};
const removeSelfEdges = (g) => {
    g.getAllEdges().forEach((e) => {
        if (e.source === e.target) {
            const node = g.getNode(e.source);
            if (!node.data.selfEdges) {
                node.data.selfEdges = [];
            }
            node.data.selfEdges.push(e);
            g.removeEdge(e.id);
        }
    });
};
const insertSelfEdges = (g) => {
    const layers = (0,_util__WEBPACK_IMPORTED_MODULE_3__.buildLayerMatrix)(g);
    layers === null || layers === void 0 ? void 0 : layers.forEach((layer) => {
        let orderShift = 0;
        layer === null || layer === void 0 ? void 0 : layer.forEach((v, i) => {
            var _a;
            const node = g.getNode(v);
            node.data.order = i + orderShift;
            (_a = node.data.selfEdges) === null || _a === void 0 ? void 0 : _a.forEach((selfEdge) => {
                (0,_util__WEBPACK_IMPORTED_MODULE_3__.addDummyNode)(g, 'selfedge', {
                    width: selfEdge.data.width,
                    height: selfEdge.data.height,
                    rank: node.data.rank,
                    order: i + ++orderShift,
                    e: selfEdge,
                }, '_se');
            });
            delete node.data.selfEdges;
        });
    });
};
const positionSelfEdges = (g) => {
    g.getAllNodes().forEach((v) => {
        const node = g.getNode(v.id);
        if (node.data.dummy === 'selfedge') {
            const selfNode = g.getNode(node.data.e.source);
            const x = selfNode.data.x + selfNode.data.width / 2;
            const y = selfNode.data.y;
            const dx = node.data.x - x;
            const dy = selfNode.data.height / 2;
            if (g.hasEdge(node.data.e.id)) {
                g.updateEdgeData(node.data.e.id, node.data.e.data);
            }
            else {
                g.addEdge({
                    id: node.data.e.id,
                    source: node.data.e.source,
                    target: node.data.e.target,
                    data: node.data.e.data,
                });
            }
            g.removeNode(v.id);
            node.data.e.data.points = [
                { x: x + (2 * dx) / 3, y: y - dy },
                { x: x + (5 * dx) / 6, y: y - dy },
                { y, x: x + dx },
                { x: x + (5 * dx) / 6, y: y + dy },
                { x: x + (2 * dx) / 3, y: y + dy },
            ];
            node.data.e.data.x = node.data.x;
            node.data.e.data.y = node.data.y;
        }
    });
};
const selectNumberAttrs = (obj, attrs) => {
    const pickedProperties = {};
    attrs === null || attrs === void 0 ? void 0 : attrs.forEach((key) => {
        if (obj[key] === undefined)
            return;
        pickedProperties[key] = +obj[key];
    });
    return pickedProperties;
};
const canonicalize = (attrs = {}) => {
    const newAttrs = {};
    Object.keys(attrs).forEach((k) => {
        newAttrs[k.toLowerCase()] = attrs[k];
    });
    return newAttrs;
};
//# sourceMappingURL=layout.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre/nesting-graph.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre/nesting-graph.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   cleanup: () => (/* binding */ cleanup),
/* harmony export */   run: () => (/* binding */ run)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/lib/antv-dagre/util.js");

/*
 * A nesting graph creates dummy nodes for the tops and bottoms of subgraphs,
 * adds appropriate edges to ensure that all cluster nodes are placed between
 * these boundries, and ensures that the graph is connected.
 *
 * In addition we ensure, through the use of the minlen property, that nodes
 * and subgraph border nodes to not end up on the same rank.
 *
 * Preconditions:
 *
 *    1. Input graph is a DAG
 *    2. Nodes in the input graph has a minlen attribute
 *
 * Postconditions:
 *
 *    1. Input graph is connected.
 *    2. Dummy nodes are added for the tops and bottoms of subgraphs.
 *    3. The minlen attribute for nodes is adjusted to ensure nodes do not
 *       get placed on the same rank as subgraph border nodes.
 *
 * The nesting graph idea comes from Sander, "Layout of Compound Directed
 * Graphs."
 */
const run = (g) => {
    const root = (0,_util__WEBPACK_IMPORTED_MODULE_0__.addDummyNode)(g, 'root', {}, '_root');
    const depths = treeDepths(g);
    let maxDepth = Math.max(...Object.values(depths));
    if (Math.abs(maxDepth) === Infinity) {
        maxDepth = 1;
    }
    const height = maxDepth - 1; // Note: depths is an Object not an array
    const nodeSep = 2 * height + 1;
    // g.graph().nestingRoot = root;
    // Multiply minlen by nodeSep to align nodes on non-border ranks.
    g.getAllEdges().forEach((e) => {
        e.data.minlen *= nodeSep;
    });
    // Calculate a weight that is sufficient to keep subgraphs vertically compact
    const weight = sumWeights(g) + 1;
    // Create border nodes and link them up
    // g.children()?.forEach((child) => {
    //   dfs(g, root, nodeSep, weight, height, depths, child);
    // });
    g.getRoots().forEach((child) => {
        dfs(g, root, nodeSep, weight, height, depths, child.id);
    });
    // Save the multiplier for node layers for later removal of empty border
    // layers.
    // g.graph().nodeRankFactor = nodeSep;
    return {
        nestingRoot: root,
        nodeRankFactor: nodeSep,
    };
};
const dfs = (g, root, nodeSep, weight, height, depths, v) => {
    const children = g.getChildren(v);
    if (!(children === null || children === void 0 ? void 0 : children.length)) {
        if (v !== root) {
            // g.setEdge(root, v, { weight: 0, minlen: nodeSep });
            g.addEdge({
                id: `e${Math.random()}`,
                source: root,
                target: v,
                data: { weight: 0, minlen: nodeSep },
            });
        }
        return;
    }
    const top = (0,_util__WEBPACK_IMPORTED_MODULE_0__.addBorderNode)(g, '_bt');
    const bottom = (0,_util__WEBPACK_IMPORTED_MODULE_0__.addBorderNode)(g, '_bb');
    const label = g.getNode(v);
    g.setParent(top, v);
    label.data.borderTop = top;
    g.setParent(bottom, v);
    label.data.borderBottom = bottom;
    children === null || children === void 0 ? void 0 : children.forEach((childNode) => {
        dfs(g, root, nodeSep, weight, height, depths, childNode.id);
        const childTop = childNode.data.borderTop
            ? childNode.data.borderTop
            : childNode.id;
        const childBottom = childNode.data.borderBottom
            ? childNode.data.borderBottom
            : childNode.id;
        const thisWeight = childNode.data.borderTop ? weight : 2 * weight;
        const minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;
        g.addEdge({
            id: `e${Math.random()}`,
            source: top,
            target: childTop,
            data: {
                minlen,
                weight: thisWeight,
                nestingEdge: true,
            },
        });
        g.addEdge({
            id: `e${Math.random()}`,
            source: childBottom,
            target: bottom,
            data: {
                minlen,
                weight: thisWeight,
                nestingEdge: true,
            },
        });
    });
    if (!g.getParent(v)) {
        g.addEdge({
            id: `e${Math.random()}`,
            source: root,
            target: top,
            data: {
                weight: 0,
                minlen: height + depths[v],
            },
        });
    }
};
const treeDepths = (g) => {
    const depths = {};
    const dfs = (v, depth) => {
        const children = g.getChildren(v);
        children === null || children === void 0 ? void 0 : children.forEach((child) => dfs(child.id, depth + 1));
        depths[v] = depth;
    };
    // g.children()?.forEach((v) => dfs(v, 1));
    g.getRoots().forEach((v) => dfs(v.id, 1));
    return depths;
};
const sumWeights = (g) => {
    let result = 0;
    g.getAllEdges().forEach((e) => {
        result += e.data.weight;
    });
    return result;
};
const cleanup = (g, nestingRoot) => {
    // const graphLabel = g.graph();
    // graphLabel.nestingRoot && g.removeNode(graphLabel.nestingRoot);
    // delete graphLabel.nestingRoot;
    if (nestingRoot) {
        g.removeNode(nestingRoot);
    }
    g.getAllEdges().forEach((e) => {
        if (e.data.nestingEdge) {
            g.removeEdge(e.id);
        }
    });
};

//# sourceMappingURL=nesting-graph.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre/normalize.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre/normalize.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   run: () => (/* binding */ run),
/* harmony export */   undo: () => (/* binding */ undo)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/lib/antv-dagre/util.js");

/*
 * Breaks any long edges in the graph into short segments that span 1 layer
 * each. This operation is undoable with the denormalize function.
 *
 * Pre-conditions:
 *
 *    1. The input graph is a DAG.
 *    2. Each node in the graph has a "rank" property.
 *
 * Post-condition:
 *
 *    1. All edges in the graph have a length of 1.
 *    2. Dummy nodes are added where edges have been split into segments.
 *    3. The graph is augmented with a "dummyChains" attribute which contains
 *       the first dummy in each chain of dummy nodes produced.
 */
const DUMMY_NODE_EDGE = 'edge';
const DUMMY_NODE_EDGE_LABEL = 'edge-label';
const run = (g, dummyChains) => {
    g.getAllEdges().forEach((edge) => normalizeEdge(g, edge, dummyChains));
};
const normalizeEdge = (g, e, dummyChains) => {
    let v = e.source;
    let vRank = g.getNode(v).data.rank;
    const w = e.target;
    const wRank = g.getNode(w).data.rank;
    const labelRank = e.data.labelRank;
    if (wRank === vRank + 1)
        return;
    g.removeEdge(e.id);
    let dummy;
    let nodeData;
    let i;
    for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {
        e.data.points = [];
        nodeData = {
            originalEdge: e,
            width: 0,
            height: 0,
            rank: vRank,
        };
        dummy = (0,_util__WEBPACK_IMPORTED_MODULE_0__.addDummyNode)(g, DUMMY_NODE_EDGE, nodeData, '_d');
        if (vRank === labelRank) {
            nodeData.width = e.data.width;
            nodeData.height = e.data.height;
            nodeData.dummy = DUMMY_NODE_EDGE_LABEL;
            nodeData.labelpos = e.data.labelpos;
        }
        g.addEdge({
            id: `e${Math.random()}`,
            source: v,
            target: dummy,
            data: { weight: e.data.weight },
        });
        if (i === 0) {
            dummyChains.push(dummy);
        }
        v = dummy;
    }
    g.addEdge({
        id: `e${Math.random()}`,
        source: v,
        target: w,
        data: { weight: e.data.weight },
    });
};
const undo = (g, dummyChains) => {
    dummyChains.forEach((v) => {
        let node = g.getNode(v);
        const { data } = node;
        const originalEdge = data.originalEdge;
        let w;
        // Restore original edge.
        if (originalEdge) {
            g.addEdge(originalEdge);
        }
        let currentV = v;
        while (node.data.dummy) {
            w = g.getSuccessors(currentV)[0];
            g.removeNode(currentV);
            originalEdge.data.points.push({
                x: node.data.x,
                y: node.data.y,
            });
            if (node.data.dummy === DUMMY_NODE_EDGE_LABEL) {
                originalEdge.data.x = node.data.x;
                originalEdge.data.y = node.data.y;
                originalEdge.data.width = node.data.width;
                originalEdge.data.height = node.data.height;
            }
            currentV = w.id;
            node = g.getNode(currentV);
        }
    });
};

//# sourceMappingURL=normalize.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre/order/add-subgraph-constraints.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre/order/add-subgraph-constraints.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addSubgraphConstraints: () => (/* binding */ addSubgraphConstraints)
/* harmony export */ });
const addSubgraphConstraints = (g, cg, vs) => {
    const prev = {};
    let rootPrev;
    vs === null || vs === void 0 ? void 0 : vs.forEach((v) => {
        let child = g.getParent(v);
        let parent;
        let prevChild;
        while (child) {
            parent = g.getParent(child.id);
            if (parent) {
                prevChild = prev[parent.id];
                prev[parent.id] = child.id;
            }
            else {
                prevChild = rootPrev;
                rootPrev = child.id;
            }
            if (prevChild && prevChild !== child.id) {
                if (!cg.hasNode(prevChild)) {
                    cg.addNode({
                        id: prevChild,
                        data: {},
                    });
                }
                if (!cg.hasNode(child.id)) {
                    cg.addNode({
                        id: child.id,
                        data: {},
                    });
                }
                if (!cg.hasEdge(`e${prevChild}-${child.id}`)) {
                    cg.addEdge({
                        id: `e${prevChild}-${child.id}`,
                        source: prevChild,
                        target: child.id,
                        data: {},
                    });
                }
                return;
            }
            child = parent;
        }
    });
};
//# sourceMappingURL=add-subgraph-constraints.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre/order/barycenter.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre/order/barycenter.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   barycenter: () => (/* binding */ barycenter)
/* harmony export */ });
/**
 * TODO: The median method consistently performs better than the barycenter method and has a slight theoretical advantage
 */
const barycenter = (g, movable) => {
    return movable.map((v) => {
        const inV = g.getRelatedEdges(v, 'in');
        if (!(inV === null || inV === void 0 ? void 0 : inV.length)) {
            return { v };
        }
        const result = { sum: 0, weight: 0 };
        inV === null || inV === void 0 ? void 0 : inV.forEach((e) => {
            const nodeU = g.getNode(e.source);
            result.sum += e.data.weight * nodeU.data.order;
            result.weight += e.data.weight;
        });
        return {
            v,
            barycenter: result.sum / result.weight,
            weight: result.weight,
        };
    });
};
//# sourceMappingURL=barycenter.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre/order/build-layer-graph.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre/order/build-layer-graph.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildLayerGraph: () => (/* binding */ buildLayerGraph)
/* harmony export */ });
/* harmony import */ var _antv_graphlib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/graphlib */ "./node_modules/@antv/graphlib/esm/graph.js");

/*
 * Constructs a graph that can be used to sort a layer of nodes. The graph will
 * contain all base and subgraph nodes from the request layer in their original
 * hierarchy and any edges that are incident on these nodes and are of the type
 * requested by the "relationship" parameter.
 *
 * Nodes from the requested rank that do not have parents are assigned a root
 * node in the output graph, which is set in the root graph attribute. This
 * makes it easy to walk the hierarchy of movable nodes during ordering.
 *
 * Pre-conditions:
 *
 *    1. Input graph is a DAG
 *    2. Base nodes in the input graph have a rank attribute
 *    3. Subgraph nodes in the input graph has minRank and maxRank attributes
 *    4. Edges have an assigned weight
 *
 * Post-conditions:
 *
 *    1. Output graph has all nodes in the movable rank with preserved
 *       hierarchy.
 *    2. Root nodes in the movable layer are made children of the node
 *       indicated by the root attribute of the graph.
 *    3. Non-movable nodes incident on movable nodes, selected by the
 *       relationship parameter, are included in the graph (without hierarchy).
 *    4. Edges incident on movable nodes, selected by the relationship
 *       parameter, are added to the output graph.
 *    5. The weights for copied edges are aggregated as need, since the output
 *       graph is not a multi-graph.
 */
const buildLayerGraph = (g, rank, direction) => {
    const root = createRootNode(g);
    const result = new _antv_graphlib__WEBPACK_IMPORTED_MODULE_0__.Graph({
        tree: [
            {
                id: root,
                children: [],
                data: {},
            },
        ],
    });
    g.getAllNodes().forEach((v) => {
        const parent = g.getParent(v.id);
        if (v.data.rank === rank ||
            (v.data.minRank <= rank && rank <= v.data.maxRank)) {
            if (!result.hasNode(v.id)) {
                result.addNode(Object.assign({}, v));
            }
            if ((parent === null || parent === void 0 ? void 0 : parent.id) && !result.hasNode(parent === null || parent === void 0 ? void 0 : parent.id)) {
                result.addNode(Object.assign({}, parent));
            }
            result.setParent(v.id, (parent === null || parent === void 0 ? void 0 : parent.id) || root);
            // This assumes we have only short edges!
            g.getRelatedEdges(v.id, direction).forEach((e) => {
                const u = e.source === v.id ? e.target : e.source;
                if (!result.hasNode(u)) {
                    result.addNode(Object.assign({}, g.getNode(u)));
                }
                const edge = result
                    .getRelatedEdges(u, 'out')
                    .find(({ target }) => target === v.id);
                const weight = edge !== undefined ? edge.data.weight : 0;
                if (!edge) {
                    result.addEdge({
                        id: e.id,
                        source: u,
                        target: v.id,
                        data: {
                            weight: e.data.weight + weight,
                        },
                    });
                }
                else {
                    result.updateEdgeData(edge.id, Object.assign(Object.assign({}, edge.data), { weight: e.data.weight + weight }));
                }
            });
            // console.log(v);
            if (v.data.hasOwnProperty('minRank')) {
                result.updateNodeData(v.id, Object.assign(Object.assign({}, v.data), { borderLeft: v.data.borderLeft[rank], borderRight: v.data.borderRight[rank] }));
            }
        }
    });
    return result;
};
const createRootNode = (g) => {
    let v;
    while (g.hasNode((v = `_root${Math.random()}`)))
        ;
    return v;
};
//# sourceMappingURL=build-layer-graph.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre/order/cross-count.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre/order/cross-count.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   crossCount: () => (/* binding */ crossCount)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/lib/antv-dagre/util.js");
/*
 * A function that takes a layering (an array of layers, each with an array of
 * ordererd nodes) and a graph and returns a weighted crossing count.
 *
 * Pre-conditions:
 *
 *    1. Input graph must be simple (not a multigraph), directed, and include
 *       only simple edges.
 *    2. Edges in the input graph must have assigned weights.
 *
 * Post-conditions:
 *
 *    1. The graph and layering matrix are left unchanged.
 *
 * This algorithm is derived from Barth, et al., "Bilayer Cross Counting."
 */

const twoLayerCrossCount = (g, northLayer, southLayer) => {
    // Sort all of the edges between the north and south layers by their position
    // in the north layer and then the south. Map these edges to the position of
    // their head in the south layer.
    const southPos = (0,_util__WEBPACK_IMPORTED_MODULE_0__.zipObject)(southLayer, southLayer.map((v, i) => i));
    const unflat = northLayer.map((v) => {
        const unsort = g.getRelatedEdges(v, 'out').map((e) => {
            return { pos: southPos[e.target] || 0, weight: e.data.weight };
        });
        return unsort === null || unsort === void 0 ? void 0 : unsort.sort((a, b) => a.pos - b.pos);
    });
    const southEntries = unflat.flat().filter((entry) => entry !== undefined);
    // Build the accumulator tree
    let firstIndex = 1;
    while (firstIndex < southLayer.length)
        firstIndex <<= 1;
    const treeSize = 2 * firstIndex - 1;
    firstIndex -= 1;
    const tree = Array(treeSize).fill(0, 0, treeSize);
    // Calculate the weighted crossings
    let cc = 0;
    southEntries === null || southEntries === void 0 ? void 0 : southEntries.forEach((entry) => {
        if (entry) {
            let index = entry.pos + firstIndex;
            tree[index] += entry.weight;
            let weightSum = 0;
            while (index > 0) {
                if (index % 2) {
                    weightSum += tree[index + 1];
                }
                index = (index - 1) >> 1;
                tree[index] += entry.weight;
            }
            cc += entry.weight * weightSum;
        }
    });
    return cc;
};
const crossCount = (g, layering) => {
    let cc = 0;
    for (let i = 1; i < (layering === null || layering === void 0 ? void 0 : layering.length); i += 1) {
        cc += twoLayerCrossCount(g, layering[i - 1], layering[i]);
    }
    return cc;
};
//# sourceMappingURL=cross-count.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre/order/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre/order/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   order: () => (/* binding */ order)
/* harmony export */ });
/* harmony import */ var _antv_graphlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @antv/graphlib */ "./node_modules/@antv/graphlib/esm/graph.js");
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/clone.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/lib/antv-dagre/util.js");
/* harmony import */ var _add_subgraph_constraints__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./add-subgraph-constraints */ "./node_modules/@antv/layout/lib/antv-dagre/order/add-subgraph-constraints.js");
/* harmony import */ var _build_layer_graph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./build-layer-graph */ "./node_modules/@antv/layout/lib/antv-dagre/order/build-layer-graph.js");
/* harmony import */ var _cross_count__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cross-count */ "./node_modules/@antv/layout/lib/antv-dagre/order/cross-count.js");
/* harmony import */ var _init_order__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./init-order */ "./node_modules/@antv/layout/lib/antv-dagre/order/init-order.js");
/* harmony import */ var _sort_subgraph__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sort-subgraph */ "./node_modules/@antv/layout/lib/antv-dagre/order/sort-subgraph.js");








/*
 * Applies heuristics to minimize edge crossings in the graph and sets the best
 * order solution as an order attribute on each node.
 *
 * Pre-conditions:
 *
 *    1. Graph must be DAG
 *    2. Graph nodes must be objects with a "rank" attribute
 *    3. Graph edges must have the "weight" attribute
 *
 * Post-conditions:
 *
 *    1. Graph nodes will have an "order" attribute based on the results of the
 *       algorithm.
 */
const order = (g, keepNodeOrder) => {
    const mxRank = (0,_util__WEBPACK_IMPORTED_MODULE_0__.maxRank)(g);
    const range1 = [];
    const range2 = [];
    for (let i = 1; i < mxRank + 1; i++)
        range1.push(i);
    for (let i = mxRank - 1; i > -1; i--)
        range2.push(i);
    const downLayerGraphs = buildLayerGraphs(g, range1, 'in');
    const upLayerGraphs = buildLayerGraphs(g, range2, 'out');
    let layering = (0,_init_order__WEBPACK_IMPORTED_MODULE_1__.initOrder)(g);
    assignOrder(g, layering);
    let bestCC = Number.POSITIVE_INFINITY;
    let best;
    for (let i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
        sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2, false, keepNodeOrder);
        layering = (0,_util__WEBPACK_IMPORTED_MODULE_0__.buildLayerMatrix)(g);
        const cc = (0,_cross_count__WEBPACK_IMPORTED_MODULE_2__.crossCount)(g, layering);
        if (cc < bestCC) {
            lastBest = 0;
            best = (0,_antv_util__WEBPACK_IMPORTED_MODULE_3__["default"])(layering);
            bestCC = cc;
        }
    }
    // consider use previous result, maybe somewhat reduendant
    layering = (0,_init_order__WEBPACK_IMPORTED_MODULE_1__.initOrder)(g);
    assignOrder(g, layering);
    for (let i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
        sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2, true, keepNodeOrder);
        layering = (0,_util__WEBPACK_IMPORTED_MODULE_0__.buildLayerMatrix)(g);
        const cc = (0,_cross_count__WEBPACK_IMPORTED_MODULE_2__.crossCount)(g, layering);
        if (cc < bestCC) {
            lastBest = 0;
            best = (0,_antv_util__WEBPACK_IMPORTED_MODULE_3__["default"])(layering);
            bestCC = cc;
        }
    }
    assignOrder(g, best);
};
const buildLayerGraphs = (g, ranks, direction) => {
    return ranks.map((rank) => {
        return (0,_build_layer_graph__WEBPACK_IMPORTED_MODULE_4__.buildLayerGraph)(g, rank, direction);
    });
};
const sweepLayerGraphs = (layerGraphs, biasRight, usePrev, keepNodeOrder) => {
    const cg = new _antv_graphlib__WEBPACK_IMPORTED_MODULE_5__.Graph();
    layerGraphs === null || layerGraphs === void 0 ? void 0 : layerGraphs.forEach((lg) => {
        var _a;
        // const root = lg.graph().root as string;
        const root = lg.getRoots()[0].id;
        const sorted = (0,_sort_subgraph__WEBPACK_IMPORTED_MODULE_6__.sortSubgraph)(lg, root, cg, biasRight, usePrev, keepNodeOrder);
        for (let i = 0; i < ((_a = sorted.vs) === null || _a === void 0 ? void 0 : _a.length) || 0; i++) {
            const lnode = lg.getNode(sorted.vs[i]);
            if (lnode) {
                lnode.data.order = i;
            }
        }
        (0,_add_subgraph_constraints__WEBPACK_IMPORTED_MODULE_7__.addSubgraphConstraints)(lg, cg, sorted.vs);
    });
};
const assignOrder = (g, layering) => {
    layering === null || layering === void 0 ? void 0 : layering.forEach((layer) => {
        layer === null || layer === void 0 ? void 0 : layer.forEach((v, i) => {
            g.getNode(v).data.order = i;
        });
    });
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre/order/init-data-order.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre/order/init-data-order.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initDataOrder: () => (/* binding */ initDataOrder)
/* harmony export */ });
/**
 * 按照数据中的结果设置fixorder
 */
const initDataOrder = (g, nodeOrder) => {
    const simpleNodes = g.getAllNodes().filter((v) => {
        var _a;
        return !((_a = g.getChildren(v.id)) === null || _a === void 0 ? void 0 : _a.length);
    });
    const ranks = simpleNodes.map((v) => v.data.rank);
    const maxRank = Math.max(...ranks);
    const layers = [];
    for (let i = 0; i < maxRank + 1; i++) {
        layers[i] = [];
    }
    nodeOrder === null || nodeOrder === void 0 ? void 0 : nodeOrder.forEach((n) => {
        const node = g.getNode(n);
        // 只考虑原有节点，dummy节点需要按照后续算法排出
        if (!node || node.data.dummy) {
            return;
        }
        if (!isNaN(node.data.rank)) {
            node.data.fixorder = layers[node.data.rank].length; // 设置fixorder为当层的顺序
            layers[node.data.rank].push(n);
        }
    });
};
//# sourceMappingURL=init-data-order.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre/order/init-order.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre/order/init-order.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initOrder: () => (/* binding */ initOrder)
/* harmony export */ });
/*
 * Assigns an initial order value for each node by performing a DFS search
 * starting from nodes in the first rank. Nodes are assigned an order in their
 * rank as they are first visited.
 *
 * This approach comes from Gansner, et al., "A Technique for Drawing Directed
 * Graphs."
 *
 * Returns a layering matrix with an array per layer and each layer sorted by
 * the order of its nodes.
 */
const initOrder = (g) => {
    const visited = {};
    // const simpleNodes = g.getAllNodes().filter((v) => {
    //   return !g.getChildren(v.id)?.length;
    // });
    const simpleNodes = g.getAllNodes();
    const nodeRanks = simpleNodes.map((v) => { var _a; return (_a = v.data.rank) !== null && _a !== void 0 ? _a : -Infinity; });
    const maxRank = Math.max(...nodeRanks);
    const layers = [];
    for (let i = 0; i < maxRank + 1; i++) {
        layers.push([]);
    }
    const orderedVs = simpleNodes.sort((a, b) => g.getNode(a.id).data.rank - g.getNode(b.id).data.rank);
    // const orderedVs = _.sortBy(simpleNodes, function(v) { return g.node(v)!.rank; });
    // 有fixOrder的，直接排序好放进去
    const beforeSort = orderedVs.filter((n) => {
        return g.getNode(n.id).data.fixorder !== undefined;
    });
    const fixOrderNodes = beforeSort.sort((a, b) => g.getNode(a.id).data.fixorder - g.getNode(b.id).data.fixorder);
    fixOrderNodes === null || fixOrderNodes === void 0 ? void 0 : fixOrderNodes.forEach((n) => {
        if (!isNaN(g.getNode(n.id).data.rank)) {
            layers[g.getNode(n.id).data.rank].push(n.id);
        }
        visited[n.id] = true;
    });
    orderedVs === null || orderedVs === void 0 ? void 0 : orderedVs.forEach((n) => g.dfsTree(n.id, (node) => {
        if (visited.hasOwnProperty(node.id))
            return true;
        visited[node.id] = true;
        if (!isNaN(node.data.rank)) {
            layers[node.data.rank].push(node.id);
        }
    }));
    return layers;
};
//# sourceMappingURL=init-order.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre/order/resolve-conflicts.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre/order/resolve-conflicts.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 * Given a list of entries of the form {v, barycenter, weight} and a
 * constraint graph this function will resolve any conflicts between the
 * constraint graph and the barycenters for the entries. If the barycenters for
 * an entry would violate a constraint in the constraint graph then we coalesce
 * the nodes in the conflict into a new node that respects the contraint and
 * aggregates barycenter and weight information.
 *
 * This implementation is based on the description in Forster, "A Fast and
 * Simple Hueristic for Constrained Two-Level Crossing Reduction," thought it
 * differs in some specific details.
 *
 * Pre-conditions:
 *
 *    1. Each entry has the form {v, barycenter, weight}, or if the node has
 *       no barycenter, then {v}.
 *
 * Returns:
 *
 *    A new list of entries of the form {vs, i, barycenter, weight}. The list
 *    `vs` may either be a singleton or it may be an aggregation of nodes
 *    ordered such that they do not violate constraints from the constraint
 *    graph. The property `i` is the lowest original index of any of the
 *    elements in `vs`.
 */
const resolveConflicts = (entries, cg) => {
    var _a, _b, _c;
    const mappedEntries = {};
    entries === null || entries === void 0 ? void 0 : entries.forEach((entry, i) => {
        mappedEntries[entry.v] = {
            i,
            indegree: 0,
            in: [],
            out: [],
            vs: [entry.v],
        };
        const tmp = mappedEntries[entry.v];
        if (entry.barycenter !== undefined) {
            tmp.barycenter = entry.barycenter;
            tmp.weight = entry.weight;
        }
    });
    (_a = cg.getAllEdges()) === null || _a === void 0 ? void 0 : _a.forEach((e) => {
        const entryV = mappedEntries[e.source];
        const entryW = mappedEntries[e.target];
        if (entryV !== undefined && entryW !== undefined) {
            entryW.indegree++;
            entryV.out.push(mappedEntries[e.target]);
        }
    });
    const sourceSet = (_c = (_b = Object.values(mappedEntries)).filter) === null || _c === void 0 ? void 0 : _c.call(_b, (entry) => !entry.indegree);
    return doResolveConflicts(sourceSet);
};
const doResolveConflicts = (sourceSet) => {
    var _a, _b;
    const entries = [];
    const handleIn = (vEntry) => {
        return (uEntry) => {
            if (uEntry.merged)
                return;
            if (uEntry.barycenter === undefined ||
                vEntry.barycenter === undefined ||
                uEntry.barycenter >= vEntry.barycenter) {
                mergeEntries(vEntry, uEntry);
            }
        };
    };
    const handleOut = (vEntry) => {
        return (wEntry) => {
            wEntry['in'].push(vEntry);
            if (--wEntry.indegree === 0) {
                sourceSet.push(wEntry);
            }
        };
    };
    while (sourceSet === null || sourceSet === void 0 ? void 0 : sourceSet.length) {
        const entry = sourceSet.pop();
        entries.push(entry);
        (_a = entry['in'].reverse()) === null || _a === void 0 ? void 0 : _a.forEach((e) => handleIn(entry)(e));
        (_b = entry.out) === null || _b === void 0 ? void 0 : _b.forEach((e) => handleOut(entry)(e));
    }
    const filtered = entries.filter((entry) => !entry.merged);
    const keys = [
        'vs',
        'i',
        'barycenter',
        'weight',
    ];
    return filtered.map((entry) => {
        const picked = {};
        keys === null || keys === void 0 ? void 0 : keys.forEach((key) => {
            if (entry[key] === undefined)
                return;
            picked[key] = entry[key];
        });
        return picked;
    });
};
const mergeEntries = (target, source) => {
    var _a;
    let sum = 0;
    let weight = 0;
    if (target.weight) {
        sum += target.barycenter * target.weight;
        weight += target.weight;
    }
    if (source.weight) {
        sum += source.barycenter * source.weight;
        weight += source.weight;
    }
    target.vs = (_a = source.vs) === null || _a === void 0 ? void 0 : _a.concat(target.vs);
    target.barycenter = sum / weight;
    target.weight = weight;
    target.i = Math.min(source.i, target.i);
    source.merged = true;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (resolveConflicts);
//# sourceMappingURL=resolve-conflicts.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre/order/sort-subgraph.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre/order/sort-subgraph.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sortSubgraph: () => (/* binding */ sortSubgraph)
/* harmony export */ });
/* harmony import */ var _barycenter__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./barycenter */ "./node_modules/@antv/layout/lib/antv-dagre/order/barycenter.js");
/* harmony import */ var _resolve_conflicts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resolve-conflicts */ "./node_modules/@antv/layout/lib/antv-dagre/order/resolve-conflicts.js");
/* harmony import */ var _sort__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sort */ "./node_modules/@antv/layout/lib/antv-dagre/order/sort.js");



const sortSubgraph = (g, v, cg, biasRight, usePrev, keepNodeOrder) => {
    var _a, _b, _c, _d;
    let movable = g.getChildren(v).map((n) => n.id);
    // fixorder的点不参与排序（这个方案不合适，只排了新增节点，和原来的分离）
    const node = g.getNode(v);
    const bl = node ? node.data.borderLeft : undefined;
    const br = node ? node.data.borderRight : undefined;
    const subgraphs = {};
    if (bl) {
        movable = movable === null || movable === void 0 ? void 0 : movable.filter((w) => {
            return w !== bl && w !== br;
        });
    }
    const barycenters = (0,_barycenter__WEBPACK_IMPORTED_MODULE_0__.barycenter)(g, movable || []);
    barycenters === null || barycenters === void 0 ? void 0 : barycenters.forEach((entry) => {
        var _a;
        if ((_a = g.getChildren(entry.v)) === null || _a === void 0 ? void 0 : _a.length) {
            const subgraphResult = sortSubgraph(g, entry.v, cg, biasRight, keepNodeOrder);
            subgraphs[entry.v] = subgraphResult;
            if (subgraphResult.hasOwnProperty('barycenter')) {
                mergeBarycenters(entry, subgraphResult);
            }
        }
    });
    const entries = (0,_resolve_conflicts__WEBPACK_IMPORTED_MODULE_1__["default"])(barycenters, cg);
    expandSubgraphs(entries, subgraphs);
    // 添加fixorder信息到entries里边
    // TODO: 不考虑复合情况，只用第一个点的fixorder信息，后续考虑更完备的实现
    (_a = entries
        .filter((e) => e.vs.length > 0)) === null || _a === void 0 ? void 0 : _a.forEach((e) => {
        const node = g.getNode(e.vs[0]);
        if (node) {
            e.fixorder = node.data.fixorder;
            e.order = node.data.order;
        }
    });
    const result = (0,_sort__WEBPACK_IMPORTED_MODULE_2__.sort)(entries, biasRight, usePrev, keepNodeOrder);
    if (bl) {
        result.vs = [bl, result.vs, br].flat();
        if ((_b = g.getPredecessors(bl)) === null || _b === void 0 ? void 0 : _b.length) {
            const blPred = g.getNode(((_c = g.getPredecessors(bl)) === null || _c === void 0 ? void 0 : _c[0].id) || '');
            const brPred = g.getNode(((_d = g.getPredecessors(br)) === null || _d === void 0 ? void 0 : _d[0].id) || '');
            if (!result.hasOwnProperty('barycenter')) {
                result.barycenter = 0;
                result.weight = 0;
            }
            result.barycenter =
                (result.barycenter * result.weight +
                    blPred.data.order +
                    brPred.data.order) /
                    (result.weight + 2);
            result.weight += 2;
        }
    }
    return result;
};
const expandSubgraphs = (entries, subgraphs) => {
    entries === null || entries === void 0 ? void 0 : entries.forEach((entry) => {
        var _a;
        const vss = (_a = entry.vs) === null || _a === void 0 ? void 0 : _a.map((v) => {
            if (subgraphs[v]) {
                return subgraphs[v].vs;
            }
            return v;
        });
        entry.vs = vss.flat();
    });
};
const mergeBarycenters = (target, other) => {
    if (target.barycenter !== undefined) {
        target.barycenter =
            (target.barycenter * target.weight + other.barycenter * other.weight) /
                (target.weight + other.weight);
        target.weight += other.weight;
    }
    else {
        target.barycenter = other.barycenter;
        target.weight = other.weight;
    }
};
//# sourceMappingURL=sort-subgraph.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre/order/sort.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre/order/sort.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sort: () => (/* binding */ sort)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/lib/antv-dagre/util.js");

const sort = (entries, biasRight, usePrev, keepNodeOrder) => {
    const parts = (0,_util__WEBPACK_IMPORTED_MODULE_0__.partition)(entries, (entry) => {
        const hasFixOrder = entry.hasOwnProperty('fixorder') && !isNaN(entry.fixorder);
        if (keepNodeOrder) {
            return !hasFixOrder && entry.hasOwnProperty('barycenter');
        }
        // NOTE: 有fixorder的也可以排
        return hasFixOrder || entry.hasOwnProperty('barycenter');
    });
    const sortable = parts.lhs;
    const unsortable = parts.rhs.sort((a, b) => -a.i - -b.i);
    const vs = [];
    let sum = 0;
    let weight = 0;
    let vsIndex = 0;
    sortable === null || sortable === void 0 ? void 0 : sortable.sort(compareWithBias(!!biasRight, !!usePrev));
    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
    sortable === null || sortable === void 0 ? void 0 : sortable.forEach((entry) => {
        var _a;
        vsIndex += (_a = entry.vs) === null || _a === void 0 ? void 0 : _a.length;
        vs.push(entry.vs);
        sum += entry.barycenter * entry.weight;
        weight += entry.weight;
        vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
    });
    const result = {
        vs: vs.flat(),
    };
    if (weight) {
        result.barycenter = sum / weight;
        result.weight = weight;
    }
    return result;
};
const consumeUnsortable = (vs, unsortable, index) => {
    let iindex = index;
    let last;
    while (unsortable.length &&
        (last = unsortable[unsortable.length - 1]).i <= iindex) {
        unsortable.pop();
        vs === null || vs === void 0 ? void 0 : vs.push(last.vs);
        iindex++;
    }
    return iindex;
};
/**
 * 配置是否考虑使用之前的布局结果
 */
const compareWithBias = (bias, usePrev) => {
    return (entryV, entryW) => {
        // 排序的时候先判断fixorder，不行再判断重心
        if (entryV.fixorder !== undefined && entryW.fixorder !== undefined) {
            return entryV.fixorder - entryW.fixorder;
        }
        if (entryV.barycenter < entryW.barycenter) {
            return -1;
        }
        if (entryV.barycenter > entryW.barycenter) {
            return 1;
        }
        // 重心相同，考虑之前排好的顺序
        if (usePrev && entryV.order !== undefined && entryW.order !== undefined) {
            if (entryV.order < entryW.order) {
                return -1;
            }
            if (entryV.order > entryW.order) {
                return 1;
            }
        }
        return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
    };
};
//# sourceMappingURL=sort.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre/parent-dummy-chains.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre/parent-dummy-chains.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parentDummyChains: () => (/* binding */ parentDummyChains)
/* harmony export */ });
// deep first search with both order low for pre, lim for post
const dfsBothOrder = (g) => {
    const result = {};
    let lim = 0;
    const dfs = (v) => {
        const low = lim;
        g.getChildren(v).forEach((n) => dfs(n.id));
        result[v] = { low, lim: lim++ };
    };
    g.getRoots().forEach((n) => dfs(n.id));
    return result;
};
// Find a path from v to w through the lowest common ancestor (LCA). Return the
// full path and the LCA.
const findPath = (g, postorderNums, v, w) => {
    var _a, _b;
    const vPath = [];
    const wPath = [];
    const low = Math.min(postorderNums[v].low, postorderNums[w].low);
    const lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);
    let parent;
    let lca;
    // Traverse up from v to find the LCA
    parent = v;
    do {
        parent = (_a = g.getParent(parent)) === null || _a === void 0 ? void 0 : _a.id;
        vPath.push(parent);
    } while (parent &&
        (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
    lca = parent;
    // Traverse from w to LCA
    parent = w;
    while (parent && parent !== lca) {
        wPath.push(parent);
        parent = (_b = g.getParent(parent)) === null || _b === void 0 ? void 0 : _b.id;
    }
    return { lca, path: vPath.concat(wPath.reverse()) };
};
const parentDummyChains = (g, dummyChains) => {
    const postorderNums = dfsBothOrder(g);
    dummyChains.forEach((startV) => {
        var _a, _b;
        let v = startV;
        let node = g.getNode(v);
        const originalEdge = node.data.originalEdge;
        if (!originalEdge)
            return;
        const pathData = findPath(g, postorderNums, originalEdge.source, originalEdge.target);
        const path = pathData.path;
        const lca = pathData.lca;
        let pathIdx = 0;
        let pathV = path[pathIdx];
        let ascending = true;
        while (v !== originalEdge.target) {
            node = g.getNode(v);
            if (ascending) {
                while (pathV !== lca &&
                    ((_a = g.getNode(pathV)) === null || _a === void 0 ? void 0 : _a.data.maxRank) < node.data.rank) {
                    pathIdx++;
                    pathV = path[pathIdx];
                }
                if (pathV === lca) {
                    ascending = false;
                }
            }
            if (!ascending) {
                while (pathIdx < path.length - 1 &&
                    ((_b = g.getNode(path[pathIdx + 1])) === null || _b === void 0 ? void 0 : _b.data.minRank) <= node.data.rank) {
                    pathIdx++;
                }
                pathV = path[pathIdx];
            }
            if (g.hasNode(pathV)) {
                g.setParent(v, pathV);
            }
            v = g.getSuccessors(v)[0].id;
        }
    });
};
//# sourceMappingURL=parent-dummy-chains.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre/position/bk.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre/position/bk.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addConflict: () => (/* binding */ addConflict),
/* harmony export */   alignCoordinates: () => (/* binding */ alignCoordinates),
/* harmony export */   balance: () => (/* binding */ balance),
/* harmony export */   buildBlockGraph: () => (/* binding */ buildBlockGraph),
/* harmony export */   findOtherInnerSegmentNode: () => (/* binding */ findOtherInnerSegmentNode),
/* harmony export */   findSmallestWidthAlignment: () => (/* binding */ findSmallestWidthAlignment),
/* harmony export */   findType1Conflicts: () => (/* binding */ findType1Conflicts),
/* harmony export */   findType2Conflicts: () => (/* binding */ findType2Conflicts),
/* harmony export */   hasConflict: () => (/* binding */ hasConflict),
/* harmony export */   horizontalCompaction: () => (/* binding */ horizontalCompaction),
/* harmony export */   positionX: () => (/* binding */ positionX),
/* harmony export */   sep: () => (/* binding */ sep),
/* harmony export */   verticalAlignment: () => (/* binding */ verticalAlignment),
/* harmony export */   width: () => (/* binding */ width)
/* harmony export */ });
/* harmony import */ var _antv_graphlib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/graphlib */ "./node_modules/@antv/graphlib/esm/graph.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/lib/antv-dagre/util.js");
/*
 * This module provides coordinate assignment based on Brandes and Köpf, "Fast
 * and Simple Horizontal Coordinate Assignment."
 */


const findType1Conflicts = (g, layering) => {
    const conflicts = {};
    const visitLayer = (prevLayer, layer) => {
        // last visited node in the previous layer that is incident on an inner
        // segment.
        let k0 = 0;
        // Tracks the last node in this layer scanned for crossings with a type-1
        // segment.
        let scanPos = 0;
        const prevLayerLength = prevLayer.length;
        const lastNode = layer === null || layer === void 0 ? void 0 : layer[(layer === null || layer === void 0 ? void 0 : layer.length) - 1];
        layer === null || layer === void 0 ? void 0 : layer.forEach((v, i) => {
            var _a;
            const w = findOtherInnerSegmentNode(g, v);
            const k1 = w ? g.getNode(w.id).data.order : prevLayerLength;
            if (w || v === lastNode) {
                (_a = layer.slice(scanPos, i + 1)) === null || _a === void 0 ? void 0 : _a.forEach((scanNode) => {
                    var _a;
                    (_a = g.getPredecessors(scanNode)) === null || _a === void 0 ? void 0 : _a.forEach((u) => {
                        var _a;
                        const uLabel = g.getNode(u.id);
                        const uPos = uLabel.data.order;
                        if ((uPos < k0 || k1 < uPos) &&
                            !(uLabel.data.dummy && ((_a = g.getNode(scanNode)) === null || _a === void 0 ? void 0 : _a.data.dummy))) {
                            addConflict(conflicts, u.id, scanNode);
                        }
                    });
                });
                scanPos = i + 1;
                k0 = k1;
            }
        });
        return layer;
    };
    if (layering === null || layering === void 0 ? void 0 : layering.length) {
        layering.reduce(visitLayer);
    }
    return conflicts;
};
const findType2Conflicts = (g, layering) => {
    const conflicts = {};
    function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
        var _a, _b;
        let v;
        for (let i = southPos; i < southEnd; i++) {
            v = south[i];
            if ((_a = g.getNode(v)) === null || _a === void 0 ? void 0 : _a.data.dummy) {
                (_b = g.getPredecessors(v)) === null || _b === void 0 ? void 0 : _b.forEach((u) => {
                    const uNode = g.getNode(u.id);
                    if (uNode.data.dummy &&
                        (uNode.data.order < prevNorthBorder ||
                            uNode.data.order > nextNorthBorder)) {
                        addConflict(conflicts, u.id, v);
                    }
                });
            }
        }
    }
    function getScannedKey(params) {
        // south数组可能很大，不适合做key
        return JSON.stringify(params.slice(1));
    }
    function scanIfNeeded(params, scanCache) {
        const cacheKey = getScannedKey(params);
        if (scanCache.get(cacheKey))
            return;
        scan(...params);
        scanCache.set(cacheKey, true);
    }
    const visitLayer = (north, south) => {
        let prevNorthPos = -1;
        let nextNorthPos;
        let southPos = 0;
        const scanned = new Map();
        south === null || south === void 0 ? void 0 : south.forEach((v, southLookahead) => {
            var _a;
            if (((_a = g.getNode(v)) === null || _a === void 0 ? void 0 : _a.data.dummy) === 'border') {
                const predecessors = g.getPredecessors(v) || [];
                if (predecessors.length) {
                    nextNorthPos = g.getNode(predecessors[0].id).data.order;
                    scanIfNeeded([south, southPos, southLookahead, prevNorthPos, nextNorthPos], scanned);
                    southPos = southLookahead;
                    prevNorthPos = nextNorthPos;
                }
            }
            scanIfNeeded([south, southPos, south.length, nextNorthPos, north.length], scanned);
        });
        return south;
    };
    if (layering === null || layering === void 0 ? void 0 : layering.length) {
        layering.reduce(visitLayer);
    }
    return conflicts;
};
const findOtherInnerSegmentNode = (g, v) => {
    var _a, _b;
    if ((_a = g.getNode(v)) === null || _a === void 0 ? void 0 : _a.data.dummy) {
        return (_b = g.getPredecessors(v)) === null || _b === void 0 ? void 0 : _b.find((u) => g.getNode(u.id).data.dummy);
    }
};
const addConflict = (conflicts, v, w) => {
    let vv = v;
    let ww = w;
    if (vv > ww) {
        const tmp = vv;
        vv = ww;
        ww = tmp;
    }
    let conflictsV = conflicts[vv];
    if (!conflictsV) {
        conflicts[vv] = conflictsV = {};
    }
    conflictsV[ww] = true;
};
const hasConflict = (conflicts, v, w) => {
    let vv = v;
    let ww = w;
    if (vv > ww) {
        const tmp = v;
        vv = ww;
        ww = tmp;
    }
    return !!conflicts[vv];
};
/*
 * Try to align nodes into vertical "blocks" where possible. This algorithm
 * attempts to align a node with one of its median neighbors. If the edge
 * connecting a neighbor is a type-1 conflict then we ignore that possibility.
 * If a previous node has already formed a block with a node after the node
 * we're trying to form a block with, we also ignore that possibility - our
 * blocks would be split in that scenario.
 */
const verticalAlignment = (g, layering, conflicts, neighborFn) => {
    const root = {};
    const align = {};
    const pos = {};
    // We cache the position here based on the layering because the graph and
    // layering may be out of sync. The layering matrix is manipulated to
    // generate different extreme alignments.
    layering === null || layering === void 0 ? void 0 : layering.forEach((layer) => {
        layer === null || layer === void 0 ? void 0 : layer.forEach((v, order) => {
            root[v] = v;
            align[v] = v;
            pos[v] = order;
        });
    });
    layering === null || layering === void 0 ? void 0 : layering.forEach((layer) => {
        let prevIdx = -1;
        layer === null || layer === void 0 ? void 0 : layer.forEach((v) => {
            let ws = neighborFn(v).map((n) => n.id);
            if (ws.length) {
                ws = ws.sort((a, b) => pos[a] - pos[b]);
                const mp = (ws.length - 1) / 2;
                for (let i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {
                    const w = ws[i];
                    if (align[v] === v &&
                        prevIdx < pos[w] &&
                        !hasConflict(conflicts, v, w)) {
                        align[w] = v;
                        align[v] = root[v] = root[w];
                        prevIdx = pos[w];
                    }
                }
            }
        });
    });
    return { root, align };
};
const horizontalCompaction = (g, layering, root, align, nodesep, edgesep, reverseSep) => {
    var _a;
    // This portion of the algorithm differs from BK due to a number of problems.
    // Instead of their algorithm we construct a new block graph and do two
    // sweeps. The first sweep places blocks with the smallest possible
    // coordinates. The second sweep removes unused space by moving blocks to the
    // greatest coordinates without violating separation.
    const xs = {};
    const blockG = buildBlockGraph(g, layering, root, nodesep, edgesep, reverseSep);
    const borderType = reverseSep ? 'borderLeft' : 'borderRight';
    const iterate = (setXsFunc, nextNodesFunc) => {
        let stack = blockG.getAllNodes();
        let elem = stack.pop();
        const visited = {};
        while (elem) {
            if (visited[elem.id]) {
                setXsFunc(elem.id);
            }
            else {
                visited[elem.id] = true;
                stack.push(elem);
                stack = stack.concat(nextNodesFunc(elem.id));
            }
            elem = stack.pop();
        }
    };
    // First pass, assign smallest coordinates
    const pass1 = (elem) => {
        xs[elem] = (blockG.getRelatedEdges(elem, 'in') || []).reduce((acc, e) => {
            return Math.max(acc, (xs[e.source] || 0) + e.data.weight);
        }, 0);
    };
    // Second pass, assign greatest coordinates
    const pass2 = (elem) => {
        const min = (blockG.getRelatedEdges(elem, 'out') || []).reduce((acc, e) => {
            return Math.min(acc, (xs[e.target] || 0) - e.data.weight);
        }, Number.POSITIVE_INFINITY);
        const node = g.getNode(elem);
        if (min !== Number.POSITIVE_INFINITY &&
            node.data.borderType !== borderType) {
            xs[elem] = Math.max(xs[elem], min);
        }
    };
    iterate(pass1, blockG.getPredecessors.bind(blockG));
    iterate(pass2, blockG.getSuccessors.bind(blockG));
    // Assign x coordinates to all nodes
    (_a = Object.values(align)) === null || _a === void 0 ? void 0 : _a.forEach((v) => {
        xs[v] = xs[root[v]];
    });
    return xs;
};
const buildBlockGraph = (g, layering, root, nodesep, edgesep, reverseSep) => {
    const blockGraph = new _antv_graphlib__WEBPACK_IMPORTED_MODULE_0__.Graph();
    const sepFn = sep(nodesep, edgesep, reverseSep);
    layering === null || layering === void 0 ? void 0 : layering.forEach((layer) => {
        let u;
        layer === null || layer === void 0 ? void 0 : layer.forEach((v) => {
            const vRoot = root[v];
            if (!blockGraph.hasNode(vRoot)) {
                blockGraph.addNode({
                    id: vRoot,
                    data: {},
                });
            }
            if (u) {
                const uRoot = root[u];
                const edge = blockGraph
                    .getRelatedEdges(uRoot, 'out')
                    .find((edge) => edge.target === vRoot);
                if (!edge) {
                    blockGraph.addEdge({
                        id: `e${Math.random()}`,
                        source: uRoot,
                        target: vRoot,
                        data: {
                            weight: Math.max(sepFn(g, v, u), 0),
                        },
                    });
                }
                else {
                    blockGraph.updateEdgeData(edge.id, Object.assign(Object.assign({}, edge.data), { weight: Math.max(sepFn(g, v, u), edge.data.weight || 0) }));
                }
            }
            u = v;
        });
    });
    return blockGraph;
};
/*
 * Returns the alignment that has the smallest width of the given alignments.
 */
const findSmallestWidthAlignment = (g, xss) => {
    return (0,_util__WEBPACK_IMPORTED_MODULE_1__.minBy)(Object.values(xss), (xs) => {
        var _a;
        let max = Number.NEGATIVE_INFINITY;
        let min = Number.POSITIVE_INFINITY;
        (_a = Object.keys(xs)) === null || _a === void 0 ? void 0 : _a.forEach((v) => {
            const x = xs[v];
            const halfWidth = width(g, v) / 2;
            max = Math.max(x + halfWidth, max);
            min = Math.min(x - halfWidth, min);
        });
        return max - min;
    });
};
/*
 * Align the coordinates of each of the layout alignments such that
 * left-biased alignments have their minimum coordinate at the same point as
 * the minimum coordinate of the smallest width alignment and right-biased
 * alignments have their maximum coordinate at the same point as the maximum
 * coordinate of the smallest width alignment.
 */
function alignCoordinates(xss, alignTo) {
    const alignToVals = Object.values(alignTo);
    const alignToMin = Math.min(...alignToVals);
    const alignToMax = Math.max(...alignToVals);
    ['u', 'd'].forEach((vert) => {
        ['l', 'r'].forEach((horiz) => {
            const alignment = vert + horiz;
            const xs = xss[alignment];
            let delta;
            if (xs === alignTo)
                return;
            const xsVals = Object.values(xs);
            delta =
                horiz === 'l'
                    ? alignToMin - Math.min(...xsVals)
                    : alignToMax - Math.max(...xsVals);
            if (delta) {
                xss[alignment] = {};
                Object.keys(xs).forEach((key) => {
                    xss[alignment][key] = xs[key] + delta;
                });
            }
        });
    });
}
const balance = (xss, align) => {
    const result = {};
    Object.keys(xss.ul).forEach((key) => {
        if (align) {
            result[key] = xss[align.toLowerCase()][key];
        }
        else {
            const values = Object.values(xss).map((x) => x[key]);
            result[key] = (values[0] + values[1]) / 2; // (ur + ul) / 2
        }
    });
    return result;
};
const positionX = (g, options) => {
    const { align: graphAlign, nodesep = 0, edgesep = 0 } = options || {};
    const layering = (0,_util__WEBPACK_IMPORTED_MODULE_1__.buildLayerMatrix)(g);
    const conflicts = Object.assign(findType1Conflicts(g, layering), findType2Conflicts(g, layering));
    const xss = {};
    let adjustedLayering;
    ['u', 'd'].forEach((vert) => {
        adjustedLayering =
            vert === 'u' ? layering : Object.values(layering).reverse();
        ['l', 'r'].forEach((horiz) => {
            if (horiz === 'r') {
                adjustedLayering = adjustedLayering.map((inner) => Object.values(inner).reverse());
            }
            const neighborFn = (vert === 'u' ? g.getPredecessors : g.getSuccessors).bind(g);
            const align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);
            const xs = horizontalCompaction(g, adjustedLayering, align.root, align.align, nodesep, edgesep, horiz === 'r');
            if (horiz === 'r') {
                Object.keys(xs).forEach((key) => {
                    xs[key] = -xs[key];
                });
            }
            xss[vert + horiz] = xs;
        });
    });
    const smallestWidth = findSmallestWidthAlignment(g, xss);
    alignCoordinates(xss, smallestWidth);
    return balance(xss, graphAlign);
};
const sep = (nodeSep, edgeSep, reverseSep) => {
    return (g, v, w) => {
        const vLabel = g.getNode(v);
        const wLabel = g.getNode(w);
        let sum = 0;
        let delta = 0;
        sum += vLabel.data.width / 2;
        if (vLabel.data.hasOwnProperty('labelpos')) {
            switch ((vLabel.data.labelpos || '').toLowerCase()) {
                case 'l':
                    delta = -vLabel.data.width / 2;
                    break;
                case 'r':
                    delta = vLabel.data.width / 2;
                    break;
            }
        }
        if (delta) {
            sum += reverseSep ? delta : -delta;
        }
        delta = 0;
        sum += (vLabel.data.dummy ? edgeSep : nodeSep) / 2;
        sum += (wLabel.data.dummy ? edgeSep : nodeSep) / 2;
        sum += wLabel.data.width / 2;
        if (wLabel.data.labelpos) {
            switch ((wLabel.data.labelpos || '').toLowerCase()) {
                case 'l':
                    delta = wLabel.data.width / 2;
                    break;
                case 'r':
                    delta = -wLabel.data.width / 2;
                    break;
            }
        }
        if (delta) {
            sum += reverseSep ? delta : -delta;
        }
        delta = 0;
        return sum;
    };
};
const width = (g, v) => g.getNode(v).data.width || 0;
//# sourceMappingURL=bk.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre/position/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre/position/index.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   position: () => (/* binding */ position)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/lib/antv-dagre/util.js");
/* harmony import */ var _bk__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bk */ "./node_modules/@antv/layout/lib/antv-dagre/position/bk.js");


const positionY = (g, options) => {
    const { ranksep = 0 } = options || {};
    const layering = (0,_util__WEBPACK_IMPORTED_MODULE_0__.buildLayerMatrix)(g);
    let prevY = 0;
    layering === null || layering === void 0 ? void 0 : layering.forEach((layer) => {
        const heights = layer.map((v) => g.getNode(v).data.height);
        const maxHeight = Math.max(...heights, 0);
        layer === null || layer === void 0 ? void 0 : layer.forEach((v) => {
            g.getNode(v).data.y = prevY + maxHeight / 2;
        });
        prevY += maxHeight + ranksep;
    });
};
const positionX = (g, options) => {
    const { align: graphAlign, nodesep = 0, edgesep = 0 } = options || {};
    const layering = (0,_util__WEBPACK_IMPORTED_MODULE_0__.buildLayerMatrix)(g);
    const conflicts = Object.assign((0,_bk__WEBPACK_IMPORTED_MODULE_1__.findType1Conflicts)(g, layering), (0,_bk__WEBPACK_IMPORTED_MODULE_1__.findType2Conflicts)(g, layering));
    const xss = {};
    let adjustedLayering = [];
    ['u', 'd'].forEach((vert) => {
        adjustedLayering =
            vert === 'u' ? layering : Object.values(layering).reverse();
        ['l', 'r'].forEach((horiz) => {
            if (horiz === 'r') {
                adjustedLayering = adjustedLayering.map((inner) => Object.values(inner).reverse());
            }
            const neighborFn = (vert === 'u' ? g.getPredecessors : g.getSuccessors).bind(g);
            const align = (0,_bk__WEBPACK_IMPORTED_MODULE_1__.verticalAlignment)(g, adjustedLayering, conflicts, neighborFn);
            const xs = (0,_bk__WEBPACK_IMPORTED_MODULE_1__.horizontalCompaction)(g, adjustedLayering, align.root, align.align, nodesep, edgesep, horiz === 'r');
            if (horiz === 'r') {
                Object.keys(xs).forEach((xsKey) => (xs[xsKey] = -xs[xsKey]));
            }
            xss[vert + horiz] = xs;
        });
    });
    const smallestWidth = (0,_bk__WEBPACK_IMPORTED_MODULE_1__.findSmallestWidthAlignment)(g, xss);
    smallestWidth && (0,_bk__WEBPACK_IMPORTED_MODULE_1__.alignCoordinates)(xss, smallestWidth);
    return (0,_bk__WEBPACK_IMPORTED_MODULE_1__.balance)(xss, graphAlign);
};
const position = (g, options) => {
    var _a;
    const ng = (0,_util__WEBPACK_IMPORTED_MODULE_0__.asNonCompoundGraph)(g);
    positionY(ng, options);
    const xs = positionX(ng, options);
    (_a = Object.keys(xs)) === null || _a === void 0 ? void 0 : _a.forEach((key) => {
        ng.getNode(key).data.x = xs[key];
    });
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre/rank/feasible-tree.js":
/*!************************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre/rank/feasible-tree.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   feasibleTree: () => (/* binding */ feasibleTree),
/* harmony export */   feasibleTreeWithLayer: () => (/* binding */ feasibleTreeWithLayer)
/* harmony export */ });
/* harmony import */ var _antv_graphlib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/graphlib */ "./node_modules/@antv/graphlib/esm/graph.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/lib/antv-dagre/util.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/lib/antv-dagre/rank/util.js");



/*
 * Constructs a spanning tree with tight edges and adjusted the input node's
 * ranks to achieve this. A tight edge is one that is has a length that matches
 * its "minlen" attribute.
 *
 * The basic structure for this function is derived from Gansner, et al., "A
 * Technique for Drawing Directed Graphs."
 *
 * Pre-conditions:
 *
 *    1. Graph must be a DAG.
 *    2. Graph must be connected.
 *    3. Graph must have at least one node.
 *    5. Graph nodes must have been previously assigned a "rank" property that
 *       respects the "minlen" property of incident edges.
 *    6. Graph edges must have a "minlen" property.
 *
 * Post-conditions:
 *
 *    - Graph nodes will have their rank adjusted to ensure that all edges are
 *      tight.
 *
 * Returns a tree (undirected graph) that is constructed using only "tight"
 * edges.
 */
const feasibleTree = (g) => {
    const t = new _antv_graphlib__WEBPACK_IMPORTED_MODULE_0__.Graph({
        tree: [],
    });
    // Choose arbitrary node from which to start our tree
    const start = g.getAllNodes()[0];
    const size = g.getAllNodes().length;
    t.addNode(start);
    let edge;
    let delta;
    while (tightTree(t, g) < size) {
        edge = findMinSlackEdge(t, g);
        delta = t.hasNode(edge.source) ? (0,_util__WEBPACK_IMPORTED_MODULE_1__.slack)(g, edge) : -(0,_util__WEBPACK_IMPORTED_MODULE_1__.slack)(g, edge);
        shiftRanks(t, g, delta);
    }
    return t;
};
/*
 * Finds a maximal tree of tight edges and returns the number of nodes in the
 * tree.
 */
const tightTree = (t, g) => {
    const dfs = (v) => {
        g.getRelatedEdges(v, 'both').forEach((e) => {
            const edgeV = e.source;
            const w = v === edgeV ? e.target : edgeV;
            if (!t.hasNode(w) && !(0,_util__WEBPACK_IMPORTED_MODULE_1__.slack)(g, e)) {
                t.addNode({
                    id: w,
                    data: {},
                });
                t.addEdge({
                    id: e.id,
                    source: v,
                    target: w,
                    data: {},
                });
                dfs(w);
            }
        });
    };
    t.getAllNodes().forEach((n) => dfs(n.id));
    return t.getAllNodes().length;
};
/*
 * Constructs a spanning tree with tight edges and adjusted the input node's
 * ranks to achieve this. A tight edge is one that is has a length that matches
 * its "minlen" attribute.
 *
 * The basic structure for this function is derived from Gansner, et al., "A
 * Technique for Drawing Directed Graphs."
 *
 * Pre-conditions:
 *
 *    1. Graph must be a DAG.
 *    2. Graph must be connected.
 *    3. Graph must have at least one node.
 *    5. Graph nodes must have been previously assigned a "rank" property that
 *       respects the "minlen" property of incident edges.
 *    6. Graph edges must have a "minlen" property.
 *
 * Post-conditions:
 *
 *    - Graph nodes will have their rank adjusted to ensure that all edges are
 *      tight.
 *
 * Returns a tree (undirected graph) that is constructed using only "tight"
 * edges.
 */
const feasibleTreeWithLayer = (g) => {
    const t = new _antv_graphlib__WEBPACK_IMPORTED_MODULE_0__.Graph({ tree: [] });
    // Choose arbitrary node from which to start our tree
    const start = g.getAllNodes()[0];
    const size = g.getAllNodes().length;
    t.addNode(start);
    let edge;
    let delta;
    while (tightTreeWithLayer(t, g) < size) {
        edge = findMinSlackEdge(t, g);
        delta = t.hasNode(edge.source) ? (0,_util__WEBPACK_IMPORTED_MODULE_1__.slack)(g, edge) : -(0,_util__WEBPACK_IMPORTED_MODULE_1__.slack)(g, edge);
        shiftRanks(t, g, delta);
    }
    return t;
};
/*
 * Finds a maximal tree of tight edges and returns the number of nodes in the
 * tree.
 */
const tightTreeWithLayer = (t, g) => {
    const dfs = (v) => {
        var _a;
        (_a = g.getRelatedEdges(v, 'both')) === null || _a === void 0 ? void 0 : _a.forEach((e) => {
            const edgeV = e.source;
            const w = v === edgeV ? e.target : edgeV;
            // 对于指定layer的，直接加入tight-tree，不参与调整
            if (!t.hasNode(w) &&
                (g.getNode(w).data.layer !== undefined || !(0,_util__WEBPACK_IMPORTED_MODULE_1__.slack)(g, e))) {
                t.addNode({
                    id: w,
                    data: {},
                });
                t.addEdge({
                    id: e.id,
                    source: v,
                    target: w,
                    data: {},
                });
                dfs(w);
            }
        });
    };
    t.getAllNodes().forEach((n) => dfs(n.id));
    return t.getAllNodes().length;
};
/*
 * Finds the edge with the smallest slack that is incident on tree and returns
 * it.
 */
const findMinSlackEdge = (t, g) => {
    return (0,_util__WEBPACK_IMPORTED_MODULE_2__.minBy)(g.getAllEdges(), (e) => {
        if (t.hasNode(e.source) !== t.hasNode(e.target)) {
            return (0,_util__WEBPACK_IMPORTED_MODULE_1__.slack)(g, e);
        }
        return Infinity;
    });
};
const shiftRanks = (t, g, delta) => {
    t.getAllNodes().forEach((tn) => {
        const v = g.getNode(tn.id);
        if (!v.data.rank)
            v.data.rank = 0;
        v.data.rank += delta;
    });
};

//# sourceMappingURL=feasible-tree.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre/rank/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre/rank/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   rank: () => (/* binding */ rank)
/* harmony export */ });
/* harmony import */ var _feasible_tree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./feasible-tree */ "./node_modules/@antv/layout/lib/antv-dagre/rank/feasible-tree.js");
/* harmony import */ var _network_simplex__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./network-simplex */ "./node_modules/@antv/layout/lib/antv-dagre/rank/network-simplex.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/lib/antv-dagre/rank/util.js");



/*
 * Assigns a rank to each node in the input graph that respects the "minlen"
 * constraint specified on edges between nodes.
 *
 * This basic structure is derived from Gansner, et al., "A Technique for
 * Drawing Directed Graphs."
 *
 * Pre-conditions:
 *
 *    1. Graph must be a connected DAG
 *    2. Graph nodes must be objects
 *    3. Graph edges must have "weight" and "minlen" attributes
 *
 * Post-conditions:
 *
 *    1. Graph nodes will have a "rank" attribute based on the results of the
 *       algorithm. Ranks can start at any index (including negative), we'll
 *       fix them up later.
 */
const rank = (g, ranker) => {
    switch (ranker) {
        case 'network-simplex':
            networkSimplexRanker(g);
            break;
        case 'tight-tree':
            tightTreeRanker(g);
            break;
        case 'longest-path':
            longestPathRanker(g);
            break;
        // default: networkSimplexRanker(g);
        default:
            tightTreeRanker(g);
    }
};
// A fast and simple ranker, but results are far from optimal.
const longestPathRanker = _util__WEBPACK_IMPORTED_MODULE_0__.longestPath;
const tightTreeRanker = (g) => {
    (0,_util__WEBPACK_IMPORTED_MODULE_0__.longestPathWithLayer)(g);
    (0,_feasible_tree__WEBPACK_IMPORTED_MODULE_1__.feasibleTreeWithLayer)(g);
};
const networkSimplexRanker = (g) => {
    (0,_network_simplex__WEBPACK_IMPORTED_MODULE_2__.networkSimplex)(g);
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre/rank/network-simplex.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre/rank/network-simplex.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   calcCutValue: () => (/* binding */ calcCutValue),
/* harmony export */   enterEdge: () => (/* binding */ enterEdge),
/* harmony export */   exchangeEdges: () => (/* binding */ exchangeEdges),
/* harmony export */   initCutValues: () => (/* binding */ initCutValues),
/* harmony export */   initLowLimValues: () => (/* binding */ initLowLimValues),
/* harmony export */   leaveEdge: () => (/* binding */ leaveEdge),
/* harmony export */   networkSimplex: () => (/* binding */ networkSimplex)
/* harmony export */ });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/lib/antv-dagre/util.js");
/* harmony import */ var _feasible_tree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./feasible-tree */ "./node_modules/@antv/layout/lib/antv-dagre/rank/feasible-tree.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/lib/antv-dagre/rank/util.js");



/*
 * The network simplex algorithm assigns ranks to each node in the input graph
 * and iteratively improves the ranking to reduce the length of edges.
 *
 * Preconditions:
 *
 *    1. The input graph must be a DAG.
 *    2. All nodes in the graph must have an object value.
 *    3. All edges in the graph must have "minlen" and "weight" attributes.
 *
 * Postconditions:
 *
 *    1. All nodes in the graph will have an assigned "rank" attribute that has
 *       been optimized by the network simplex algorithm. Ranks start at 0.
 *
 *
 * A rough sketch of the algorithm is as follows:
 *
 *    1. Assign initial ranks to each node. We use the longest path algorithm,
 *       which assigns ranks to the lowest position possible. In general this
 *       leads to very wide bottom ranks and unnecessarily long edges.
 *    2. Construct a feasible tight tree. A tight tree is one such that all
 *       edges in the tree have no slack (difference between length of edge
 *       and minlen for the edge). This by itself greatly improves the assigned
 *       rankings by shorting edges.
 *    3. Iteratively find edges that have negative cut values. Generally a
 *       negative cut value indicates that the edge could be removed and a new
 *       tree edge could be added to produce a more compact graph.
 *
 * Much of the algorithms here are derived from Gansner, et al., "A Technique
 * for Drawing Directed Graphs." The structure of the file roughly follows the
 * structure of the overall algorithm.
 */
const networkSimplex = (og) => {
    const g = (0,_util__WEBPACK_IMPORTED_MODULE_0__.simplify)(og);
    (0,_util__WEBPACK_IMPORTED_MODULE_1__.longestPath)(g);
    const t = (0,_feasible_tree__WEBPACK_IMPORTED_MODULE_2__.feasibleTree)(g);
    initLowLimValues(t);
    initCutValues(t, g);
    let e;
    let f;
    while ((e = leaveEdge(t))) {
        f = enterEdge(t, g, e);
        exchangeEdges(t, g, e, f);
    }
};
/*
 * Initializes cut values for all edges in the tree.
 */
const initCutValues = (t, g) => {
    let vs = (0,_util__WEBPACK_IMPORTED_MODULE_0__.dfs)(t, t.getAllNodes(), 'post', false);
    vs = vs.slice(0, (vs === null || vs === void 0 ? void 0 : vs.length) - 1);
    vs.forEach((v) => {
        assignCutValue(t, g, v);
    });
};
const assignCutValue = (t, g, child) => {
    const childLab = t.getNode(child);
    const parent = childLab.data.parent;
    // FIXME: use undirected edge?
    const edge = t
        .getRelatedEdges(child, 'both')
        .find((e) => e.target === parent || e.source === parent);
    edge.data.cutvalue = calcCutValue(t, g, child);
};
/*
 * Given the tight tree, its graph, and a child in the graph calculate and
 * return the cut value for the edge between the child and its parent.
 */
const calcCutValue = (t, g, child) => {
    const childLab = t.getNode(child);
    const parent = childLab.data.parent;
    // True if the child is on the tail end of the edge in the directed graph
    let childIsTail = true;
    // The graph's view of the tree edge we're inspecting
    let graphEdge = g
        .getRelatedEdges(child, 'out')
        .find((e) => e.target === parent);
    // The accumulated cut value for the edge between this node and its parent
    let cutValue = 0;
    if (!graphEdge) {
        childIsTail = false;
        graphEdge = g
            .getRelatedEdges(parent, 'out')
            .find((e) => e.target === child);
    }
    cutValue = graphEdge.data.weight;
    g.getRelatedEdges(child, 'both').forEach((e) => {
        const isOutEdge = e.source === child;
        const other = isOutEdge ? e.target : e.source;
        if (other !== parent) {
            const pointsToHead = isOutEdge === childIsTail;
            const otherWeight = e.data.weight;
            cutValue += pointsToHead ? otherWeight : -otherWeight;
            if (isTreeEdge(t, child, other)) {
                // FIXME: use undirected edge?
                const otherCutValue = t
                    .getRelatedEdges(child, 'both')
                    .find((e) => e.source === other || e.target === other).data
                    .cutvalue;
                cutValue += pointsToHead ? -otherCutValue : otherCutValue;
            }
        }
    });
    return cutValue;
};
const initLowLimValues = (tree, root = tree.getAllNodes()[0].id) => {
    dfsAssignLowLim(tree, {}, 1, root);
};
const dfsAssignLowLim = (tree, visited, nextLim, v, parent) => {
    var _a;
    const low = nextLim;
    let useNextLim = nextLim;
    const label = tree.getNode(v);
    visited[v] = true;
    (_a = tree.getNeighbors(v)) === null || _a === void 0 ? void 0 : _a.forEach((w) => {
        if (!visited[w.id]) {
            useNextLim = dfsAssignLowLim(tree, visited, useNextLim, w.id, v);
        }
    });
    label.data.low = low;
    label.data.lim = useNextLim++;
    if (parent) {
        label.data.parent = parent;
    }
    else {
        // TODO should be able to remove this when we incrementally update low lim
        delete label.data.parent;
    }
    return useNextLim;
};
const leaveEdge = (tree) => {
    return tree.getAllEdges().find((e) => {
        return e.data.cutvalue < 0;
    });
};
const enterEdge = (t, g, edge) => {
    let v = edge.source;
    let w = edge.target;
    // For the rest of this function we assume that v is the tail and w is the
    // head, so if we don't have this edge in the graph we should flip it to
    // match the correct orientation.
    if (!g.getRelatedEdges(v, 'out').find((e) => e.target === w)) {
        v = edge.target;
        w = edge.source;
    }
    const vLabel = t.getNode(v);
    const wLabel = t.getNode(w);
    let tailLabel = vLabel;
    let flip = false;
    // If the root is in the tail of the edge then we need to flip the logic that
    // checks for the head and tail nodes in the candidates function below.
    if (vLabel.data.lim > wLabel.data.lim) {
        tailLabel = wLabel;
        flip = true;
    }
    const candidates = g.getAllEdges().filter((edge) => {
        return (flip === isDescendant(t.getNode(edge.source), tailLabel) &&
            flip !== isDescendant(t.getNode(edge.target), tailLabel));
    });
    return (0,_util__WEBPACK_IMPORTED_MODULE_0__.minBy)(candidates, (edge) => {
        return (0,_util__WEBPACK_IMPORTED_MODULE_1__.slack)(g, edge);
    });
};
/**
 *
 * @param t
 * @param g
 * @param e edge to remove
 * @param f edge to add
 */
const exchangeEdges = (t, g, e, f) => {
    // FIXME: use undirected edge?
    const existed = t
        .getRelatedEdges(e.source, 'both')
        .find((edge) => edge.source === e.target || edge.target === e.target);
    if (existed) {
        t.removeEdge(existed.id);
    }
    t.addEdge({
        id: `e${Math.random()}`,
        source: f.source,
        target: f.target,
        data: {},
    });
    initLowLimValues(t);
    initCutValues(t, g);
    updateRanks(t, g);
};
const updateRanks = (t, g) => {
    const root = t.getAllNodes().find((v) => {
        return !v.data.parent;
    });
    let vs = (0,_util__WEBPACK_IMPORTED_MODULE_0__.dfs)(t, root, 'pre', false);
    vs = vs.slice(1);
    vs.forEach((v) => {
        const parent = t.getNode(v).data.parent;
        let edge = g.getRelatedEdges(v, 'out').find((e) => e.target === parent);
        // let edge = g.edgeFromArgs(v, parent);
        let flipped = false;
        if (!edge && g.hasNode(parent)) {
            // edge = g.edgeFromArgs(parent, v)!;
            edge = g.getRelatedEdges(parent, 'out').find((e) => e.target === v);
            flipped = true;
        }
        g.getNode(v).data.rank =
            ((g.hasNode(parent) && g.getNode(parent).data.rank) || 0) +
                (flipped ? edge === null || edge === void 0 ? void 0 : edge.data.minlen : -(edge === null || edge === void 0 ? void 0 : edge.data.minlen));
    });
};
/*
 * Returns true if the edge is in the tree.
 */
const isTreeEdge = (tree, u, v) => {
    // FIXME: use undirected edge?
    return tree
        .getRelatedEdges(u, 'both')
        .find((e) => e.source === v || e.target === v);
};
/*
 * Returns true if the specified node is descendant of the root node per the
 * assigned low and lim attributes in the tree.
 */
const isDescendant = (vLabel, rootLabel) => {
    return (rootLabel.data.low <= vLabel.data.lim &&
        vLabel.data.lim <= rootLabel.data.lim);
};
//# sourceMappingURL=network-simplex.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre/rank/util.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre/rank/util.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   longestPath: () => (/* binding */ longestPath),
/* harmony export */   longestPathWithLayer: () => (/* binding */ longestPathWithLayer),
/* harmony export */   slack: () => (/* binding */ slack)
/* harmony export */ });
/*
 * Initializes ranks for the input graph using the longest path algorithm. This
 * algorithm scales well and is fast in practice, it yields rather poor
 * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom
 * ranks wide and leaving edges longer than necessary. However, due to its
 * speed, this algorithm is good for getting an initial ranking that can be fed
 * into other algorithms.
 *
 * This algorithm does not normalize layers because it will be used by other
 * algorithms in most cases. If using this algorithm directly, be sure to
 * run normalize at the end.
 *
 * Pre-conditions:
 *
 *    1. Input graph is a DAG.
 *    2. Input graph node labels can be assigned properties.
 *
 * Post-conditions:
 *
 *    1. Each node will be assign an (unnormalized) "rank" property.
 */
const longestPath = (g) => {
    const visited = {};
    const dfs = (v) => {
        var _a;
        const label = g.getNode(v);
        if (!label)
            return 0;
        if (visited[v]) {
            return label.data.rank;
        }
        visited[v] = true;
        let rank;
        (_a = g.getRelatedEdges(v, 'out')) === null || _a === void 0 ? void 0 : _a.forEach((e) => {
            const wRank = dfs(e.target);
            const minLen = e.data.minlen;
            const r = wRank - minLen;
            if (r) {
                if (rank === undefined || r < rank) {
                    rank = r;
                }
            }
        });
        if (!rank) {
            rank = 0;
        }
        label.data.rank = rank;
        return rank;
    };
    g.getAllNodes()
        .filter((n) => g.getRelatedEdges(n.id, 'in').length === 0)
        .forEach((source) => dfs(source.id));
};
const longestPathWithLayer = (g) => {
    // 用longest path，找出最深的点
    const visited = {};
    let minRank;
    const dfs = (v) => {
        var _a;
        const label = g.getNode(v);
        if (!label)
            return 0;
        if (visited[v]) {
            return label.data.rank;
        }
        visited[v] = true;
        let rank;
        (_a = g.getRelatedEdges(v, 'out')) === null || _a === void 0 ? void 0 : _a.forEach((e) => {
            const wRank = dfs(e.target);
            const minLen = e.data.minlen;
            const r = wRank - minLen;
            if (r) {
                if (rank === undefined || r < rank) {
                    rank = r;
                }
            }
        });
        if (!rank) {
            rank = 0;
        }
        if (minRank === undefined || rank < minRank) {
            minRank = rank;
        }
        label.data.rank = rank;
        return rank;
    };
    g.getAllNodes()
        .filter((n) => g.getRelatedEdges(n.id, 'in').length === 0)
        .forEach((source) => {
        if (source)
            dfs(source.id);
    });
    if (minRank === undefined) {
        minRank = 0;
    }
    // minRank += 1; // NOTE: 最小的层级是dummy root，+1
    // forward一遍，赋值层级
    const forwardVisited = {};
    const dfsForward = (v, nextRank) => {
        var _a;
        const label = g.getNode(v);
        const currRank = !isNaN(label.data.layer) ? label.data.layer : nextRank;
        // 没有指定，取最大值
        if (label.data.rank === undefined || label.data.rank < currRank) {
            label.data.rank = currRank;
        }
        if (forwardVisited[v])
            return;
        forwardVisited[v] = true;
        // DFS遍历子节点
        (_a = g.getRelatedEdges(v, 'out')) === null || _a === void 0 ? void 0 : _a.forEach((e) => {
            dfsForward(e.target, currRank + e.data.minlen);
        });
    };
    // 指定层级的，更新下游
    g.getAllNodes().forEach((n) => {
        const label = n.data;
        if (!label)
            return;
        if (!isNaN(label.layer)) {
            dfsForward(n.id, label.layer); // 默认的dummy root所在层的rank是-1
        }
        else {
            label.rank -= minRank;
        }
    });
};
/*
 * Returns the amount of slack for the given edge. The slack is defined as the
 * difference between the length of the edge and its minimum length.
 */
const slack = (g, e) => {
    return (g.getNode(e.target).data.rank -
        g.getNode(e.source).data.rank -
        e.data.minlen);
};

//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/antv-dagre/util.js":
/*!**********************************************************!*\
  !*** ./node_modules/@antv/layout/lib/antv-dagre/util.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addBorderNode: () => (/* binding */ addBorderNode),
/* harmony export */   addDummyNode: () => (/* binding */ addDummyNode),
/* harmony export */   asNonCompoundGraph: () => (/* binding */ asNonCompoundGraph),
/* harmony export */   buildLayerMatrix: () => (/* binding */ buildLayerMatrix),
/* harmony export */   dfs: () => (/* binding */ dfs),
/* harmony export */   intersectRect: () => (/* binding */ intersectRect),
/* harmony export */   maxRank: () => (/* binding */ maxRank),
/* harmony export */   minBy: () => (/* binding */ minBy),
/* harmony export */   normalizeRanks: () => (/* binding */ normalizeRanks),
/* harmony export */   partition: () => (/* binding */ partition),
/* harmony export */   predecessorWeights: () => (/* binding */ predecessorWeights),
/* harmony export */   removeEmptyRanks: () => (/* binding */ removeEmptyRanks),
/* harmony export */   simplify: () => (/* binding */ simplify),
/* harmony export */   successorWeights: () => (/* binding */ successorWeights),
/* harmony export */   zipObject: () => (/* binding */ zipObject)
/* harmony export */ });
/* harmony import */ var _antv_graphlib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/graphlib */ "./node_modules/@antv/graphlib/esm/graph.js");
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/is-number.js");


const safeSort = (valueA, valueB) => {
    return Number(valueA) - Number(valueB);
};
/*
 * Adds a dummy node to the graph and return v.
 */
const addDummyNode = (g, type, data, name) => {
    let v;
    do {
        v = `${name}${Math.random()}`;
    } while (g.hasNode(v));
    data.dummy = type;
    g.addNode({
        id: v,
        data,
    });
    return v;
};
/*
 * Returns a new graph with only simple edges. Handles aggregation of data
 * associated with multi-edges.
 */
const simplify = (g) => {
    const simplified = new _antv_graphlib__WEBPACK_IMPORTED_MODULE_0__.Graph();
    g.getAllNodes().forEach((v) => {
        simplified.addNode(Object.assign({}, v));
    });
    g.getAllEdges().forEach((e) => {
        const edge = simplified
            .getRelatedEdges(e.source, 'out')
            .find((edge) => edge.target === e.target);
        if (!edge) {
            simplified.addEdge({
                id: e.id,
                source: e.source,
                target: e.target,
                data: {
                    weight: e.data.weight || 0,
                    minlen: e.data.minlen || 1,
                },
            });
        }
        else {
            simplified.updateEdgeData(edge === null || edge === void 0 ? void 0 : edge.id, Object.assign(Object.assign({}, edge.data), { weight: edge.data.weight + e.data.weight || 0, minlen: Math.max(edge.data.minlen, e.data.minlen || 1) }));
        }
    });
    return simplified;
};
const asNonCompoundGraph = (g) => {
    const simplified = new _antv_graphlib__WEBPACK_IMPORTED_MODULE_0__.Graph();
    g.getAllNodes().forEach((node) => {
        if (!g.getChildren(node.id).length) {
            simplified.addNode(Object.assign({}, node));
        }
    });
    g.getAllEdges().forEach((edge) => {
        simplified.addEdge(edge);
    });
    return simplified;
};
const zipObject = (keys, values) => {
    return keys === null || keys === void 0 ? void 0 : keys.reduce((obj, key, i) => {
        obj[key] = values[i];
        return obj;
    }, {});
};
const successorWeights = (g) => {
    const weightsMap = {};
    g.getAllNodes().forEach((node) => {
        const sucs = {};
        g.getRelatedEdges(node.id, 'out').forEach((e) => {
            sucs[e.target] = (sucs[e.target] || 0) + (e.data.weight || 0);
        });
        weightsMap[node.id] = sucs;
    });
    return weightsMap;
};
const predecessorWeights = (g) => {
    const nodes = g.getAllNodes();
    const weightMap = nodes.map((v) => {
        const preds = {};
        g.getRelatedEdges(v.id, 'in').forEach((e) => {
            preds[e.source] = (preds[e.source] || 0) + e.data.weight;
        });
        return preds;
    });
    return zipObject(nodes.map((n) => n.id), weightMap);
};
/*
 * Finds where a line starting at point ({x, y}) would intersect a rectangle
 * ({x, y, width, height}) if it were pointing at the rectangle's center.
 */
const intersectRect = (rect, point) => {
    const x = Number(rect.x);
    const y = Number(rect.y);
    // Rectangle intersection algorithm from:
    // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes
    const dx = Number(point.x) - x;
    const dy = Number(point.y) - y;
    let w = Number(rect.width) / 2;
    let h = Number(rect.height) / 2;
    if (!dx && !dy) {
        // completely overlapped directly, then return points its self
        return { x: 0, y: 0 };
    }
    let sx;
    let sy;
    if (Math.abs(dy) * w > Math.abs(dx) * h) {
        // Intersection is top or bottom of rect.
        if (dy < 0) {
            h = -h;
        }
        sx = (h * dx) / dy;
        sy = h;
    }
    else {
        // Intersection is left or right of rect.
        if (dx < 0) {
            w = -w;
        }
        sx = w;
        sy = (w * dy) / dx;
    }
    return { x: x + sx, y: y + sy };
};
/*
 * Given a DAG with each node assigned "rank" and "order" properties, this
 * const will produce a matrix with the ids of each node.
 */
const buildLayerMatrix = (g) => {
    const layeringNodes = [];
    const rankMax = maxRank(g) + 1;
    for (let i = 0; i < rankMax; i++) {
        layeringNodes.push([]);
    }
    // const layering = _.map(_.range(maxRank(g) + 1), function() { return []; });
    g.getAllNodes().forEach((node) => {
        const rank = node.data.rank;
        if (rank !== undefined && layeringNodes[rank]) {
            layeringNodes[rank].push(node.id);
        }
    });
    for (let i = 0; i < rankMax; i++) {
        layeringNodes[i] = layeringNodes[i].sort((va, vb) => safeSort(g.getNode(va).data.order, g.getNode(vb).data.order));
    }
    return layeringNodes;
};
/*
 * Adjusts the ranks for all nodes in the graph such that all nodes v have
 * rank(v) >= 0 and at least one node w has rank(w) = 0.
 */
const normalizeRanks = (g) => {
    const nodeRanks = g
        .getAllNodes()
        .filter((v) => v.data.rank !== undefined)
        .map((v) => v.data.rank);
    const min = Math.min(...nodeRanks);
    g.getAllNodes().forEach((v) => {
        if (v.data.hasOwnProperty('rank') && min !== Infinity) {
            v.data.rank -= min;
        }
    });
};
const removeEmptyRanks = (g, nodeRankFactor = 0) => {
    // Ranks may not start at 0, so we need to offset them
    const nodes = g.getAllNodes();
    const nodeRanks = nodes
        .filter((v) => v.data.rank !== undefined)
        .map((v) => v.data.rank);
    const offset = Math.min(...nodeRanks);
    const layers = [];
    nodes.forEach((v) => {
        const rank = (v.data.rank || 0) - offset;
        if (!layers[rank]) {
            layers[rank] = [];
        }
        layers[rank].push(v.id);
    });
    let delta = 0;
    for (let i = 0; i < layers.length; i++) {
        const vs = layers[i];
        if (vs === undefined) {
            if (i % nodeRankFactor !== 0) {
                delta -= 1;
            }
        }
        else if (delta) {
            vs === null || vs === void 0 ? void 0 : vs.forEach((v) => {
                const node = g.getNode(v);
                if (node) {
                    node.data.rank = node.data.rank || 0;
                    node.data.rank += delta;
                }
            });
        }
    }
};
const addBorderNode = (g, prefix, rank, order) => {
    const node = {
        width: 0,
        height: 0,
    };
    if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_1__["default"])(rank) && (0,_antv_util__WEBPACK_IMPORTED_MODULE_1__["default"])(order)) {
        node.rank = rank;
        node.order = order;
    }
    return addDummyNode(g, 'border', node, prefix);
};
const maxRank = (g) => {
    let maxRank;
    g.getAllNodes().forEach((v) => {
        const rank = v.data.rank;
        if (rank !== undefined) {
            if (maxRank === undefined || rank > maxRank) {
                maxRank = rank;
            }
        }
    });
    if (!maxRank) {
        maxRank = 0;
    }
    return maxRank;
};
/*
 * Partition a collection into two groups: `lhs` and `rhs`. If the supplied
 * const returns true for an entry it goes into `lhs`. Otherwise it goes
 * into `rhs.
 */
const partition = (collection, fn) => {
    const result = { lhs: [], rhs: [] };
    collection === null || collection === void 0 ? void 0 : collection.forEach((value) => {
        if (fn(value)) {
            result.lhs.push(value);
        }
        else {
            result.rhs.push(value);
        }
    });
    return result;
};
const minBy = (array, func) => {
    return array.reduce((a, b) => {
        const valA = func(a);
        const valB = func(b);
        return valA > valB ? b : a;
    });
};
const doDFS = (graph, node, postorder, visited, navigator, result) => {
    if (!visited.includes(node.id)) {
        visited.push(node.id);
        if (!postorder) {
            result.push(node.id);
        }
        navigator(node.id).forEach((n) => doDFS(graph, n, postorder, visited, navigator, result));
        if (postorder) {
            result.push(node.id);
        }
    }
};
/**
 * @description DFS traversal.
 * @description.zh-CN DFS 遍历。
 */
const dfs = (graph, node, order, isDirected) => {
    const nodes = Array.isArray(node) ? node : [node];
    const navigator = (n) => (isDirected ? graph.getSuccessors(n) : graph.getNeighbors(n));
    const results = [];
    const visited = [];
    nodes.forEach((node) => {
        if (!graph.hasNode(node.id)) {
            throw new Error(`Graph does not have node: ${node}`);
        }
        else {
            doDFS(graph, node, order === 'post', visited, navigator, results);
        }
    });
    return results;
};
//# sourceMappingURL=util.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/circular.js":
/*!***************************************************!*\
  !*** ./node_modules/@antv/layout/lib/circular.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CircularLayout: () => (/* binding */ CircularLayout)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/lib/util/function.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/lib/util/object.js");
/* harmony import */ var _util_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/common */ "./node_modules/@antv/layout/lib/util/common.js");



const DEFAULTS_LAYOUT_OPTIONS = {
    radius: null,
    startRadius: null,
    endRadius: null,
    startAngle: 0,
    endAngle: 2 * Math.PI,
    clockwise: true,
    divisions: 1,
    ordering: null,
    angleRatio: 1,
};
/**
 * <zh/> 环形布局
 *
 * <en/> Circular layout
 */
class CircularLayout {
    constructor(options = {}) {
        this.options = options;
        this.id = 'circular';
        this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS), options);
    }
    /**
     * Return the positions of nodes and edges(if needed).
     */
    execute(graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            return this.genericCircularLayout(false, graph, options);
        });
    }
    /**
     * To directly assign the positions to the nodes.
     */
    assign(graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            yield this.genericCircularLayout(true, graph, options);
        });
    }
    genericCircularLayout(assign, graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            const mergedOptions = Object.assign(Object.assign({}, this.options), options);
            const { width, height, center, divisions, startAngle = 0, endAngle = 2 * Math.PI, angleRatio, ordering, clockwise, nodeSpacing: paramNodeSpacing, nodeSize: paramNodeSize, } = mergedOptions;
            const nodes = graph.getAllNodes();
            const edges = graph.getAllEdges();
            // Calculate center according to `window` if not provided.
            const [calculatedWidth, calculatedHeight, calculatedCenter] = calculateCenter(width, height, center);
            const n = nodes === null || nodes === void 0 ? void 0 : nodes.length;
            if (!n || n === 1) {
                return (0,_util_common__WEBPACK_IMPORTED_MODULE_1__.handleSingleNodeGraph)(graph, assign, calculatedCenter);
            }
            const angleStep = (endAngle - startAngle) / n;
            let { radius, startRadius, endRadius } = mergedOptions;
            if (paramNodeSpacing) {
                const nodeSpacing = (0,_util__WEBPACK_IMPORTED_MODULE_2__.formatNumberFn)(10, paramNodeSpacing);
                const nodeSize = (0,_util__WEBPACK_IMPORTED_MODULE_2__.formatSizeFn)(10, paramNodeSize);
                let maxNodeSize = -Infinity;
                nodes.forEach((node) => {
                    const nSize = nodeSize(node);
                    if (maxNodeSize < nSize)
                        maxNodeSize = nSize;
                });
                let perimeter = 0;
                nodes.forEach((node, i) => {
                    if (i === 0)
                        perimeter += maxNodeSize || 10;
                    else
                        perimeter += (nodeSpacing(node) || 0) + (maxNodeSize || 10);
                });
                radius = perimeter / (2 * Math.PI);
            }
            else if (!radius && !startRadius && !endRadius) {
                radius = Math.min(calculatedHeight, calculatedWidth) / 2;
            }
            else if (!startRadius && endRadius) {
                startRadius = endRadius;
            }
            else if (startRadius && !endRadius) {
                endRadius = startRadius;
            }
            const astep = angleStep * angleRatio;
            // calculated nodes as temporary result
            let layoutNodes = [];
            if (ordering === 'topology') {
                // layout according to the topology
                layoutNodes = topologyOrdering(graph, nodes);
            }
            else if (ordering === 'topology-directed') {
                // layout according to the topology
                layoutNodes = topologyOrdering(graph, nodes, true);
            }
            else if (ordering === 'degree') {
                // layout according to the descent order of degrees
                layoutNodes = degreeOrdering(graph, nodes);
            }
            else {
                // layout according to the original order in the data.nodes
                layoutNodes = nodes.map((node) => (0,_util__WEBPACK_IMPORTED_MODULE_3__.cloneFormatData)(node));
            }
            const divN = Math.ceil(n / divisions); // node number in each division
            for (let i = 0; i < n; ++i) {
                let r = radius;
                if (!r && startRadius !== null && endRadius !== null) {
                    r = startRadius + (i * (endRadius - startRadius)) / (n - 1);
                }
                if (!r) {
                    r = 10 + (i * 100) / (n - 1);
                }
                let angle = startAngle +
                    (i % divN) * astep +
                    ((2 * Math.PI) / divisions) * Math.floor(i / divN);
                if (!clockwise) {
                    angle =
                        endAngle -
                            (i % divN) * astep -
                            ((2 * Math.PI) / divisions) * Math.floor(i / divN);
                }
                layoutNodes[i].data.x = calculatedCenter[0] + Math.cos(angle) * r;
                layoutNodes[i].data.y = calculatedCenter[1] + Math.sin(angle) * r;
            }
            if (assign) {
                layoutNodes.forEach((node) => {
                    graph.mergeNodeData(node.id, {
                        x: node.data.x,
                        y: node.data.y,
                    });
                });
            }
            const result = {
                nodes: layoutNodes,
                edges,
            };
            return result;
        });
    }
}
/**
 * order the nodes acoording to the graph topology
 * @param graph
 * @param nodes
 * @param directed
 * @returns
 */
const topologyOrdering = (graph, nodes, directed = false) => {
    const orderedCNodes = [(0,_util__WEBPACK_IMPORTED_MODULE_3__.cloneFormatData)(nodes[0])];
    const pickFlags = {};
    const n = nodes.length;
    pickFlags[nodes[0].id] = true;
    // write children into cnodes
    let k = 0;
    nodes.forEach((node, i) => {
        if (i !== 0) {
            if ((i === n - 1 ||
                graph.getDegree(node.id, 'both') !==
                    graph.getDegree(nodes[i + 1].id, 'both') ||
                graph.areNeighbors(orderedCNodes[k].id, node.id)) &&
                !pickFlags[node.id]) {
                orderedCNodes.push((0,_util__WEBPACK_IMPORTED_MODULE_3__.cloneFormatData)(node));
                pickFlags[node.id] = true;
                k++;
            }
            else {
                const children = directed
                    ? graph.getSuccessors(orderedCNodes[k].id)
                    : graph.getNeighbors(orderedCNodes[k].id);
                let foundChild = false;
                for (let j = 0; j < children.length; j++) {
                    const child = children[j];
                    if (graph.getDegree(child.id) === graph.getDegree(node.id) &&
                        !pickFlags[child.id]) {
                        orderedCNodes.push((0,_util__WEBPACK_IMPORTED_MODULE_3__.cloneFormatData)(child));
                        pickFlags[child.id] = true;
                        foundChild = true;
                        break;
                    }
                }
                let ii = 0;
                while (!foundChild) {
                    if (!pickFlags[nodes[ii].id]) {
                        orderedCNodes.push((0,_util__WEBPACK_IMPORTED_MODULE_3__.cloneFormatData)(nodes[ii]));
                        pickFlags[nodes[ii].id] = true;
                        foundChild = true;
                    }
                    ii++;
                    if (ii === n) {
                        break;
                    }
                }
            }
        }
    });
    return orderedCNodes;
};
/**
 * order the nodes according to their degree
 * @param graph
 * @param nodes
 * @returns
 */
function degreeOrdering(graph, nodes) {
    const orderedNodes = [];
    nodes.forEach((node, i) => {
        orderedNodes.push((0,_util__WEBPACK_IMPORTED_MODULE_3__.cloneFormatData)(node));
    });
    orderedNodes.sort((nodeA, nodeB) => graph.getDegree(nodeA.id, 'both') - graph.getDegree(nodeB.id, 'both'));
    return orderedNodes;
}
/**
 * format the invalide width and height, and get the center position
 * @param width
 * @param height
 * @param center
 * @returns
 */
const calculateCenter = (width, height, center) => {
    let calculatedWidth = width;
    let calculatedHeight = height;
    let calculatedCenter = center;
    if (!calculatedWidth && typeof window !== 'undefined') {
        calculatedWidth = window.innerWidth;
    }
    if (!calculatedHeight && typeof window !== 'undefined') {
        calculatedHeight = window.innerHeight;
    }
    if (!calculatedCenter) {
        calculatedCenter = [calculatedWidth / 2, calculatedHeight / 2];
    }
    return [calculatedWidth, calculatedHeight, calculatedCenter];
};
//# sourceMappingURL=circular.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/combo-combined.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/layout/lib/combo-combined.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ComboCombinedLayout: () => (/* binding */ ComboCombinedLayout)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _antv_graphlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @antv/graphlib */ "./node_modules/@antv/graphlib/esm/graph.js");
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/is-number.js");
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/is-function.js");
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/is-object.js");
/* harmony import */ var _concentric__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./concentric */ "./node_modules/@antv/layout/lib/concentric.js");
/* harmony import */ var _force__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./force */ "./node_modules/@antv/layout/lib/force/index.js");
/* harmony import */ var _mds__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./mds */ "./node_modules/@antv/layout/lib/mds.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./types */ "./node_modules/@antv/layout/lib/types.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/lib/util/math.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/lib/util/array.js");
/* harmony import */ var _util_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/common */ "./node_modules/@antv/layout/lib/util/common.js");









const FORCE_LAYOUT_TYPE_MAP = {
    gForce: true,
    force2: true,
    d3force: true,
    fruchterman: true,
    forceAtlas2: true,
    force: true,
    'graphin-force': true,
};
const DEFAULTS_LAYOUT_OPTIONS = {
    center: [0, 0],
    comboPadding: 10,
    treeKey: 'combo',
};
/**
 * <zh/> 组合布局
 *
 * <en/> Combo-Combined layout
 */
class ComboCombinedLayout {
    constructor(options = {}) {
        this.options = options;
        this.id = 'comboCombined';
        this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS), options);
    }
    /**
     * Return the positions of nodes and edges(if needed).
     */
    execute(graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            return this.genericComboCombinedLayout(false, graph, options);
        });
    }
    /**
     * To directly assign the positions to the nodes.
     */
    assign(graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            yield this.genericComboCombinedLayout(true, graph, options);
        });
    }
    genericComboCombinedLayout(assign, graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            const mergedOptions = this.initVals(Object.assign(Object.assign({}, this.options), options));
            const { center, treeKey, outerLayout: propsOuterLayout } = mergedOptions;
            const nodes = graph
                .getAllNodes()
                .filter((node) => !node.data._isCombo);
            const combos = graph
                .getAllNodes()
                .filter((node) => node.data._isCombo);
            const edges = graph.getAllEdges();
            const n = nodes === null || nodes === void 0 ? void 0 : nodes.length;
            if (!n || n === 1) {
                return (0,_util_common__WEBPACK_IMPORTED_MODULE_1__.handleSingleNodeGraph)(graph, assign, center);
            }
            // output nodes
            const layoutNodes = [];
            const nodeMap = new Map();
            nodes.forEach((node) => {
                nodeMap.set(node.id, node);
            });
            const comboMap = new Map();
            combos.forEach((combo) => {
                comboMap.set(combo.id, combo);
            });
            // each one in comboNodes is a combo contains the size and child nodes
            // comboNodes includes the node who has no parent combo
            const comboNodes = new Map();
            // the inner layouts, the result positions are stored in comboNodes and their child nodes
            const innerGraphLayoutPromises = this.getInnerGraphs(graph, treeKey, nodeMap, comboMap, edges, mergedOptions, comboNodes);
            yield Promise.all(innerGraphLayoutPromises);
            const outerNodeIds = new Map();
            const outerLayoutNodes = [];
            const nodeAncestorIdMap = new Map();
            let allHaveNoPosition = true;
            graph.getRoots(treeKey).forEach((root) => {
                const combo = comboNodes.get(root.id);
                const cacheCombo = comboMap.get(root.id) || nodeMap.get(root.id);
                const comboLayoutNode = {
                    id: root.id,
                    data: Object.assign(Object.assign({}, root.data), { x: combo.data.x || cacheCombo.data.x, y: combo.data.y || cacheCombo.data.y, fx: combo.data.fx || cacheCombo.data.fx, fy: combo.data.fy || cacheCombo.data.fy, mass: combo.data.mass || cacheCombo.data.mass, size: combo.data.size }),
                };
                outerLayoutNodes.push(comboLayoutNode);
                outerNodeIds.set(root.id, true);
                if (!isNaN(comboLayoutNode.data.x) &&
                    comboLayoutNode.data.x !== 0 &&
                    !isNaN(comboLayoutNode.data.y) &&
                    comboLayoutNode.data.y !== 0) {
                    allHaveNoPosition = false;
                }
                else {
                    comboLayoutNode.data.x = Math.random() * 100;
                    comboLayoutNode.data.y = Math.random() * 100;
                }
                (0,_util__WEBPACK_IMPORTED_MODULE_2__.graphTreeDfs)(graph, [root], (child) => {
                    if (child.id !== root.id)
                        nodeAncestorIdMap.set(child.id, root.id);
                }, 'TB', treeKey);
            });
            const outerLayoutEdges = [];
            edges.forEach((edge) => {
                const sourceAncestorId = nodeAncestorIdMap.get(edge.source) || edge.source;
                const targetAncestorId = nodeAncestorIdMap.get(edge.target) || edge.target;
                // create an edge for outer layout if both source and target's ancestor combo is in outer layout nodes
                if (sourceAncestorId !== targetAncestorId &&
                    outerNodeIds.has(sourceAncestorId) &&
                    outerNodeIds.has(targetAncestorId)) {
                    outerLayoutEdges.push({
                        id: edge.id,
                        source: sourceAncestorId,
                        target: targetAncestorId,
                        data: {},
                    });
                }
            });
            // 若有需要最外层的 combo 或节点，则对最外层执行力导向
            let outerPositions;
            if (outerLayoutNodes === null || outerLayoutNodes === void 0 ? void 0 : outerLayoutNodes.length) {
                if (outerLayoutNodes.length === 1) {
                    outerLayoutNodes[0].data.x = center[0];
                    outerLayoutNodes[0].data.y = center[1];
                }
                else {
                    const outerLayoutGraph = new _antv_graphlib__WEBPACK_IMPORTED_MODULE_3__.Graph({
                        nodes: outerLayoutNodes,
                        edges: outerLayoutEdges,
                    });
                    const outerLayout = propsOuterLayout || new _force__WEBPACK_IMPORTED_MODULE_4__.ForceLayout();
                    // preset the nodes if the outerLayout is a force family layout
                    if (allHaveNoPosition && FORCE_LAYOUT_TYPE_MAP[outerLayout.id]) {
                        const outerLayoutPreset = outerLayoutNodes.length < 100
                            ? new _mds__WEBPACK_IMPORTED_MODULE_5__.MDSLayout()
                            : new _concentric__WEBPACK_IMPORTED_MODULE_6__.ConcentricLayout();
                        yield outerLayoutPreset.assign(outerLayoutGraph);
                    }
                    const options = Object.assign({ center, kg: 5, preventOverlap: true, animate: false }, (outerLayout.id === 'force'
                        ? {
                            gravity: 1,
                            factor: 4,
                            linkDistance: (edge, source, target) => {
                                const sourceSize = Math.max(...source.data.size) || 32;
                                const targetSize = Math.max(...target.data.size) || 32;
                                return sourceSize / 2 + targetSize / 2 + 200;
                            },
                        }
                        : {}));
                    outerPositions = yield executeLayout(outerLayout, outerLayoutGraph, options);
                }
                // move the combos and their child nodes
                comboNodes.forEach((comboNode) => {
                    var _a;
                    const outerPosition = outerPositions.nodes.find((pos) => pos.id === comboNode.id);
                    if (outerPosition) {
                        // if it is one of the outer layout nodes, update the positions
                        const { x, y } = outerPosition.data;
                        comboNode.data.visited = true;
                        comboNode.data.x = x;
                        comboNode.data.y = y;
                        layoutNodes.push({
                            id: comboNode.id,
                            data: { x, y },
                        });
                    }
                    // move the child nodes
                    const { x, y } = comboNode.data;
                    (_a = comboNode.data.nodes) === null || _a === void 0 ? void 0 : _a.forEach((node) => {
                        layoutNodes.push({
                            id: node.id,
                            data: { x: node.data.x + x, y: node.data.y + y },
                        });
                    });
                });
                // move the nodes from top to bottom
                comboNodes.forEach(({ data }) => {
                    const { x, y, visited, nodes } = data;
                    nodes === null || nodes === void 0 ? void 0 : nodes.forEach((node) => {
                        if (!visited) {
                            const layoutNode = layoutNodes.find((n) => n.id === node.id);
                            layoutNode.data.x += x || 0;
                            layoutNode.data.y += y || 0;
                        }
                    });
                });
            }
            if (assign) {
                layoutNodes.forEach((node) => {
                    graph.mergeNodeData(node.id, {
                        x: node.data.x,
                        y: node.data.y,
                    });
                });
            }
            const result = {
                nodes: layoutNodes,
                edges,
            };
            return result;
        });
    }
    initVals(options) {
        const formattedOptions = Object.assign({}, options);
        const { nodeSize, spacing, comboPadding } = options;
        let nodeSizeFunc;
        let spacingFunc;
        // nodeSpacing to function
        if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_7__["default"])(spacing)) {
            spacingFunc = () => spacing;
        }
        else if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_8__["default"])(spacing)) {
            spacingFunc = spacing;
        }
        else {
            spacingFunc = () => 0;
        }
        formattedOptions.spacing = spacingFunc;
        // nodeSize to function
        if (!nodeSize) {
            nodeSizeFunc = (d) => {
                const spacing = spacingFunc(d);
                if (d.size) {
                    if ((0,_util__WEBPACK_IMPORTED_MODULE_9__.isArray)(d.size)) {
                        const res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];
                        return (res + spacing) / 2;
                    }
                    if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_10__["default"])(d.size)) {
                        const res = d.size.width > d.size.height ? d.size.width : d.size.height;
                        return (res + spacing) / 2;
                    }
                    return (d.size + spacing) / 2;
                }
                return 32 + spacing / 2;
            };
        }
        else if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_8__["default"])(nodeSize)) {
            nodeSizeFunc = (d) => {
                const size = nodeSize(d);
                const spacing = spacingFunc(d);
                if ((0,_util__WEBPACK_IMPORTED_MODULE_9__.isArray)(d.size)) {
                    const res = d.size[0] > d.size[1] ? d.size[0] : d.size[1];
                    return (res + spacing) / 2;
                }
                return ((size || 32) + spacing) / 2;
            };
        }
        else if ((0,_util__WEBPACK_IMPORTED_MODULE_9__.isArray)(nodeSize)) {
            const larger = nodeSize[0] > nodeSize[1] ? nodeSize[0] : nodeSize[1];
            const radius = larger / 2;
            nodeSizeFunc = (d) => radius + spacingFunc(d) / 2;
        }
        else {
            // number type
            const radius = nodeSize / 2;
            nodeSizeFunc = (d) => radius + spacingFunc(d) / 2;
        }
        formattedOptions.nodeSize = nodeSizeFunc;
        // comboPadding to function
        let comboPaddingFunc;
        if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_7__["default"])(comboPadding)) {
            comboPaddingFunc = () => comboPadding;
        }
        else if ((0,_util__WEBPACK_IMPORTED_MODULE_9__.isArray)(comboPadding)) {
            comboPaddingFunc = () => Math.max.apply(null, comboPadding);
        }
        else if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_8__["default"])(comboPadding)) {
            comboPaddingFunc = comboPadding;
        }
        else {
            // null type
            comboPaddingFunc = () => 0;
        }
        formattedOptions.comboPadding = comboPaddingFunc;
        return formattedOptions;
    }
    getInnerGraphs(graph, treeKey, nodeMap, comboMap, edges, options, comboNodes) {
        const { nodeSize, comboPadding, spacing, innerLayout } = options;
        const innerGraphLayout = innerLayout || new _concentric__WEBPACK_IMPORTED_MODULE_6__.ConcentricLayout({});
        const innerLayoutOptions = {
            center: [0, 0],
            preventOverlap: true,
            nodeSpacing: spacing,
        };
        const innerLayoutPromises = [];
        const getSize = (node) => {
            // @ts-ignore
            let padding = (comboPadding === null || comboPadding === void 0 ? void 0 : comboPadding(node)) || 10;
            if ((0,_util__WEBPACK_IMPORTED_MODULE_9__.isArray)(padding))
                padding = Math.max(...padding);
            return {
                size: padding ? [padding * 2, padding * 2] : [30, 30],
                padding,
            };
        };
        graph.getRoots(treeKey).forEach((root) => {
            // @ts-ignore
            comboNodes.set(root.id, {
                id: root.id,
                data: {
                    nodes: [],
                    size: getSize(root).size,
                },
            });
            let start = Promise.resolve();
            // Regard the child nodes in one combo as a graph, and layout them from bottom to top
            (0,_util__WEBPACK_IMPORTED_MODULE_2__.graphTreeDfs)(graph, [root], (treeNode) => {
                var _a;
                if (!treeNode.data._isCombo)
                    return;
                const { size: nsize, padding } = getSize(treeNode);
                if (!((_a = graph.getChildren(treeNode.id, treeKey)) === null || _a === void 0 ? void 0 : _a.length)) {
                    // empty combo
                    comboNodes.set(treeNode.id, {
                        id: treeNode.id,
                        data: Object.assign(Object.assign({}, treeNode.data), { size: nsize }),
                    });
                }
                else {
                    // combo not empty
                    const comboNode = comboNodes.get(treeNode.id);
                    comboNodes.set(treeNode.id, {
                        id: treeNode.id,
                        data: Object.assign({ nodes: [] }, comboNode === null || comboNode === void 0 ? void 0 : comboNode.data),
                    });
                    const innerLayoutNodeIds = new Map();
                    const innerLayoutNodes = graph
                        .getChildren(treeNode.id, treeKey)
                        .map((child) => {
                        if (child.data._isCombo) {
                            if (!comboNodes.has(child.id)) {
                                comboNodes.set(child.id, {
                                    id: child.id,
                                    data: Object.assign({}, child.data),
                                });
                            }
                            innerLayoutNodeIds.set(child.id, true);
                            return comboNodes.get(child.id);
                        }
                        const oriNode = nodeMap.get(child.id) || comboMap.get(child.id);
                        innerLayoutNodeIds.set(child.id, true);
                        return {
                            id: child.id,
                            data: Object.assign(Object.assign({}, oriNode.data), child.data),
                        };
                    });
                    const innerGraphData = {
                        nodes: innerLayoutNodes,
                        edges: edges.filter((edge) => innerLayoutNodeIds.has(edge.source) &&
                            innerLayoutNodeIds.has(edge.target)),
                    };
                    let minNodeSize = Infinity;
                    innerLayoutNodes.forEach((node) => {
                        var _a;
                        let { size } = node.data;
                        if (!size) {
                            size = ((_a = comboNodes.get(node.id)) === null || _a === void 0 ? void 0 : _a.data.size) ||
                                (nodeSize === null || nodeSize === void 0 ? void 0 : nodeSize(node)) || [30, 30];
                        }
                        if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_7__["default"])(size))
                            size = [size, size];
                        const [size0, size1] = size;
                        if (minNodeSize > size0)
                            minNodeSize = size0;
                        if (minNodeSize > size1)
                            minNodeSize = size1;
                        node.data.size = size;
                    });
                    // innerGraphLayout.assign(innerGraphCore, innerLayoutOptions);
                    start = start.then(() => (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
                        const innerGraphCore = new _antv_graphlib__WEBPACK_IMPORTED_MODULE_3__.Graph(innerGraphData);
                        yield executeLayout(innerGraphLayout, innerGraphCore, innerLayoutOptions, true);
                        const { minX, minY, maxX, maxY } = (0,_util__WEBPACK_IMPORTED_MODULE_2__.getLayoutBBox)(innerLayoutNodes);
                        // move the innerGraph to [0, 0], for later controlled by parent layout
                        const center = { x: (maxX + minX) / 2, y: (maxY + minY) / 2 };
                        innerGraphData.nodes.forEach((node) => {
                            node.data.x -= center.x;
                            node.data.y -= center.y;
                        });
                        const size = [
                            Math.max(maxX - minX, minNodeSize) + padding * 2,
                            Math.max(maxY - minY, minNodeSize) + padding * 2,
                        ];
                        comboNodes.get(treeNode.id).data.size = size;
                        comboNodes.get(treeNode.id).data.nodes = innerLayoutNodes;
                    }));
                }
                return true;
            }, 'BT', treeKey);
            innerLayoutPromises.push(start);
        });
        return innerLayoutPromises;
    }
}
function executeLayout(layout, graph, options, assign) {
    var _a;
    return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
        if ((0,_types__WEBPACK_IMPORTED_MODULE_11__.isLayoutWithIterations)(layout)) {
            layout.execute(graph, options);
            layout.stop();
            return layout.tick((_a = options.iterations) !== null && _a !== void 0 ? _a : 300);
        }
        if (assign)
            return yield layout.assign(graph, options);
        return yield layout.execute(graph, options);
    });
}
//# sourceMappingURL=combo-combined.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/concentric.js":
/*!*****************************************************!*\
  !*** ./node_modules/@antv/layout/lib/concentric.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConcentricLayout: () => (/* binding */ ConcentricLayout)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/is-function.js");
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/is-number.js");
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/is-object.js");
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/is-string.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/lib/util/array.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/lib/util/object.js");
/* harmony import */ var _util_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/common */ "./node_modules/@antv/layout/lib/util/common.js");
/* harmony import */ var _util_size__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./util/size */ "./node_modules/@antv/layout/lib/util/size.js");





const DEFAULTS_LAYOUT_OPTIONS = {
    nodeSize: 30,
    nodeSpacing: 10,
    preventOverlap: false,
    sweep: undefined,
    equidistant: false,
    startAngle: (3 / 2) * Math.PI,
    clockwise: true,
    maxLevelDiff: undefined,
    sortBy: 'degree',
};
/**
 * <zh/> 同心圆布局
 *
 * <en/> Concentric layout
 */
class ConcentricLayout {
    constructor(options = {}) {
        this.options = options;
        this.id = 'concentric';
        this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS), options);
    }
    /**
     * Return the positions of nodes and edges(if needed).
     */
    execute(graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            return this.genericConcentricLayout(false, graph, options);
        });
    }
    /**
     * To directly assign the positions to the nodes.
     */
    assign(graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            yield this.genericConcentricLayout(true, graph, options);
        });
    }
    genericConcentricLayout(assign, graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            const mergedOptions = Object.assign(Object.assign({}, this.options), options);
            const { center: propsCenter, width: propsWidth, height: propsHeight, sortBy: propsSortBy, maxLevelDiff: propsMaxLevelDiff, sweep: propsSweep, clockwise, equidistant, preventOverlap, startAngle = (3 / 2) * Math.PI, nodeSize, nodeSpacing, } = mergedOptions;
            const nodes = graph.getAllNodes();
            const edges = graph.getAllEdges();
            const width = !propsWidth && typeof window !== 'undefined'
                ? window.innerWidth
                : propsWidth;
            const height = !propsHeight && typeof window !== 'undefined'
                ? window.innerHeight
                : propsHeight;
            const center = (!propsCenter ? [width / 2, height / 2] : propsCenter);
            if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length) || nodes.length === 1) {
                return (0,_util_common__WEBPACK_IMPORTED_MODULE_1__.handleSingleNodeGraph)(graph, assign, center);
            }
            const layoutNodes = [];
            let maxNodeSize;
            let maxNodeSpacing = 0;
            if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(nodeSize)) {
                maxNodeSize = Math.max(nodeSize[0], nodeSize[1]);
            }
            else if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_3__["default"])(nodeSize)) {
                maxNodeSize = -Infinity;
                nodes.forEach((node) => {
                    const currentSize = Math.max(...(0,_util_size__WEBPACK_IMPORTED_MODULE_4__.parseSize)(nodeSize(node)));
                    if (currentSize > maxNodeSize)
                        maxNodeSize = currentSize;
                });
            }
            else {
                maxNodeSize = nodeSize;
            }
            if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(nodeSpacing)) {
                maxNodeSpacing = Math.max(nodeSpacing[0], nodeSpacing[1]);
            }
            else if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_5__["default"])(nodeSpacing)) {
                maxNodeSpacing = nodeSpacing;
            }
            nodes.forEach((node) => {
                const cnode = (0,_util__WEBPACK_IMPORTED_MODULE_6__.cloneFormatData)(node);
                layoutNodes.push(cnode);
                let nodeSize = maxNodeSize;
                const { data } = cnode;
                if ((0,_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(data.size)) {
                    nodeSize = Math.max(data.size[0], data.size[1]);
                }
                else if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_5__["default"])(data.size)) {
                    nodeSize = data.size;
                }
                else if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_7__["default"])(data.size)) {
                    nodeSize = Math.max(data.size.width, data.size.height);
                }
                maxNodeSize = Math.max(maxNodeSize, nodeSize);
                if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_3__["default"])(nodeSpacing)) {
                    maxNodeSpacing = Math.max(nodeSpacing(node), maxNodeSpacing);
                }
            });
            // layout
            const nodeIdxMap = {};
            layoutNodes.forEach((node, i) => {
                nodeIdxMap[node.id] = i;
            });
            // get the node degrees
            let sortBy = propsSortBy;
            if (!(0,_antv_util__WEBPACK_IMPORTED_MODULE_8__["default"])(sortBy) ||
                layoutNodes[0].data[sortBy] === undefined) {
                sortBy = 'degree';
            }
            if (sortBy === 'degree') {
                layoutNodes.sort((n1, n2) => graph.getDegree(n2.id, 'both') - graph.getDegree(n1.id, 'both'));
            }
            else {
                // sort nodes by value
                layoutNodes.sort((n1, n2) => n2.data[sortBy] - n1.data[sortBy]);
            }
            const maxValueNode = layoutNodes[0];
            const maxLevelDiff = (propsMaxLevelDiff ||
                (sortBy === 'degree'
                    ? graph.getDegree(maxValueNode.id, 'both')
                    : maxValueNode.data[sortBy])) / 4;
            // put the values into levels
            const levels = [{ nodes: [] }];
            let currentLevel = levels[0];
            layoutNodes.forEach((node) => {
                if (currentLevel.nodes.length > 0) {
                    const diff = sortBy === 'degree'
                        ? Math.abs(graph.getDegree(currentLevel.nodes[0].id, 'both') -
                            graph.getDegree(node.id, 'both'))
                        : Math.abs(currentLevel.nodes[0].data[sortBy] -
                            node.data[sortBy]);
                    if (maxLevelDiff && diff >= maxLevelDiff) {
                        currentLevel = { nodes: [] };
                        levels.push(currentLevel);
                    }
                }
                currentLevel.nodes.push(node);
            });
            // create positions for levels
            let minDist = maxNodeSize + maxNodeSpacing; // min dist between nodes
            if (!preventOverlap) {
                // then strictly constrain to bb
                const firstLvlHasMulti = levels.length > 0 && levels[0].nodes.length > 1;
                const maxR = Math.min(width, height) / 2 - minDist;
                const rStep = maxR / (levels.length + (firstLvlHasMulti ? 1 : 0));
                minDist = Math.min(minDist, rStep);
            }
            // find the metrics for each level
            let r = 0;
            levels.forEach((level) => {
                const sweep = propsSweep === undefined
                    ? 2 * Math.PI - (2 * Math.PI) / level.nodes.length
                    : propsSweep;
                level.dTheta = sweep / Math.max(1, level.nodes.length - 1);
                // calculate the radius
                if (level.nodes.length > 1 && preventOverlap) {
                    // but only if more than one node (can't overlap)
                    const dcos = Math.cos(level.dTheta) - Math.cos(0);
                    const dsin = Math.sin(level.dTheta) - Math.sin(0);
                    const rMin = Math.sqrt((minDist * minDist) / (dcos * dcos + dsin * dsin)); // s.t. no nodes overlapping
                    r = Math.max(rMin, r);
                }
                level.r = r;
                r += minDist;
            });
            if (equidistant) {
                let rDeltaMax = 0;
                let rr = 0;
                for (let i = 0; i < levels.length; i++) {
                    const level = levels[i];
                    const rDelta = (level.r || 0) - rr;
                    rDeltaMax = Math.max(rDeltaMax, rDelta);
                }
                rr = 0;
                levels.forEach((level, i) => {
                    if (i === 0) {
                        rr = level.r || 0;
                    }
                    level.r = rr;
                    rr += rDeltaMax;
                });
            }
            // calculate the node positions
            levels.forEach((level) => {
                const dTheta = level.dTheta || 0;
                const rr = level.r || 0;
                level.nodes.forEach((node, j) => {
                    const theta = startAngle + (clockwise ? 1 : -1) * dTheta * j;
                    node.data.x = center[0] + rr * Math.cos(theta);
                    node.data.y = center[1] + rr * Math.sin(theta);
                });
            });
            if (assign) {
                layoutNodes.forEach((node) => graph.mergeNodeData(node.id, {
                    x: node.data.x,
                    y: node.data.y,
                }));
            }
            const result = {
                nodes: layoutNodes,
                edges,
            };
            return result;
        });
    }
}
//# sourceMappingURL=concentric.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/d3-force-3d/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/d3-force-3d/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D3Force3DLayout: () => (/* binding */ D3Force3DLayout)
/* harmony export */ });
/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-force-3d */ "./node_modules/d3-force-3d/src/link.js");
/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-force-3d */ "./node_modules/d3-force-3d/src/manyBody.js");
/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-force-3d */ "./node_modules/d3-force-3d/src/center.js");
/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-force-3d */ "./node_modules/d3-force-3d/src/collide.js");
/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-force-3d */ "./node_modules/d3-force-3d/src/radial.js");
/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-force-3d */ "./node_modules/d3-force-3d/src/x.js");
/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-force-3d */ "./node_modules/d3-force-3d/src/y.js");
/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-force-3d */ "./node_modules/d3-force-3d/src/z.js");
/* harmony import */ var d3_force_3d__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-force-3d */ "./node_modules/d3-force-3d/src/simulation.js");
/* harmony import */ var _d3_force__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../d3-force */ "./node_modules/@antv/layout/lib/d3-force/index.js");


class D3Force3DLayout extends _d3_force__WEBPACK_IMPORTED_MODULE_0__.D3ForceLayout {
    constructor() {
        super(...arguments);
        this.id = 'd3-force-3d';
        this.config = {
            inputNodeAttrs: ['x', 'y', 'z', 'vx', 'vy', 'vz', 'fx', 'fy', 'fz'],
            outputNodeAttrs: ['x', 'y', 'z', 'vx', 'vy', 'vz'],
            simulationAttrs: [
                'alpha',
                'alphaMin',
                'alphaDecay',
                'alphaTarget',
                'velocityDecay',
                'randomSource',
                'numDimensions',
            ],
        };
        this.forceMap = {
            link: d3_force_3d__WEBPACK_IMPORTED_MODULE_1__["default"],
            manyBody: d3_force_3d__WEBPACK_IMPORTED_MODULE_2__["default"],
            center: d3_force_3d__WEBPACK_IMPORTED_MODULE_3__["default"],
            collide: d3_force_3d__WEBPACK_IMPORTED_MODULE_4__["default"],
            radial: d3_force_3d__WEBPACK_IMPORTED_MODULE_5__["default"],
            x: d3_force_3d__WEBPACK_IMPORTED_MODULE_6__["default"],
            y: d3_force_3d__WEBPACK_IMPORTED_MODULE_7__["default"],
            z: d3_force_3d__WEBPACK_IMPORTED_MODULE_8__["default"],
        };
        this.options = {
            numDimensions: 3,
            link: {
                id: (edge) => edge.id,
            },
            manyBody: {},
            center: {
                x: 0,
                y: 0,
                z: 0,
            },
        };
    }
    initSimulation() {
        return (0,d3_force_3d__WEBPACK_IMPORTED_MODULE_9__["default"])();
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/d3-force/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/layout/lib/d3-force/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   D3ForceLayout: () => (/* binding */ D3ForceLayout)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/deep-mix.js");
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/pick.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/link.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/manyBody.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/center.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/collide.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/radial.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/x.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/y.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/simulation.js");



class D3ForceLayout {
    constructor(options) {
        this.id = 'd3-force';
        this.config = {
            inputNodeAttrs: ['x', 'y', 'vx', 'vy', 'fx', 'fy'],
            outputNodeAttrs: ['x', 'y', 'vx', 'vy'],
            simulationAttrs: [
                'alpha',
                'alphaMin',
                'alphaDecay',
                'alphaTarget',
                'velocityDecay',
                'randomSource',
            ],
        };
        this.forceMap = {
            link: d3_force__WEBPACK_IMPORTED_MODULE_0__["default"],
            manyBody: d3_force__WEBPACK_IMPORTED_MODULE_1__["default"],
            center: d3_force__WEBPACK_IMPORTED_MODULE_2__["default"],
            collide: d3_force__WEBPACK_IMPORTED_MODULE_3__["default"],
            radial: d3_force__WEBPACK_IMPORTED_MODULE_4__["default"],
            x: d3_force__WEBPACK_IMPORTED_MODULE_5__["default"],
            y: d3_force__WEBPACK_IMPORTED_MODULE_6__["default"],
        };
        // @ts-ignore
        this.options = {
            link: {
                id: (edge) => edge.id,
            },
            manyBody: {},
            center: {
                x: 0,
                y: 0,
            },
        };
        this.context = {
            options: {},
            assign: false,
            nodes: [],
            edges: [],
        };
        (0,_antv_util__WEBPACK_IMPORTED_MODULE_7__["default"])(this.options, options);
        if (this.options.forceSimulation) {
            this.simulation = this.options.forceSimulation;
        }
    }
    execute(graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_8__.__awaiter)(this, void 0, void 0, function* () {
            return this.genericLayout(false, graph, options);
        });
    }
    assign(graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_8__.__awaiter)(this, void 0, void 0, function* () {
            yield this.genericLayout(true, graph, options);
        });
    }
    stop() {
        this.simulation.stop();
    }
    tick(iterations) {
        this.simulation.tick(iterations);
        return this.getResult();
    }
    restart() {
        this.simulation.restart();
    }
    setFixedPosition(id, position) {
        const node = this.context.nodes.find((n) => n.id === id);
        if (!node)
            return;
        position.forEach((value, index) => {
            if (typeof value === 'number' || value === null) {
                const key = ['fx', 'fy', 'fz'][index];
                node[key] = value;
            }
        });
    }
    getOptions(options) {
        var _a, _b;
        const _ = (0,_antv_util__WEBPACK_IMPORTED_MODULE_7__["default"])({}, this.options, options);
        // process nodeSize
        if (_.collide && ((_a = _.collide) === null || _a === void 0 ? void 0 : _a.radius) === undefined) {
            _.collide = _.collide || {};
            // @ts-ignore
            _.collide.radius = (_b = _.nodeSize) !== null && _b !== void 0 ? _b : 10;
        }
        // process iterations
        if (_.iterations === undefined) {
            if (_.link && _.link.iterations === undefined) {
                _.iterations = _.link.iterations;
            }
            if (_.collide && _.collide.iterations === undefined) {
                _.iterations = _.collide.iterations;
            }
        }
        // assign to context
        this.context.options = _;
        return _;
    }
    genericLayout(assign, graph, options) {
        var _a;
        return (0,tslib__WEBPACK_IMPORTED_MODULE_8__.__awaiter)(this, void 0, void 0, function* () {
            const _options = this.getOptions(options);
            const nodes = graph.getAllNodes().map(({ id, data }) => (Object.assign(Object.assign({ id }, data), (0,_antv_util__WEBPACK_IMPORTED_MODULE_9__["default"])(data.data, this.config.inputNodeAttrs))));
            const edges = graph.getAllEdges().map((edge) => (Object.assign({}, edge)));
            Object.assign(this.context, { assign, nodes, edges, graph });
            const promise = new Promise((resolver) => {
                this.resolver = resolver;
            });
            const simulation = this.setSimulation(_options);
            simulation.nodes(nodes);
            (_a = simulation.force('link')) === null || _a === void 0 ? void 0 : _a.links(edges);
            return promise;
        });
    }
    getResult() {
        const { assign, nodes, edges, graph } = this.context;
        const nodesResult = nodes.map((node) => ({
            id: node.id,
            data: Object.assign(Object.assign({}, node.data), (0,_antv_util__WEBPACK_IMPORTED_MODULE_9__["default"])(node, this.config.outputNodeAttrs)),
        }));
        const edgeResult = edges.map(({ id, source, target, data }) => ({
            id,
            source: typeof source === 'object' ? source.id : source,
            target: typeof target === 'object' ? target.id : target,
            data,
        }));
        if (assign) {
            nodesResult.forEach((node) => graph.mergeNodeData(node.id, node.data));
        }
        return { nodes: nodesResult, edges: edgeResult };
    }
    initSimulation() {
        return (0,d3_force__WEBPACK_IMPORTED_MODULE_10__["default"])();
    }
    setSimulation(options) {
        const simulation = this.simulation || this.options.forceSimulation || this.initSimulation();
        if (!this.simulation) {
            this.simulation = simulation
                .on('tick', () => { var _a; return (_a = options.onTick) === null || _a === void 0 ? void 0 : _a.call(options, this.getResult()); })
                .on('end', () => { var _a; return (_a = this.resolver) === null || _a === void 0 ? void 0 : _a.call(this, this.getResult()); });
        }
        apply(simulation, this.config.simulationAttrs.map((name) => [
            name,
            options[name],
        ]));
        Object.entries(this.forceMap).forEach(([name, Ctor]) => {
            const forceName = name;
            if (options[name]) {
                let force = simulation.force(forceName);
                if (!force) {
                    force = Ctor();
                    simulation.force(forceName, force);
                }
                apply(force, Object.entries(options[forceName]));
            }
            else
                simulation.force(forceName, null);
        });
        return simulation;
    }
}
const apply = (target, params) => {
    return params.reduce((acc, [method, param]) => {
        if (!acc[method] || param === undefined)
            return acc;
        return acc[method].call(target, param);
    }, target);
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/dagre.js":
/*!************************************************!*\
  !*** ./node_modules/@antv/layout/lib/dagre.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DagreLayout: () => (/* binding */ DagreLayout)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/is-number.js");
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/is-function.js");
/* harmony import */ var dagre__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dagre */ "./node_modules/dagre/index.js");
/* harmony import */ var dagre__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dagre__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _util_size__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/size */ "./node_modules/@antv/layout/lib/util/size.js");




/**
 * <zh/> Dagre 布局
 *
 * <en/> Dagre layout
 */
class DagreLayout {
    constructor(options) {
        this.id = 'dagre';
        this.options = {};
        Object.assign(this.options, DagreLayout.defaultOptions, options);
    }
    execute(graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {
            return this.genericDagreLayout(false, graph, Object.assign(Object.assign({}, this.options), options));
        });
    }
    assign(graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {
            yield this.genericDagreLayout(true, graph, Object.assign(Object.assign({}, this.options), options));
        });
    }
    genericDagreLayout(assign, graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__awaiter)(this, void 0, void 0, function* () {
            const { nodeSize } = options;
            const g = new dagre__WEBPACK_IMPORTED_MODULE_0__.graphlib.Graph();
            g.setGraph(options);
            g.setDefaultEdgeLabel(() => ({}));
            const nodes = graph.getAllNodes();
            const edges = graph.getAllEdges();
            if ([...nodes, ...edges].some(({ id }) => (0,_antv_util__WEBPACK_IMPORTED_MODULE_2__["default"])(id))) {
                console.error('Dagre layout only support string id, it will convert number to string.');
            }
            graph.getAllNodes().forEach((node) => {
                const { id } = node;
                const data = Object.assign({}, node.data);
                if (nodeSize !== undefined) {
                    const [width, height] = (0,_util_size__WEBPACK_IMPORTED_MODULE_3__.parseSize)((0,_antv_util__WEBPACK_IMPORTED_MODULE_4__["default"])(nodeSize) ? nodeSize(node) : nodeSize);
                    Object.assign(data, { width, height });
                }
                g.setNode(id.toString(), data);
            });
            graph.getAllEdges().forEach(({ id, source, target }) => {
                g.setEdge(source.toString(), target.toString(), { id });
            });
            dagre__WEBPACK_IMPORTED_MODULE_0___default().layout(g);
            const mapping = { nodes: [], edges: [] };
            g.nodes().forEach((id) => {
                const data = g.node(id);
                mapping.nodes.push({ id, data });
                if (assign)
                    graph.mergeNodeData(id, data);
            });
            g.edges().forEach((edge) => {
                const _a = g.edge(edge), { id } = _a, data = (0,tslib__WEBPACK_IMPORTED_MODULE_1__.__rest)(_a, ["id"]);
                const { v: source, w: target } = edge;
                mapping.edges.push({ id, source, target, data });
                if (assign)
                    graph.mergeEdgeData(id, data);
            });
            return mapping;
        });
    }
}
DagreLayout.defaultOptions = {};
//# sourceMappingURL=dagre.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/force-atlas2/body.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/force-atlas2/body.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Body)
/* harmony export */ });
// represents a body(a point mass) and its position
class Body {
    constructor(params) {
        /**
         * the id of this body, the same with the node id
         * @type  {number}
         */
        this.id = params.id || 0;
        /**
         * the position of this body
         * @type  {number}
         */
        this.rx = params.rx;
        /**
         * the position of this body
         * @type  {number}
         */
        this.ry = params.ry;
        /**
         * the force acting on this body
         * @type  {number}
         */
        this.fx = 0;
        /**
         * the force acting on this body
         * @type  {number}
         */
        this.fy = 0;
        /**
         * the mass of this body, =1 for a node
         * @type  {number}
         */
        this.mass = params.mass;
        /**
         * the degree of the node represented by this body
         * @type  {number}
         */
        this.degree = params.degree;
        /**
         * the parameter for repulsive force, = kr
         * @type  {number}
         */
        this.g = params.g || 0;
    }
    // returns the euclidean distance
    distanceTo(bo) {
        const dx = this.rx - bo.rx;
        const dy = this.ry - bo.ry;
        return Math.hypot(dx, dy);
    }
    setPos(x, y) {
        this.rx = x;
        this.ry = y;
    }
    // resets the forces
    resetForce() {
        this.fx = 0;
        this.fy = 0;
    }
    addForce(b) {
        const dx = b.rx - this.rx;
        const dy = b.ry - this.ry;
        let dist = Math.hypot(dx, dy);
        dist = dist < 0.0001 ? 0.0001 : dist;
        // the repulsive defined by force atlas 2
        const F = (this.g * (this.degree + 1) * (b.degree + 1)) / dist;
        this.fx += (F * dx) / dist;
        this.fy += (F * dy) / dist;
    }
    // if quad contains this body
    in(quad) {
        return quad.contains(this.rx, this.ry);
    }
    // returns a new body
    add(bo) {
        const nenwMass = this.mass + bo.mass;
        const x = (this.rx * this.mass + bo.rx * bo.mass) / nenwMass;
        const y = (this.ry * this.mass + bo.ry * bo.mass) / nenwMass;
        const dg = this.degree + bo.degree;
        const params = {
            rx: x,
            ry: y,
            mass: nenwMass,
            degree: dg,
        };
        return new Body(params);
    }
}
//# sourceMappingURL=body.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/force-atlas2/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/force-atlas2/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ForceAtlas2Layout: () => (/* binding */ ForceAtlas2Layout)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _antv_graphlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @antv/graphlib */ "./node_modules/@antv/graphlib/esm/graph.js");
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/is-number.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/lib/util/object.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/lib/util/function.js");
/* harmony import */ var _util_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/common */ "./node_modules/@antv/layout/lib/util/common.js");
/* harmony import */ var _body__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./body */ "./node_modules/@antv/layout/lib/force-atlas2/body.js");
/* harmony import */ var _quad__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./quad */ "./node_modules/@antv/layout/lib/force-atlas2/quad.js");
/* harmony import */ var _quad_tree__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./quad-tree */ "./node_modules/@antv/layout/lib/force-atlas2/quad-tree.js");








const DEFAULTS_LAYOUT_OPTIONS = {
    center: [0, 0],
    width: 300,
    height: 300,
    kr: 5,
    kg: 1,
    mode: 'normal',
    preventOverlap: false,
    dissuadeHubs: false,
    maxIteration: 0,
    ks: 0.1,
    ksmax: 10,
    tao: 0.1,
};
/**
 * <zh/> Atlas2 力导向布局
 *
 * <en/> Force Atlas 2 layout
 */
class ForceAtlas2Layout {
    constructor(options = {}) {
        this.options = options;
        this.id = 'forceAtlas2';
        this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS), options);
    }
    /**
     * Return the positions of nodes and edges(if needed).
     */
    execute(graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            return this.genericForceAtlas2Layout(false, graph, options);
        });
    }
    /**
     * To directly assign the positions to the nodes.
     */
    assign(graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            yield this.genericForceAtlas2Layout(true, graph, options);
        });
    }
    genericForceAtlas2Layout(assign, graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            const edges = graph.getAllEdges();
            const nodes = graph.getAllNodes();
            const mergedOptions = this.formatOptions(options, nodes.length);
            const { width, height, prune, maxIteration, nodeSize, center } = mergedOptions;
            if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length) || nodes.length === 1) {
                return (0,_util_common__WEBPACK_IMPORTED_MODULE_1__.handleSingleNodeGraph)(graph, assign, center);
            }
            const calcNodes = nodes.map((node) => (0,_util__WEBPACK_IMPORTED_MODULE_2__.cloneFormatData)(node, [width, height]));
            const calcEdges = edges.filter((edge) => {
                const { source, target } = edge;
                return source !== target;
            });
            const calcGraph = new _antv_graphlib__WEBPACK_IMPORTED_MODULE_3__.Graph({
                nodes: calcNodes,
                edges: calcEdges,
            });
            const sizes = this.getSizes(calcGraph, nodeSize);
            this.run(calcGraph, graph, maxIteration, sizes, assign, mergedOptions);
            // if prune, place the leaves around their parents, and then re-layout for several iterations.
            if (prune) {
                for (let j = 0; j < calcEdges.length; j += 1) {
                    const { source, target } = calcEdges[j];
                    const sourceDegree = calcGraph.getDegree(source);
                    const targetDegree = calcGraph.getDegree(source);
                    if (sourceDegree <= 1) {
                        const targetNode = calcGraph.getNode(target);
                        calcGraph.mergeNodeData(source, {
                            x: targetNode.data.x,
                            y: targetNode.data.y,
                        });
                    }
                    else if (targetDegree <= 1) {
                        const sourceNode = calcGraph.getNode(source);
                        calcGraph.mergeNodeData(target, {
                            x: sourceNode.data.x,
                            y: sourceNode.data.y,
                        });
                    }
                }
                const postOptions = Object.assign(Object.assign({}, mergedOptions), { prune: false, barnesHut: false });
                this.run(calcGraph, graph, 100, sizes, assign, postOptions);
            }
            return {
                nodes: calcNodes,
                edges,
            };
        });
    }
    /**
     * Init the node positions if there is no initial positions.
     * And pre-calculate the size (max of width and height) for each node.
     * @param calcGraph graph for calculation
     * @param nodeSize node size config from layout options
     * @returns {SizeMap} node'id mapped to max of its width and height
     */
    getSizes(calcGraph, nodeSize) {
        const nodes = calcGraph.getAllNodes();
        const sizes = {};
        for (let i = 0; i < nodes.length; i += 1) {
            const node = nodes[i];
            sizes[node.id] = (0,_util__WEBPACK_IMPORTED_MODULE_4__.formatNodeSizeToNumber)(nodeSize, undefined)(node);
        }
        return sizes;
    }
    /**
     * Format the options.
     * @param options input options
     * @param nodeNum number of nodes
     * @returns formatted options
     */
    formatOptions(options = {}, nodeNum) {
        const mergedOptions = Object.assign(Object.assign({}, this.options), options);
        const { center, width, height, barnesHut, prune, maxIteration, kr, kg } = mergedOptions;
        mergedOptions.width =
            !width && typeof window !== 'undefined' ? window.innerWidth : width;
        mergedOptions.height =
            !height && typeof window !== 'undefined' ? window.innerHeight : height;
        mergedOptions.center = !center
            ? [mergedOptions.width / 2, mergedOptions.height / 2]
            : center;
        if (barnesHut === undefined && nodeNum > 250) {
            mergedOptions.barnesHut = true;
        }
        if (prune === undefined && nodeNum > 100)
            mergedOptions.prune = true;
        if (maxIteration === 0 && !prune) {
            mergedOptions.maxIteration = 250;
            if (nodeNum <= 200 && nodeNum > 100)
                mergedOptions.maxIteration = 1000;
            else if (nodeNum > 200)
                mergedOptions.maxIteration = 1200;
        }
        else if (maxIteration === 0 && prune) {
            mergedOptions.maxIteration = 100;
            if (nodeNum <= 200 && nodeNum > 100)
                mergedOptions.maxIteration = 500;
            else if (nodeNum > 200)
                mergedOptions.maxIteration = 950;
        }
        if (!kr) {
            mergedOptions.kr = 50;
            if (nodeNum > 100 && nodeNum <= 500)
                mergedOptions.kr = 20;
            else if (nodeNum > 500)
                mergedOptions.kr = 1;
        }
        if (!kg) {
            mergedOptions.kg = 20;
            if (nodeNum > 100 && nodeNum <= 500)
                mergedOptions.kg = 10;
            else if (nodeNum > 500)
                mergedOptions.kg = 1;
        }
        return mergedOptions;
    }
    /**
     * Loops for fa2.
     * @param calcGraph graph for calculation
     * @param graph original graph
     * @param iteration iteration number
     * @param sizes nodes' size
     * @param options formatted layout options
     * @returns
     */
    run(calcGraph, graph, iteration, sizes, assign, options) {
        const { kr, barnesHut, onTick } = options;
        const calcNodes = calcGraph.getAllNodes();
        let sg = 0;
        let iter = iteration;
        const forces = {};
        const preForces = {};
        const bodies = {};
        for (let i = 0; i < calcNodes.length; i += 1) {
            const { data, id } = calcNodes[i];
            forces[id] = [0, 0];
            if (barnesHut) {
                const params = {
                    id: i,
                    rx: data.x,
                    ry: data.y,
                    mass: 1,
                    g: kr,
                    degree: calcGraph.getDegree(id),
                };
                bodies[id] = new _body__WEBPACK_IMPORTED_MODULE_5__["default"](params);
            }
        }
        while (iter > 0) {
            sg = this.oneStep(calcGraph, {
                iter,
                preventOverlapIters: 50,
                krPrime: 100,
                sg,
                forces,
                preForces,
                bodies,
                sizes,
            }, options);
            iter--;
            onTick === null || onTick === void 0 ? void 0 : onTick({
                nodes: calcNodes,
                edges: graph.getAllEdges(),
            });
            // if (assign) {
            //   calcNodes.forEach(({ id, data }) => graph.mergeNodeData(id, {
            //     x: data.x,
            //     y: data.y
            //   }))
            // }
        }
        return calcGraph;
    }
    /**
     * One step for a loop.
     * @param graph graph for calculation
     * @param params parameters for a loop
     * @param options formatted layout's input options
     * @returns
     */
    oneStep(graph, params, options) {
        const { iter, preventOverlapIters, krPrime, sg, preForces, bodies, sizes } = params;
        let { forces } = params;
        const { preventOverlap, barnesHut } = options;
        const nodes = graph.getAllNodes();
        for (let i = 0; i < nodes.length; i += 1) {
            const { id } = nodes[i];
            preForces[id] = [...forces[id]];
            forces[id] = [0, 0];
        }
        // attractive forces, existing on every actual edge
        forces = this.getAttrForces(graph, iter, preventOverlapIters, sizes, forces, options);
        // repulsive forces and Gravity, existing on every node pair
        // if preventOverlap, using the no-optimized method in the last preventOverlapIters instead.
        if (barnesHut &&
            ((preventOverlap && iter > preventOverlapIters) || !preventOverlap)) {
            forces = this.getOptRepGraForces(graph, forces, bodies, options);
        }
        else {
            forces = this.getRepGraForces(graph, iter, preventOverlapIters, forces, krPrime, sizes, options);
        }
        // update the positions
        return this.updatePos(graph, forces, preForces, sg, options);
    }
    /**
     * Calculate the attract forces for nodes.
     * @param graph graph for calculation
     * @param iter current iteration index
     * @param preventOverlapIters the iteration number for preventing overlappings
     * @param sizes nodes' sizes
     * @param forces forces for nodes, which will be modified
     * @param options formatted layout's input options
     * @returns
     */
    getAttrForces(graph, iter, preventOverlapIters, sizes, forces, options) {
        const { preventOverlap, dissuadeHubs, mode, prune } = options;
        const edges = graph.getAllEdges();
        for (let i = 0; i < edges.length; i += 1) {
            const { source, target } = edges[i];
            const sourceNode = graph.getNode(source);
            const targetNode = graph.getNode(target);
            const sourceDegree = graph.getDegree(source);
            const targetDegree = graph.getDegree(target);
            if (prune && (sourceDegree <= 1 || targetDegree <= 1))
                continue;
            const dir = [
                targetNode.data.x - sourceNode.data.x,
                targetNode.data.y - sourceNode.data.y,
            ];
            let eucliDis = Math.hypot(dir[0], dir[1]);
            eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;
            dir[0] = dir[0] / eucliDis;
            dir[1] = dir[1] / eucliDis;
            if (preventOverlap && iter < preventOverlapIters) {
                eucliDis = eucliDis - sizes[source] - sizes[target];
            }
            let fa1 = eucliDis;
            let fa2 = fa1;
            if (mode === 'linlog') {
                fa1 = Math.log(1 + eucliDis);
                fa2 = fa1;
            }
            if (dissuadeHubs) {
                fa1 = eucliDis / sourceDegree;
                fa2 = eucliDis / targetDegree;
            }
            if (preventOverlap && iter < preventOverlapIters && eucliDis <= 0) {
                fa1 = 0;
                fa2 = 0;
            }
            else if (preventOverlap && iter < preventOverlapIters && eucliDis > 0) {
                fa1 = eucliDis;
                fa2 = eucliDis;
            }
            forces[source][0] += fa1 * dir[0];
            forces[target][0] -= fa2 * dir[0];
            forces[source][1] += fa1 * dir[1];
            forces[target][1] -= fa2 * dir[1];
        }
        return forces;
    }
    /**
     * Calculate the repulsive forces for nodes under barnesHut mode.
     * @param graph graph for calculatiion
     * @param forces forces for nodes, which will be modified
     * @param bodies force body map
     * @param options formatted layout's input options
     * @returns
     */
    getOptRepGraForces(graph, forces, bodies, options) {
        const { kg, center, prune } = options;
        const nodes = graph.getAllNodes();
        const nodeNum = nodes.length;
        let minx = 9e10;
        let maxx = -9e10;
        let miny = 9e10;
        let maxy = -9e10;
        for (let i = 0; i < nodeNum; i += 1) {
            const { id, data } = nodes[i];
            if (prune && graph.getDegree(id) <= 1)
                continue;
            bodies[id].setPos(data.x, data.y);
            if (data.x >= maxx)
                maxx = data.x;
            if (data.x <= minx)
                minx = data.x;
            if (data.y >= maxy)
                maxy = data.y;
            if (data.y <= miny)
                miny = data.y;
        }
        const width = Math.max(maxx - minx, maxy - miny);
        const quadParams = {
            xmid: (maxx + minx) / 2,
            ymid: (maxy + miny) / 2,
            length: width,
            massCenter: center,
            mass: nodeNum,
        };
        const quad = new _quad__WEBPACK_IMPORTED_MODULE_6__["default"](quadParams);
        const quadTree = new _quad_tree__WEBPACK_IMPORTED_MODULE_7__["default"](quad);
        // build the tree, insert the nodes(quads) into the tree
        for (let i = 0; i < nodeNum; i += 1) {
            const { id } = nodes[i];
            if (prune && graph.getDegree(id) <= 1)
                continue;
            if (bodies[id].in(quad))
                quadTree.insert(bodies[id]);
        }
        // update the repulsive forces and the gravity.
        for (let i = 0; i < nodeNum; i += 1) {
            const { id, data } = nodes[i];
            const degree = graph.getDegree(id);
            if (prune && degree <= 1)
                continue;
            bodies[id].resetForce();
            quadTree.updateForce(bodies[id]);
            forces[id][0] -= bodies[id].fx;
            forces[id][1] -= bodies[id].fy;
            // gravity
            const dir = [data.x - center[0], data.y - center[1]];
            let eucliDis = Math.hypot(dir[0], dir[1]);
            eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;
            dir[0] = dir[0] / eucliDis;
            dir[1] = dir[1] / eucliDis;
            const fg = kg * (degree + 1); // tslint:disable-line
            forces[id][0] -= fg * dir[0];
            forces[id][1] -= fg * dir[1];
        }
        return forces;
    }
    /**
     * Calculate the repulsive forces for nodes.
     * @param graph graph for calculatiion
     * @param iter current iteration index
     * @param preventOverlapIters the iteration number for preventing overlappings
     * @param forces forces for nodes, which will be modified
     * @param krPrime larger the krPrime, larger the repulsive force
     * @param sizes nodes' sizes
     * @param options formatted layout's input options
     * @returns
     */
    getRepGraForces(graph, iter, preventOverlapIters, forces, krPrime, sizes, options) {
        const { preventOverlap, kr, kg, center, prune } = options;
        const nodes = graph.getAllNodes();
        const nodeNum = nodes.length;
        for (let i = 0; i < nodeNum; i += 1) {
            const nodei = nodes[i];
            const degreei = graph.getDegree(nodei.id);
            for (let j = i + 1; j < nodeNum; j += 1) {
                const nodej = nodes[j];
                const degreej = graph.getDegree(nodej.id);
                if (prune && (degreei <= 1 || degreej <= 1))
                    continue;
                const dir = [nodej.data.x - nodei.data.x, nodej.data.y - nodei.data.y];
                let eucliDis = Math.hypot(dir[0], dir[1]);
                eucliDis = eucliDis < 0.0001 ? 0.0001 : eucliDis;
                dir[0] = dir[0] / eucliDis;
                dir[1] = dir[1] / eucliDis;
                if (preventOverlap && iter < preventOverlapIters) {
                    eucliDis = eucliDis - sizes[nodei.id] - sizes[nodej.id];
                }
                let fr = (kr * (degreei + 1) * (degreej + 1)) / eucliDis;
                if (preventOverlap && iter < preventOverlapIters && eucliDis < 0) {
                    fr = krPrime * (degreei + 1) * (degreej + 1);
                }
                else if (preventOverlap &&
                    iter < preventOverlapIters &&
                    eucliDis === 0) {
                    fr = 0;
                }
                else if (preventOverlap &&
                    iter < preventOverlapIters &&
                    eucliDis > 0) {
                    fr = (kr * (degreei + 1) * (degreej + 1)) / eucliDis;
                }
                forces[nodei.id][0] -= fr * dir[0];
                forces[nodej.id][0] += fr * dir[0];
                forces[nodei.id][1] -= fr * dir[1];
                forces[nodej.id][1] += fr * dir[1];
            }
            // gravity
            const dir = [nodei.data.x - center[0], nodei.data.y - center[1]];
            const eucliDis = Math.hypot(dir[0], dir[1]);
            dir[0] = dir[0] / eucliDis;
            dir[1] = dir[1] / eucliDis;
            const fg = kg * (degreei + 1); // tslint:disable-line
            forces[nodei.id][0] -= fg * dir[0];
            forces[nodei.id][1] -= fg * dir[1];
        }
        return forces;
    }
    /**
     * Update node positions.
     * @param graph graph for calculatiion
     * @param forces forces for nodes, which will be modified
     * @param preForces previous forces for nodes, which will be modified
     * @param sg constant for move distance of one step
     * @param options formatted layout's input options
     * @returns
     */
    updatePos(graph, forces, preForces, sg, options) {
        const { ks, tao, prune, ksmax } = options;
        const nodes = graph.getAllNodes();
        const nodeNum = nodes.length;
        const swgns = [];
        const trans = [];
        // swg(G) and tra(G)
        let swgG = 0;
        let traG = 0;
        let usingSg = sg;
        for (let i = 0; i < nodeNum; i += 1) {
            const { id } = nodes[i];
            const degree = graph.getDegree(id);
            if (prune && degree <= 1)
                continue;
            const minus = [
                forces[id][0] - preForces[id][0],
                forces[id][1] - preForces[id][1],
            ];
            const minusNorm = Math.hypot(minus[0], minus[1]);
            const add = [
                forces[id][0] + preForces[id][0],
                forces[id][1] + preForces[id][1],
            ];
            const addNorm = Math.hypot(add[0], add[1]);
            swgns[i] = minusNorm;
            trans[i] = addNorm / 2;
            swgG += (degree + 1) * swgns[i];
            traG += (degree + 1) * trans[i];
        }
        const preSG = usingSg;
        usingSg = (tao * traG) / swgG;
        if (preSG !== 0) {
            usingSg = usingSg > 1.5 * preSG ? 1.5 * preSG : usingSg;
        }
        // update the node positions
        for (let i = 0; i < nodeNum; i += 1) {
            const { id, data } = nodes[i];
            const degree = graph.getDegree(id);
            if (prune && degree <= 1)
                continue;
            if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_8__["default"])(data.fx) && (0,_antv_util__WEBPACK_IMPORTED_MODULE_8__["default"])(data.fy))
                continue;
            let sn = (ks * usingSg) / (1 + usingSg * Math.sqrt(swgns[i]));
            let absForce = Math.hypot(forces[id][0], forces[id][1]);
            absForce = absForce < 0.0001 ? 0.0001 : absForce;
            const max = ksmax / absForce;
            sn = sn > max ? max : sn;
            const dnx = sn * forces[id][0];
            const dny = sn * forces[id][1];
            graph.mergeNodeData(id, {
                x: data.x + dnx,
                y: data.y + dny,
            });
        }
        return usingSg;
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/force-atlas2/quad-tree.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/force-atlas2/quad-tree.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ QuadTree)
/* harmony export */ });
/**
 * @fileOverview quadTree
 * @author shiwu.wyy@antfin.com
 */
class QuadTree {
    // each quadtree represents a quadrant and an aggregate body
    // that represents all bodies inside the quadrant
    constructor(param) {
        /**
         * (aggregated) body in this quad
         * @type  {object}
         */
        this.body = null;
        /**
         * tree representing the northwest quadrant
         * @type  {object}
         */
        this.quad = null;
        this.NW = null;
        this.NE = null;
        this.SW = null;
        this.SE = null;
        /**
         * threshold
         * @type  {number}
         */
        this.theta = 0.5;
        if (param != null)
            this.quad = param;
    }
    // insert a body(node) into the tree
    insert(bo) {
        // if this node does not contain a body, put the new body bo here
        if (this.body == null) {
            this.body = bo;
            return;
        }
        // internal node
        if (!this._isExternal()) {
            // update mass info
            this.body = this.body.add(bo);
            // insert body into quadrant
            this._putBody(bo);
        }
        else {
            // external node
            // divide this region into four children
            if (this.quad) {
                this.NW = new QuadTree(this.quad.NW());
                this.NE = new QuadTree(this.quad.NE());
                this.SW = new QuadTree(this.quad.SW());
                this.SE = new QuadTree(this.quad.SE());
            }
            // insert this body and bo
            this._putBody(this.body);
            this._putBody(bo);
            // update the mass info
            this.body = this.body.add(bo);
        }
    }
    // inserts bo into a quad
    // tslint:disable-next-line
    _putBody(bo) {
        if (!this.quad)
            return;
        if (bo.in(this.quad.NW()) && this.NW)
            this.NW.insert(bo);
        else if (bo.in(this.quad.NE()) && this.NE)
            this.NE.insert(bo);
        else if (bo.in(this.quad.SW()) && this.SW)
            this.SW.insert(bo);
        else if (bo.in(this.quad.SE()) && this.SE)
            this.SE.insert(bo);
    }
    // tslint:disable-next-line
    _isExternal() {
        // four children are null
        return (this.NW == null && this.NE == null && this.SW == null && this.SE == null);
    }
    // update the forces
    updateForce(bo) {
        if (this.body == null || bo === this.body) {
            return;
        }
        // if the current node is external
        if (this._isExternal())
            bo.addForce(this.body);
        // internal nodes
        else {
            const s = this.quad ? this.quad.getLength() : 0;
            const d = this.body.distanceTo(bo);
            // b is far enough
            if (s / d < this.theta)
                bo.addForce(this.body);
            else {
                this.NW && this.NW.updateForce(bo);
                this.NE && this.NE.updateForce(bo);
                this.SW && this.SW.updateForce(bo);
                this.SE && this.SE.updateForce(bo);
            }
        }
    }
}
//# sourceMappingURL=quad-tree.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/force-atlas2/quad.js":
/*!************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/force-atlas2/quad.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Quad)
/* harmony export */ });
class Quad {
    constructor(params) {
        /**
         * the center position of this quad
         * @type  {number}
         */
        this.xmid = params.xmid;
        /**
         * the center position of this quad
         * @type  {number}
         */
        this.ymid = params.ymid;
        /**
         * the length of this quad
         * @type  {number}
         */
        this.length = params.length;
        /**
         * the mass center of this quad
         * @type  {number}
         */
        this.massCenter = params.massCenter || [0, 0];
        /**
         * the mass of this quad
         * @type  {number}
         */
        this.mass = params.mass || 1;
    }
    getLength() {
        return this.length;
    }
    contains(x, y) {
        const halfLen = this.length / 2;
        return (x <= this.xmid + halfLen &&
            x >= this.xmid - halfLen &&
            y <= this.ymid + halfLen &&
            y >= this.ymid - halfLen);
    }
    // northwest quadrant
    // tslint:disable-next-line
    NW() {
        const x = this.xmid - this.length / 4;
        const y = this.ymid + this.length / 4;
        const len = this.length / 2;
        const params = {
            xmid: x,
            ymid: y,
            length: len,
        };
        const NW = new Quad(params);
        return NW;
    }
    // northeast
    // tslint:disable-next-line
    NE() {
        const x = this.xmid + this.length / 4;
        const y = this.ymid + this.length / 4;
        const len = this.length / 2;
        const params = {
            xmid: x,
            ymid: y,
            length: len,
        };
        const NE = new Quad(params);
        return NE;
    }
    // southwest
    // tslint:disable-next-line
    SW() {
        const x = this.xmid - this.length / 4;
        const y = this.ymid - this.length / 4;
        const len = this.length / 2;
        const params = {
            xmid: x,
            ymid: y,
            length: len,
        };
        const SW = new Quad(params);
        return SW;
    }
    // southeast
    // tslint:disable-next-line
    SE() {
        const x = this.xmid + this.length / 4;
        const y = this.ymid - this.length / 4;
        const len = this.length / 2;
        const params = {
            xmid: x,
            ymid: y,
            length: len,
        };
        const SE = new Quad(params);
        return SE;
    }
}
//# sourceMappingURL=quad.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/force/force-n-body.js":
/*!*************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/force/force-n-body.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   forceNBody: () => (/* binding */ forceNBody)
/* harmony export */ });
/* harmony import */ var d3_quadtree__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-quadtree */ "./node_modules/d3-quadtree/src/quadtree.js");
/* harmony import */ var d3_octree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-octree */ "./node_modules/d3-octree/src/octree.js");

// @ts-ignore

const theta2 = 0.81; // Barnes-Hut approximation threshold
const epsilon = 0.1; // 为了防止出现除0的情况，加一个epsilon
function forceNBody(calcGraph, factor, coulombDisScale2, accMap, dimensions = 2) {
    const weightParam = factor / coulombDisScale2;
    const calcNodes = calcGraph.getAllNodes();
    const data = calcNodes.map((calcNode, i) => {
        const { nodeStrength, x, y, z, size } = calcNode.data;
        return {
            x,
            y,
            z,
            size,
            index: i,
            id: calcNode.id,
            vx: 0,
            vy: 0,
            vz: 0,
            weight: weightParam * nodeStrength,
        };
    });
    const tree = (dimensions === 2
        ? (0,d3_quadtree__WEBPACK_IMPORTED_MODULE_0__["default"])(data, (d) => d.x, (d) => d.y)
        : (0,d3_octree__WEBPACK_IMPORTED_MODULE_1__["default"])(data, (d) => d.x, (d) => d.y, (d) => d.z)).visitAfter(accumulate); // init internal node
    const nodeMap = new Map();
    data.forEach((n) => {
        nodeMap.set(n.id, n);
        // @ts-ignore
        computeForce(n, tree, dimensions);
    });
    data.map((n, i) => {
        const { id, data } = calcNodes[i];
        const { mass = 1 } = data;
        // 从 0 开始，= 初始化 + 加斥力
        accMap[id] = {
            x: n.vx / mass,
            y: n.vy / mass,
            z: n.vz / mass,
        };
    });
    return accMap;
}
function accumulate(treeNode) {
    let accWeight = 0;
    let accX = 0;
    let accY = 0;
    let accZ = 0;
    let accSize = 0;
    const numChildren = treeNode.length;
    if (numChildren) {
        // internal node, accumulate 4 child quads
        for (let i = 0; i < numChildren; i++) {
            const q = treeNode[i];
            if (q && q.weight) {
                accWeight += q.weight;
                accX += q.x * q.weight;
                accY += q.y * q.weight;
                accZ += q.z * q.weight;
                accSize += q.size * q.weight;
            }
        }
        treeNode.x = accX / accWeight;
        treeNode.y = accY / accWeight;
        treeNode.z = accZ / accWeight;
        treeNode.size = accSize / accWeight;
        treeNode.weight = accWeight;
    }
    else {
        // leaf node
        const q = treeNode;
        treeNode.x = q.data.x;
        treeNode.y = q.data.y;
        treeNode.z = q.data.z;
        treeNode.size = q.data.size;
        treeNode.weight = q.data.weight;
    }
}
const apply = (treeNode, x1, arg1, arg2, arg3, node, dimensions) => {
    var _a;
    if (((_a = treeNode.data) === null || _a === void 0 ? void 0 : _a.id) === node.id)
        return;
    const x2 = [arg1, arg2, arg3][dimensions - 1];
    const dx = node.x - treeNode.x || epsilon;
    const dy = node.y - treeNode.y || epsilon;
    const dz = node.z - treeNode.z || epsilon;
    const pos = [dx, dy, dz];
    const width = x2 - x1;
    let len2 = 0;
    for (let i = 0; i < dimensions; i++) {
        len2 += pos[i] * pos[i];
    }
    const len1 = Math.sqrt(len2);
    const len3 = len1 * len2;
    // far node, apply Barnes-Hut approximation
    if (width * width * theta2 < len2) {
        const param = treeNode.weight / len3;
        node.vx += dx * param;
        node.vy += dy * param;
        node.vz += dz * param;
        return true;
    }
    // near quad, compute force directly
    if (treeNode.length)
        return false; // internal node, visit children
    // leaf node
    if (treeNode.data !== node) {
        const param = treeNode.data.weight / len3;
        node.vx += dx * param;
        node.vy += dy * param;
        node.vz += dz * param;
    }
};
// @ts-ignore
function computeForce(node, tree, dimensions) {
    // @ts-ignore
    tree.visit((treeNode, x1, y1, x2, y2) => apply(treeNode, x1, y1, x2, y2, node, dimensions));
}
//# sourceMappingURL=force-n-body.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/force/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@antv/layout/lib/force/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ForceLayout: () => (/* binding */ ForceLayout)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _antv_graphlib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @antv/graphlib */ "./node_modules/@antv/graphlib/esm/graph.js");
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/is-number.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/lib/util/function.js");
/* harmony import */ var _force_n_body__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./force-n-body */ "./node_modules/@antv/layout/lib/force/force-n-body.js");





const DEFAULTS_LAYOUT_OPTIONS = {
    dimensions: 2,
    maxIteration: 500,
    gravity: 10,
    factor: 1,
    edgeStrength: 50,
    nodeStrength: 1000,
    coulombDisScale: 0.005,
    damping: 0.9,
    maxSpeed: 200,
    minMovement: 0.4,
    interval: 0.02,
    linkDistance: 200,
    clusterNodeStrength: 20,
    preventOverlap: true,
    distanceThresholdMode: 'mean',
};
/**
 * <zh/> 力导向布局
 *
 * <en/> Force-directed layout
 */
class ForceLayout {
    constructor(options = {}) {
        this.options = options;
        this.id = 'force';
        /**
         * time interval for layout force animations
         */
        this.timeInterval = 0;
        /**
         * compare with minMovement to end the nodes' movement
         */
        this.judgingDistance = 0;
        this.running = false;
        this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS), options);
    }
    /**
     * Return the positions of nodes and edges(if needed).
     */
    execute(graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            return this.genericForceLayout(false, graph, options);
        });
    }
    /**
     * To directly assign the positions to the nodes.
     */
    assign(graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            yield this.genericForceLayout(true, graph, options);
        });
    }
    /**
     * Stop simulation immediately.
     */
    stop() {
        if (this.timeInterval && typeof window !== 'undefined') {
            window.clearInterval(this.timeInterval);
        }
        this.running = false;
    }
    /**
     * Manually steps the simulation by the specified number of iterations.
     * @see https://github.com/d3/d3-force#simulation_tick
     */
    tick(iterations = this.options.maxIteration || 1) {
        if (this.lastResult) {
            return this.lastResult;
        }
        for (let i = 0; (this.judgingDistance > this.lastOptions.minMovement || i < 1) &&
            i < iterations; i++) {
            this.runOneStep(this.lastCalcGraph, this.lastGraph, i, this.lastVelMap, this.lastOptions);
            this.updatePosition(this.lastGraph, this.lastCalcGraph, this.lastVelMap, this.lastOptions);
        }
        const result = {
            nodes: this.lastLayoutNodes,
            edges: this.lastLayoutEdges,
        };
        if (this.lastAssign) {
            result.nodes.forEach((node) => this.lastGraph.mergeNodeData(node.id, {
                x: node.data.x,
                y: node.data.y,
                z: this.options.dimensions === 3 ? node.data.z : undefined,
            }));
        }
        return result;
    }
    genericForceLayout(assign, graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            const mergedOptions = Object.assign(Object.assign({}, this.options), options);
            const nodes = graph.getAllNodes();
            const edges = graph.getAllEdges();
            const formattedOptions = this.formatOptions(mergedOptions, graph);
            const { dimensions, width, height, nodeSize, getMass, nodeStrength, edgeStrength, linkDistance, } = formattedOptions;
            // clones the original data and attaches calculation attributes for this layout algorithm
            const layoutNodes = nodes.map((node, i) => {
                return Object.assign(Object.assign({}, node), { data: Object.assign(Object.assign({}, node.data), { 
                        // ...randomDistribution(node, dimensions, 30, i),
                        x: (0,_antv_util__WEBPACK_IMPORTED_MODULE_1__["default"])(node.data.x) ? node.data.x : Math.random() * width, y: (0,_antv_util__WEBPACK_IMPORTED_MODULE_1__["default"])(node.data.y) ? node.data.y : Math.random() * height, z: (0,_antv_util__WEBPACK_IMPORTED_MODULE_1__["default"])(node.data.z)
                            ? node.data.z
                            : Math.random() * Math.sqrt(width * height), size: nodeSize(node) || 30, mass: getMass(node), nodeStrength: nodeStrength(node) }) });
            });
            const layoutEdges = edges.map((edge) => (Object.assign(Object.assign({}, edge), { data: Object.assign(Object.assign({}, edge.data), { edgeStrength: edgeStrength(edge), linkDistance: linkDistance(edge, graph.getNode(edge.source), graph.getNode(edge.target)) }) })));
            if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length)) {
                this.lastResult = { nodes: [], edges };
                return { nodes: [], edges };
            }
            const velMap = {};
            nodes.forEach((node, i) => {
                velMap[node.id] = {
                    x: 0,
                    y: 0,
                    z: 0,
                };
            });
            const calcGraph = new _antv_graphlib__WEBPACK_IMPORTED_MODULE_2__.Graph({
                nodes: layoutNodes,
                edges: layoutEdges,
            });
            this.formatCentripetal(formattedOptions, calcGraph);
            const { maxIteration, minMovement, onTick } = formattedOptions;
            // Use them later in `tick`.
            this.lastLayoutNodes = layoutNodes;
            this.lastLayoutEdges = layoutEdges;
            this.lastAssign = assign;
            this.lastGraph = graph;
            this.lastCalcGraph = calcGraph;
            this.lastOptions = formattedOptions;
            this.lastVelMap = velMap;
            if (typeof window === 'undefined')
                return;
            let iter = 0;
            return new Promise((resolve) => {
                // interval for render the result after each iteration
                this.timeInterval = window.setInterval(() => {
                    if (!nodes || !this.running) {
                        resolve({
                            nodes: formatOutNodes(graph, layoutNodes),
                            edges,
                        });
                    }
                    this.runOneStep(calcGraph, graph, iter, velMap, formattedOptions);
                    this.updatePosition(graph, calcGraph, velMap, formattedOptions);
                    if (assign) {
                        layoutNodes.forEach((node) => graph.mergeNodeData(node.id, {
                            x: node.data.x,
                            y: node.data.y,
                            z: dimensions === 3 ? node.data.z : undefined,
                        }));
                    }
                    onTick === null || onTick === void 0 ? void 0 : onTick({
                        nodes: formatOutNodes(graph, layoutNodes),
                        edges,
                    });
                    iter++;
                    if (iter >= maxIteration || this.judgingDistance < minMovement) {
                        window.clearInterval(this.timeInterval);
                        resolve({
                            nodes: formatOutNodes(graph, layoutNodes),
                            edges,
                        });
                    }
                }, 0);
                this.running = true;
            });
        });
    }
    /**
     * Format merged layout options.
     * @param options merged layout options
     * @param graph original graph
     * @returns
     */
    formatOptions(options, graph) {
        const formattedOptions = Object.assign({}, options);
        const { width: propsWidth, height: propsHeight, getMass } = options;
        // === formating width, height, and center =====
        formattedOptions.width =
            !propsWidth && typeof window !== 'undefined'
                ? window.innerWidth
                : propsWidth;
        formattedOptions.height =
            !propsHeight && typeof window !== 'undefined'
                ? window.innerHeight
                : propsHeight;
        if (!options.center) {
            formattedOptions.center = [
                formattedOptions.width / 2,
                formattedOptions.height / 2,
            ];
        }
        // === formating node mass =====
        if (!getMass) {
            formattedOptions.getMass = (d) => {
                let massWeight = 1;
                if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_1__["default"])(d === null || d === void 0 ? void 0 : d.data.mass))
                    massWeight = d === null || d === void 0 ? void 0 : d.data.mass;
                const degree = graph.getDegree(d.id, 'both');
                return !degree || degree < 5 ? massWeight : degree * 5 * massWeight;
            };
        }
        // === formating node size =====
        formattedOptions.nodeSize = (0,_util__WEBPACK_IMPORTED_MODULE_3__.formatNodeSizeToNumber)(options.nodeSize, options.nodeSpacing);
        // === formating node / edge strengths =====
        const linkDistanceFn = options.linkDistance
            ? (0,_util__WEBPACK_IMPORTED_MODULE_3__.formatNumberFn)(1, options.linkDistance)
            : (edge) => {
                return (1 +
                    formattedOptions.nodeSize(graph.getNode(edge.source)) +
                    formattedOptions.nodeSize(graph.getNode(edge.target)));
            };
        formattedOptions.linkDistance = linkDistanceFn;
        formattedOptions.nodeStrength = (0,_util__WEBPACK_IMPORTED_MODULE_3__.formatNumberFn)(1, options.nodeStrength);
        formattedOptions.edgeStrength = (0,_util__WEBPACK_IMPORTED_MODULE_3__.formatNumberFn)(1, options.edgeStrength);
        return formattedOptions;
    }
    /**
     * Format centripetalOption in the option.
     * @param options merged layout options
     * @param calcGraph calculation graph
     */
    formatCentripetal(options, calcGraph) {
        const { dimensions, centripetalOptions, center, clusterNodeStrength, leafCluster, clustering, nodeClusterBy, } = options;
        const calcNodes = calcGraph.getAllNodes();
        // === formating centripetalOptions =====
        const basicCentripetal = centripetalOptions || {
            leaf: 2,
            single: 2,
            others: 1,
            // eslint-disable-next-line
            center: (n) => {
                return {
                    x: center[0],
                    y: center[1],
                    z: dimensions === 3 ? center[2] : undefined,
                };
            },
        };
        if (typeof clusterNodeStrength !== 'function') {
            options.clusterNodeStrength = (node) => clusterNodeStrength;
        }
        let sameTypeLeafMap;
        let clusters;
        if (leafCluster && nodeClusterBy) {
            sameTypeLeafMap = getSameTypeLeafMap(calcGraph, nodeClusterBy);
            clusters =
                Array.from(new Set(calcNodes === null || calcNodes === void 0 ? void 0 : calcNodes.map((node) => node.data[nodeClusterBy]))) || [];
            // @ts-ignore
            options.centripetalOptions = Object.assign(basicCentripetal, {
                single: 100,
                leaf: (node) => {
                    // 找出与它关联的边的起点或终点出发的所有一度节点中同类型的叶子节点
                    const { siblingLeaves, sameTypeLeaves } = sameTypeLeafMap[node.id] || {};
                    // 如果都是同一类型或者每种类型只有1个，则施加默认向心力
                    if ((sameTypeLeaves === null || sameTypeLeaves === void 0 ? void 0 : sameTypeLeaves.length) === (siblingLeaves === null || siblingLeaves === void 0 ? void 0 : siblingLeaves.length) ||
                        (clusters === null || clusters === void 0 ? void 0 : clusters.length) === 1) {
                        return 1;
                    }
                    return options.clusterNodeStrength(node);
                },
                others: 1,
                center: (node) => {
                    const degree = calcGraph.getDegree(node.id, 'both');
                    // 孤点默认给1个远离的中心点
                    if (!degree) {
                        return {
                            x: 100,
                            y: 100,
                            z: 0,
                        };
                    }
                    let centerPos;
                    if (degree === 1) {
                        // 如果为叶子节点
                        // 找出与它关联的边的起点出发的所有一度节点中同类型的叶子节点
                        const { sameTypeLeaves = [] } = sameTypeLeafMap[node.id] || {};
                        if (sameTypeLeaves.length === 1) {
                            // 如果同类型的叶子节点只有1个，中心位置为undefined
                            centerPos = undefined;
                        }
                        else if (sameTypeLeaves.length > 1) {
                            // 找出同类型节点平均位置作为中心
                            centerPos = getAvgNodePosition(sameTypeLeaves);
                        }
                    }
                    else {
                        centerPos = undefined;
                    }
                    return {
                        x: centerPos === null || centerPos === void 0 ? void 0 : centerPos.x,
                        y: centerPos === null || centerPos === void 0 ? void 0 : centerPos.y,
                        z: centerPos === null || centerPos === void 0 ? void 0 : centerPos.z,
                    };
                },
            });
        }
        if (clustering && nodeClusterBy) {
            if (!sameTypeLeafMap) {
                sameTypeLeafMap = getSameTypeLeafMap(calcGraph, nodeClusterBy);
            }
            if (!clusters) {
                clusters = Array.from(new Set(calcNodes.map((node) => node.data[nodeClusterBy])));
            }
            clusters = clusters.filter((item) => item !== undefined);
            const centerInfo = {};
            clusters.forEach((cluster) => {
                const sameTypeNodes = calcNodes
                    .filter((node) => node.data[nodeClusterBy] === cluster)
                    .map((node) => calcGraph.getNode(node.id));
                // 找出同类型节点平均位置节点的距离最近的节点作为中心节点
                centerInfo[cluster] = getAvgNodePosition(sameTypeNodes);
            });
            options.centripetalOptions = Object.assign(basicCentripetal, {
                single: (node) => options.clusterNodeStrength(node),
                leaf: (node) => options.clusterNodeStrength(node),
                others: (node) => options.clusterNodeStrength(node),
                center: (node) => {
                    // 找出同类型节点平均位置节点的距离最近的节点作为中心节点
                    const centerPos = centerInfo[node.data[nodeClusterBy]];
                    return {
                        x: centerPos === null || centerPos === void 0 ? void 0 : centerPos.x,
                        y: centerPos === null || centerPos === void 0 ? void 0 : centerPos.y,
                        z: centerPos === null || centerPos === void 0 ? void 0 : centerPos.z,
                    };
                },
            });
        }
        const { leaf, single, others } = options.centripetalOptions || {};
        if (leaf && typeof leaf !== 'function') {
            options.centripetalOptions.leaf = () => leaf;
        }
        if (single && typeof single !== 'function') {
            options.centripetalOptions.single = () => single;
        }
        if (others && typeof others !== 'function') {
            options.centripetalOptions.others = () => others;
        }
    }
    /**
     * One iteration.
     * @param calcGraph calculation graph
     * @param graph origin graph
     * @param iter current iteration index
     * @param velMap nodes' velocity map
     * @param options formatted layout options
     * @returns
     */
    runOneStep(calcGraph, graph, iter, velMap, options) {
        const accMap = {};
        const calcNodes = calcGraph.getAllNodes();
        const calcEdges = calcGraph.getAllEdges();
        if (!(calcNodes === null || calcNodes === void 0 ? void 0 : calcNodes.length))
            return;
        const { monitor } = options;
        this.calRepulsive(calcGraph, accMap, options);
        if (calcEdges)
            this.calAttractive(calcGraph, accMap, options);
        this.calGravity(calcGraph, graph, accMap, options);
        this.updateVelocity(calcGraph, accMap, velMap, options);
        /** 如果需要监控信息，则提供给用户 */
        if (monitor) {
            const energy = this.calTotalEnergy(accMap, calcNodes);
            monitor({
                energy,
                nodes: graph.getAllNodes(),
                edges: graph.getAllEdges(),
                iterations: iter,
            });
        }
    }
    /**
     * Calculate graph energy for monitoring convergence.
     * @param accMap acceleration map
     * @param nodes calculation nodes
     * @returns energy
     */
    calTotalEnergy(accMap, nodes) {
        if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
            return 0;
        let energy = 0.0;
        nodes.forEach((node, i) => {
            const vx = accMap[node.id].x;
            const vy = accMap[node.id].y;
            const vz = this.options.dimensions === 3 ? accMap[node.id].z : 0;
            const speed2 = vx * vx + vy * vy + vz * vz;
            const { mass = 1 } = node.data;
            energy += mass * speed2 * 0.5; // p = 1/2*(mv^2)
        });
        return energy;
    }
    /**
     * Calculate the repulsive forces according to coulombs law.
     * @param calcGraph calculation graph
     * @param accMap acceleration map
     * @param options formatted layout options
     */
    calRepulsive(calcGraph, accMap, options) {
        const { dimensions, factor, coulombDisScale } = options;
        (0,_force_n_body__WEBPACK_IMPORTED_MODULE_4__.forceNBody)(calcGraph, factor, coulombDisScale * coulombDisScale, accMap, dimensions);
    }
    /**
     * Calculate the attractive forces according to hooks law.
     * @param calcGraph calculation graph
     * @param accMap acceleration map
     */
    calAttractive(calcGraph, accMap, options) {
        const { dimensions, nodeSize } = options;
        calcGraph.getAllEdges().forEach((edge, i) => {
            const { source, target } = edge;
            const sourceNode = calcGraph.getNode(source);
            const targetNode = calcGraph.getNode(target);
            if (!sourceNode || !targetNode)
                return;
            let vecX = targetNode.data.x - sourceNode.data.x;
            let vecY = targetNode.data.y - sourceNode.data.y;
            let vecZ = dimensions === 3 ? targetNode.data.z - sourceNode.data.z : 0;
            if (!vecX && !vecY) {
                vecX = Math.random() * 0.01;
                vecY = Math.random() * 0.01;
                if (dimensions === 3 && !vecZ) {
                    vecZ = Math.random() * 0.01;
                }
            }
            const vecLength = Math.sqrt(vecX * vecX + vecY * vecY + vecZ * vecZ);
            if (vecLength < nodeSize(sourceNode) + nodeSize(targetNode))
                return;
            const direX = vecX / vecLength;
            const direY = vecY / vecLength;
            const direZ = vecZ / vecLength;
            const { linkDistance = 200, edgeStrength = 200 } = edge.data || {};
            const diff = linkDistance - vecLength;
            const param = diff * edgeStrength;
            const massSource = sourceNode.data.mass || 1;
            const massTarget = targetNode.data.mass || 1;
            // 质量占比越大，对另一端影响程度越大
            const sourceMassRatio = 1 / massSource;
            const targetMassRatio = 1 / massTarget;
            const disX = direX * param;
            const disY = direY * param;
            const disZ = direZ * param;
            accMap[source].x -= disX * sourceMassRatio;
            accMap[source].y -= disY * sourceMassRatio;
            accMap[source].z -= disZ * sourceMassRatio;
            accMap[target].x += disX * targetMassRatio;
            accMap[target].y += disY * targetMassRatio;
            accMap[target].z += disZ * targetMassRatio;
        });
    }
    /**
     * Calculate the gravity forces toward center.
     * @param calcGraph calculation graph
     * @param graph origin graph
     * @param accMap acceleration map
     * @param options formatted layout options
     */
    calGravity(calcGraph, graph, accMap, options) {
        const { getCenter } = options;
        const calcNodes = calcGraph.getAllNodes();
        const nodes = graph.getAllNodes();
        const edges = graph.getAllEdges();
        const { width, height, center, gravity: defaultGravity, centripetalOptions, } = options;
        if (!calcNodes)
            return;
        calcNodes.forEach((calcNode) => {
            const { id, data } = calcNode;
            const { mass, x, y, z } = data;
            const node = graph.getNode(id);
            let vecX = 0;
            let vecY = 0;
            let vecZ = 0;
            let gravity = defaultGravity;
            const inDegree = calcGraph.getDegree(id, 'in');
            const outDegree = calcGraph.getDegree(id, 'out');
            const degree = calcGraph.getDegree(id, 'both');
            const forceCenter = getCenter === null || getCenter === void 0 ? void 0 : getCenter(node, degree);
            if (forceCenter) {
                const [centerX, centerY, strength] = forceCenter;
                vecX = x - centerX;
                vecY = y - centerY;
                gravity = strength;
            }
            else {
                vecX = x - center[0];
                vecY = y - center[1];
                vecZ = z - center[2];
            }
            if (gravity) {
                accMap[id].x -= (gravity * vecX) / mass;
                accMap[id].y -= (gravity * vecY) / mass;
                accMap[id].z -= (gravity * vecZ) / mass;
            }
            if (centripetalOptions) {
                const { leaf, single, others, center: centriCenter, } = centripetalOptions;
                const { x: centriX, y: centriY, z: centriZ, centerStrength, } = (centriCenter === null || centriCenter === void 0 ? void 0 : centriCenter(node, nodes, edges, width, height)) || {
                    x: 0,
                    y: 0,
                    z: 0,
                    centerStrength: 0,
                };
                if (!(0,_antv_util__WEBPACK_IMPORTED_MODULE_1__["default"])(centriX) || !(0,_antv_util__WEBPACK_IMPORTED_MODULE_1__["default"])(centriY))
                    return;
                const vx = (x - centriX) / mass;
                const vy = (y - centriY) / mass;
                const vz = (z - centriZ) / mass;
                if (centerStrength) {
                    accMap[id].x -= centerStrength * vx;
                    accMap[id].y -= centerStrength * vy;
                    accMap[id].z -= centerStrength * vz;
                }
                // 孤点
                if (degree === 0) {
                    const singleStrength = single(node);
                    if (!singleStrength)
                        return;
                    accMap[id].x -= singleStrength * vx;
                    accMap[id].y -= singleStrength * vy;
                    accMap[id].z -= singleStrength * vz;
                    return;
                }
                // 没有出度或没有入度，都认为是叶子节点
                if (inDegree === 0 || outDegree === 0) {
                    const leafStrength = leaf(node, nodes, edges);
                    if (!leafStrength)
                        return;
                    accMap[id].x -= leafStrength * vx;
                    accMap[id].y -= leafStrength * vy;
                    accMap[id].z -= leafStrength * vz;
                    return;
                }
                /** others */
                const othersStrength = others(node);
                if (!othersStrength)
                    return;
                accMap[id].x -= othersStrength * vx;
                accMap[id].y -= othersStrength * vy;
                accMap[id].z -= othersStrength * vz;
            }
        });
    }
    /**
     * Update the velocities for nodes.
     * @param calcGraph calculation graph
     * @param accMap acceleration map
     * @param velMap velocity map
     * @param options formatted layout options
     * @returns
     */
    updateVelocity(calcGraph, accMap, velMap, options) {
        const { damping, maxSpeed, interval, dimensions } = options;
        const calcNodes = calcGraph.getAllNodes();
        if (!(calcNodes === null || calcNodes === void 0 ? void 0 : calcNodes.length))
            return;
        calcNodes.forEach((calcNode) => {
            const { id } = calcNode;
            let vx = (velMap[id].x + accMap[id].x * interval) * damping || 0.01;
            let vy = (velMap[id].y + accMap[id].y * interval) * damping || 0.01;
            let vz = dimensions === 3
                ? (velMap[id].z + accMap[id].z * interval) * damping || 0.01
                : 0.0;
            const vLength = Math.sqrt(vx * vx + vy * vy + vz * vz);
            if (vLength > maxSpeed) {
                const param2 = maxSpeed / vLength;
                vx = param2 * vx;
                vy = param2 * vy;
                vz = param2 * vz;
            }
            velMap[id] = {
                x: vx,
                y: vy,
                z: vz,
            };
        });
    }
    /**
     * Update nodes' positions.
     * @param graph origin graph
     * @param calcGraph calculatition graph
     * @param velMap velocity map
     * @param options formatted layou options
     * @returns
     */
    updatePosition(graph, calcGraph, velMap, options) {
        const { distanceThresholdMode, interval, dimensions } = options;
        const calcNodes = calcGraph.getAllNodes();
        if (!(calcNodes === null || calcNodes === void 0 ? void 0 : calcNodes.length)) {
            this.judgingDistance = 0;
            return;
        }
        let sum = 0;
        if (distanceThresholdMode === 'max')
            this.judgingDistance = -Infinity;
        else if (distanceThresholdMode === 'min')
            this.judgingDistance = Infinity;
        calcNodes.forEach((calcNode) => {
            const { id } = calcNode;
            const node = graph.getNode(id);
            if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_1__["default"])(node.data.fx) && (0,_antv_util__WEBPACK_IMPORTED_MODULE_1__["default"])(node.data.fy)) {
                calcGraph.mergeNodeData(id, {
                    x: node.data.fx,
                    y: node.data.fy,
                    z: dimensions === 3 ? node.data.fz : undefined,
                });
                return;
            }
            const distX = velMap[id].x * interval;
            const distY = velMap[id].y * interval;
            const distZ = dimensions === 3 ? velMap[id].z * interval : 0.0;
            calcGraph.mergeNodeData(id, {
                x: calcNode.data.x + distX,
                y: calcNode.data.y + distY,
                z: calcNode.data.z + distZ,
            });
            const distanceMagnitude = Math.sqrt(distX * distX + distY * distY + distZ * distZ);
            switch (distanceThresholdMode) {
                case 'max':
                    if (this.judgingDistance < distanceMagnitude) {
                        this.judgingDistance = distanceMagnitude;
                    }
                    break;
                case 'min':
                    if (this.judgingDistance > distanceMagnitude) {
                        this.judgingDistance = distanceMagnitude;
                    }
                    break;
                default:
                    sum = sum + distanceMagnitude;
                    break;
            }
        });
        if (!distanceThresholdMode || distanceThresholdMode === 'mean') {
            this.judgingDistance = sum / calcNodes.length;
        }
    }
}
/**
 * Group the leaf nodes according to nodeClusterBy field.
 * @param calcGraph calculation graph
 * @param nodeClusterBy the field name in node.data to ditinguish different node clusters
 * @returns related same group leaf nodes for each leaf node
 */
const getSameTypeLeafMap = (calcGraph, nodeClusterBy) => {
    const calcNodes = calcGraph.getAllNodes();
    if (!(calcNodes === null || calcNodes === void 0 ? void 0 : calcNodes.length))
        return {};
    const sameTypeLeafMap = {};
    calcNodes.forEach((node, i) => {
        const degree = calcGraph.getDegree(node.id, 'both');
        if (degree === 1) {
            sameTypeLeafMap[node.id] = getCoreNodeAndSiblingLeaves(calcGraph, 'leaf', node, nodeClusterBy);
        }
    });
    return sameTypeLeafMap;
};
/**
 * Find the successor or predecessor of node as coreNode, the sibling leaf nodes
 * @param calcGraph calculation graph
 * @param type ('all') filter out the not-same-cluster nodes, ('leaf') or filter out the not-leaf nodes in the same time
 * @param node the target node
 * @param nodeClusterBy the field name in node.data to ditinguish different node clusters
 * @returns coreNode, sibling leaf nodes, and grouped sibling leaf nodes
 */
const getCoreNodeAndSiblingLeaves = (calcGraph, type, node, nodeClusterBy) => {
    const inDegree = calcGraph.getDegree(node.id, 'in');
    const outDegree = calcGraph.getDegree(node.id, 'out');
    // node is not a leaf, coreNode is itself, siblingLeaves is empty
    let coreNode = node;
    let siblingLeaves = [];
    if (inDegree === 0) {
        // node is a leaf node without out edges, its related(successor) node is coreNode, siblingLeaves is the neighbors of its related node
        coreNode = calcGraph.getSuccessors(node.id)[0];
        siblingLeaves = calcGraph.getNeighbors(coreNode.id);
    }
    else if (outDegree === 0) {
        // node is a leaf node without in edges, its related(predecessor) node is coreNode, siblingLeaves is the neighbors of its related node
        coreNode = calcGraph.getPredecessors(node.id)[0];
        siblingLeaves = calcGraph.getNeighbors(coreNode.id);
    }
    // siblingLeaves are leaf nodes
    siblingLeaves = siblingLeaves.filter((node) => calcGraph.getDegree(node.id, 'in') === 0 ||
        calcGraph.getDegree(node.id, 'out') === 0);
    const sameTypeLeaves = getSameTypeNodes(calcGraph, type, nodeClusterBy, node, siblingLeaves);
    return { coreNode, siblingLeaves, sameTypeLeaves };
};
/**
 * Find the same type (according to nodeClusterBy field) of node in relativeNodes.
 * @param calcGraph calculation graph
 * @param type ('all') filter out the not-same-cluster nodes, ('leaf') or filter out the not-leaf nodes in the same time
 * @param nodeClusterBy the field name in node.data to ditinguish different node clusters
 * @param node the target node
 * @param relativeNodes node's related ndoes to be filtered
 * @returns related nodes that meet the filtering conditions
 */
const getSameTypeNodes = (calcGraph, type, nodeClusterBy, node, relativeNodes) => {
    const typeName = node.data[nodeClusterBy] || '';
    let sameTypeNodes = (relativeNodes === null || relativeNodes === void 0 ? void 0 : relativeNodes.filter((item) => item.data[nodeClusterBy] === typeName)) ||
        [];
    if (type === 'leaf') {
        sameTypeNodes = sameTypeNodes.filter((item) => calcGraph.getDegree(item.id, 'in') === 0 ||
            calcGraph.getDegree(item.id, 'out') === 0);
    }
    return sameTypeNodes;
};
/**
 * Get the average position of nodes.
 * @param nodes nodes set
 * @returns average ppsition
 */
const getAvgNodePosition = (nodes) => {
    const totalNodes = { x: 0, y: 0 };
    nodes.forEach((node) => {
        const { x, y } = node.data;
        totalNodes.x += x || 0;
        totalNodes.y += y || 0;
    });
    // 获取均值向量
    const length = nodes.length || 1;
    return {
        x: totalNodes.x / length,
        y: totalNodes.y / length,
    };
};
/**
 * Format the output nodes from CalcNode[].
 * @param graph origin graph
 * @param layoutNodes calculation nodes
 * @returns output nodes
 */
const formatOutNodes = (graph, layoutNodes) => layoutNodes.map((calcNode) => {
    const { id, data } = calcNode;
    const node = graph.getNode(id);
    return Object.assign(Object.assign({}, node), { data: Object.assign(Object.assign({}, node.data), { x: data.x, y: data.y, z: data.z }) });
});
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/fruchterman.js":
/*!******************************************************!*\
  !*** ./node_modules/@antv/layout/lib/fruchterman.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FruchtermanLayout: () => (/* binding */ FruchtermanLayout)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _antv_graphlib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @antv/graphlib */ "./node_modules/@antv/graphlib/esm/graph.js");
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/is-number.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/lib/util/object.js");




const DEFAULTS_LAYOUT_OPTIONS = {
    maxIteration: 1000,
    gravity: 10,
    speed: 5,
    clustering: false,
    clusterGravity: 10,
    width: 300,
    height: 300,
    nodeClusterBy: 'cluster',
};
const SPEED_DIVISOR = 800;
/**
 * <zh/> Fruchterman 力导向布局
 *
 * <en/> Fruchterman force-directed layout
 */
class FruchtermanLayout {
    constructor(options = {}) {
        this.options = options;
        this.id = 'fruchterman';
        this.timeInterval = 0;
        this.running = false;
        this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS), options);
    }
    /**
     * Return the positions of nodes and edges(if needed).
     */
    execute(graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            return this.genericFruchtermanLayout(false, graph, options);
        });
    }
    /**
     * To directly assign the positions to the nodes.
     */
    assign(graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            yield this.genericFruchtermanLayout(true, graph, options);
        });
    }
    /**
     * Stop simulation immediately.
     */
    stop() {
        if (this.timeInterval && typeof window !== 'undefined') {
            window.clearInterval(this.timeInterval);
        }
        this.running = false;
    }
    /**
     * Manually steps the simulation by the specified number of iterations.
     * @see https://github.com/d3/d3-force#simulation_tick
     */
    tick(iterations = this.options.maxIteration || 1) {
        if (this.lastResult) {
            return this.lastResult;
        }
        for (let i = 0; i < iterations; i++) {
            this.runOneStep(this.lastGraph, this.lastClusterMap, this.lastOptions);
        }
        const result = {
            nodes: this.lastLayoutNodes,
            edges: this.lastLayoutEdges,
        };
        if (this.lastAssign) {
            result.nodes.forEach((node) => this.lastGraph.mergeNodeData(node.id, {
                x: node.data.x,
                y: node.data.y,
                z: this.options.dimensions === 3 ? node.data.z : undefined,
            }));
        }
        return result;
    }
    genericFruchtermanLayout(assign, graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            if (this.running)
                return;
            const formattedOptions = this.formatOptions(options);
            const { dimensions, width, height, center, clustering, nodeClusterBy, maxIteration, onTick, } = formattedOptions;
            const nodes = graph.getAllNodes();
            const edges = graph.getAllEdges();
            if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length)) {
                const result = { nodes: [], edges };
                this.lastResult = result;
                return result;
            }
            if (nodes.length === 1) {
                if (assign) {
                    graph.mergeNodeData(nodes[0].id, {
                        x: center[0],
                        y: center[1],
                        z: dimensions === 3 ? center[2] : undefined,
                    });
                }
                const result = {
                    nodes: [
                        Object.assign(Object.assign({}, nodes[0]), { data: Object.assign(Object.assign({}, nodes[0].data), { x: center[0], y: center[1], z: dimensions === 3 ? center[2] : undefined }) }),
                    ],
                    edges,
                };
                this.lastResult = result;
                return result;
            }
            const layoutNodes = nodes.map((node) => (0,_util__WEBPACK_IMPORTED_MODULE_1__.cloneFormatData)(node, [width, height]));
            const calcGraph = new _antv_graphlib__WEBPACK_IMPORTED_MODULE_2__.Graph({
                nodes: layoutNodes,
                edges,
            });
            // clustering info
            const clusterMap = {};
            if (clustering) {
                layoutNodes.forEach((node) => {
                    const clusterValue = node.data[nodeClusterBy];
                    if (!clusterMap[clusterValue]) {
                        clusterMap[clusterValue] = {
                            name: clusterValue,
                            cx: 0,
                            cy: 0,
                            count: 0,
                        };
                    }
                });
            }
            // Use them later in `tick`.
            this.lastLayoutNodes = layoutNodes;
            this.lastLayoutEdges = edges;
            this.lastAssign = assign;
            this.lastGraph = calcGraph;
            this.lastOptions = formattedOptions;
            this.lastClusterMap = clusterMap;
            if (typeof window === 'undefined')
                return;
            let iter = 0;
            return new Promise((resolve) => {
                // interval for render the result after each iteration
                this.timeInterval = window.setInterval(() => {
                    if (!this.running) {
                        resolve({ nodes: layoutNodes, edges });
                        return;
                    }
                    this.runOneStep(calcGraph, clusterMap, formattedOptions);
                    if (assign) {
                        layoutNodes.forEach(({ id, data }) => graph.mergeNodeData(id, {
                            x: data.x,
                            y: data.y,
                            z: dimensions === 3 ? data.z : undefined,
                        }));
                    }
                    onTick === null || onTick === void 0 ? void 0 : onTick({
                        nodes: layoutNodes,
                        edges,
                    });
                    iter++;
                    if (iter >= maxIteration) {
                        window.clearInterval(this.timeInterval);
                        resolve({ nodes: layoutNodes, edges });
                    }
                }, 0);
                this.running = true;
            });
        });
    }
    formatOptions(options = {}) {
        const mergedOptions = Object.assign(Object.assign({}, this.options), options);
        const { clustering, nodeClusterBy } = mergedOptions;
        const { center: propsCenter, width: propsWidth, height: propsHeight, } = mergedOptions;
        mergedOptions.width =
            !propsWidth && typeof window !== 'undefined'
                ? window.innerWidth
                : propsWidth;
        mergedOptions.height =
            !propsHeight && typeof window !== 'undefined'
                ? window.innerHeight
                : propsHeight;
        mergedOptions.center = !propsCenter
            ? [mergedOptions.width / 2, mergedOptions.height / 2]
            : propsCenter;
        mergedOptions.clustering = clustering && !!nodeClusterBy;
        return mergedOptions;
    }
    runOneStep(calcGraph, clusterMap, options) {
        const { dimensions, height, width, gravity, center, speed, clustering, nodeClusterBy, clusterGravity: propsClusterGravity, } = options;
        const area = height * width;
        const maxDisplace = Math.sqrt(area) / 10;
        const nodes = calcGraph.getAllNodes();
        const k2 = area / (nodes.length + 1);
        const k = Math.sqrt(k2);
        const displacements = {};
        this.applyCalculate(calcGraph, displacements, k, k2);
        // gravity for clusters
        if (clustering) {
            // reset the clustering centers
            for (const key in clusterMap) {
                clusterMap[key].cx = 0;
                clusterMap[key].cy = 0;
                clusterMap[key].count = 0;
            }
            // re-compute clustering centers
            nodes.forEach((node) => {
                const { data } = node; // node is one of layoutNodes, which is formatted and data field exists
                const c = clusterMap[data[nodeClusterBy]];
                if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_3__["default"])(data.x)) {
                    c.cx += data.x;
                }
                if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_3__["default"])(data.y)) {
                    c.cy += data.y;
                }
                c.count++;
            });
            for (const key in clusterMap) {
                clusterMap[key].cx /= clusterMap[key].count;
                clusterMap[key].cy /= clusterMap[key].count;
            }
            // compute the cluster gravity forces
            const clusterGravity = (propsClusterGravity || gravity);
            nodes.forEach((node, j) => {
                const { id, data } = node;
                if (!(0,_antv_util__WEBPACK_IMPORTED_MODULE_3__["default"])(data.x) || !(0,_antv_util__WEBPACK_IMPORTED_MODULE_3__["default"])(data.y))
                    return;
                const c = clusterMap[data[nodeClusterBy]];
                const distLength = Math.sqrt((data.x - c.cx) * (data.x - c.cx) + (data.y - c.cy) * (data.y - c.cy));
                const gravityForce = k * clusterGravity;
                displacements[id].x -= (gravityForce * (data.x - c.cx)) / distLength;
                displacements[id].y -= (gravityForce * (data.y - c.cy)) / distLength;
            });
        }
        // gravity
        nodes.forEach((node, j) => {
            const { id, data } = node;
            if (!(0,_antv_util__WEBPACK_IMPORTED_MODULE_3__["default"])(data.x) || !(0,_antv_util__WEBPACK_IMPORTED_MODULE_3__["default"])(data.y))
                return;
            const gravityForce = 0.01 * k * gravity;
            displacements[id].x -= gravityForce * (data.x - center[0]);
            displacements[id].y -= gravityForce * (data.y - center[1]);
            if (dimensions === 3) {
                displacements[id].z -= gravityForce * (data.z - center[2]);
            }
        });
        // move
        nodes.forEach((node, j) => {
            const { id, data } = node;
            if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_3__["default"])(data.fx) && (0,_antv_util__WEBPACK_IMPORTED_MODULE_3__["default"])(data.fy)) {
                data.x = data.fx;
                data.y = data.fy;
                if (dimensions === 3) {
                    data.z = data.fz;
                }
                return;
            }
            if (!(0,_antv_util__WEBPACK_IMPORTED_MODULE_3__["default"])(data.x) || !(0,_antv_util__WEBPACK_IMPORTED_MODULE_3__["default"])(data.y))
                return;
            const distLength = Math.sqrt(displacements[id].x * displacements[id].x +
                displacements[id].y * displacements[id].y +
                (dimensions === 3 ? displacements[id].z * displacements[id].z : 0));
            if (distLength > 0) {
                // && !n.isFixed()
                const limitedDist = Math.min(maxDisplace * (speed / SPEED_DIVISOR), distLength);
                calcGraph.mergeNodeData(id, {
                    x: data.x + (displacements[id].x / distLength) * limitedDist,
                    y: data.y + (displacements[id].y / distLength) * limitedDist,
                    z: dimensions === 3
                        ? data.z + (displacements[id].z / distLength) * limitedDist
                        : undefined,
                });
            }
        });
    }
    applyCalculate(calcGraph, displacements, k, k2) {
        this.calRepulsive(calcGraph, displacements, k2);
        this.calAttractive(calcGraph, displacements, k);
    }
    calRepulsive(calcGraph, displacements, k2) {
        const nodes = calcGraph.getAllNodes();
        nodes.forEach(({ data: v, id: vid }, i) => {
            displacements[vid] = { x: 0, y: 0, z: 0 };
            nodes.forEach(({ data: u, id: uid }, j) => {
                if (i <= j ||
                    !(0,_antv_util__WEBPACK_IMPORTED_MODULE_3__["default"])(v.x) ||
                    !(0,_antv_util__WEBPACK_IMPORTED_MODULE_3__["default"])(u.x) ||
                    !(0,_antv_util__WEBPACK_IMPORTED_MODULE_3__["default"])(v.y) ||
                    !(0,_antv_util__WEBPACK_IMPORTED_MODULE_3__["default"])(u.y)) {
                    return;
                }
                let vecX = v.x - u.x;
                let vecY = v.y - u.y;
                let vecZ = this.options.dimensions === 3 ? v.z - u.z : 0;
                let lengthSqr = vecX * vecX + vecY * vecY + vecZ * vecZ;
                if (lengthSqr === 0) {
                    lengthSqr = 1;
                    vecX = 0.01;
                    vecY = 0.01;
                    vecZ = 0.01;
                }
                const common = k2 / lengthSqr;
                const dispX = vecX * common;
                const dispY = vecY * common;
                const dispZ = vecZ * common;
                displacements[vid].x += dispX;
                displacements[vid].y += dispY;
                displacements[uid].x -= dispX;
                displacements[uid].y -= dispY;
                if (this.options.dimensions === 3) {
                    displacements[vid].z += dispZ;
                    displacements[uid].z -= dispZ;
                }
            });
        });
    }
    calAttractive(calcGraph, displacements, k) {
        const edges = calcGraph.getAllEdges();
        edges.forEach((e) => {
            const { source, target } = e;
            if (!source || !target || source === target) {
                return;
            }
            const { data: u } = calcGraph.getNode(source);
            const { data: v } = calcGraph.getNode(target);
            if (!(0,_antv_util__WEBPACK_IMPORTED_MODULE_3__["default"])(v.x) ||
                !(0,_antv_util__WEBPACK_IMPORTED_MODULE_3__["default"])(u.x) ||
                !(0,_antv_util__WEBPACK_IMPORTED_MODULE_3__["default"])(v.y) ||
                !(0,_antv_util__WEBPACK_IMPORTED_MODULE_3__["default"])(u.y)) {
                return;
            }
            const vecX = v.x - u.x;
            const vecY = v.y - u.y;
            const vecZ = this.options.dimensions === 3 ? v.z - u.z : 0;
            const common = Math.sqrt(vecX * vecX + vecY * vecY + vecZ * vecZ) / k;
            const dispX = vecX * common;
            const dispY = vecY * common;
            const dispZ = vecZ * common;
            displacements[source].x += dispX;
            displacements[source].y += dispY;
            displacements[target].x -= dispX;
            displacements[target].y -= dispY;
            if (this.options.dimensions === 3) {
                displacements[source].z += dispZ;
                displacements[target].z -= dispZ;
            }
        });
    }
}
//# sourceMappingURL=fruchterman.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/grid.js":
/*!***********************************************!*\
  !*** ./node_modules/@antv/layout/lib/grid.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GridLayout: () => (/* binding */ GridLayout)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/is-string.js");
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/is-number.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/lib/util/object.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/lib/util/function.js");
/* harmony import */ var _util_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/common */ "./node_modules/@antv/layout/lib/util/common.js");
/* harmony import */ var _util_size__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./util/size */ "./node_modules/@antv/layout/lib/util/size.js");





const DEFAULTS_LAYOUT_OPTIONS = {
    begin: [0, 0],
    preventOverlap: true,
    preventOverlapPadding: 10,
    condense: false,
    rows: undefined,
    cols: undefined,
    position: undefined,
    sortBy: 'degree',
    nodeSize: 30,
    width: 300,
    height: 300,
};
/**
 * <zh/> 网格布局
 *
 * <en/> Grid layout
 */
class GridLayout {
    constructor(options = {}) {
        this.options = options;
        this.id = 'grid';
        this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS), options);
    }
    /**
     * Return the positions of nodes and edges(if needed).
     */
    execute(graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            return this.genericGridLayout(false, graph, options);
        });
    }
    /**
     * To directly assign the positions to the nodes.
     */
    assign(graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            yield this.genericGridLayout(true, graph, options);
        });
    }
    genericGridLayout(assign, graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            const mergedOptions = Object.assign(Object.assign({}, this.options), options);
            const { begin = [0, 0], condense, preventOverlapPadding, preventOverlap, rows: propsRows, cols: propsCols, nodeSpacing: paramNodeSpacing, nodeSize: paramNodeSize, width: propsWidth, height: propsHeight, position, } = mergedOptions;
            let { sortBy } = mergedOptions;
            const nodes = graph.getAllNodes();
            const edges = graph.getAllEdges();
            const n = nodes === null || nodes === void 0 ? void 0 : nodes.length;
            // Need no layout if there is no node.
            if (!n || n === 1) {
                return (0,_util_common__WEBPACK_IMPORTED_MODULE_1__.handleSingleNodeGraph)(graph, assign, begin);
            }
            const layoutNodes = nodes.map((node) => (0,_util__WEBPACK_IMPORTED_MODULE_2__.cloneFormatData)(node));
            if (
            // `id` should be reserved keyword
            sortBy !== 'id' &&
                (!(0,_antv_util__WEBPACK_IMPORTED_MODULE_3__["default"])(sortBy) || layoutNodes[0].data[sortBy] === undefined)) {
                sortBy = 'degree';
            }
            if (sortBy === 'degree') {
                layoutNodes.sort((n1, n2) => graph.getDegree(n2.id, 'both') - graph.getDegree(n1.id, 'both'));
            }
            else if (sortBy === 'id') {
                // sort nodes by ID
                layoutNodes.sort((n1, n2) => {
                    if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_4__["default"])(n2.id) && (0,_antv_util__WEBPACK_IMPORTED_MODULE_4__["default"])(n1.id)) {
                        return n2.id - n1.id;
                    }
                    return `${n1.id}`.localeCompare(`${n2.id}`);
                });
            }
            else {
                // sort nodes by value
                layoutNodes.sort((n1, n2) => n2.data[sortBy] - n1.data[sortBy]);
            }
            const width = !propsWidth && typeof window !== 'undefined'
                ? window.innerWidth
                : propsWidth;
            const height = !propsHeight && typeof window !== 'undefined'
                ? window.innerHeight
                : propsHeight;
            const cells = n;
            const rcs = { rows: propsRows, cols: propsCols };
            // if rows or columns were set in self, use those values
            if (propsRows != null && propsCols != null) {
                rcs.rows = propsRows;
                rcs.cols = propsCols;
            }
            else if (propsRows != null && propsCols == null) {
                rcs.rows = propsRows;
                rcs.cols = Math.ceil(cells / rcs.rows);
            }
            else if (propsRows == null && propsCols != null) {
                rcs.cols = propsCols;
                rcs.rows = Math.ceil(cells / rcs.cols);
            }
            else {
                // otherwise use the automatic values and adjust accordingly	      // otherwise use the automatic values and adjust accordingly
                // width/height * splits^2 = cells where splits is number of times to split width
                const splits = Math.sqrt((cells * height) / width);
                rcs.rows = Math.round(splits);
                rcs.cols = Math.round((width / height) * splits);
            }
            rcs.rows = Math.max(rcs.rows, 1);
            rcs.cols = Math.max(rcs.cols, 1);
            if (rcs.cols * rcs.rows > cells) {
                // otherwise use the automatic values and adjust accordingly
                // if rounding was up, see if we can reduce rows or columns
                const sm = small(rcs);
                const lg = large(rcs);
                // reducing the small side takes away the most cells, so try it first
                if ((sm - 1) * lg >= cells) {
                    small(rcs, sm - 1);
                }
                else if ((lg - 1) * sm >= cells) {
                    large(rcs, lg - 1);
                }
            }
            else {
                // if rounding was too low, add rows or columns
                while (rcs.cols * rcs.rows < cells) {
                    const sm = small(rcs);
                    const lg = large(rcs);
                    // try to add to larger side first (adds less in multiplication)
                    if ((lg + 1) * sm >= cells) {
                        large(rcs, lg + 1);
                    }
                    else {
                        small(rcs, sm + 1);
                    }
                }
            }
            let cellWidth = condense ? 0 : width / rcs.cols;
            let cellHeight = condense ? 0 : height / rcs.rows;
            if (preventOverlap || paramNodeSpacing) {
                const nodeSpacing = (0,_util__WEBPACK_IMPORTED_MODULE_5__.formatNumberFn)(10, paramNodeSpacing);
                const nodeSize = (0,_util__WEBPACK_IMPORTED_MODULE_5__.formatSizeFn)(30, paramNodeSize, false);
                layoutNodes.forEach((node) => {
                    if (!node.data.x || !node.data.y) {
                        // for bb
                        node.data.x = 0;
                        node.data.y = 0;
                    }
                    const oNode = graph.getNode(node.id);
                    const [nodeW, nodeH] = (0,_util_size__WEBPACK_IMPORTED_MODULE_6__.parseSize)(nodeSize(oNode) || 30);
                    const p = nodeSpacing !== undefined ? nodeSpacing(node) : preventOverlapPadding;
                    const w = nodeW + p;
                    const h = nodeH + p;
                    cellWidth = Math.max(cellWidth, w);
                    cellHeight = Math.max(cellHeight, h);
                });
            }
            const cellUsed = {}; // e.g. 'c-0-2' => true
            // to keep track of current cell position
            const rc = { row: 0, col: 0 };
            // get a cache of all the manual positions
            const id2manPos = {};
            for (let i = 0; i < layoutNodes.length; i++) {
                const node = layoutNodes[i];
                let rcPos;
                if (position) {
                    // TODO: not sure the api name
                    rcPos = position(graph.getNode(node.id));
                }
                if (rcPos && (rcPos.row !== undefined || rcPos.col !== undefined)) {
                    // must have at least row or col def'd
                    const pos = {
                        row: rcPos.row,
                        col: rcPos.col,
                    };
                    if (pos.col === undefined) {
                        // find unused col
                        pos.col = 0;
                        while (used(cellUsed, pos)) {
                            pos.col++;
                        }
                    }
                    else if (pos.row === undefined) {
                        // find unused row
                        pos.row = 0;
                        while (used(cellUsed, pos)) {
                            pos.row++;
                        }
                    }
                    id2manPos[node.id] = pos;
                    use(cellUsed, pos);
                }
                getPos(node, begin, cellWidth, cellHeight, id2manPos, rcs, rc, cellUsed);
            }
            const result = {
                nodes: layoutNodes,
                edges,
            };
            if (assign) {
                layoutNodes.forEach((node) => {
                    graph.mergeNodeData(node.id, {
                        x: node.data.x,
                        y: node.data.y,
                    });
                });
            }
            return result;
        });
    }
}
const small = (rcs, val) => {
    let res;
    const rows = rcs.rows || 5;
    const cols = rcs.cols || 5;
    if (val == null) {
        res = Math.min(rows, cols);
    }
    else {
        const min = Math.min(rows, cols);
        if (min === rcs.rows) {
            rcs.rows = val;
        }
        else {
            rcs.cols = val;
        }
    }
    return res;
};
const large = (rcs, val) => {
    let result;
    const usedRows = rcs.rows || 5;
    const usedCols = rcs.cols || 5;
    if (val == null) {
        result = Math.max(usedRows, usedCols);
    }
    else {
        const max = Math.max(usedRows, usedCols);
        if (max === rcs.rows) {
            rcs.rows = val;
        }
        else {
            rcs.cols = val;
        }
    }
    return result;
};
const used = (cellUsed, rc) => cellUsed[`c-${rc.row}-${rc.col}`] || false;
const use = (cellUsed, rc) => (cellUsed[`c-${rc.row}-${rc.col}`] = true);
const moveToNextCell = (rcs, rc) => {
    const cols = rcs.cols || 5;
    rc.col++;
    if (rc.col >= cols) {
        rc.col = 0;
        rc.row++;
    }
};
const getPos = (node, begin, cellWidth, cellHeight, id2manPos, rcs, rc, cellUsed) => {
    let x;
    let y;
    // see if we have a manual position set
    const rcPos = id2manPos[node.id];
    if (rcPos) {
        x = rcPos.col * cellWidth + cellWidth / 2 + begin[0];
        y = rcPos.row * cellHeight + cellHeight / 2 + begin[1];
    }
    else {
        // otherwise set automatically
        while (used(cellUsed, rc)) {
            moveToNextCell(rcs, rc);
        }
        x = rc.col * cellWidth + cellWidth / 2 + begin[0];
        y = rc.row * cellHeight + cellHeight / 2 + begin[1];
        use(cellUsed, rc);
        moveToNextCell(rcs, rc);
    }
    node.data.x = x;
    node.data.y = y;
};
//# sourceMappingURL=grid.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/mds.js":
/*!**********************************************!*\
  !*** ./node_modules/@antv/layout/lib/mds.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MDSLayout: () => (/* binding */ MDSLayout)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var ml_matrix__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ml-matrix */ "./node_modules/ml-matrix/matrix.mjs");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/lib/util/math.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util */ "./node_modules/@antv/layout/lib/util/object.js");
/* harmony import */ var _util_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/common */ "./node_modules/@antv/layout/lib/util/common.js");




const DEFAULTS_LAYOUT_OPTIONS = {
    center: [0, 0],
    linkDistance: 50,
};
/**
 * <zh/> 多维缩放算法布局
 *
 * <en/> Multidimensional scaling layout
 */
class MDSLayout {
    constructor(options = {}) {
        this.options = options;
        this.id = 'mds';
        this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS), options);
    }
    /**
     * Return the positions of nodes and edges(if needed).
     */
    execute(graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            return this.genericMDSLayout(false, graph, options);
        });
    }
    /**
     * To directly assign the positions to the nodes.
     */
    assign(graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            yield this.genericMDSLayout(true, graph, options);
        });
    }
    genericMDSLayout(assign, graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            const mergedOptions = Object.assign(Object.assign({}, this.options), options);
            const { center = [0, 0], linkDistance = 50 } = mergedOptions;
            const nodes = graph.getAllNodes();
            const edges = graph.getAllEdges();
            if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length) || nodes.length === 1) {
                return (0,_util_common__WEBPACK_IMPORTED_MODULE_1__.handleSingleNodeGraph)(graph, assign, center);
            }
            // the graph-theoretic distance (shortest path distance) matrix
            const adjMatrix = (0,_util__WEBPACK_IMPORTED_MODULE_2__.getAdjMatrix)({ nodes, edges }, false);
            const distances = (0,_util__WEBPACK_IMPORTED_MODULE_2__.floydWarshall)(adjMatrix);
            handleInfinity(distances);
            // scale the ideal edge length acoording to linkDistance
            const scaledD = (0,_util__WEBPACK_IMPORTED_MODULE_2__.scaleMatrix)(distances, linkDistance);
            // get positions by MDS
            const positions = runMDS(scaledD);
            const layoutNodes = [];
            positions.forEach((p, i) => {
                const cnode = (0,_util__WEBPACK_IMPORTED_MODULE_3__.cloneFormatData)(nodes[i]);
                cnode.data.x = p[0] + center[0];
                cnode.data.y = p[1] + center[1];
                layoutNodes.push(cnode);
            });
            if (assign) {
                layoutNodes.forEach((node) => graph.mergeNodeData(node.id, {
                    x: node.data.x,
                    y: node.data.y,
                }));
            }
            const result = {
                nodes: layoutNodes,
                edges,
            };
            return result;
        });
    }
}
const handleInfinity = (distances) => {
    let maxDistance = -999999;
    distances.forEach((row) => {
        row.forEach((value) => {
            if (value === Infinity) {
                return;
            }
            if (maxDistance < value) {
                maxDistance = value;
            }
        });
    });
    distances.forEach((row, i) => {
        row.forEach((value, j) => {
            if (value === Infinity) {
                distances[i][j] = maxDistance;
            }
        });
    });
};
/**
 * mds 算法
 * @return {array} positions 计算后的节点位置数组
 */
const runMDS = (distances) => {
    const dimension = 2;
    // square distances
    const M = ml_matrix__WEBPACK_IMPORTED_MODULE_4__.Matrix.mul(ml_matrix__WEBPACK_IMPORTED_MODULE_4__.Matrix.pow(distances, 2), -0.5);
    // double centre the rows/columns
    const rowMeans = M.mean('row');
    const colMeans = M.mean('column');
    const totalMean = M.mean();
    M.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans);
    // take the SVD of the double centred matrix, and return the
    // points from it
    const ret = new ml_matrix__WEBPACK_IMPORTED_MODULE_4__.SingularValueDecomposition(M);
    const eigenValues = ml_matrix__WEBPACK_IMPORTED_MODULE_4__.Matrix.sqrt(ret.diagonalMatrix).diagonal();
    return ret.leftSingularVectors.toJSON().map((row) => {
        return ml_matrix__WEBPACK_IMPORTED_MODULE_4__.Matrix.mul([row], [eigenValues])
            .toJSON()[0]
            .splice(0, dimension);
    });
};
//# sourceMappingURL=mds.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/radial/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/layout/lib/radial/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RadialLayout: () => (/* binding */ RadialLayout)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/is-string.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/lib/util/math.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/lib/util/function.js");
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../util */ "./node_modules/@antv/layout/lib/util/object.js");
/* harmony import */ var _util_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/common */ "./node_modules/@antv/layout/lib/util/common.js");
/* harmony import */ var _mds__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mds */ "./node_modules/@antv/layout/lib/radial/mds.js");
/* harmony import */ var _radial_nonoverlap_force__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./radial-nonoverlap-force */ "./node_modules/@antv/layout/lib/radial/radial-nonoverlap-force.js");






const DEFAULTS_LAYOUT_OPTIONS = {
    maxIteration: 1000,
    focusNode: null,
    unitRadius: null,
    linkDistance: 50,
    preventOverlap: false,
    strictRadial: true,
    maxPreventOverlapIteration: 200,
    sortStrength: 10,
};
/**
 * <zh/> 径向布局
 *
 * <en/> Radial layout
 */
class RadialLayout {
    constructor(options = {}) {
        this.options = options;
        this.id = 'radial';
        this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS), options);
    }
    /**
     * Return the positions of nodes and edges(if needed).
     */
    execute(graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            return this.genericRadialLayout(false, graph, options);
        });
    }
    /**
     * To directly assign the positions to the nodes.
     */
    assign(graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            yield this.genericRadialLayout(true, graph, options);
        });
    }
    genericRadialLayout(assign, graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            const mergedOptions = Object.assign(Object.assign({}, this.options), options);
            const { width: propsWidth, height: propsHeight, center: propsCenter, focusNode: propsFocusNode, unitRadius: propsUnitRadius, nodeSize, nodeSpacing, strictRadial, preventOverlap, maxPreventOverlapIteration, sortBy, linkDistance = 50, sortStrength = 10, maxIteration = 1000, } = mergedOptions;
            const nodes = graph.getAllNodes();
            const edges = graph.getAllEdges();
            const width = !propsWidth && typeof window !== 'undefined'
                ? window.innerWidth
                : propsWidth;
            const height = !propsHeight && typeof window !== 'undefined'
                ? window.innerHeight
                : propsHeight;
            const center = (!propsCenter ? [width / 2, height / 2] : propsCenter);
            if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length) || nodes.length === 1) {
                return (0,_util_common__WEBPACK_IMPORTED_MODULE_1__.handleSingleNodeGraph)(graph, assign, center);
            }
            let focusNode = nodes[0];
            if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_2__["default"])(propsFocusNode)) {
                for (let i = 0; i < nodes.length; i++) {
                    if (nodes[i].id === propsFocusNode) {
                        focusNode = nodes[i];
                        break;
                    }
                }
            }
            else {
                focusNode = propsFocusNode || nodes[0];
            }
            // the index of the focusNode in data
            const focusIndex = getIndexById(nodes, focusNode.id);
            // the graph-theoretic distance (shortest path distance) matrix
            const adjMatrix = (0,_util__WEBPACK_IMPORTED_MODULE_3__.getAdjMatrix)({ nodes, edges }, false);
            const distances = (0,_util__WEBPACK_IMPORTED_MODULE_3__.floydWarshall)(adjMatrix);
            const maxDistance = maxToFocus(distances, focusIndex);
            // replace first node in unconnected component to the circle at (maxDistance + 1)
            handleInfinity(distances, focusIndex, maxDistance + 1);
            // the shortest path distance from each node to focusNode
            const focusNodeD = distances[focusIndex];
            let semiWidth = width - center[0] > center[0] ? center[0] : width - center[0];
            let semiHeight = height - center[1] > center[1] ? center[1] : height - center[1];
            if (semiWidth === 0) {
                semiWidth = width / 2;
            }
            if (semiHeight === 0) {
                semiHeight = height / 2;
            }
            // the maxRadius of the graph
            const maxRadius = Math.min(semiWidth, semiHeight);
            const maxD = Math.max(...focusNodeD);
            // the radius for each nodes away from focusNode
            const radii = [];
            const unitRadius = !propsUnitRadius ? maxRadius / maxD : propsUnitRadius;
            focusNodeD.forEach((value, i) => {
                radii[i] = value * unitRadius;
            });
            const idealDistances = eIdealDisMatrix(nodes, distances, linkDistance, radii, unitRadius, sortBy, sortStrength);
            // the weight matrix, Wij = 1 / dij^(-2)
            const weights = getWeightMatrix(idealDistances);
            // the initial positions from mds, move the graph to origin, centered at focusNode
            const mdsResult = (0,_mds__WEBPACK_IMPORTED_MODULE_4__.mds)(linkDistance, idealDistances, linkDistance);
            let positions = mdsResult.map(([x, y]) => ({
                x: (isNaN(x) ? Math.random() * linkDistance : x) -
                    mdsResult[focusIndex][0],
                y: (isNaN(y) ? Math.random() * linkDistance : y) -
                    mdsResult[focusIndex][1],
            }));
            this.run(maxIteration, positions, weights, idealDistances, radii, focusIndex);
            let nodeSizeFunc;
            // stagger the overlapped nodes
            if (preventOverlap) {
                nodeSizeFunc = (0,_util__WEBPACK_IMPORTED_MODULE_5__.formatNodeSizeToNumber)(nodeSize, nodeSpacing);
                const nonoverlapForceParams = {
                    nodes,
                    nodeSizeFunc,
                    positions,
                    radii,
                    height,
                    width,
                    strictRadial: Boolean(strictRadial),
                    focusIdx: focusIndex,
                    iterations: maxPreventOverlapIteration || 200,
                    k: positions.length / 4.5,
                };
                positions = (0,_radial_nonoverlap_force__WEBPACK_IMPORTED_MODULE_6__.radialNonoverlapForce)(graph, nonoverlapForceParams);
            }
            // move the graph to center
            const layoutNodes = [];
            positions.forEach((p, i) => {
                const cnode = (0,_util__WEBPACK_IMPORTED_MODULE_7__.cloneFormatData)(nodes[i]);
                cnode.data.x = p.x + center[0];
                cnode.data.y = p.y + center[1];
                layoutNodes.push(cnode);
            });
            if (assign) {
                layoutNodes.forEach((node) => graph.mergeNodeData(node.id, {
                    x: node.data.x,
                    y: node.data.y,
                }));
            }
            const result = {
                nodes: layoutNodes,
                edges,
            };
            return result;
        });
    }
    run(maxIteration, positions, weights, idealDistances, radii, focusIndex) {
        for (let i = 0; i <= maxIteration; i++) {
            const param = i / maxIteration;
            this.oneIteration(param, positions, radii, idealDistances, weights, focusIndex);
        }
    }
    oneIteration(param, positions, radii, distances, weights, focusIndex) {
        const vparam = 1 - param;
        positions.forEach((v, i) => {
            // v
            const originDis = (0,_util__WEBPACK_IMPORTED_MODULE_3__.getEuclideanDistance)(v, { x: 0, y: 0 });
            const reciODis = originDis === 0 ? 0 : 1 / originDis;
            if (i === focusIndex) {
                return;
            }
            let xMolecule = 0;
            let yMolecule = 0;
            let denominator = 0;
            positions.forEach((u, j) => {
                // u
                if (i === j) {
                    return;
                }
                // the euclidean distance between v and u
                const edis = (0,_util__WEBPACK_IMPORTED_MODULE_3__.getEuclideanDistance)(v, u);
                const reciEdis = edis === 0 ? 0 : 1 / edis;
                const idealDis = distances[j][i];
                // same for x and y
                denominator += weights[i][j];
                // x
                xMolecule += weights[i][j] * (u.x + idealDis * (v.x - u.x) * reciEdis);
                // y
                yMolecule += weights[i][j] * (u.y + idealDis * (v.y - u.y) * reciEdis);
            });
            const reciR = radii[i] === 0 ? 0 : 1 / radii[i];
            denominator *= vparam;
            denominator += param * reciR * reciR;
            // x
            xMolecule *= vparam;
            xMolecule += param * reciR * v.x * reciODis;
            v.x = xMolecule / denominator;
            // y
            yMolecule *= vparam;
            yMolecule += param * reciR * v.y * reciODis;
            v.y = yMolecule / denominator;
        });
    }
}
const eIdealDisMatrix = (nodes, distances, linkDistance, radii, unitRadius, sortBy, sortStrength) => {
    if (!nodes)
        return [];
    const result = [];
    if (distances) {
        // cache the value of field sortBy for nodes to avoid dupliate calculation
        const sortValueCache = {};
        distances.forEach((row, i) => {
            const newRow = [];
            row.forEach((v, j) => {
                var _a, _b;
                if (i === j) {
                    newRow.push(0);
                }
                else if (radii[i] === radii[j]) {
                    // i and j are on the same circle
                    if (sortBy === 'data') {
                        // sort the nodes on the same circle according to the ordering of the data
                        newRow.push((v * (Math.abs(i - j) * sortStrength)) / (radii[i] / unitRadius));
                    }
                    else if (sortBy) {
                        // sort the nodes on the same circle according to the attributes
                        let iValue;
                        let jValue;
                        if (sortValueCache[nodes[i].id]) {
                            iValue = sortValueCache[nodes[i].id];
                        }
                        else {
                            const value = (sortBy === 'id'
                                ? nodes[i].id
                                : (_a = nodes[i].data) === null || _a === void 0 ? void 0 : _a[sortBy]) || 0;
                            if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_2__["default"])(value)) {
                                iValue = value.charCodeAt(0);
                            }
                            else {
                                iValue = value;
                            }
                            sortValueCache[nodes[i].id] = iValue;
                        }
                        if (sortValueCache[nodes[j].id]) {
                            jValue = sortValueCache[nodes[j].id];
                        }
                        else {
                            const value = (sortBy === 'id'
                                ? nodes[j].id
                                : (_b = nodes[j].data) === null || _b === void 0 ? void 0 : _b[sortBy]) || 0;
                            if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_2__["default"])(value)) {
                                jValue = value.charCodeAt(0);
                            }
                            else {
                                jValue = value;
                            }
                            sortValueCache[nodes[j].id] = jValue;
                        }
                        newRow.push((v * (Math.abs(iValue - jValue) * sortStrength)) /
                            (radii[i] / unitRadius));
                    }
                    else {
                        newRow.push((v * linkDistance) / (radii[i] / unitRadius));
                    }
                }
                else {
                    // i and j are on different circles
                    const link = (linkDistance + unitRadius) / 2;
                    newRow.push(v * link);
                }
            });
            result.push(newRow);
        });
    }
    return result;
};
const getWeightMatrix = (idealDistances) => {
    const rows = idealDistances.length;
    const cols = idealDistances[0].length;
    const result = [];
    for (let i = 0; i < rows; i++) {
        const row = [];
        for (let j = 0; j < cols; j++) {
            if (idealDistances[i][j] !== 0) {
                row.push(1 / (idealDistances[i][j] * idealDistances[i][j]));
            }
            else {
                row.push(0);
            }
        }
        result.push(row);
    }
    return result;
};
const getIndexById = (array, id) => {
    let index = -1;
    array.forEach((a, i) => {
        if (a.id === id) {
            index = i;
        }
    });
    return Math.max(index, 0);
};
const handleInfinity = (matrix, focusIndex, step) => {
    const length = matrix.length;
    // 遍历 matrix 中遍历 focus 对应行
    for (let i = 0; i < length; i++) {
        // matrix 关注点对应行的 Inf 项
        if (matrix[focusIndex][i] === Infinity) {
            matrix[focusIndex][i] = step;
            matrix[i][focusIndex] = step;
            // 遍历 matrix 中的 i 行，i 行中非 Inf 项若在 focus 行为 Inf，则替换 focus 行的那个 Inf
            for (let j = 0; j < length; j++) {
                if (matrix[i][j] !== Infinity && matrix[focusIndex][j] === Infinity) {
                    matrix[focusIndex][j] = step + matrix[i][j];
                    matrix[j][focusIndex] = step + matrix[i][j];
                }
            }
        }
    }
    // 处理其他行的 Inf。根据该行对应点与 focus 距离以及 Inf 项点 与 focus 距离，决定替换值
    for (let i = 0; i < length; i++) {
        if (i === focusIndex) {
            continue;
        }
        for (let j = 0; j < length; j++) {
            if (matrix[i][j] === Infinity) {
                let minus = Math.abs(matrix[focusIndex][i] - matrix[focusIndex][j]);
                minus = minus === 0 ? 1 : minus;
                matrix[i][j] = minus;
            }
        }
    }
};
const maxToFocus = (matrix, focusIndex) => {
    let max = 0;
    for (let i = 0; i < matrix[focusIndex].length; i++) {
        if (matrix[focusIndex][i] === Infinity) {
            continue;
        }
        max = matrix[focusIndex][i] > max ? matrix[focusIndex][i] : max;
    }
    return max;
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/radial/mds.js":
/*!*****************************************************!*\
  !*** ./node_modules/@antv/layout/lib/radial/mds.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   mds: () => (/* binding */ mds)
/* harmony export */ });
/* harmony import */ var ml_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ml-matrix */ "./node_modules/ml-matrix/matrix.mjs");

const mds = (dimension, distances, linkDistance) => {
    try {
        // square distances
        const M = ml_matrix__WEBPACK_IMPORTED_MODULE_0__.Matrix.mul(ml_matrix__WEBPACK_IMPORTED_MODULE_0__.Matrix.pow(distances, 2), -0.5);
        // double centre the rows/columns
        const rowMeans = M.mean('row');
        const colMeans = M.mean('column');
        const totalMean = M.mean();
        M.add(totalMean).subRowVector(rowMeans).subColumnVector(colMeans);
        // take the SVD of the double centred matrix, and return the
        // points from it
        const ret = new ml_matrix__WEBPACK_IMPORTED_MODULE_0__.SingularValueDecomposition(M);
        const eigenValues = ml_matrix__WEBPACK_IMPORTED_MODULE_0__.Matrix.sqrt(ret.diagonalMatrix).diagonal();
        return ret.leftSingularVectors.toJSON().map((row) => {
            return ml_matrix__WEBPACK_IMPORTED_MODULE_0__.Matrix.mul([row], [eigenValues])
                .toJSON()[0]
                .splice(0, dimension);
        });
    }
    catch (_a) {
        const res = [];
        for (let i = 0; i < distances.length; i++) {
            const x = Math.random() * linkDistance;
            const y = Math.random() * linkDistance;
            res.push([x, y]);
        }
        return res;
    }
};
//# sourceMappingURL=mds.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/radial/radial-nonoverlap-force.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@antv/layout/lib/radial/radial-nonoverlap-force.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   radialNonoverlapForce: () => (/* binding */ radialNonoverlapForce)
/* harmony export */ });
const SPEED_DIVISOR = 800;
const DEFAULTS_LAYOUT_OPTIONS = {
    iterations: 10,
    height: 10,
    width: 10,
    speed: 100,
    gravity: 10,
    k: 5,
};
const radialNonoverlapForce = (graph, options) => {
    const mergedOptions = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS), options);
    const { positions, iterations, width, k, speed = 100, strictRadial, focusIdx, radii = [], nodeSizeFunc, } = mergedOptions;
    const nodes = graph.getAllNodes();
    const disp = [];
    const maxDisplace = width / 10;
    for (let i = 0; i < iterations; i++) {
        positions.forEach((_, k) => {
            disp[k] = { x: 0, y: 0 };
        });
        // 给重叠的节点增加斥力
        getRepulsion(nodes, positions, disp, k, radii, nodeSizeFunc);
        updatePositions(positions, disp, speed, strictRadial, focusIdx, maxDisplace, width, radii);
    }
    return positions;
};
const getRepulsion = (nodes, positions, disp, k, radii, nodeSizeFunc) => {
    positions.forEach((v, i) => {
        disp[i] = { x: 0, y: 0 };
        positions.forEach((u, j) => {
            if (i === j) {
                return;
            }
            // v and u are not on the same circle, return
            if (radii[i] !== radii[j]) {
                return;
            }
            let vecx = v.x - u.x;
            let vecy = v.y - u.y;
            let vecLength = Math.sqrt(vecx * vecx + vecy * vecy);
            if (vecLength === 0) {
                vecLength = 1;
                const sign = i > j ? 1 : -1;
                vecx = 0.01 * sign;
                vecy = 0.01 * sign;
            }
            // these two nodes overlap
            if (vecLength < nodeSizeFunc(nodes[i]) / 2 + nodeSizeFunc(nodes[j]) / 2) {
                const common = (k * k) / vecLength;
                disp[i].x += (vecx / vecLength) * common;
                disp[i].y += (vecy / vecLength) * common;
            }
        });
    });
};
const updatePositions = (positions, disp, speed, strictRadial, focusIdx, maxDisplace, width, radii) => {
    const maxDisp = maxDisplace || width / 10;
    if (strictRadial) {
        disp.forEach((di, i) => {
            const vx = positions[i].x - positions[focusIdx].x;
            const vy = positions[i].y - positions[focusIdx].y;
            const vLength = Math.sqrt(vx * vx + vy * vy);
            let vpx = vy / vLength;
            let vpy = -vx / vLength;
            const diLength = Math.sqrt(di.x * di.x + di.y * di.y);
            let alpha = Math.acos((vpx * di.x + vpy * di.y) / diLength);
            if (alpha > Math.PI / 2) {
                alpha -= Math.PI / 2;
                vpx *= -1;
                vpy *= -1;
            }
            const tdispLength = Math.cos(alpha) * diLength;
            di.x = vpx * tdispLength;
            di.y = vpy * tdispLength;
        });
    }
    // move
    positions.forEach((n, i) => {
        if (i === focusIdx) {
            return;
        }
        const distLength = Math.sqrt(disp[i].x * disp[i].x + disp[i].y * disp[i].y);
        if (distLength > 0 && i !== focusIdx) {
            const limitedDist = Math.min(maxDisp * (speed / SPEED_DIVISOR), distLength);
            n.x += (disp[i].x / distLength) * limitedDist;
            n.y += (disp[i].y / distLength) * limitedDist;
            if (strictRadial) {
                let vx = n.x - positions[focusIdx].x;
                let vy = n.y - positions[focusIdx].y;
                const nfDis = Math.sqrt(vx * vx + vy * vy);
                vx = (vx / nfDis) * radii[i];
                vy = (vy / nfDis) * radii[i];
                n.x = positions[focusIdx].x + vx;
                n.y = positions[focusIdx].y + vy;
            }
        }
    });
    return positions;
};
//# sourceMappingURL=radial-nonoverlap-force.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/random.js":
/*!*************************************************!*\
  !*** ./node_modules/@antv/layout/lib/random.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RandomLayout: () => (/* binding */ RandomLayout)
/* harmony export */ });
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");

const DEFAULTS_LAYOUT_OPTIONS = {
    center: [0, 0],
    width: 300,
    height: 300,
};
/**
 * <zh/> 随机布局
 *
 * <en/> Random layout
 */
class RandomLayout {
    constructor(options = {}) {
        this.options = options;
        this.id = 'random';
        this.options = Object.assign(Object.assign({}, DEFAULTS_LAYOUT_OPTIONS), options);
    }
    /**
     * Return the positions of nodes and edges(if needed).
     */
    execute(graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            return this.genericRandomLayout(false, graph, options);
        });
    }
    /**
     * To directly assign the positions to the nodes.
     */
    assign(graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            yield this.genericRandomLayout(true, graph, options);
        });
    }
    genericRandomLayout(assign, graph, options) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            const mergedOptions = Object.assign(Object.assign({}, this.options), options);
            const { center: propsCenter, width: propsWidth, height: propsHeight, } = mergedOptions;
            const nodes = graph.getAllNodes();
            const layoutScale = 0.9;
            const width = !propsWidth && typeof window !== 'undefined'
                ? window.innerWidth
                : propsWidth;
            const height = !propsHeight && typeof window !== 'undefined'
                ? window.innerHeight
                : propsHeight;
            const center = !propsCenter
                ? [width / 2, height / 2]
                : propsCenter;
            const layoutNodes = [];
            if (nodes) {
                nodes.forEach((node) => {
                    layoutNodes.push({
                        id: node.id,
                        data: {
                            x: (Math.random() - 0.5) * layoutScale * width + center[0],
                            y: (Math.random() - 0.5) * layoutScale * height + center[1],
                        },
                    });
                });
            }
            if (assign) {
                layoutNodes.forEach((node) => graph.mergeNodeData(node.id, {
                    x: node.data.x,
                    y: node.data.y,
                }));
            }
            const result = {
                nodes: layoutNodes,
                edges: graph.getAllEdges(),
            };
            return result;
        });
    }
}
//# sourceMappingURL=random.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/registry.js":
/*!***************************************************!*\
  !*** ./node_modules/@antv/layout/lib/registry.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   registry: () => (/* binding */ registry)
/* harmony export */ });
/* harmony import */ var _antv_dagre__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./antv-dagre */ "./node_modules/@antv/layout/lib/antv-dagre.js");
/* harmony import */ var _circular__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./circular */ "./node_modules/@antv/layout/lib/circular.js");
/* harmony import */ var _combo_combined__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./combo-combined */ "./node_modules/@antv/layout/lib/combo-combined.js");
/* harmony import */ var _concentric__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./concentric */ "./node_modules/@antv/layout/lib/concentric.js");
/* harmony import */ var _d3_force__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./d3-force */ "./node_modules/@antv/layout/lib/d3-force/index.js");
/* harmony import */ var _d3_force_3d__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./d3-force-3d */ "./node_modules/@antv/layout/lib/d3-force-3d/index.js");
/* harmony import */ var _dagre__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./dagre */ "./node_modules/@antv/layout/lib/dagre.js");
/* harmony import */ var _force__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./force */ "./node_modules/@antv/layout/lib/force/index.js");
/* harmony import */ var _force_atlas2__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./force-atlas2 */ "./node_modules/@antv/layout/lib/force-atlas2/index.js");
/* harmony import */ var _fruchterman__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./fruchterman */ "./node_modules/@antv/layout/lib/fruchterman.js");
/* harmony import */ var _grid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./grid */ "./node_modules/@antv/layout/lib/grid.js");
/* harmony import */ var _mds__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mds */ "./node_modules/@antv/layout/lib/mds.js");
/* harmony import */ var _radial__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./radial */ "./node_modules/@antv/layout/lib/radial/index.js");
/* harmony import */ var _random__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./random */ "./node_modules/@antv/layout/lib/random.js");














const registry = {
    circular: _circular__WEBPACK_IMPORTED_MODULE_0__.CircularLayout,
    concentric: _concentric__WEBPACK_IMPORTED_MODULE_1__.ConcentricLayout,
    mds: _mds__WEBPACK_IMPORTED_MODULE_2__.MDSLayout,
    random: _random__WEBPACK_IMPORTED_MODULE_3__.RandomLayout,
    grid: _grid__WEBPACK_IMPORTED_MODULE_4__.GridLayout,
    radial: _radial__WEBPACK_IMPORTED_MODULE_5__.RadialLayout,
    force: _force__WEBPACK_IMPORTED_MODULE_6__.ForceLayout,
    d3force: _d3_force__WEBPACK_IMPORTED_MODULE_7__.D3ForceLayout,
    'd3-force-3d': _d3_force_3d__WEBPACK_IMPORTED_MODULE_8__.D3Force3DLayout,
    fruchterman: _fruchterman__WEBPACK_IMPORTED_MODULE_9__.FruchtermanLayout,
    forceAtlas2: _force_atlas2__WEBPACK_IMPORTED_MODULE_10__.ForceAtlas2Layout,
    dagre: _dagre__WEBPACK_IMPORTED_MODULE_11__.DagreLayout,
    antvDagre: _antv_dagre__WEBPACK_IMPORTED_MODULE_12__.AntVDagreLayout,
    comboCombined: _combo_combined__WEBPACK_IMPORTED_MODULE_13__.ComboCombinedLayout,
};
//# sourceMappingURL=registry.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/types.js":
/*!************************************************!*\
  !*** ./node_modules/@antv/layout/lib/types.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isLayoutWithIterations: () => (/* binding */ isLayoutWithIterations)
/* harmony export */ });
function isLayoutWithIterations(layout) {
    return !!layout.tick && !!layout.stop;
}
//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/util/array.js":
/*!*****************************************************!*\
  !*** ./node_modules/@antv/layout/lib/util/array.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isArray: () => (/* binding */ isArray)
/* harmony export */ });
const isArray = Array.isArray;
//# sourceMappingURL=array.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/util/common.js":
/*!******************************************************!*\
  !*** ./node_modules/@antv/layout/lib/util/common.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   handleSingleNodeGraph: () => (/* binding */ handleSingleNodeGraph)
/* harmony export */ });
/**
 * Assign or only return the result for the graph who has no nodes or only one node.
 * @param graph original graph
 * @param assign whether assign result to original graph
 * @param center the layout center
 * @returns
 */
const handleSingleNodeGraph = (graph, assign, center) => {
    const nodes = graph.getAllNodes();
    const edges = graph.getAllEdges();
    if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length)) {
        const result = { nodes: [], edges };
        return result;
    }
    if (nodes.length === 1) {
        if (assign) {
            graph.mergeNodeData(nodes[0].id, {
                x: center[0],
                y: center[1],
            });
        }
        const result = {
            nodes: [
                Object.assign(Object.assign({}, nodes[0]), { data: Object.assign(Object.assign({}, nodes[0].data), { x: center[0], y: center[1] }) }),
            ],
            edges,
        };
        return result;
    }
};
//# sourceMappingURL=common.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/util/function.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/layout/lib/util/function.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   formatNodeSizeToNumber: () => (/* binding */ formatNodeSizeToNumber),
/* harmony export */   formatNumberFn: () => (/* binding */ formatNumberFn),
/* harmony export */   formatSizeFn: () => (/* binding */ formatSizeFn)
/* harmony export */ });
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/is-function.js");
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/is-number.js");
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/is-object.js");
/* harmony import */ var _size__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./size */ "./node_modules/@antv/layout/lib/util/size.js");


/**
 * Format value with multiple types into a function returns number.
 * @param defaultValue default value when value is invalid
 * @param value value to be formatted
 * @returns formatted result, a function returns number
 */
function formatNumberFn(defaultValue, value) {
    let resultFunc;
    if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
        resultFunc = value;
    }
    else if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_1__["default"])(value)) {
        // value is number
        resultFunc = () => value;
    }
    else {
        // value is not number and function
        resultFunc = () => defaultValue;
    }
    return resultFunc;
}
/**
 * Format size config with multiple types into a function returns number
 * @param defaultValue default value when value is invalid
 * @param value value to be formatted
 * @param resultIsNumber whether returns number
 * @returns formatted result, a function returns number
 */
function formatSizeFn(defaultValue, value, resultIsNumber = true) {
    if (!value && value !== 0) {
        return (d) => {
            const { size } = d.data || {};
            if (size) {
                if (Array.isArray(size))
                    return resultIsNumber ? Math.max(...size) || defaultValue : size;
                if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_2__["default"])(size) &&
                    size.width &&
                    size.height) {
                    return resultIsNumber
                        ? Math.max(size.width, size.height) || defaultValue
                        : [size.width, size.height];
                }
                return size;
            }
            return defaultValue;
        };
    }
    if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_0__["default"])(value))
        return value;
    if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_1__["default"])(value))
        return () => value;
    if (Array.isArray(value)) {
        return () => {
            if (resultIsNumber)
                return Math.max(...value) || defaultValue;
            return value;
        };
    }
    if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_2__["default"])(value) && value.width && value.height) {
        return () => {
            if (resultIsNumber)
                return Math.max(value.width, value.height) || defaultValue;
            return [value.width, value.height];
        };
    }
    return () => defaultValue;
}
/**
 * format the props nodeSize and nodeSpacing to a function
 * @param nodeSize
 * @param nodeSpacing
 * @returns
 */
const formatNodeSizeToNumber = (nodeSize, nodeSpacing, defaultNodeSize = 10) => {
    let nodeSizeFunc;
    const nodeSpacingFunc = typeof nodeSpacing === 'function' ? nodeSpacing : () => nodeSpacing || 0;
    if (!nodeSize) {
        nodeSizeFunc = (d) => {
            var _a, _b, _c;
            if ((_a = d.data) === null || _a === void 0 ? void 0 : _a.bboxSize)
                return (_b = d.data) === null || _b === void 0 ? void 0 : _b.bboxSize;
            if ((_c = d.data) === null || _c === void 0 ? void 0 : _c.size) {
                const dataSize = d.data.size;
                if (Array.isArray(dataSize))
                    return dataSize;
                if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_2__["default"])(dataSize))
                    return [dataSize.width, dataSize.height];
                return dataSize;
            }
            return defaultNodeSize;
        };
    }
    else if (Array.isArray(nodeSize)) {
        nodeSizeFunc = (d) => nodeSize;
    }
    else if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_0__["default"])(nodeSize)) {
        nodeSizeFunc = nodeSize;
    }
    else {
        nodeSizeFunc = (d) => nodeSize;
    }
    const func = (d) => {
        const nodeSize = nodeSizeFunc(d);
        const nodeSpacing = nodeSpacingFunc(d);
        return Math.max(...(0,_size__WEBPACK_IMPORTED_MODULE_3__.parseSize)(nodeSize)) + nodeSpacing;
    };
    return func;
};
//# sourceMappingURL=function.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/util/math.js":
/*!****************************************************!*\
  !*** ./node_modules/@antv/layout/lib/util/math.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   floydWarshall: () => (/* binding */ floydWarshall),
/* harmony export */   getAdjMatrix: () => (/* binding */ getAdjMatrix),
/* harmony export */   getEuclideanDistance: () => (/* binding */ getEuclideanDistance),
/* harmony export */   getLayoutBBox: () => (/* binding */ getLayoutBBox),
/* harmony export */   graphTreeDfs: () => (/* binding */ graphTreeDfs),
/* harmony export */   scaleMatrix: () => (/* binding */ scaleMatrix)
/* harmony export */ });
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/is-number.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./array */ "./node_modules/@antv/layout/lib/util/array.js");


const floydWarshall = (adjMatrix) => {
    // initialize
    const dist = [];
    const size = adjMatrix.length;
    for (let i = 0; i < size; i += 1) {
        dist[i] = [];
        for (let j = 0; j < size; j += 1) {
            if (i === j) {
                dist[i][j] = 0;
            }
            else if (adjMatrix[i][j] === 0 || !adjMatrix[i][j]) {
                dist[i][j] = Infinity;
            }
            else {
                dist[i][j] = adjMatrix[i][j];
            }
        }
    }
    // floyd
    for (let k = 0; k < size; k += 1) {
        for (let i = 0; i < size; i += 1) {
            for (let j = 0; j < size; j += 1) {
                if (dist[i][j] > dist[i][k] + dist[k][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }
            }
        }
    }
    return dist;
};
const getAdjMatrix = (data, directed) => {
    const { nodes, edges } = data;
    const matrix = [];
    // map node with index in data.nodes
    const nodeMap = {};
    if (!nodes) {
        throw new Error('invalid nodes data!');
    }
    if (nodes) {
        nodes.forEach((node, i) => {
            nodeMap[node.id] = i;
            const row = [];
            matrix.push(row);
        });
    }
    edges === null || edges === void 0 ? void 0 : edges.forEach((e) => {
        const { source, target } = e;
        const sIndex = nodeMap[source];
        const tIndex = nodeMap[target];
        if (sIndex === undefined || tIndex === undefined)
            return;
        matrix[sIndex][tIndex] = 1;
        if (!directed) {
            matrix[tIndex][sIndex] = 1;
        }
    });
    return matrix;
};
/**
 * scale matrix
 * @param matrix [ [], [], [] ]
 * @param ratio
 */
const scaleMatrix = (matrix, ratio) => {
    const result = [];
    matrix.forEach((row) => {
        const newRow = [];
        row.forEach((v) => {
            newRow.push(v * ratio);
        });
        result.push(newRow);
    });
    return result;
};
/**
 * calculate the bounding box for the nodes according to their x, y, and size
 * @param nodes nodes in the layout
 * @returns
 */
const getLayoutBBox = (nodes) => {
    let minX = Infinity;
    let minY = Infinity;
    let maxX = -Infinity;
    let maxY = -Infinity;
    nodes.forEach((node) => {
        let size = node.data.size;
        if ((0,_array__WEBPACK_IMPORTED_MODULE_0__.isArray)(size)) {
            if (size.length === 1)
                size = [size[0], size[0]];
        }
        else if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_1__["default"])(size)) {
            size = [size, size];
        }
        else if (size === undefined || isNaN(size)) {
            size = [30, 30];
        }
        const halfSize = [size[0] / 2, size[1] / 2];
        const left = node.data.x - halfSize[0];
        const right = node.data.x + halfSize[0];
        const top = node.data.y - halfSize[1];
        const bottom = node.data.y + halfSize[1];
        if (minX > left)
            minX = left;
        if (minY > top)
            minY = top;
        if (maxX < right)
            maxX = right;
        if (maxY < bottom)
            maxY = bottom;
    });
    return { minX, minY, maxX, maxY };
};
/**
 * calculate the euclidean distance form p1 to p2
 * @param p1
 * @param p2
 * @returns
 */
const getEuclideanDistance = (p1, p2) => Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
/**
 * Depth first search begin from nodes in graphCore data.
 * @param graphCore graphlib data structure
 * @param nodes begin nodes
 * @param fn will be called while visiting each node
 * @param mode 'TB' - visit from top to bottom; 'BT' - visit from bottom to top;
 * @returns
 */
const graphTreeDfs = (graph, nodes, fn, mode = 'TB', treeKey, stopFns = {}) => {
    if (!(nodes === null || nodes === void 0 ? void 0 : nodes.length))
        return;
    const { stopBranchFn, stopAllFn } = stopFns;
    for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (!graph.hasNode(node.id))
            continue;
        if (stopBranchFn === null || stopBranchFn === void 0 ? void 0 : stopBranchFn(node))
            continue; // Stop this branch
        if (stopAllFn === null || stopAllFn === void 0 ? void 0 : stopAllFn(node))
            return; // Stop all
        if (mode === 'TB')
            fn(node); // Traverse from top to bottom
        graphTreeDfs(graph, graph.getChildren(node.id, treeKey), fn, mode, treeKey, stopFns);
        if (mode !== 'TB')
            fn(node); // Traverse from bottom to top
    }
};
//# sourceMappingURL=math.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/util/object.js":
/*!******************************************************!*\
  !*** ./node_modules/@antv/layout/lib/util/object.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clone: () => (/* binding */ clone),
/* harmony export */   cloneFormatData: () => (/* binding */ cloneFormatData)
/* harmony export */ });
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/is-number.js");

const clone = (target) => {
    if (target === null) {
        return target;
    }
    if (target instanceof Date) {
        return new Date(target.getTime());
    }
    if (target instanceof Array) {
        const cp = [];
        target.forEach((v) => {
            cp.push(v);
        });
        return cp.map((n) => clone(n));
    }
    if (typeof target === 'object') {
        const cp = {};
        Object.keys(target).forEach((k) => {
            cp[k] = clone(target[k]);
        });
        return cp;
    }
    return target;
};
/**
 * Clone node or edge data and format it
 * @param target node/edge to be cloned
 * @param initRange whether init the x and y in data with the range, which means [xRange, yRange]
 * @returns cloned node/edge
 */
const cloneFormatData = (target, initRange) => {
    const cloned = clone(target);
    cloned.data = cloned.data || {};
    if (initRange) {
        if (!(0,_antv_util__WEBPACK_IMPORTED_MODULE_0__["default"])(cloned.data.x))
            cloned.data.x = Math.random() * initRange[0];
        if (!(0,_antv_util__WEBPACK_IMPORTED_MODULE_0__["default"])(cloned.data.y))
            cloned.data.y = Math.random() * initRange[1];
    }
    return cloned;
};
//# sourceMappingURL=object.js.map

/***/ }),

/***/ "./node_modules/@antv/layout/lib/util/size.js":
/*!****************************************************!*\
  !*** ./node_modules/@antv/layout/lib/util/size.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseSize: () => (/* binding */ parseSize)
/* harmony export */ });
/* harmony import */ var _antv_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @antv/util */ "./node_modules/@antv/util/esm/lodash/is-number.js");

function parseSize(size) {
    if (!size)
        return [0, 0, 0];
    if ((0,_antv_util__WEBPACK_IMPORTED_MODULE_0__["default"])(size))
        return [size, size, size];
    else if (size.length === 0)
        return [0, 0, 0];
    const [x, y = x, z = x] = size;
    return [x, y, z];
}
//# sourceMappingURL=size.js.map

/***/ }),

/***/ "./node_modules/@antv/util/esm/lodash/clone.js":
/*!*****************************************************!*\
  !*** ./node_modules/@antv/util/esm/lodash/clone.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _is_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-array */ "./node_modules/@antv/util/esm/lodash/is-array.js");

var clone = function (obj) {
    if (typeof obj !== 'object' || obj === null) {
        return obj;
    }
    var rst;
    if ((0,_is_array__WEBPACK_IMPORTED_MODULE_0__["default"])(obj)) {
        rst = [];
        for (var i = 0, l = obj.length; i < l; i++) {
            if (typeof obj[i] === 'object' && obj[i] != null) {
                rst[i] = clone(obj[i]);
            }
            else {
                rst[i] = obj[i];
            }
        }
    }
    else {
        rst = {};
        for (var k in obj) {
            if (typeof obj[k] === 'object' && obj[k] != null) {
                rst[k] = clone(obj[k]);
            }
            else {
                rst[k] = obj[k];
            }
        }
    }
    return rst;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (clone);
//# sourceMappingURL=clone.js.map

/***/ }),

/***/ "./node_modules/@antv/util/esm/lodash/deep-mix.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/util/esm/lodash/deep-mix.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _is_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is-array */ "./node_modules/@antv/util/esm/lodash/is-array.js");
/* harmony import */ var _is_plain_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-plain-object */ "./node_modules/@antv/util/esm/lodash/is-plain-object.js");


var MAX_MIX_LEVEL = 5;
function hasOwn(object, property) {
    if (Object.hasOwn) {
        return Object.hasOwn(object, property);
    }
    if (object == null) {
        throw new TypeError('Cannot convert undefined or null to object');
    }
    return Object.prototype.hasOwnProperty.call(Object(object), property);
}
function _deepMix(dist, src, level, maxLevel) {
    level = level || 0;
    maxLevel = maxLevel || MAX_MIX_LEVEL;
    for (var key in src) {
        if (hasOwn(src, key)) {
            var value = src[key];
            if (value !== null && (0,_is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(value)) {
                if (!(0,_is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(dist[key])) {
                    dist[key] = {};
                }
                if (level < maxLevel) {
                    _deepMix(dist[key], value, level + 1, maxLevel);
                }
                else {
                    dist[key] = src[key];
                }
            }
            else if ((0,_is_array__WEBPACK_IMPORTED_MODULE_1__["default"])(value)) {
                dist[key] = [];
                dist[key] = dist[key].concat(value);
            }
            else if (value !== undefined) {
                dist[key] = value;
            }
        }
    }
}
// todo 重写
var deepMix = function (rst) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    for (var i = 0; i < args.length; i += 1) {
        _deepMix(rst, args[i]);
    }
    return rst;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (deepMix);
//# sourceMappingURL=deep-mix.js.map

/***/ }),

/***/ "./node_modules/@antv/util/esm/lodash/each.js":
/*!****************************************************!*\
  !*** ./node_modules/@antv/util/esm/lodash/each.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _is_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-array */ "./node_modules/@antv/util/esm/lodash/is-array.js");
/* harmony import */ var _is_object__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is-object */ "./node_modules/@antv/util/esm/lodash/is-object.js");


function each(elements, func) {
    if (!elements) {
        return;
    }
    var rst;
    if ((0,_is_array__WEBPACK_IMPORTED_MODULE_0__["default"])(elements)) {
        for (var i = 0, len = elements.length; i < len; i++) {
            rst = func(elements[i], i);
            if (rst === false) {
                break;
            }
        }
    }
    else if ((0,_is_object__WEBPACK_IMPORTED_MODULE_1__["default"])(elements)) {
        for (var k in elements) {
            if (elements.hasOwnProperty(k)) {
                rst = func(elements[k], k);
                if (rst === false) {
                    break;
                }
            }
        }
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (each);
//# sourceMappingURL=each.js.map

/***/ }),

/***/ "./node_modules/@antv/util/esm/lodash/is-array.js":
/*!********************************************************!*\
  !*** ./node_modules/@antv/util/esm/lodash/is-array.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isArray)
/* harmony export */ });
/**
 * 判断值是否为数组
 * @return 是否为数组
 */
function isArray(value) {
    return Array.isArray(value);
}
//# sourceMappingURL=is-array.js.map

/***/ }),

/***/ "./node_modules/@antv/util/esm/lodash/is-function.js":
/*!***********************************************************!*\
  !*** ./node_modules/@antv/util/esm/lodash/is-function.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isFunction)
/* harmony export */ });
/**
 * 判断值是否为函数
 * @return 是否为函数
 */
function isFunction(value) {
    return typeof value === 'function';
}
//# sourceMappingURL=is-function.js.map

/***/ }),

/***/ "./node_modules/@antv/util/esm/lodash/is-nil.js":
/*!******************************************************!*\
  !*** ./node_modules/@antv/util/esm/lodash/is-nil.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isNil)
/* harmony export */ });
/**
 * 判断值是否为 null 或 undefined
 * @return 是否为 null 或 undefined
 */
function isNil(value) {
    return value === null || value === undefined;
}
//# sourceMappingURL=is-nil.js.map

/***/ }),

/***/ "./node_modules/@antv/util/esm/lodash/is-number.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/util/esm/lodash/is-number.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isNumber)
/* harmony export */ });
/**
 * 判断值是否为数字
 * @return 是否为数字
 */
function isNumber(value) {
    return typeof value === 'number';
}
//# sourceMappingURL=is-number.js.map

/***/ }),

/***/ "./node_modules/@antv/util/esm/lodash/is-object-like.js":
/*!**************************************************************!*\
  !*** ./node_modules/@antv/util/esm/lodash/is-object-like.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var isObjectLike = function (value) {
    /**
     * isObjectLike({}) => true
     * isObjectLike([1, 2, 3]) => true
     * isObjectLike(Function) => false
     * isObjectLike(null) => false
     */
    return typeof value === 'object' && value !== null;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isObjectLike);
//# sourceMappingURL=is-object-like.js.map

/***/ }),

/***/ "./node_modules/@antv/util/esm/lodash/is-object.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/util/esm/lodash/is-object.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function (value) {
    /**
     * isObject({}) => true
     * isObject([1, 2, 3]) => true
     * isObject(Function) => true
     * isObject(null) => false
     */
    var type = typeof value;
    return (value !== null && type === 'object') || type === 'function';
});
//# sourceMappingURL=is-object.js.map

/***/ }),

/***/ "./node_modules/@antv/util/esm/lodash/is-plain-object.js":
/*!***************************************************************!*\
  !*** ./node_modules/@antv/util/esm/lodash/is-plain-object.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _is_object_like__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-object-like */ "./node_modules/@antv/util/esm/lodash/is-object-like.js");
/* harmony import */ var _is_type__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is-type */ "./node_modules/@antv/util/esm/lodash/is-type.js");


var isPlainObject = function (value) {
    /**
     * isObjectLike(new Foo) => false
     * isObjectLike([1, 2, 3]) => false
     * isObjectLike({ x: 0, y: 0 }) => true
     * isObjectLike(Object.create(null)) => true
     */
    if (!(0,_is_object_like__WEBPACK_IMPORTED_MODULE_0__["default"])(value) || !(0,_is_type__WEBPACK_IMPORTED_MODULE_1__["default"])(value, 'Object')) {
        return false;
    }
    if (Object.getPrototypeOf(value) === null) {
        return true;
    }
    var proto = value;
    while (Object.getPrototypeOf(proto) !== null) {
        proto = Object.getPrototypeOf(proto);
    }
    return Object.getPrototypeOf(value) === proto;
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isPlainObject);
//# sourceMappingURL=is-plain-object.js.map

/***/ }),

/***/ "./node_modules/@antv/util/esm/lodash/is-string.js":
/*!*********************************************************!*\
  !*** ./node_modules/@antv/util/esm/lodash/is-string.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isString)
/* harmony export */ });
/**
 * 判断值是否为字符串
 * @return 是否为字符串
 */
function isString(value) {
    return typeof value === 'string';
}
//# sourceMappingURL=is-string.js.map

/***/ }),

/***/ "./node_modules/@antv/util/esm/lodash/is-type.js":
/*!*******************************************************!*\
  !*** ./node_modules/@antv/util/esm/lodash/is-type.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var toString = {}.toString;
var isType = function (value, type) { return toString.call(value) === '[object ' + type + ']'; };
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isType);
//# sourceMappingURL=is-type.js.map

/***/ }),

/***/ "./node_modules/@antv/util/esm/lodash/pick.js":
/*!****************************************************!*\
  !*** ./node_modules/@antv/util/esm/lodash/pick.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _each__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./each */ "./node_modules/@antv/util/esm/lodash/each.js");
/* harmony import */ var _is_plain_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-plain-object */ "./node_modules/@antv/util/esm/lodash/is-plain-object.js");


var hasOwnProperty = Object.prototype.hasOwnProperty;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (function (object, keys) {
    if (object === null || !(0,_is_plain_object__WEBPACK_IMPORTED_MODULE_0__["default"])(object)) {
        return {};
    }
    var result = {};
    (0,_each__WEBPACK_IMPORTED_MODULE_1__["default"])(keys, function (key) {
        if (hasOwnProperty.call(object, key)) {
            result[key] = object[key];
        }
    });
    return result;
});
//# sourceMappingURL=pick.js.map

/***/ }),

/***/ "./node_modules/comlink/dist/esm/comlink.mjs":
/*!***************************************************!*\
  !*** ./node_modules/comlink/dist/esm/comlink.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createEndpoint: () => (/* binding */ createEndpoint),
/* harmony export */   expose: () => (/* binding */ expose),
/* harmony export */   finalizer: () => (/* binding */ finalizer),
/* harmony export */   proxy: () => (/* binding */ proxy),
/* harmony export */   proxyMarker: () => (/* binding */ proxyMarker),
/* harmony export */   releaseProxy: () => (/* binding */ releaseProxy),
/* harmony export */   transfer: () => (/* binding */ transfer),
/* harmony export */   transferHandlers: () => (/* binding */ transferHandlers),
/* harmony export */   windowEndpoint: () => (/* binding */ windowEndpoint),
/* harmony export */   wrap: () => (/* binding */ wrap)
/* harmony export */ });
/**
 * @license
 * Copyright 2019 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
const proxyMarker = Symbol("Comlink.proxy");
const createEndpoint = Symbol("Comlink.endpoint");
const releaseProxy = Symbol("Comlink.releaseProxy");
const finalizer = Symbol("Comlink.finalizer");
const throwMarker = Symbol("Comlink.thrown");
const isObject = (val) => (typeof val === "object" && val !== null) || typeof val === "function";
/**
 * Internal transfer handle to handle objects marked to proxy.
 */
const proxyTransferHandler = {
    canHandle: (val) => isObject(val) && val[proxyMarker],
    serialize(obj) {
        const { port1, port2 } = new MessageChannel();
        expose(obj, port1);
        return [port2, [port2]];
    },
    deserialize(port) {
        port.start();
        return wrap(port);
    },
};
/**
 * Internal transfer handler to handle thrown exceptions.
 */
const throwTransferHandler = {
    canHandle: (value) => isObject(value) && throwMarker in value,
    serialize({ value }) {
        let serialized;
        if (value instanceof Error) {
            serialized = {
                isError: true,
                value: {
                    message: value.message,
                    name: value.name,
                    stack: value.stack,
                },
            };
        }
        else {
            serialized = { isError: false, value };
        }
        return [serialized, []];
    },
    deserialize(serialized) {
        if (serialized.isError) {
            throw Object.assign(new Error(serialized.value.message), serialized.value);
        }
        throw serialized.value;
    },
};
/**
 * Allows customizing the serialization of certain values.
 */
const transferHandlers = new Map([
    ["proxy", proxyTransferHandler],
    ["throw", throwTransferHandler],
]);
function isAllowedOrigin(allowedOrigins, origin) {
    for (const allowedOrigin of allowedOrigins) {
        if (origin === allowedOrigin || allowedOrigin === "*") {
            return true;
        }
        if (allowedOrigin instanceof RegExp && allowedOrigin.test(origin)) {
            return true;
        }
    }
    return false;
}
function expose(obj, ep = globalThis, allowedOrigins = ["*"]) {
    ep.addEventListener("message", function callback(ev) {
        if (!ev || !ev.data) {
            return;
        }
        if (!isAllowedOrigin(allowedOrigins, ev.origin)) {
            console.warn(`Invalid origin '${ev.origin}' for comlink proxy`);
            return;
        }
        const { id, type, path } = Object.assign({ path: [] }, ev.data);
        const argumentList = (ev.data.argumentList || []).map(fromWireValue);
        let returnValue;
        try {
            const parent = path.slice(0, -1).reduce((obj, prop) => obj[prop], obj);
            const rawValue = path.reduce((obj, prop) => obj[prop], obj);
            switch (type) {
                case "GET" /* MessageType.GET */:
                    {
                        returnValue = rawValue;
                    }
                    break;
                case "SET" /* MessageType.SET */:
                    {
                        parent[path.slice(-1)[0]] = fromWireValue(ev.data.value);
                        returnValue = true;
                    }
                    break;
                case "APPLY" /* MessageType.APPLY */:
                    {
                        returnValue = rawValue.apply(parent, argumentList);
                    }
                    break;
                case "CONSTRUCT" /* MessageType.CONSTRUCT */:
                    {
                        const value = new rawValue(...argumentList);
                        returnValue = proxy(value);
                    }
                    break;
                case "ENDPOINT" /* MessageType.ENDPOINT */:
                    {
                        const { port1, port2 } = new MessageChannel();
                        expose(obj, port2);
                        returnValue = transfer(port1, [port1]);
                    }
                    break;
                case "RELEASE" /* MessageType.RELEASE */:
                    {
                        returnValue = undefined;
                    }
                    break;
                default:
                    return;
            }
        }
        catch (value) {
            returnValue = { value, [throwMarker]: 0 };
        }
        Promise.resolve(returnValue)
            .catch((value) => {
            return { value, [throwMarker]: 0 };
        })
            .then((returnValue) => {
            const [wireValue, transferables] = toWireValue(returnValue);
            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
            if (type === "RELEASE" /* MessageType.RELEASE */) {
                // detach and deactive after sending release response above.
                ep.removeEventListener("message", callback);
                closeEndPoint(ep);
                if (finalizer in obj && typeof obj[finalizer] === "function") {
                    obj[finalizer]();
                }
            }
        })
            .catch((error) => {
            // Send Serialization Error To Caller
            const [wireValue, transferables] = toWireValue({
                value: new TypeError("Unserializable return value"),
                [throwMarker]: 0,
            });
            ep.postMessage(Object.assign(Object.assign({}, wireValue), { id }), transferables);
        });
    });
    if (ep.start) {
        ep.start();
    }
}
function isMessagePort(endpoint) {
    return endpoint.constructor.name === "MessagePort";
}
function closeEndPoint(endpoint) {
    if (isMessagePort(endpoint))
        endpoint.close();
}
function wrap(ep, target) {
    const pendingListeners = new Map();
    ep.addEventListener("message", function handleMessage(ev) {
        const { data } = ev;
        if (!data || !data.id) {
            return;
        }
        const resolver = pendingListeners.get(data.id);
        if (!resolver) {
            return;
        }
        try {
            resolver(data);
        }
        finally {
            pendingListeners.delete(data.id);
        }
    });
    return createProxy(ep, pendingListeners, [], target);
}
function throwIfProxyReleased(isReleased) {
    if (isReleased) {
        throw new Error("Proxy has been released and is not useable");
    }
}
function releaseEndpoint(ep) {
    return requestResponseMessage(ep, new Map(), {
        type: "RELEASE" /* MessageType.RELEASE */,
    }).then(() => {
        closeEndPoint(ep);
    });
}
const proxyCounter = new WeakMap();
const proxyFinalizers = "FinalizationRegistry" in globalThis &&
    new FinalizationRegistry((ep) => {
        const newCount = (proxyCounter.get(ep) || 0) - 1;
        proxyCounter.set(ep, newCount);
        if (newCount === 0) {
            releaseEndpoint(ep);
        }
    });
function registerProxy(proxy, ep) {
    const newCount = (proxyCounter.get(ep) || 0) + 1;
    proxyCounter.set(ep, newCount);
    if (proxyFinalizers) {
        proxyFinalizers.register(proxy, ep, proxy);
    }
}
function unregisterProxy(proxy) {
    if (proxyFinalizers) {
        proxyFinalizers.unregister(proxy);
    }
}
function createProxy(ep, pendingListeners, path = [], target = function () { }) {
    let isProxyReleased = false;
    const proxy = new Proxy(target, {
        get(_target, prop) {
            throwIfProxyReleased(isProxyReleased);
            if (prop === releaseProxy) {
                return () => {
                    unregisterProxy(proxy);
                    releaseEndpoint(ep);
                    pendingListeners.clear();
                    isProxyReleased = true;
                };
            }
            if (prop === "then") {
                if (path.length === 0) {
                    return { then: () => proxy };
                }
                const r = requestResponseMessage(ep, pendingListeners, {
                    type: "GET" /* MessageType.GET */,
                    path: path.map((p) => p.toString()),
                }).then(fromWireValue);
                return r.then.bind(r);
            }
            return createProxy(ep, pendingListeners, [...path, prop]);
        },
        set(_target, prop, rawValue) {
            throwIfProxyReleased(isProxyReleased);
            // FIXME: ES6 Proxy Handler `set` methods are supposed to return a
            // boolean. To show good will, we return true asynchronously ¯\_(ツ)_/¯
            const [value, transferables] = toWireValue(rawValue);
            return requestResponseMessage(ep, pendingListeners, {
                type: "SET" /* MessageType.SET */,
                path: [...path, prop].map((p) => p.toString()),
                value,
            }, transferables).then(fromWireValue);
        },
        apply(_target, _thisArg, rawArgumentList) {
            throwIfProxyReleased(isProxyReleased);
            const last = path[path.length - 1];
            if (last === createEndpoint) {
                return requestResponseMessage(ep, pendingListeners, {
                    type: "ENDPOINT" /* MessageType.ENDPOINT */,
                }).then(fromWireValue);
            }
            // We just pretend that `bind()` didn’t happen.
            if (last === "bind") {
                return createProxy(ep, pendingListeners, path.slice(0, -1));
            }
            const [argumentList, transferables] = processArguments(rawArgumentList);
            return requestResponseMessage(ep, pendingListeners, {
                type: "APPLY" /* MessageType.APPLY */,
                path: path.map((p) => p.toString()),
                argumentList,
            }, transferables).then(fromWireValue);
        },
        construct(_target, rawArgumentList) {
            throwIfProxyReleased(isProxyReleased);
            const [argumentList, transferables] = processArguments(rawArgumentList);
            return requestResponseMessage(ep, pendingListeners, {
                type: "CONSTRUCT" /* MessageType.CONSTRUCT */,
                path: path.map((p) => p.toString()),
                argumentList,
            }, transferables).then(fromWireValue);
        },
    });
    registerProxy(proxy, ep);
    return proxy;
}
function myFlat(arr) {
    return Array.prototype.concat.apply([], arr);
}
function processArguments(argumentList) {
    const processed = argumentList.map(toWireValue);
    return [processed.map((v) => v[0]), myFlat(processed.map((v) => v[1]))];
}
const transferCache = new WeakMap();
function transfer(obj, transfers) {
    transferCache.set(obj, transfers);
    return obj;
}
function proxy(obj) {
    return Object.assign(obj, { [proxyMarker]: true });
}
function windowEndpoint(w, context = globalThis, targetOrigin = "*") {
    return {
        postMessage: (msg, transferables) => w.postMessage(msg, targetOrigin, transferables),
        addEventListener: context.addEventListener.bind(context),
        removeEventListener: context.removeEventListener.bind(context),
    };
}
function toWireValue(value) {
    for (const [name, handler] of transferHandlers) {
        if (handler.canHandle(value)) {
            const [serializedValue, transferables] = handler.serialize(value);
            return [
                {
                    type: "HANDLER" /* WireValueType.HANDLER */,
                    name,
                    value: serializedValue,
                },
                transferables,
            ];
        }
    }
    return [
        {
            type: "RAW" /* WireValueType.RAW */,
            value,
        },
        transferCache.get(value) || [],
    ];
}
function fromWireValue(value) {
    switch (value.type) {
        case "HANDLER" /* WireValueType.HANDLER */:
            return transferHandlers.get(value.name).deserialize(value.value);
        case "RAW" /* WireValueType.RAW */:
            return value.value;
    }
}
function requestResponseMessage(ep, pendingListeners, msg, transfers) {
    return new Promise((resolve) => {
        const id = generateUUID();
        pendingListeners.set(id, resolve);
        if (ep.start) {
            ep.start();
        }
        ep.postMessage(Object.assign({ id }, msg), transfers);
    });
}
function generateUUID() {
    return new Array(4)
        .fill(0)
        .map(() => Math.floor(Math.random() * Number.MAX_SAFE_INTEGER).toString(16))
        .join("-");
}


//# sourceMappingURL=comlink.mjs.map


/***/ }),

/***/ "./node_modules/d3-binarytree/src/add.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-binarytree/src/add.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addAll: () => (/* binding */ addAll),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  const x = +this._x.call(null, d);
  return add(this.cover(x), x, d);
}

function add(tree, x, d) {
  if (isNaN(x)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      x1 = tree._x1,
      xm,
      xp,
      right,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (parent = node, !(node = node[i = +right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  if (x === xp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(2) : tree._root = new Array(2);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
  } while ((i = +right) === (j = +(xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  if (!Array.isArray(data)) data = Array.from(data);
  const n = data.length;
  const xz = new Float64Array(n);
  let x0 = Infinity,
      x1 = -Infinity;

  // Compute the points and their extent.
  for (let i = 0, x; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, data[i]))) continue;
    xz[i] = x;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
  }

  // If there were no (valid) points, abort.
  if (x0 > x1) return this;

  // Expand the tree to cover the new points.
  this.cover(x0).cover(x1);

  // Add the new points.
  for (let i = 0; i < n; ++i) {
    add(this, xz[i], data[i]);
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-binarytree/src/binarytree.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-binarytree/src/binarytree.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ binarytree)
/* harmony export */ });
/* harmony import */ var _add_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./add.js */ "./node_modules/d3-binarytree/src/add.js");
/* harmony import */ var _cover_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cover.js */ "./node_modules/d3-binarytree/src/cover.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./data.js */ "./node_modules/d3-binarytree/src/data.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./extent.js */ "./node_modules/d3-binarytree/src/extent.js");
/* harmony import */ var _find_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./find.js */ "./node_modules/d3-binarytree/src/find.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-binarytree/src/remove.js");
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./root.js */ "./node_modules/d3-binarytree/src/root.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./size.js */ "./node_modules/d3-binarytree/src/size.js");
/* harmony import */ var _visit_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./visit.js */ "./node_modules/d3-binarytree/src/visit.js");
/* harmony import */ var _visitAfter_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./visitAfter.js */ "./node_modules/d3-binarytree/src/visitAfter.js");
/* harmony import */ var _x_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./x.js */ "./node_modules/d3-binarytree/src/x.js");












function binarytree(nodes, x) {
  var tree = new Binarytree(x == null ? _x_js__WEBPACK_IMPORTED_MODULE_0__.defaultX : x, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Binarytree(x, x0, x1) {
  this._x = x;
  this._x0 = x0;
  this._x1 = x1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = binarytree.prototype = Binarytree.prototype;

treeProto.copy = function() {
  var copy = new Binarytree(this._x, this._x0, this._x1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(2)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 2; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(2)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = _add_js__WEBPACK_IMPORTED_MODULE_1__["default"];
treeProto.addAll = _add_js__WEBPACK_IMPORTED_MODULE_1__.addAll;
treeProto.cover = _cover_js__WEBPACK_IMPORTED_MODULE_2__["default"];
treeProto.data = _data_js__WEBPACK_IMPORTED_MODULE_3__["default"];
treeProto.extent = _extent_js__WEBPACK_IMPORTED_MODULE_4__["default"];
treeProto.find = _find_js__WEBPACK_IMPORTED_MODULE_5__["default"];
treeProto.remove = _remove_js__WEBPACK_IMPORTED_MODULE_6__["default"];
treeProto.removeAll = _remove_js__WEBPACK_IMPORTED_MODULE_6__.removeAll;
treeProto.root = _root_js__WEBPACK_IMPORTED_MODULE_7__["default"];
treeProto.size = _size_js__WEBPACK_IMPORTED_MODULE_8__["default"];
treeProto.visit = _visit_js__WEBPACK_IMPORTED_MODULE_9__["default"];
treeProto.visitAfter = _visitAfter_js__WEBPACK_IMPORTED_MODULE_10__["default"];
treeProto.x = _x_js__WEBPACK_IMPORTED_MODULE_0__["default"];

/***/ }),

/***/ "./node_modules/d3-binarytree/src/cover.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-binarytree/src/cover.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  if (isNaN(x = +x)) return this; // ignore invalid points

  var x0 = this._x0,
      x1 = this._x1;

  // If the binarytree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing half boundaries don’t change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else {
    var z = x1 - x0 || 1,
        node = this._root,
        parent,
        i;

    while (x0 > x || x >= x1) {
      i = +(x < x0);
      parent = new Array(2), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0: x1 = x0 + z; break;
        case 1: x0 = x1 - z; break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  this._x0 = x0;
  this._x1 = x1;
  return this;
}


/***/ }),

/***/ "./node_modules/d3-binarytree/src/data.js":
/*!************************************************!*\
  !*** ./node_modules/d3-binarytree/src/data.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
}


/***/ }),

/***/ "./node_modules/d3-binarytree/src/extent.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-binarytree/src/extent.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length
      ? this.cover(+_[0][0]).cover(+_[1][0])
      : isNaN(this._x0) ? undefined : [[this._x0], [this._x1]];
}


/***/ }),

/***/ "./node_modules/d3-binarytree/src/find.js":
/*!************************************************!*\
  !*** ./node_modules/d3-binarytree/src/find.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _half_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./half.js */ "./node_modules/d3-binarytree/src/half.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, radius) {
  var data,
      x0 = this._x0,
      x1,
      x2,
      x3 = this._x1,
      halves = [],
      node = this._root,
      q,
      i;

  if (node) halves.push(new _half_js__WEBPACK_IMPORTED_MODULE_0__["default"](node, x0, x3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius;
    x3 = x + radius;
  }

  while (q = halves.pop()) {

    // Stop searching if this half can’t contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (x2 = q.x1) < x0) continue;

    // Bisect the current half.
    if (node.length) {
      var xm = (x1 + x2) / 2;

      halves.push(
        new _half_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[1], xm, x2),
        new _half_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[0], x1, xm)
      );

      // Visit the closest half first.
      if (i = +(x >= xm)) {
        q = halves[halves.length - 1];
        halves[halves.length - 1] = halves[halves.length - 1 - i];
        halves[halves.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isn’t necessary!)
    else {
      var d = Math.abs(x - +this._x.call(null, node.data));
      if (d < radius) {
        radius = d;
        x0 = x - d;
        x3 = x + d;
        data = node.data;
      }
    }
  }

  return data;
}


/***/ }),

/***/ "./node_modules/d3-binarytree/src/half.js":
/*!************************************************!*\
  !*** ./node_modules/d3-binarytree/src/half.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, x0, x1) {
  this.node = node;
  this.x0 = x0;
  this.x1 = x1;
}


/***/ }),

/***/ "./node_modules/d3-binarytree/src/remove.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-binarytree/src/remove.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   removeAll: () => (/* binding */ removeAll)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  if (isNaN(x = +this._x.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      x1 = this._x1,
      x,
      xm,
      right,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (!(parent = node, node = node[i = +right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 1]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1])
      && node === (parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
}

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}


/***/ }),

/***/ "./node_modules/d3-binarytree/src/root.js":
/*!************************************************!*\
  !*** ./node_modules/d3-binarytree/src/root.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this._root;
}


/***/ }),

/***/ "./node_modules/d3-binarytree/src/size.js":
/*!************************************************!*\
  !*** ./node_modules/d3-binarytree/src/size.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
}


/***/ }),

/***/ "./node_modules/d3-binarytree/src/visit.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-binarytree/src/visit.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _half_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./half.js */ "./node_modules/d3-binarytree/src/half.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {
  var halves = [], q, node = this._root, child, x0, x1;
  if (node) halves.push(new _half_js__WEBPACK_IMPORTED_MODULE_0__["default"](node, this._x0, this._x1));
  while (q = halves.pop()) {
    if (!callback(node = q.node, x0 = q.x0, x1 = q.x1) && node.length) {
      var xm = (x0 + x1) / 2;
      if (child = node[1]) halves.push(new _half_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, x1));
      if (child = node[0]) halves.push(new _half_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, xm));
    }
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-binarytree/src/visitAfter.js":
/*!******************************************************!*\
  !*** ./node_modules/d3-binarytree/src/visitAfter.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _half_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./half.js */ "./node_modules/d3-binarytree/src/half.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {
  var halves = [], next = [], q;
  if (this._root) halves.push(new _half_js__WEBPACK_IMPORTED_MODULE_0__["default"](this._root, this._x0, this._x1));
  while (q = halves.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, x1 = q.x1, xm = (x0 + x1) / 2;
      if (child = node[0]) halves.push(new _half_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, xm));
      if (child = node[1]) halves.push(new _half_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, x1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.x1);
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-binarytree/src/x.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-binarytree/src/x.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultX: () => (/* binding */ defaultX)
/* harmony export */ });
function defaultX(d) {
  return d[0];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}


/***/ }),

/***/ "./node_modules/d3-dispatch/src/dispatch.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-dispatch/src/dispatch.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
var noop = {value: () => {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dispatch);


/***/ }),

/***/ "./node_modules/d3-force-3d/src/center.js":
/*!************************************************!*\
  !*** ./node_modules/d3-force-3d/src/center.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y, z) {
  var nodes, strength = 1;

  if (x == null) x = 0;
  if (y == null) y = 0;
  if (z == null) z = 0;

  function force() {
    var i,
        n = nodes.length,
        node,
        sx = 0,
        sy = 0,
        sz = 0;

    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x || 0, sy += node.y || 0, sz += node.z || 0;
    }

    for (sx = (sx / n - x) * strength, sy = (sy / n - y) * strength, sz = (sz / n - z) * strength, i = 0; i < n; ++i) {
      node = nodes[i];
      if (sx) { node.x -= sx }
      if (sy) { node.y -= sy; }
      if (sz) { node.z -= sz; }
    }
  }

  force.initialize = function(_) {
    nodes = _;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  force.z = function(_) {
    return arguments.length ? (z = +_, force) : z;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force-3d/src/collide.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-force-3d/src/collide.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_binarytree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-binarytree */ "./node_modules/d3-binarytree/src/binarytree.js");
/* harmony import */ var d3_quadtree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-quadtree */ "./node_modules/d3-quadtree/src/quadtree.js");
/* harmony import */ var d3_octree__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-octree */ "./node_modules/d3-octree/src/octree.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force-3d/src/constant.js");
/* harmony import */ var _jiggle_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./jiggle.js */ "./node_modules/d3-force-3d/src/jiggle.js");






function x(d) {
  return d.x + d.vx;
}

function y(d) {
  return d.y + d.vy;
}

function z(d) {
  return d.z + d.vz;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(radius) {
  var nodes,
      nDim,
      radii,
      random,
      strength = 1,
      iterations = 1;

  if (typeof radius !== "function") radius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(radius == null ? 1 : +radius);

  function force() {
    var i, n = nodes.length,
        tree,
        node,
        xi,
        yi,
        zi,
        ri,
        ri2;

    for (var k = 0; k < iterations; ++k) {
      tree =
          (nDim === 1 ? (0,d3_binarytree__WEBPACK_IMPORTED_MODULE_1__["default"])(nodes, x)
          :(nDim === 2 ? (0,d3_quadtree__WEBPACK_IMPORTED_MODULE_2__["default"])(nodes, x, y)
          :(nDim === 3 ? (0,d3_octree__WEBPACK_IMPORTED_MODULE_3__["default"])(nodes, x, y, z)
          :null
      ))).visitAfter(prepare);

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        if (nDim > 1) { yi = node.y + node.vy; }
        if (nDim > 2) { zi = node.z + node.vz; }
        tree.visit(apply);
      }
    }

    function apply(treeNode, arg1, arg2, arg3, arg4, arg5, arg6) {
      var args = [arg1, arg2, arg3, arg4, arg5, arg6];
      var x0 = args[0],
          y0 = args[1],
          z0 = args[2],
          x1 = args[nDim],
          y1 = args[nDim+1],
          z1 = args[nDim+2];

      var data = treeNode.data, rj = treeNode.r, r = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x = xi - data.x - data.vx,
              y = (nDim > 1 ? yi - data.y - data.vy : 0),
              z = (nDim > 2 ? zi - data.z - data.vz : 0),
              l = x * x + y * y + z * z;
          if (l < r * r) {
            if (x === 0) x = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_4__["default"])(random), l += x * x;
            if (nDim > 1 && y === 0) y = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_4__["default"])(random), l += y * y;
            if (nDim > 2 && z === 0) z = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_4__["default"])(random), l += z * z;
            l = (r - (l = Math.sqrt(l))) / l * strength;

            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
            if (nDim > 1) { node.vy += (y *= l) * r; }
            if (nDim > 2) { node.vz += (z *= l) * r; }

            data.vx -= x * (r = 1 - r);
            if (nDim > 1) { data.vy -= y * r; }
            if (nDim > 2) { data.vz -= z * r; }
          }
        }
        return;
      }
      return x0 > xi + r || x1 < xi - r
          || (nDim > 1 && (y0 > yi + r || y1 < yi - r))
          || (nDim > 2 && (z0 > zi + r || z1 < zi - r));
    }
  }

  function prepare(treeNode) {
    if (treeNode.data) return treeNode.r = radii[treeNode.data.index];
    for (var i = treeNode.r = 0; i < Math.pow(2, nDim); ++i) {
      if (treeNode[i] && treeNode[i].r > treeNode.r) {
        treeNode.r = treeNode[i].r;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }

  force.initialize = function(_nodes, ...args) {
    nodes = _nodes;
    random = args.find(arg => typeof arg === 'function') || Math.random;
    nDim = args.find(arg => [1, 2, 3].includes(arg)) || 2;
    initialize();
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : radius;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force-3d/src/constant.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-force-3d/src/constant.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-force-3d/src/jiggle.js":
/*!************************************************!*\
  !*** ./node_modules/d3-force-3d/src/jiggle.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(random) {
  return (random() - 0.5) * 1e-6;
}


/***/ }),

/***/ "./node_modules/d3-force-3d/src/lcg.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-force-3d/src/lcg.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
const a = 1664525;
const c = 1013904223;
const m = 4294967296; // 2^32

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  let s = 1;
  return () => (s = (a * s + c) % m) / m;
}


/***/ }),

/***/ "./node_modules/d3-force-3d/src/link.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-force-3d/src/link.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force-3d/src/constant.js");
/* harmony import */ var _jiggle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jiggle.js */ "./node_modules/d3-force-3d/src/jiggle.js");



function index(d) {
  return d.index;
}

function find(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("node not found: " + nodeId);
  return node;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(links) {
  var id = index,
      strength = defaultStrength,
      strengths,
      distance = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(30),
      distances,
      nodes,
      nDim,
      count,
      bias,
      random,
      iterations = 1;

  if (links == null) links = [];

  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }

  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations; ++k) {
      for (var i = 0, link, source, target, x = 0, y = 0, z = 0, l, b; i < n; ++i) {
        link = links[i], source = link.source, target = link.target;
        x = target.x + target.vx - source.x - source.vx || (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(random);
        if (nDim > 1) { y = target.y + target.vy - source.y - source.vy || (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(random); }
        if (nDim > 2) { z = target.z + target.vz - source.z - source.vz || (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(random); }
        l = Math.sqrt(x * x + y * y + z * z);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x *= l, y *= l, z *= l;

        target.vx -= x * (b = bias[i]);
        if (nDim > 1) { target.vy -= y * b; }
        if (nDim > 2) { target.vz -= z * b; }

        source.vx += x * (b = 1 - b);
        if (nDim > 1) { source.vy += y * b; }
        if (nDim > 2) { source.vz += z * b; }
      }
    }
  }

  function initialize() {
    if (!nodes) return;

    var i,
        n = nodes.length,
        m = links.length,
        nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d])),
        link;

    for (i = 0, count = new Array(n); i < m; ++i) {
      link = links[i], link.index = i;
      if (typeof link.source !== "object") link.source = find(nodeById, link.source);
      if (typeof link.target !== "object") link.target = find(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }

    for (i = 0, bias = new Array(m); i < m; ++i) {
      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }

    strengths = new Array(m), initializeStrength();
    distances = new Array(m), initializeDistance();
  }

  function initializeStrength() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }

  function initializeDistance() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }

  force.initialize = function(_nodes, ...args) {
    nodes = _nodes;
    random = args.find(arg => typeof arg === 'function') || Math.random;
    nDim = args.find(arg => [1, 2, 3].includes(arg)) || 2;
    initialize();
  };

  force.links = function(_) {
    return arguments.length ? (links = _, initialize(), force) : links;
  };

  force.id = function(_) {
    return arguments.length ? (id = _, force) : id;
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initializeStrength(), force) : strength;
  };

  force.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initializeDistance(), force) : distance;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force-3d/src/manyBody.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-force-3d/src/manyBody.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_binarytree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-binarytree */ "./node_modules/d3-binarytree/src/binarytree.js");
/* harmony import */ var d3_quadtree__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-quadtree */ "./node_modules/d3-quadtree/src/quadtree.js");
/* harmony import */ var d3_octree__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-octree */ "./node_modules/d3-octree/src/octree.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force-3d/src/constant.js");
/* harmony import */ var _jiggle_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./jiggle.js */ "./node_modules/d3-force-3d/src/jiggle.js");
/* harmony import */ var _simulation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./simulation.js */ "./node_modules/d3-force-3d/src/simulation.js");







/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var nodes,
      nDim,
      node,
      random,
      alpha,
      strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(-30),
      strengths,
      distanceMin2 = 1,
      distanceMax2 = Infinity,
      theta2 = 0.81;

  function force(_) {
    var i,
        n = nodes.length,
        tree =
            (nDim === 1 ? (0,d3_binarytree__WEBPACK_IMPORTED_MODULE_1__["default"])(nodes, _simulation_js__WEBPACK_IMPORTED_MODULE_2__.x)
            :(nDim === 2 ? (0,d3_quadtree__WEBPACK_IMPORTED_MODULE_3__["default"])(nodes, _simulation_js__WEBPACK_IMPORTED_MODULE_2__.x, _simulation_js__WEBPACK_IMPORTED_MODULE_2__.y)
            :(nDim === 3 ? (0,d3_octree__WEBPACK_IMPORTED_MODULE_4__["default"])(nodes, _simulation_js__WEBPACK_IMPORTED_MODULE_2__.x, _simulation_js__WEBPACK_IMPORTED_MODULE_2__.y, _simulation_js__WEBPACK_IMPORTED_MODULE_2__.z)
            :null
        ))).visitAfter(accumulate);

    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    strengths = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
  }

  function accumulate(treeNode) {
    var strength = 0, q, c, weight = 0, x, y, z, i;
    var numChildren = treeNode.length;

    // For internal nodes, accumulate forces from children.
    if (numChildren) {
      for (x = y = z = i = 0; i < numChildren; ++i) {
        if ((q = treeNode[i]) && (c = Math.abs(q.value))) {
          strength += q.value, weight += c, x += c * (q.x || 0), y += c * (q.y || 0), z += c * (q.z || 0);
        }
      }
      strength *= Math.sqrt(4 / numChildren); // scale accumulated strength according to number of dimensions

      treeNode.x = x / weight;
      if (nDim > 1) { treeNode.y = y / weight; }
      if (nDim > 2) { treeNode.z = z / weight; }
    }

    // For leaf nodes, accumulate forces from coincident nodes.
    else {
      q = treeNode;
      q.x = q.data.x;
      if (nDim > 1) { q.y = q.data.y; }
      if (nDim > 2) { q.z = q.data.z; }
      do strength += strengths[q.data.index];
      while (q = q.next);
    }

    treeNode.value = strength;
  }

  function apply(treeNode, x1, arg1, arg2, arg3) {
    if (!treeNode.value) return true;
    var x2 = [arg1, arg2, arg3][nDim-1];

    var x = treeNode.x - node.x,
        y = (nDim > 1 ? treeNode.y - node.y : 0),
        z = (nDim > 2 ? treeNode.z - node.z : 0),
        w = x2 - x1,
        l = x * x + y * y + z * z;

    // Apply the Barnes-Hut approximation if possible.
    // Limit forces for very close nodes; randomize direction if coincident.
    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x === 0) x = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_5__["default"])(random), l += x * x;
        if (nDim > 1 && y === 0) y = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_5__["default"])(random), l += y * y;
        if (nDim > 2 && z === 0) z = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_5__["default"])(random), l += z * z;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        node.vx += x * treeNode.value * alpha / l;
        if (nDim > 1) { node.vy += y * treeNode.value * alpha / l; }
        if (nDim > 2) { node.vz += z * treeNode.value * alpha / l; }
      }
      return true;
    }

    // Otherwise, process points directly.
    else if (treeNode.length || l >= distanceMax2) return;

    // Limit forces for very close nodes; randomize direction if coincident.
    if (treeNode.data !== node || treeNode.next) {
      if (x === 0) x = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_5__["default"])(random), l += x * x;
      if (nDim > 1 && y === 0) y = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_5__["default"])(random), l += y * y;
      if (nDim > 2 && z === 0) z = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_5__["default"])(random), l += z * z;
      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
    }

    do if (treeNode.data !== node) {
      w = strengths[treeNode.data.index] * alpha / l;
      node.vx += x * w;
      if (nDim > 1) { node.vy += y * w; }
      if (nDim > 2) { node.vz += z * w; }
    } while (treeNode = treeNode.next);
  }

  force.initialize = function(_nodes, ...args) {
    nodes = _nodes;
    random = args.find(arg => typeof arg === 'function') || Math.random;
    nDim = args.find(arg => [1, 2, 3].includes(arg)) || 2;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : strength;
  };

  force.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };

  force.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };

  force.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force-3d/src/radial.js":
/*!************************************************!*\
  !*** ./node_modules/d3-force-3d/src/radial.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force-3d/src/constant.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(radius, x, y, z) {
  var nodes,
      nDim,
      strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(0.1),
      strengths,
      radiuses;

  if (typeof radius !== "function") radius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+radius);
  if (x == null) x = 0;
  if (y == null) y = 0;
  if (z == null) z = 0;

  function force(alpha) {
    for (var i = 0, n = nodes.length; i < n; ++i) {
      var node = nodes[i],
          dx = node.x - x || 1e-6,
          dy = (node.y || 0) - y || 1e-6,
          dz = (node.z || 0) - z || 1e-6,
          r = Math.sqrt(dx * dx + dy * dy + dz * dz),
          k = (radiuses[i] - r) * strengths[i] * alpha / r;
      node.vx += dx * k;
      if (nDim>1) { node.vy += dy * k; }
      if (nDim>2) { node.vz += dz * k; }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    radiuses = new Array(n);
    for (i = 0; i < n; ++i) {
      radiuses[i] = +radius(nodes[i], i, nodes);
      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(initNodes, ...args) {
    nodes = initNodes;
    nDim = args.find(arg => [1, 2, 3].includes(arg)) || 2;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : radius;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  force.z = function(_) {
    return arguments.length ? (z = +_, force) : z;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force-3d/src/simulation.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-force-3d/src/simulation.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   x: () => (/* binding */ x),
/* harmony export */   y: () => (/* binding */ y),
/* harmony export */   z: () => (/* binding */ z)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timer.js");
/* harmony import */ var _lcg_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lcg.js */ "./node_modules/d3-force-3d/src/lcg.js");




var MAX_DIMENSIONS = 3;

function x(d) {
  return d.x;
}

function y(d) {
  return d.y;
}

function z(d) {
  return d.z;
}

var initialRadius = 10,
    initialAngleRoll = Math.PI * (3 - Math.sqrt(5)), // Golden ratio angle
    initialAngleYaw = Math.PI * 20 / (9 + Math.sqrt(221)); // Markov irrational number

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(nodes, numDimensions) {
  numDimensions = numDimensions || 2;

  var nDim = Math.min(MAX_DIMENSIONS, Math.max(1, Math.round(numDimensions))),
      simulation,
      alpha = 1,
      alphaMin = 0.001,
      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
      alphaTarget = 0,
      velocityDecay = 0.6,
      forces = new Map(),
      stepper = (0,d3_timer__WEBPACK_IMPORTED_MODULE_0__.timer)(step),
      event = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_1__["default"])("tick", "end"),
      random = (0,_lcg_js__WEBPACK_IMPORTED_MODULE_2__["default"])();

  if (nodes == null) nodes = [];

  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }

  function tick(iterations) {
    var i, n = nodes.length, node;

    if (iterations === undefined) iterations = 1;

    for (var k = 0; k < iterations; ++k) {
      alpha += (alphaTarget - alpha) * alphaDecay;

      forces.forEach(function (force) {
        force(alpha);
      });

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null) node.x += node.vx *= velocityDecay;
        else node.x = node.fx, node.vx = 0;
        if (nDim > 1) {
          if (node.fy == null) node.y += node.vy *= velocityDecay;
          else node.y = node.fy, node.vy = 0;
        }
        if (nDim > 2) {
          if (node.fz == null) node.z += node.vz *= velocityDecay;
          else node.z = node.fz, node.vz = 0;
        }
      }
    }

    return simulation;
  }

  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;
      if (node.fz != null) node.z = node.fz;
      if (isNaN(node.x) || (nDim > 1 && isNaN(node.y)) || (nDim > 2 && isNaN(node.z))) {
        var radius = initialRadius * (nDim > 2 ? Math.cbrt(0.5 + i) : (nDim > 1 ? Math.sqrt(0.5 + i) : i)),
          rollAngle = i * initialAngleRoll,
          yawAngle = i * initialAngleYaw;

        if (nDim === 1) {
          node.x = radius;
        } else if (nDim === 2) {
          node.x = radius * Math.cos(rollAngle);
          node.y = radius * Math.sin(rollAngle);
        } else { // 3 dimensions: use spherical distribution along 2 irrational number angles
          node.x = radius * Math.sin(rollAngle) * Math.cos(yawAngle);
          node.y = radius * Math.cos(rollAngle);
          node.z = radius * Math.sin(rollAngle) * Math.sin(yawAngle);
        }
      }
      if (isNaN(node.vx) || (nDim > 1 && isNaN(node.vy)) || (nDim > 2 && isNaN(node.vz))) {
        node.vx = 0;
        if (nDim > 1) { node.vy = 0; }
        if (nDim > 2) { node.vz = 0; }
      }
    }
  }

  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes, random, nDim);
    return force;
  }

  initializeNodes();

  return simulation = {
    tick: tick,

    restart: function() {
      return stepper.restart(step), simulation;
    },

    stop: function() {
      return stepper.stop(), simulation;
    },

    numDimensions: function(_) {
      return arguments.length
          ? (nDim = Math.min(MAX_DIMENSIONS, Math.max(1, Math.round(_))), forces.forEach(initializeForce), simulation)
          : nDim;
    },

    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },

    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },

    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },

    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },

    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },

    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },

    randomSource: function(_) {
      return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
    },

    force: function(name, _) {
      return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
    },

    find: function() {
      var args = Array.prototype.slice.call(arguments);
      var x = args.shift() || 0,
          y = (nDim > 1 ? args.shift() : null) || 0,
          z = (nDim > 2 ? args.shift() : null) || 0,
          radius = args.shift() || Infinity;

      var i = 0,
          n = nodes.length,
          dx,
          dy,
          dz,
          d2,
          node,
          closest;

      radius *= radius;

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x - node.x;
        dy = y - (node.y || 0);
        dz = z - (node.z ||0);
        d2 = dx * dx + dy * dy + dz * dz;
        if (d2 < radius) closest = node, radius = d2;
      }

      return closest;
    },

    on: function(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
}


/***/ }),

/***/ "./node_modules/d3-force-3d/src/x.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-force-3d/src/x.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force-3d/src/constant.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  var strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(0.1),
      nodes,
      strengths,
      xz;

  if (typeof x !== "function") x = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x == null ? 0 : +x);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : strength;
  };

  force.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : x;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force-3d/src/y.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-force-3d/src/y.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force-3d/src/constant.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(y) {
  var strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(0.1),
      nodes,
      strengths,
      yz;

  if (typeof y !== "function") y = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(y == null ? 0 : +y);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : strength;
  };

  force.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : y;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force-3d/src/z.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-force-3d/src/z.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force-3d/src/constant.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(z) {
  var strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(0.1),
      nodes,
      strengths,
      zz;

  if (typeof z !== "function") z = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(z == null ? 0 : +z);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vz += (zz[i] - node.z) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    zz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(zz[i] = +z(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : strength;
  };

  force.z = function(_) {
    return arguments.length ? (z = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : z;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force/src/center.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-force/src/center.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  var nodes, strength = 1;

  if (x == null) x = 0;
  if (y == null) y = 0;

  function force() {
    var i,
        n = nodes.length,
        node,
        sx = 0,
        sy = 0;

    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }

    for (sx = (sx / n - x) * strength, sy = (sy / n - y) * strength, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }

  force.initialize = function(_) {
    nodes = _;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force/src/collide.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-force/src/collide.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_quadtree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-quadtree */ "./node_modules/d3-quadtree/src/quadtree.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");
/* harmony import */ var _jiggle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./jiggle.js */ "./node_modules/d3-force/src/jiggle.js");




function x(d) {
  return d.x + d.vx;
}

function y(d) {
  return d.y + d.vy;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(radius) {
  var nodes,
      radii,
      random,
      strength = 1,
      iterations = 1;

  if (typeof radius !== "function") radius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(radius == null ? 1 : +radius);

  function force() {
    var i, n = nodes.length,
        tree,
        node,
        xi,
        yi,
        ri,
        ri2;

    for (var k = 0; k < iterations; ++k) {
      tree = (0,d3_quadtree__WEBPACK_IMPORTED_MODULE_1__["default"])(nodes, x, y).visitAfter(prepare);
      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }

    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data, rj = quad.r, r = ri + rj;
      if (data) {
        if (data.index > node.index) {
          var x = xi - data.x - data.vx,
              y = yi - data.y - data.vy,
              l = x * x + y * y;
          if (l < r * r) {
            if (x === 0) x = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(random), l += x * x;
            if (y === 0) y = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(random), l += y * y;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y *= l) * r;
            data.vx -= x * (r = 1 - r);
            data.vy -= y * r;
          }
        }
        return;
      }
      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }

  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];
    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    radii = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }

  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : radius;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force/src/constant.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-force/src/constant.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return function() {
    return x;
  };
}


/***/ }),

/***/ "./node_modules/d3-force/src/jiggle.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-force/src/jiggle.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(random) {
  return (random() - 0.5) * 1e-6;
}


/***/ }),

/***/ "./node_modules/d3-force/src/lcg.js":
/*!******************************************!*\
  !*** ./node_modules/d3-force/src/lcg.js ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use
const a = 1664525;
const c = 1013904223;
const m = 4294967296; // 2^32

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  let s = 1;
  return () => (s = (a * s + c) % m) / m;
}


/***/ }),

/***/ "./node_modules/d3-force/src/link.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-force/src/link.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");
/* harmony import */ var _jiggle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./jiggle.js */ "./node_modules/d3-force/src/jiggle.js");



function index(d) {
  return d.index;
}

function find(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("node not found: " + nodeId);
  return node;
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(links) {
  var id = index,
      strength = defaultStrength,
      strengths,
      distance = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(30),
      distances,
      nodes,
      count,
      bias,
      random,
      iterations = 1;

  if (links == null) links = [];

  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }

  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations; ++k) {
      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
        link = links[i], source = link.source, target = link.target;
        x = target.x + target.vx - source.x - source.vx || (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(random);
        y = target.y + target.vy - source.y - source.vy || (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(random);
        l = Math.sqrt(x * x + y * y);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x *= l, y *= l;
        target.vx -= x * (b = bias[i]);
        target.vy -= y * b;
        source.vx += x * (b = 1 - b);
        source.vy += y * b;
      }
    }
  }

  function initialize() {
    if (!nodes) return;

    var i,
        n = nodes.length,
        m = links.length,
        nodeById = new Map(nodes.map((d, i) => [id(d, i, nodes), d])),
        link;

    for (i = 0, count = new Array(n); i < m; ++i) {
      link = links[i], link.index = i;
      if (typeof link.source !== "object") link.source = find(nodeById, link.source);
      if (typeof link.target !== "object") link.target = find(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }

    for (i = 0, bias = new Array(m); i < m; ++i) {
      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }

    strengths = new Array(m), initializeStrength();
    distances = new Array(m), initializeDistance();
  }

  function initializeStrength() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }

  function initializeDistance() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }

  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };

  force.links = function(_) {
    return arguments.length ? (links = _, initialize(), force) : links;
  };

  force.id = function(_) {
    return arguments.length ? (id = _, force) : id;
  };

  force.iterations = function(_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initializeStrength(), force) : strength;
  };

  force.distance = function(_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initializeDistance(), force) : distance;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force/src/manyBody.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-force/src/manyBody.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var d3_quadtree__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-quadtree */ "./node_modules/d3-quadtree/src/quadtree.js");
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");
/* harmony import */ var _jiggle_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./jiggle.js */ "./node_modules/d3-force/src/jiggle.js");
/* harmony import */ var _simulation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./simulation.js */ "./node_modules/d3-force/src/simulation.js");





/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var nodes,
      node,
      random,
      alpha,
      strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(-30),
      strengths,
      distanceMin2 = 1,
      distanceMax2 = Infinity,
      theta2 = 0.81;

  function force(_) {
    var i, n = nodes.length, tree = (0,d3_quadtree__WEBPACK_IMPORTED_MODULE_1__["default"])(nodes, _simulation_js__WEBPACK_IMPORTED_MODULE_2__.x, _simulation_js__WEBPACK_IMPORTED_MODULE_2__.y).visitAfter(accumulate);
    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length, node;
    strengths = new Array(n);
    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
  }

  function accumulate(quad) {
    var strength = 0, q, c, weight = 0, x, y, i;

    // For internal nodes, accumulate forces from child quadrants.
    if (quad.length) {
      for (x = y = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c = Math.abs(q.value))) {
          strength += q.value, weight += c, x += c * q.x, y += c * q.y;
        }
      }
      quad.x = x / weight;
      quad.y = y / weight;
    }

    // For leaf nodes, accumulate forces from coincident quadrants.
    else {
      q = quad;
      q.x = q.data.x;
      q.y = q.data.y;
      do strength += strengths[q.data.index];
      while (q = q.next);
    }

    quad.value = strength;
  }

  function apply(quad, x1, _, x2) {
    if (!quad.value) return true;

    var x = quad.x - node.x,
        y = quad.y - node.y,
        w = x2 - x1,
        l = x * x + y * y;

    // Apply the Barnes-Hut approximation if possible.
    // Limit forces for very close nodes; randomize direction if coincident.
    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x === 0) x = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_3__["default"])(random), l += x * x;
        if (y === 0) y = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_3__["default"])(random), l += y * y;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        node.vx += x * quad.value * alpha / l;
        node.vy += y * quad.value * alpha / l;
      }
      return true;
    }

    // Otherwise, process points directly.
    else if (quad.length || l >= distanceMax2) return;

    // Limit forces for very close nodes; randomize direction if coincident.
    if (quad.data !== node || quad.next) {
      if (x === 0) x = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_3__["default"])(random), l += x * x;
      if (y === 0) y = (0,_jiggle_js__WEBPACK_IMPORTED_MODULE_3__["default"])(random), l += y * y;
      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
    }

    do if (quad.data !== node) {
      w = strengths[quad.data.index] * alpha / l;
      node.vx += x * w;
      node.vy += y * w;
    } while (quad = quad.next);
  }

  force.initialize = function(_nodes, _random) {
    nodes = _nodes;
    random = _random;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : strength;
  };

  force.distanceMin = function(_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };

  force.distanceMax = function(_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };

  force.theta = function(_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force/src/radial.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-force/src/radial.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(radius, x, y) {
  var nodes,
      strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(0.1),
      strengths,
      radiuses;

  if (typeof radius !== "function") radius = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+radius);
  if (x == null) x = 0;
  if (y == null) y = 0;

  function force(alpha) {
    for (var i = 0, n = nodes.length; i < n; ++i) {
      var node = nodes[i],
          dx = node.x - x || 1e-6,
          dy = node.y - y || 1e-6,
          r = Math.sqrt(dx * dx + dy * dy),
          k = (radiuses[i] - r) * strengths[i] * alpha / r;
      node.vx += dx * k;
      node.vy += dy * k;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    radiuses = new Array(n);
    for (i = 0; i < n; ++i) {
      radiuses[i] = +radius(nodes[i], i, nodes);
      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _, initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : strength;
  };

  force.radius = function(_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : radius;
  };

  force.x = function(_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function(_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force/src/simulation.js":
/*!*************************************************!*\
  !*** ./node_modules/d3-force/src/simulation.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   x: () => (/* binding */ x),
/* harmony export */   y: () => (/* binding */ y)
/* harmony export */ });
/* harmony import */ var d3_dispatch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-dispatch */ "./node_modules/d3-dispatch/src/dispatch.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/timer.js");
/* harmony import */ var _lcg_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lcg.js */ "./node_modules/d3-force/src/lcg.js");




function x(d) {
  return d.x;
}

function y(d) {
  return d.y;
}

var initialRadius = 10,
    initialAngle = Math.PI * (3 - Math.sqrt(5));

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(nodes) {
  var simulation,
      alpha = 1,
      alphaMin = 0.001,
      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
      alphaTarget = 0,
      velocityDecay = 0.6,
      forces = new Map(),
      stepper = (0,d3_timer__WEBPACK_IMPORTED_MODULE_0__.timer)(step),
      event = (0,d3_dispatch__WEBPACK_IMPORTED_MODULE_1__["default"])("tick", "end"),
      random = (0,_lcg_js__WEBPACK_IMPORTED_MODULE_2__["default"])();

  if (nodes == null) nodes = [];

  function step() {
    tick();
    event.call("tick", simulation);
    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }

  function tick(iterations) {
    var i, n = nodes.length, node;

    if (iterations === undefined) iterations = 1;

    for (var k = 0; k < iterations; ++k) {
      alpha += (alphaTarget - alpha) * alphaDecay;

      forces.forEach(function(force) {
        force(alpha);
      });

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        if (node.fx == null) node.x += node.vx *= velocityDecay;
        else node.x = node.fx, node.vx = 0;
        if (node.fy == null) node.y += node.vy *= velocityDecay;
        else node.y = node.fy, node.vy = 0;
      }
    }

    return simulation;
  }

  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;
      if (node.fx != null) node.x = node.fx;
      if (node.fy != null) node.y = node.fy;
      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(0.5 + i), angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }
      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }

  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes, random);
    return force;
  }

  initializeNodes();

  return simulation = {
    tick: tick,

    restart: function() {
      return stepper.restart(step), simulation;
    },

    stop: function() {
      return stepper.stop(), simulation;
    },

    nodes: function(_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.forEach(initializeForce), simulation) : nodes;
    },

    alpha: function(_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },

    alphaMin: function(_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },

    alphaDecay: function(_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },

    alphaTarget: function(_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },

    velocityDecay: function(_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },

    randomSource: function(_) {
      return arguments.length ? (random = _, forces.forEach(initializeForce), simulation) : random;
    },

    force: function(name, _) {
      return arguments.length > 1 ? ((_ == null ? forces.delete(name) : forces.set(name, initializeForce(_))), simulation) : forces.get(name);
    },

    find: function(x, y, radius) {
      var i = 0,
          n = nodes.length,
          dx,
          dy,
          d2,
          node,
          closest;

      if (radius == null) radius = Infinity;
      else radius *= radius;

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x - node.x;
        dy = y - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }

      return closest;
    },

    on: function(name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
}


/***/ }),

/***/ "./node_modules/d3-force/src/x.js":
/*!****************************************!*\
  !*** ./node_modules/d3-force/src/x.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  var strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(0.1),
      nodes,
      strengths,
      xz;

  if (typeof x !== "function") x = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(x == null ? 0 : +x);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : strength;
  };

  force.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : x;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-force/src/y.js":
/*!****************************************!*\
  !*** ./node_modules/d3-force/src/y.js ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _constant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constant.js */ "./node_modules/d3-force/src/constant.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(y) {
  var strength = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(0.1),
      nodes,
      strengths,
      yz;

  if (typeof y !== "function") y = (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(y == null ? 0 : +y);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i, n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);
    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function(_) {
    nodes = _;
    initialize();
  };

  force.strength = function(_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : strength;
  };

  force.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0,_constant_js__WEBPACK_IMPORTED_MODULE_0__["default"])(+_), initialize(), force) : y;
  };

  return force;
}


/***/ }),

/***/ "./node_modules/d3-octree/src/add.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-octree/src/add.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addAll: () => (/* binding */ addAll),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  const x = +this._x.call(null, d),
      y = +this._y.call(null, d),
      z = +this._z.call(null, d);
  return add(this.cover(x, y, z), x, y, z, d);
}

function add(tree, x, y, z, d) {
  if (isNaN(x) || isNaN(y) || isNaN(z)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      z0 = tree._z0,
      x1 = tree._x1,
      y1 = tree._y1,
      z1 = tree._z1,
      xm,
      ym,
      zm,
      xp,
      yp,
      zp,
      right,
      bottom,
      deep,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (deep = z >= (zm = (z0 + z1) / 2)) z0 = zm; else z1 = zm;
    if (parent = node, !(node = node[i = deep << 2 | bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  zp = +tree._z.call(null, node.data);
  if (x === xp && y === yp && z === zp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(8) : tree._root = new Array(8);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (deep = z >= (zm = (z0 + z1) / 2)) z0 = zm; else z1 = zm;
  } while ((i = deep << 2 | bottom << 1 | right) === (j = (zp >= zm) << 2 | (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  if (!Array.isArray(data)) data = Array.from(data);
  const n = data.length;
  const xz = new Float64Array(n);
  const yz = new Float64Array(n);
  const zz = new Float64Array(n);
  let x0 = Infinity,
      y0 = Infinity,
      z0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity,
      z1 = -Infinity;

  // Compute the points and their extent.
  for (let i = 0, d, x, y, z; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d)) || isNaN(z = +this._z.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    zz[i] = z;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
    if (z < z0) z0 = z;
    if (z > z1) z1 = z;
  }

  // If there were no (valid) points, abort.
  if (x0 > x1 || y0 > y1 || z0 > z1) return this;

  // Expand the tree to cover the new points.
  this.cover(x0, y0, z0).cover(x1, y1, z1);

  // Add the new points.
  for (let i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], zz[i], data[i]);
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-octree/src/cover.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-octree/src/cover.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y, z) {
  if (isNaN(x = +x) || isNaN(y = +y) || isNaN(z = +z)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      z0 = this._z0,
      x1 = this._x1,
      y1 = this._y1,
      z1 = this._z1;

  // If the octree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing octant boundaries don’t change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
    z1 = (z0 = Math.floor(z)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else {
    var t = x1 - x0 || 1,
        node = this._root,
        parent,
        i;

    while (x0 > x || x >= x1 || y0 > y || y >= y1 || z0 > z || z >= z1) {
      i = (z < z0) << 2 | (y < y0) << 1 | (x < x0);
      parent = new Array(8), parent[i] = node, node = parent, t *= 2;
      switch (i) {
        case 0: x1 = x0 + t, y1 = y0 + t, z1 = z0 + t; break;
        case 1: x0 = x1 - t, y1 = y0 + t, z1 = z0 + t; break;
        case 2: x1 = x0 + t, y0 = y1 - t, z1 = z0 + t; break;
        case 3: x0 = x1 - t, y0 = y1 - t, z1 = z0 + t; break;
        case 4: x1 = x0 + t, y1 = y0 + t, z0 = z1 - t; break;
        case 5: x0 = x1 - t, y1 = y0 + t, z0 = z1 - t; break;
        case 6: x1 = x0 + t, y0 = y1 - t, z0 = z1 - t; break;
        case 7: x0 = x1 - t, y0 = y1 - t, z0 = z1 - t; break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  this._x0 = x0;
  this._y0 = y0;
  this._z0 = z0;
  this._x1 = x1;
  this._y1 = y1;
  this._z1 = z1;
  return this;
}


/***/ }),

/***/ "./node_modules/d3-octree/src/data.js":
/*!********************************************!*\
  !*** ./node_modules/d3-octree/src/data.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
}


/***/ }),

/***/ "./node_modules/d3-octree/src/extent.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-octree/src/extent.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1], +_[0][2]).cover(+_[1][0], +_[1][1], +_[1][2])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0, this._z0], [this._x1, this._y1, this._z1]];
}


/***/ }),

/***/ "./node_modules/d3-octree/src/find.js":
/*!********************************************!*\
  !*** ./node_modules/d3-octree/src/find.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _octant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./octant.js */ "./node_modules/d3-octree/src/octant.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y, z, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      z0 = this._z0,
      x1,
      y1,
      z1,
      x2,
      y2,
      z2,
      x3 = this._x1,
      y3 = this._y1,
      z3 = this._z1,
      octs = [],
      node = this._root,
      q,
      i;

  if (node) octs.push(new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](node, x0, y0, z0, x3, y3, z3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius, z0 = z - radius;
    x3 = x + radius, y3 = y + radius, z3 = z + radius;
    radius *= radius;
  }

  while (q = octs.pop()) {

    // Stop searching if this octant can’t contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (z1 = q.z0) > z3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0
        || (z2 = q.z1) < z0) continue;

    // Bisect the current octant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2,
          zm = (z1 + z2) / 2;

      octs.push(
        new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[7], xm, ym, zm, x2, y2, z2),
        new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[6], x1, ym, zm, xm, y2, z2),
        new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[5], xm, y1, zm, x2, ym, z2),
        new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[4], x1, y1, zm, xm, ym, z2),
        new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[3], xm, ym, z1, x2, y2, zm),
        new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[2], x1, ym, z1, xm, y2, zm),
        new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[1], xm, y1, z1, x2, ym, zm),
        new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[0], x1, y1, z1, xm, ym, zm)
      );

      // Visit the closest octant first.
      if (i = (z >= zm) << 2 | (y >= ym) << 1 | (x >= xm)) {
        q = octs[octs.length - 1];
        octs[octs.length - 1] = octs[octs.length - 1 - i];
        octs[octs.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isn’t necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          dz = z - +this._z.call(null, node.data),
          d2 = dx * dx + dy * dy + dz * dz;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d, z0 = z - d;
        x3 = x + d, y3 = y + d, z3 = z + d;
        data = node.data;
      }
    }
  }

  return data;
}


/***/ }),

/***/ "./node_modules/d3-octree/src/findAll.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-octree/src/findAll.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   findAllWithinRadius: () => (/* binding */ findAllWithinRadius)
/* harmony export */ });
const distance = (x1, y1, z1, x2, y2, z2) => Math.sqrt((x1-x2)**2 + (y1-y2)**2 + (z1-z2)**2);

function findAllWithinRadius(x, y, z, radius) {
  const result = [];

  const xMin = x - radius;
  const yMin = y - radius;
  const zMin = z - radius;
  const xMax = x + radius;
  const yMax = y + radius;
  const zMax = z + radius;

  this.visit((node, x1, y1, z1, x2, y2, z2) => {
    if (!node.length) {
      do {
        const d = node.data;
        if (distance(x, y, z, this._x(d), this._y(d), this._z(d)) <= radius) {
          result.push(d);
        }
      } while (node = node.next);
    }
    return x1 > xMax || y1 > yMax || z1 > zMax || x2 < xMin || y2 < yMin || z2 < zMin;
  });

  return result;
}


/***/ }),

/***/ "./node_modules/d3-octree/src/octant.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-octree/src/octant.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, x0, y0, z0, x1, y1, z1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.z0 = z0;
  this.x1 = x1;
  this.y1 = y1;
  this.z1 = z1;
}


/***/ }),

/***/ "./node_modules/d3-octree/src/octree.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-octree/src/octree.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ octree)
/* harmony export */ });
/* harmony import */ var _add_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./add.js */ "./node_modules/d3-octree/src/add.js");
/* harmony import */ var _cover_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cover.js */ "./node_modules/d3-octree/src/cover.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./data.js */ "./node_modules/d3-octree/src/data.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./extent.js */ "./node_modules/d3-octree/src/extent.js");
/* harmony import */ var _find_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./find.js */ "./node_modules/d3-octree/src/find.js");
/* harmony import */ var _findAll_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./findAll.js */ "./node_modules/d3-octree/src/findAll.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-octree/src/remove.js");
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./root.js */ "./node_modules/d3-octree/src/root.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./size.js */ "./node_modules/d3-octree/src/size.js");
/* harmony import */ var _visit_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./visit.js */ "./node_modules/d3-octree/src/visit.js");
/* harmony import */ var _visitAfter_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./visitAfter.js */ "./node_modules/d3-octree/src/visitAfter.js");
/* harmony import */ var _x_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./x.js */ "./node_modules/d3-octree/src/x.js");
/* harmony import */ var _y_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./y.js */ "./node_modules/d3-octree/src/y.js");
/* harmony import */ var _z_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./z.js */ "./node_modules/d3-octree/src/z.js");















function octree(nodes, x, y, z) {
  var tree = new Octree(x == null ? _x_js__WEBPACK_IMPORTED_MODULE_0__.defaultX : x, y == null ? _y_js__WEBPACK_IMPORTED_MODULE_1__.defaultY : y, z == null ? _z_js__WEBPACK_IMPORTED_MODULE_2__.defaultZ : z, NaN, NaN, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Octree(x, y, z, x0, y0, z0, x1, y1, z1) {
  this._x = x;
  this._y = y;
  this._z = z;
  this._x0 = x0;
  this._y0 = y0;
  this._z0 = z0;
  this._x1 = x1;
  this._y1 = y1;
  this._z1 = z1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = octree.prototype = Octree.prototype;

treeProto.copy = function() {
  var copy = new Octree(this._x, this._y, this._z, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(8)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 8; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(8)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = _add_js__WEBPACK_IMPORTED_MODULE_3__["default"];
treeProto.addAll = _add_js__WEBPACK_IMPORTED_MODULE_3__.addAll;
treeProto.cover = _cover_js__WEBPACK_IMPORTED_MODULE_4__["default"];
treeProto.data = _data_js__WEBPACK_IMPORTED_MODULE_5__["default"];
treeProto.extent = _extent_js__WEBPACK_IMPORTED_MODULE_6__["default"];
treeProto.find = _find_js__WEBPACK_IMPORTED_MODULE_7__["default"];
treeProto.findAllWithinRadius = _findAll_js__WEBPACK_IMPORTED_MODULE_8__.findAllWithinRadius;
treeProto.remove = _remove_js__WEBPACK_IMPORTED_MODULE_9__["default"];
treeProto.removeAll = _remove_js__WEBPACK_IMPORTED_MODULE_9__.removeAll;
treeProto.root = _root_js__WEBPACK_IMPORTED_MODULE_10__["default"];
treeProto.size = _size_js__WEBPACK_IMPORTED_MODULE_11__["default"];
treeProto.visit = _visit_js__WEBPACK_IMPORTED_MODULE_12__["default"];
treeProto.visitAfter = _visitAfter_js__WEBPACK_IMPORTED_MODULE_13__["default"];
treeProto.x = _x_js__WEBPACK_IMPORTED_MODULE_0__["default"];
treeProto.y = _y_js__WEBPACK_IMPORTED_MODULE_1__["default"];
treeProto.z = _z_js__WEBPACK_IMPORTED_MODULE_2__["default"];


/***/ }),

/***/ "./node_modules/d3-octree/src/remove.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-octree/src/remove.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   removeAll: () => (/* binding */ removeAll)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d)) || isNaN(z = +this._z.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      z0 = this._z0,
      x1 = this._x1,
      y1 = this._y1,
      z1 = this._z1,
      x,
      y,
      z,
      xm,
      ym,
      zm,
      right,
      bottom,
      deep,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (deep = z >= (zm = (z0 + z1) / 2)) z0 = zm; else z1 = zm;
    if (!(parent = node, node = node[i = deep << 2 | bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 7] || parent[(i + 2) & 7] || parent[(i + 3) & 7] || parent[(i + 4) & 7] || parent[(i + 5) & 7] || parent[(i + 6) & 7] || parent[(i + 7) & 7]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3] || parent[4] || parent[5] || parent[6] || parent[7])
      && node === (parent[7] || parent[6] || parent[5] || parent[4] || parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
}

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}


/***/ }),

/***/ "./node_modules/d3-octree/src/root.js":
/*!********************************************!*\
  !*** ./node_modules/d3-octree/src/root.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this._root;
}


/***/ }),

/***/ "./node_modules/d3-octree/src/size.js":
/*!********************************************!*\
  !*** ./node_modules/d3-octree/src/size.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
}


/***/ }),

/***/ "./node_modules/d3-octree/src/visit.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-octree/src/visit.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _octant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./octant.js */ "./node_modules/d3-octree/src/octant.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {
  var octs = [], q, node = this._root, child, x0, y0, z0, x1, y1, z1;
  if (node) octs.push(new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](node, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1));
  while (q = octs.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, z0 = q.z0, x1 = q.x1, y1 = q.y1, z1 = q.z1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2, zm = (z0 + z1) / 2;
      if (child = node[7]) octs.push(new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, ym, zm, x1, y1, z1));
      if (child = node[6]) octs.push(new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, ym, zm, xm, y1, z1));
      if (child = node[5]) octs.push(new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, y0, zm, x1, ym, z1));
      if (child = node[4]) octs.push(new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, y0, zm, xm, ym, z1));
      if (child = node[3]) octs.push(new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, ym, z0, x1, y1, zm));
      if (child = node[2]) octs.push(new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, ym, z0, xm, y1, zm));
      if (child = node[1]) octs.push(new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, y0, z0, x1, ym, zm));
      if (child = node[0]) octs.push(new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, y0, z0, xm, ym, zm));
    }
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-octree/src/visitAfter.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-octree/src/visitAfter.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _octant_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./octant.js */ "./node_modules/d3-octree/src/octant.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {
  var octs = [], next = [], q;
  if (this._root) octs.push(new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](this._root, this._x0, this._y0, this._z0, this._x1, this._y1, this._z1));
  while (q = octs.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, z0 = q.z0, x1 = q.x1, y1 = q.y1, z1 = q.z1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2, zm = (z0 + z1) / 2;
      if (child = node[0]) octs.push(new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, y0, z0, xm, ym, zm));
      if (child = node[1]) octs.push(new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, y0, z0, x1, ym, zm));
      if (child = node[2]) octs.push(new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, ym, z0, xm, y1, zm));
      if (child = node[3]) octs.push(new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, ym, z0, x1, y1, zm));
      if (child = node[4]) octs.push(new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, y0, zm, xm, ym, z1));
      if (child = node[5]) octs.push(new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, y0, zm, x1, ym, z1));
      if (child = node[6]) octs.push(new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, ym, zm, xm, y1, z1));
      if (child = node[7]) octs.push(new _octant_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, ym, zm, x1, y1, z1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.z0, q.x1, q.y1, q.z1);
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-octree/src/x.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-octree/src/x.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultX: () => (/* binding */ defaultX)
/* harmony export */ });
function defaultX(d) {
  return d[0];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}


/***/ }),

/***/ "./node_modules/d3-octree/src/y.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-octree/src/y.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultY: () => (/* binding */ defaultY)
/* harmony export */ });
function defaultY(d) {
  return d[1];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}


/***/ }),

/***/ "./node_modules/d3-octree/src/z.js":
/*!*****************************************!*\
  !*** ./node_modules/d3-octree/src/z.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultZ: () => (/* binding */ defaultZ)
/* harmony export */ });
function defaultZ(d) {
  return d[2];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length ? (this._z = _, this) : this._z;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/add.js":
/*!*********************************************!*\
  !*** ./node_modules/d3-quadtree/src/add.js ***!
  \*********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addAll: () => (/* binding */ addAll),
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  const x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
}

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {data: d},
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return tree._root = leaf, tree;

  // Find the existing leaf for the new point, or add it.
  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  }

  // Is the new point is exactly coincident with the existing point?
  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree;

  // Otherwise, split the leaf node until the old and new point are separated.
  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | (xp >= xm)));
  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d, i, n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity;

  // Compute the points and their extent.
  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  }

  // If there were no (valid) points, abort.
  if (x0 > x1 || y0 > y1) return this;

  // Expand the tree to cover the new points.
  this.cover(x0, y0).cover(x1, y1);

  // Add the new points.
  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/cover.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-quadtree/src/cover.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1;

  // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries don’t change due to floating point error!
  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  }

  // Otherwise, double repeatedly to cover.
  else {
    var z = x1 - x0 || 1,
        node = this._root,
        parent,
        i;

    while (x0 > x || x >= x1 || y0 > y || y >= y1) {
      i = (y < y0) << 1 | (x < x0);
      parent = new Array(4), parent[i] = node, node = parent, z *= 2;
      switch (i) {
        case 0: x1 = x0 + z, y1 = y0 + z; break;
        case 1: x0 = x1 - z, y1 = y0 + z; break;
        case 2: x1 = x0 + z, y0 = y1 - z; break;
        case 3: x0 = x1 - z, y0 = y1 - z; break;
      }
    }

    if (this._root && this._root.length) this._root = node;
  }

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/data.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/data.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var data = [];
  this.visit(function(node) {
    if (!node.length) do data.push(node.data); while (node = node.next)
  });
  return data;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/extent.js":
/*!************************************************!*\
  !*** ./node_modules/d3-quadtree/src/extent.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length
      ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1])
      : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/find.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/find.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;

  if (node) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;
  else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {

    // Stop searching if this quadrant can’t contain a closer node.
    if (!(node = q.node)
        || (x1 = q.x0) > x3
        || (y1 = q.y0) > y3
        || (x2 = q.x1) < x0
        || (y2 = q.y1) < y0) continue;

    // Bisect the current quadrant.
    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;

      quads.push(
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[3], xm, ym, x2, y2),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[2], x1, ym, xm, y2),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[1], xm, y1, x2, ym),
        new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node[0], x1, y1, xm, ym)
      );

      // Visit the closest quadrant first.
      if (i = (y >= ym) << 1 | (x >= xm)) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    }

    // Visit this point. (Visiting coincident points isn’t necessary!)
    else {
      var dx = x - +this._x.call(null, node.data),
          dy = y - +this._y.call(null, node.data),
          d2 = dx * dx + dy * dy;
      if (d2 < radius) {
        var d = Math.sqrt(radius = d2);
        x0 = x - d, y0 = y - d;
        x3 = x + d, y3 = y + d;
        data = node.data;
      }
    }
  }

  return data;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/quad.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/quad.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/quadtree.js":
/*!**************************************************!*\
  !*** ./node_modules/d3-quadtree/src/quadtree.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ quadtree)
/* harmony export */ });
/* harmony import */ var _add_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./add.js */ "./node_modules/d3-quadtree/src/add.js");
/* harmony import */ var _cover_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./cover.js */ "./node_modules/d3-quadtree/src/cover.js");
/* harmony import */ var _data_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data.js */ "./node_modules/d3-quadtree/src/data.js");
/* harmony import */ var _extent_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./extent.js */ "./node_modules/d3-quadtree/src/extent.js");
/* harmony import */ var _find_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./find.js */ "./node_modules/d3-quadtree/src/find.js");
/* harmony import */ var _remove_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./remove.js */ "./node_modules/d3-quadtree/src/remove.js");
/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./root.js */ "./node_modules/d3-quadtree/src/root.js");
/* harmony import */ var _size_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./size.js */ "./node_modules/d3-quadtree/src/size.js");
/* harmony import */ var _visit_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./visit.js */ "./node_modules/d3-quadtree/src/visit.js");
/* harmony import */ var _visitAfter_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./visitAfter.js */ "./node_modules/d3-quadtree/src/visitAfter.js");
/* harmony import */ var _x_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./x.js */ "./node_modules/d3-quadtree/src/x.js");
/* harmony import */ var _y_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./y.js */ "./node_modules/d3-quadtree/src/y.js");













function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? _x_js__WEBPACK_IMPORTED_MODULE_0__.defaultX : x, y == null ? _y_js__WEBPACK_IMPORTED_MODULE_1__.defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {data: leaf.data}, next = copy;
  while (leaf = leaf.next) next = next.next = {data: leaf.data};
  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function() {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;

  if (!node) return copy;

  if (!node.length) return copy._root = leaf_copy(node), copy;

  nodes = [{source: node, target: copy._root = new Array(4)}];
  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({source: child, target: node.target[i] = new Array(4)});
        else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = _add_js__WEBPACK_IMPORTED_MODULE_2__["default"];
treeProto.addAll = _add_js__WEBPACK_IMPORTED_MODULE_2__.addAll;
treeProto.cover = _cover_js__WEBPACK_IMPORTED_MODULE_3__["default"];
treeProto.data = _data_js__WEBPACK_IMPORTED_MODULE_4__["default"];
treeProto.extent = _extent_js__WEBPACK_IMPORTED_MODULE_5__["default"];
treeProto.find = _find_js__WEBPACK_IMPORTED_MODULE_6__["default"];
treeProto.remove = _remove_js__WEBPACK_IMPORTED_MODULE_7__["default"];
treeProto.removeAll = _remove_js__WEBPACK_IMPORTED_MODULE_7__.removeAll;
treeProto.root = _root_js__WEBPACK_IMPORTED_MODULE_8__["default"];
treeProto.size = _size_js__WEBPACK_IMPORTED_MODULE_9__["default"];
treeProto.visit = _visit_js__WEBPACK_IMPORTED_MODULE_10__["default"];
treeProto.visitAfter = _visitAfter_js__WEBPACK_IMPORTED_MODULE_11__["default"];
treeProto.x = _x_js__WEBPACK_IMPORTED_MODULE_0__["default"];
treeProto.y = _y_js__WEBPACK_IMPORTED_MODULE_1__["default"];


/***/ }),

/***/ "./node_modules/d3-quadtree/src/remove.js":
/*!************************************************!*\
  !*** ./node_modules/d3-quadtree/src/remove.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   removeAll: () => (/* binding */ removeAll)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j;

  // If the tree is empty, initialize the root as a leaf.
  if (!node) return this;

  // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.
  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm; else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym; else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[(i + 1) & 3] || parent[(i + 2) & 3] || parent[(i + 3) & 3]) retainer = parent, j = i;
  }

  // Find the point to remove.
  while (node.data !== d) if (!(previous = node, node = node.next)) return this;
  if (next = node.next) delete node.next;

  // If there are multiple coincident points, remove just the point.
  if (previous) return (next ? previous.next = next : delete previous.next), this;

  // If this is the root point, remove it.
  if (!parent) return this._root = next, this;

  // Remove this leaf.
  next ? parent[i] = next : delete parent[i];

  // If the parent now contains exactly one leaf, collapse superfluous parents.
  if ((node = parent[0] || parent[1] || parent[2] || parent[3])
      && node === (parent[3] || parent[2] || parent[1] || parent[0])
      && !node.length) {
    if (retainer) retainer[j] = node;
    else this._root = node;
  }

  return this;
}

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/root.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/root.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return this._root;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/size.js":
/*!**********************************************!*\
  !*** ./node_modules/d3-quadtree/src/size.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  var size = 0;
  this.visit(function(node) {
    if (!node.length) do ++size; while (node = node.next)
  });
  return size;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/visit.js":
/*!***********************************************!*\
  !*** ./node_modules/d3-quadtree/src/visit.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {
  var quads = [], q, node = this._root, child, x0, y0, x1, y1;
  if (node) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](node, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, y0, xm, ym));
    }
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/visitAfter.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-quadtree/src/visitAfter.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _quad_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./quad.js */ "./node_modules/d3-quadtree/src/quad.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(callback) {
  var quads = [], next = [], q;
  if (this._root) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](this._root, this._x0, this._y0, this._x1, this._y1));
  while (q = quads.pop()) {
    var node = q.node;
    if (node.length) {
      var child, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1, xm = (x0 + x1) / 2, ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new _quad_js__WEBPACK_IMPORTED_MODULE_0__["default"](child, xm, ym, x1, y1));
    }
    next.push(q);
  }
  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }
  return this;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/x.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-quadtree/src/x.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultX: () => (/* binding */ defaultX)
/* harmony export */ });
function defaultX(d) {
  return d[0];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}


/***/ }),

/***/ "./node_modules/d3-quadtree/src/y.js":
/*!*******************************************!*\
  !*** ./node_modules/d3-quadtree/src/y.js ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   defaultY: () => (/* binding */ defaultY)
/* harmony export */ });
function defaultY(d) {
  return d[1];
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}


/***/ }),

/***/ "./node_modules/d3-timer/src/timer.js":
/*!********************************************!*\
  !*** ./node_modules/d3-timer/src/timer.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Timer: () => (/* binding */ Timer),
/* harmony export */   now: () => (/* binding */ now),
/* harmony export */   timer: () => (/* binding */ timer),
/* harmony export */   timerFlush: () => (/* binding */ timerFlush)
/* harmony export */ });
var frame = 0, // is an animation frame pending?
    timeout = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}


/***/ }),

/***/ "./node_modules/dagre/index.js":
/*!*************************************!*\
  !*** ./node_modules/dagre/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
Copyright (c) 2012-2014 Chris Pettitt

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

module.exports = {
  graphlib: __webpack_require__(/*! ./lib/graphlib */ "./node_modules/dagre/lib/graphlib.js"),

  layout: __webpack_require__(/*! ./lib/layout */ "./node_modules/dagre/lib/layout.js"),
  debug: __webpack_require__(/*! ./lib/debug */ "./node_modules/dagre/lib/debug.js"),
  util: {
    time: (__webpack_require__(/*! ./lib/util */ "./node_modules/dagre/lib/util.js").time),
    notime: (__webpack_require__(/*! ./lib/util */ "./node_modules/dagre/lib/util.js").notime)
  },
  version: __webpack_require__(/*! ./lib/version */ "./node_modules/dagre/lib/version.js")
};


/***/ }),

/***/ "./node_modules/dagre/lib/acyclic.js":
/*!*******************************************!*\
  !*** ./node_modules/dagre/lib/acyclic.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var greedyFAS = __webpack_require__(/*! ./greedy-fas */ "./node_modules/dagre/lib/greedy-fas.js");

module.exports = {
  run: run,
  undo: undo
};

function run(g) {
  var fas = (g.graph().acyclicer === "greedy"
    ? greedyFAS(g, weightFn(g))
    : dfsFAS(g));
  _.forEach(fas, function(e) {
    var label = g.edge(e);
    g.removeEdge(e);
    label.forwardName = e.name;
    label.reversed = true;
    g.setEdge(e.w, e.v, label, _.uniqueId("rev"));
  });

  function weightFn(g) {
    return function(e) {
      return g.edge(e).weight;
    };
  }
}

function dfsFAS(g) {
  var fas = [];
  var stack = {};
  var visited = {};

  function dfs(v) {
    if (_.has(visited, v)) {
      return;
    }
    visited[v] = true;
    stack[v] = true;
    _.forEach(g.outEdges(v), function(e) {
      if (_.has(stack, e.w)) {
        fas.push(e);
      } else {
        dfs(e.w);
      }
    });
    delete stack[v];
  }

  _.forEach(g.nodes(), dfs);
  return fas;
}

function undo(g) {
  _.forEach(g.edges(), function(e) {
    var label = g.edge(e);
    if (label.reversed) {
      g.removeEdge(e);

      var forwardName = label.forwardName;
      delete label.reversed;
      delete label.forwardName;
      g.setEdge(e.w, e.v, label, forwardName);
    }
  });
}


/***/ }),

/***/ "./node_modules/dagre/lib/add-border-segments.js":
/*!*******************************************************!*\
  !*** ./node_modules/dagre/lib/add-border-segments.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js");

module.exports = addBorderSegments;

function addBorderSegments(g) {
  function dfs(v) {
    var children = g.children(v);
    var node = g.node(v);
    if (children.length) {
      _.forEach(children, dfs);
    }

    if (_.has(node, "minRank")) {
      node.borderLeft = [];
      node.borderRight = [];
      for (var rank = node.minRank, maxRank = node.maxRank + 1;
        rank < maxRank;
        ++rank) {
        addBorderNode(g, "borderLeft", "_bl", v, node, rank);
        addBorderNode(g, "borderRight", "_br", v, node, rank);
      }
    }
  }

  _.forEach(g.children(), dfs);
}

function addBorderNode(g, prop, prefix, sg, sgNode, rank) {
  var label = { width: 0, height: 0, rank: rank, borderType: prop };
  var prev = sgNode[prop][rank - 1];
  var curr = util.addDummyNode(g, "border", label, prefix);
  sgNode[prop][rank] = curr;
  g.setParent(curr, sg);
  if (prev) {
    g.setEdge(prev, curr, { weight: 1 });
  }
}


/***/ }),

/***/ "./node_modules/dagre/lib/coordinate-system.js":
/*!*****************************************************!*\
  !*** ./node_modules/dagre/lib/coordinate-system.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = {
  adjust: adjust,
  undo: undo
};

function adjust(g) {
  var rankDir = g.graph().rankdir.toLowerCase();
  if (rankDir === "lr" || rankDir === "rl") {
    swapWidthHeight(g);
  }
}

function undo(g) {
  var rankDir = g.graph().rankdir.toLowerCase();
  if (rankDir === "bt" || rankDir === "rl") {
    reverseY(g);
  }

  if (rankDir === "lr" || rankDir === "rl") {
    swapXY(g);
    swapWidthHeight(g);
  }
}

function swapWidthHeight(g) {
  _.forEach(g.nodes(), function(v) { swapWidthHeightOne(g.node(v)); });
  _.forEach(g.edges(), function(e) { swapWidthHeightOne(g.edge(e)); });
}

function swapWidthHeightOne(attrs) {
  var w = attrs.width;
  attrs.width = attrs.height;
  attrs.height = w;
}

function reverseY(g) {
  _.forEach(g.nodes(), function(v) { reverseYOne(g.node(v)); });

  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    _.forEach(edge.points, reverseYOne);
    if (_.has(edge, "y")) {
      reverseYOne(edge);
    }
  });
}

function reverseYOne(attrs) {
  attrs.y = -attrs.y;
}

function swapXY(g) {
  _.forEach(g.nodes(), function(v) { swapXYOne(g.node(v)); });

  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    _.forEach(edge.points, swapXYOne);
    if (_.has(edge, "x")) {
      swapXYOne(edge);
    }
  });
}

function swapXYOne(attrs) {
  var x = attrs.x;
  attrs.x = attrs.y;
  attrs.y = x;
}


/***/ }),

/***/ "./node_modules/dagre/lib/data/list.js":
/*!*********************************************!*\
  !*** ./node_modules/dagre/lib/data/list.js ***!
  \*********************************************/
/***/ ((module) => {

/*
 * Simple doubly linked list implementation derived from Cormen, et al.,
 * "Introduction to Algorithms".
 */

module.exports = List;

function List() {
  var sentinel = {};
  sentinel._next = sentinel._prev = sentinel;
  this._sentinel = sentinel;
}

List.prototype.dequeue = function() {
  var sentinel = this._sentinel;
  var entry = sentinel._prev;
  if (entry !== sentinel) {
    unlink(entry);
    return entry;
  }
};

List.prototype.enqueue = function(entry) {
  var sentinel = this._sentinel;
  if (entry._prev && entry._next) {
    unlink(entry);
  }
  entry._next = sentinel._next;
  sentinel._next._prev = entry;
  sentinel._next = entry;
  entry._prev = sentinel;
};

List.prototype.toString = function() {
  var strs = [];
  var sentinel = this._sentinel;
  var curr = sentinel._prev;
  while (curr !== sentinel) {
    strs.push(JSON.stringify(curr, filterOutLinks));
    curr = curr._prev;
  }
  return "[" + strs.join(", ") + "]";
};

function unlink(entry) {
  entry._prev._next = entry._next;
  entry._next._prev = entry._prev;
  delete entry._next;
  delete entry._prev;
}

function filterOutLinks(k, v) {
  if (k !== "_next" && k !== "_prev") {
    return v;
  }
}


/***/ }),

/***/ "./node_modules/dagre/lib/debug.js":
/*!*****************************************!*\
  !*** ./node_modules/dagre/lib/debug.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js");
var Graph = (__webpack_require__(/*! ./graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph);

module.exports = {
  debugOrdering: debugOrdering
};

/* istanbul ignore next */
function debugOrdering(g) {
  var layerMatrix = util.buildLayerMatrix(g);

  var h = new Graph({ compound: true, multigraph: true }).setGraph({});

  _.forEach(g.nodes(), function(v) {
    h.setNode(v, { label: v });
    h.setParent(v, "layer" + g.node(v).rank);
  });

  _.forEach(g.edges(), function(e) {
    h.setEdge(e.v, e.w, {}, e.name);
  });

  _.forEach(layerMatrix, function(layer, i) {
    var layerV = "layer" + i;
    h.setNode(layerV, { rank: "same" });
    _.reduce(layer, function(u, v) {
      h.setEdge(u, v, { style: "invis" });
      return v;
    });
  });

  return h;
}


/***/ }),

/***/ "./node_modules/dagre/lib/graphlib.js":
/*!********************************************!*\
  !*** ./node_modules/dagre/lib/graphlib.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* global window */

var graphlib;

if (true) {
  try {
    graphlib = __webpack_require__(/*! graphlib */ "./node_modules/graphlib/index.js");
  } catch (e) {
    // continue regardless of error
  }
}

if (!graphlib) {
  graphlib = window.graphlib;
}

module.exports = graphlib;


/***/ }),

/***/ "./node_modules/dagre/lib/greedy-fas.js":
/*!**********************************************!*\
  !*** ./node_modules/dagre/lib/greedy-fas.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var Graph = (__webpack_require__(/*! ./graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph);
var List = __webpack_require__(/*! ./data/list */ "./node_modules/dagre/lib/data/list.js");

/*
 * A greedy heuristic for finding a feedback arc set for a graph. A feedback
 * arc set is a set of edges that can be removed to make a graph acyclic.
 * The algorithm comes from: P. Eades, X. Lin, and W. F. Smyth, "A fast and
 * effective heuristic for the feedback arc set problem." This implementation
 * adjusts that from the paper to allow for weighted edges.
 */
module.exports = greedyFAS;

var DEFAULT_WEIGHT_FN = _.constant(1);

function greedyFAS(g, weightFn) {
  if (g.nodeCount() <= 1) {
    return [];
  }
  var state = buildState(g, weightFn || DEFAULT_WEIGHT_FN);
  var results = doGreedyFAS(state.graph, state.buckets, state.zeroIdx);

  // Expand multi-edges
  return _.flatten(_.map(results, function(e) {
    return g.outEdges(e.v, e.w);
  }), true);
}

function doGreedyFAS(g, buckets, zeroIdx) {
  var results = [];
  var sources = buckets[buckets.length - 1];
  var sinks = buckets[0];

  var entry;
  while (g.nodeCount()) {
    while ((entry = sinks.dequeue()))   { removeNode(g, buckets, zeroIdx, entry); }
    while ((entry = sources.dequeue())) { removeNode(g, buckets, zeroIdx, entry); }
    if (g.nodeCount()) {
      for (var i = buckets.length - 2; i > 0; --i) {
        entry = buckets[i].dequeue();
        if (entry) {
          results = results.concat(removeNode(g, buckets, zeroIdx, entry, true));
          break;
        }
      }
    }
  }

  return results;
}

function removeNode(g, buckets, zeroIdx, entry, collectPredecessors) {
  var results = collectPredecessors ? [] : undefined;

  _.forEach(g.inEdges(entry.v), function(edge) {
    var weight = g.edge(edge);
    var uEntry = g.node(edge.v);

    if (collectPredecessors) {
      results.push({ v: edge.v, w: edge.w });
    }

    uEntry.out -= weight;
    assignBucket(buckets, zeroIdx, uEntry);
  });

  _.forEach(g.outEdges(entry.v), function(edge) {
    var weight = g.edge(edge);
    var w = edge.w;
    var wEntry = g.node(w);
    wEntry["in"] -= weight;
    assignBucket(buckets, zeroIdx, wEntry);
  });

  g.removeNode(entry.v);

  return results;
}

function buildState(g, weightFn) {
  var fasGraph = new Graph();
  var maxIn = 0;
  var maxOut = 0;

  _.forEach(g.nodes(), function(v) {
    fasGraph.setNode(v, { v: v, "in": 0, out: 0 });
  });

  // Aggregate weights on nodes, but also sum the weights across multi-edges
  // into a single edge for the fasGraph.
  _.forEach(g.edges(), function(e) {
    var prevWeight = fasGraph.edge(e.v, e.w) || 0;
    var weight = weightFn(e);
    var edgeWeight = prevWeight + weight;
    fasGraph.setEdge(e.v, e.w, edgeWeight);
    maxOut = Math.max(maxOut, fasGraph.node(e.v).out += weight);
    maxIn  = Math.max(maxIn,  fasGraph.node(e.w)["in"]  += weight);
  });

  var buckets = _.range(maxOut + maxIn + 3).map(function() { return new List(); });
  var zeroIdx = maxIn + 1;

  _.forEach(fasGraph.nodes(), function(v) {
    assignBucket(buckets, zeroIdx, fasGraph.node(v));
  });

  return { graph: fasGraph, buckets: buckets, zeroIdx: zeroIdx };
}

function assignBucket(buckets, zeroIdx, entry) {
  if (!entry.out) {
    buckets[0].enqueue(entry);
  } else if (!entry["in"]) {
    buckets[buckets.length - 1].enqueue(entry);
  } else {
    buckets[entry.out - entry["in"] + zeroIdx].enqueue(entry);
  }
}


/***/ }),

/***/ "./node_modules/dagre/lib/layout.js":
/*!******************************************!*\
  !*** ./node_modules/dagre/lib/layout.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var acyclic = __webpack_require__(/*! ./acyclic */ "./node_modules/dagre/lib/acyclic.js");
var normalize = __webpack_require__(/*! ./normalize */ "./node_modules/dagre/lib/normalize.js");
var rank = __webpack_require__(/*! ./rank */ "./node_modules/dagre/lib/rank/index.js");
var normalizeRanks = (__webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js").normalizeRanks);
var parentDummyChains = __webpack_require__(/*! ./parent-dummy-chains */ "./node_modules/dagre/lib/parent-dummy-chains.js");
var removeEmptyRanks = (__webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js").removeEmptyRanks);
var nestingGraph = __webpack_require__(/*! ./nesting-graph */ "./node_modules/dagre/lib/nesting-graph.js");
var addBorderSegments = __webpack_require__(/*! ./add-border-segments */ "./node_modules/dagre/lib/add-border-segments.js");
var coordinateSystem = __webpack_require__(/*! ./coordinate-system */ "./node_modules/dagre/lib/coordinate-system.js");
var order = __webpack_require__(/*! ./order */ "./node_modules/dagre/lib/order/index.js");
var position = __webpack_require__(/*! ./position */ "./node_modules/dagre/lib/position/index.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js");
var Graph = (__webpack_require__(/*! ./graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph);

module.exports = layout;

function layout(g, opts) {
  var time = opts && opts.debugTiming ? util.time : util.notime;
  time("layout", function() {
    var layoutGraph = 
      time("  buildLayoutGraph", function() { return buildLayoutGraph(g); });
    time("  runLayout",        function() { runLayout(layoutGraph, time); });
    time("  updateInputGraph", function() { updateInputGraph(g, layoutGraph); });
  });
}

function runLayout(g, time) {
  time("    makeSpaceForEdgeLabels", function() { makeSpaceForEdgeLabels(g); });
  time("    removeSelfEdges",        function() { removeSelfEdges(g); });
  time("    acyclic",                function() { acyclic.run(g); });
  time("    nestingGraph.run",       function() { nestingGraph.run(g); });
  time("    rank",                   function() { rank(util.asNonCompoundGraph(g)); });
  time("    injectEdgeLabelProxies", function() { injectEdgeLabelProxies(g); });
  time("    removeEmptyRanks",       function() { removeEmptyRanks(g); });
  time("    nestingGraph.cleanup",   function() { nestingGraph.cleanup(g); });
  time("    normalizeRanks",         function() { normalizeRanks(g); });
  time("    assignRankMinMax",       function() { assignRankMinMax(g); });
  time("    removeEdgeLabelProxies", function() { removeEdgeLabelProxies(g); });
  time("    normalize.run",          function() { normalize.run(g); });
  time("    parentDummyChains",      function() { parentDummyChains(g); });
  time("    addBorderSegments",      function() { addBorderSegments(g); });
  time("    order",                  function() { order(g); });
  time("    insertSelfEdges",        function() { insertSelfEdges(g); });
  time("    adjustCoordinateSystem", function() { coordinateSystem.adjust(g); });
  time("    position",               function() { position(g); });
  time("    positionSelfEdges",      function() { positionSelfEdges(g); });
  time("    removeBorderNodes",      function() { removeBorderNodes(g); });
  time("    normalize.undo",         function() { normalize.undo(g); });
  time("    fixupEdgeLabelCoords",   function() { fixupEdgeLabelCoords(g); });
  time("    undoCoordinateSystem",   function() { coordinateSystem.undo(g); });
  time("    translateGraph",         function() { translateGraph(g); });
  time("    assignNodeIntersects",   function() { assignNodeIntersects(g); });
  time("    reversePoints",          function() { reversePointsForReversedEdges(g); });
  time("    acyclic.undo",           function() { acyclic.undo(g); });
}

/*
 * Copies final layout information from the layout graph back to the input
 * graph. This process only copies whitelisted attributes from the layout graph
 * to the input graph, so it serves as a good place to determine what
 * attributes can influence layout.
 */
function updateInputGraph(inputGraph, layoutGraph) {
  _.forEach(inputGraph.nodes(), function(v) {
    var inputLabel = inputGraph.node(v);
    var layoutLabel = layoutGraph.node(v);

    if (inputLabel) {
      inputLabel.x = layoutLabel.x;
      inputLabel.y = layoutLabel.y;

      if (layoutGraph.children(v).length) {
        inputLabel.width = layoutLabel.width;
        inputLabel.height = layoutLabel.height;
      }
    }
  });

  _.forEach(inputGraph.edges(), function(e) {
    var inputLabel = inputGraph.edge(e);
    var layoutLabel = layoutGraph.edge(e);

    inputLabel.points = layoutLabel.points;
    if (_.has(layoutLabel, "x")) {
      inputLabel.x = layoutLabel.x;
      inputLabel.y = layoutLabel.y;
    }
  });

  inputGraph.graph().width = layoutGraph.graph().width;
  inputGraph.graph().height = layoutGraph.graph().height;
}

var graphNumAttrs = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"];
var graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" };
var graphAttrs = ["acyclicer", "ranker", "rankdir", "align"];
var nodeNumAttrs = ["width", "height"];
var nodeDefaults = { width: 0, height: 0 };
var edgeNumAttrs = ["minlen", "weight", "width", "height", "labeloffset"];
var edgeDefaults = {
  minlen: 1, weight: 1, width: 0, height: 0,
  labeloffset: 10, labelpos: "r"
};
var edgeAttrs = ["labelpos"];

/*
 * Constructs a new graph from the input graph, which can be used for layout.
 * This process copies only whitelisted attributes from the input graph to the
 * layout graph. Thus this function serves as a good place to determine what
 * attributes can influence layout.
 */
function buildLayoutGraph(inputGraph) {
  var g = new Graph({ multigraph: true, compound: true });
  var graph = canonicalize(inputGraph.graph());

  g.setGraph(_.merge({},
    graphDefaults,
    selectNumberAttrs(graph, graphNumAttrs),
    _.pick(graph, graphAttrs)));

  _.forEach(inputGraph.nodes(), function(v) {
    var node = canonicalize(inputGraph.node(v));
    g.setNode(v, _.defaults(selectNumberAttrs(node, nodeNumAttrs), nodeDefaults));
    g.setParent(v, inputGraph.parent(v));
  });

  _.forEach(inputGraph.edges(), function(e) {
    var edge = canonicalize(inputGraph.edge(e));
    g.setEdge(e, _.merge({},
      edgeDefaults,
      selectNumberAttrs(edge, edgeNumAttrs),
      _.pick(edge, edgeAttrs)));
  });

  return g;
}

/*
 * This idea comes from the Gansner paper: to account for edge labels in our
 * layout we split each rank in half by doubling minlen and halving ranksep.
 * Then we can place labels at these mid-points between nodes.
 *
 * We also add some minimal padding to the width to push the label for the edge
 * away from the edge itself a bit.
 */
function makeSpaceForEdgeLabels(g) {
  var graph = g.graph();
  graph.ranksep /= 2;
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    edge.minlen *= 2;
    if (edge.labelpos.toLowerCase() !== "c") {
      if (graph.rankdir === "TB" || graph.rankdir === "BT") {
        edge.width += edge.labeloffset;
      } else {
        edge.height += edge.labeloffset;
      }
    }
  });
}

/*
 * Creates temporary dummy nodes that capture the rank in which each edge's
 * label is going to, if it has one of non-zero width and height. We do this
 * so that we can safely remove empty ranks while preserving balance for the
 * label's position.
 */
function injectEdgeLabelProxies(g) {
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (edge.width && edge.height) {
      var v = g.node(e.v);
      var w = g.node(e.w);
      var label = { rank: (w.rank - v.rank) / 2 + v.rank, e: e };
      util.addDummyNode(g, "edge-proxy", label, "_ep");
    }
  });
}

function assignRankMinMax(g) {
  var maxRank = 0;
  _.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    if (node.borderTop) {
      node.minRank = g.node(node.borderTop).rank;
      node.maxRank = g.node(node.borderBottom).rank;
      maxRank = _.max(maxRank, node.maxRank);
    }
  });
  g.graph().maxRank = maxRank;
}

function removeEdgeLabelProxies(g) {
  _.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    if (node.dummy === "edge-proxy") {
      g.edge(node.e).labelRank = node.rank;
      g.removeNode(v);
    }
  });
}

function translateGraph(g) {
  var minX = Number.POSITIVE_INFINITY;
  var maxX = 0;
  var minY = Number.POSITIVE_INFINITY;
  var maxY = 0;
  var graphLabel = g.graph();
  var marginX = graphLabel.marginx || 0;
  var marginY = graphLabel.marginy || 0;

  function getExtremes(attrs) {
    var x = attrs.x;
    var y = attrs.y;
    var w = attrs.width;
    var h = attrs.height;
    minX = Math.min(minX, x - w / 2);
    maxX = Math.max(maxX, x + w / 2);
    minY = Math.min(minY, y - h / 2);
    maxY = Math.max(maxY, y + h / 2);
  }

  _.forEach(g.nodes(), function(v) { getExtremes(g.node(v)); });
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (_.has(edge, "x")) {
      getExtremes(edge);
    }
  });

  minX -= marginX;
  minY -= marginY;

  _.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    node.x -= minX;
    node.y -= minY;
  });

  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    _.forEach(edge.points, function(p) {
      p.x -= minX;
      p.y -= minY;
    });
    if (_.has(edge, "x")) { edge.x -= minX; }
    if (_.has(edge, "y")) { edge.y -= minY; }
  });

  graphLabel.width = maxX - minX + marginX;
  graphLabel.height = maxY - minY + marginY;
}

function assignNodeIntersects(g) {
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    var nodeV = g.node(e.v);
    var nodeW = g.node(e.w);
    var p1, p2;
    if (!edge.points) {
      edge.points = [];
      p1 = nodeW;
      p2 = nodeV;
    } else {
      p1 = edge.points[0];
      p2 = edge.points[edge.points.length - 1];
    }
    edge.points.unshift(util.intersectRect(nodeV, p1));
    edge.points.push(util.intersectRect(nodeW, p2));
  });
}

function fixupEdgeLabelCoords(g) {
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (_.has(edge, "x")) {
      if (edge.labelpos === "l" || edge.labelpos === "r") {
        edge.width -= edge.labeloffset;
      }
      switch (edge.labelpos) {
      case "l": edge.x -= edge.width / 2 + edge.labeloffset; break;
      case "r": edge.x += edge.width / 2 + edge.labeloffset; break;
      }
    }
  });
}

function reversePointsForReversedEdges(g) {
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (edge.reversed) {
      edge.points.reverse();
    }
  });
}

function removeBorderNodes(g) {
  _.forEach(g.nodes(), function(v) {
    if (g.children(v).length) {
      var node = g.node(v);
      var t = g.node(node.borderTop);
      var b = g.node(node.borderBottom);
      var l = g.node(_.last(node.borderLeft));
      var r = g.node(_.last(node.borderRight));

      node.width = Math.abs(r.x - l.x);
      node.height = Math.abs(b.y - t.y);
      node.x = l.x + node.width / 2;
      node.y = t.y + node.height / 2;
    }
  });

  _.forEach(g.nodes(), function(v) {
    if (g.node(v).dummy === "border") {
      g.removeNode(v);
    }
  });
}

function removeSelfEdges(g) {
  _.forEach(g.edges(), function(e) {
    if (e.v === e.w) {
      var node = g.node(e.v);
      if (!node.selfEdges) {
        node.selfEdges = [];
      }
      node.selfEdges.push({ e: e, label: g.edge(e) });
      g.removeEdge(e);
    }
  });
}

function insertSelfEdges(g) {
  var layers = util.buildLayerMatrix(g);
  _.forEach(layers, function(layer) {
    var orderShift = 0;
    _.forEach(layer, function(v, i) {
      var node = g.node(v);
      node.order = i + orderShift;
      _.forEach(node.selfEdges, function(selfEdge) {
        util.addDummyNode(g, "selfedge", {
          width: selfEdge.label.width,
          height: selfEdge.label.height,
          rank: node.rank,
          order: i + (++orderShift),
          e: selfEdge.e,
          label: selfEdge.label
        }, "_se");
      });
      delete node.selfEdges;
    });
  });
}

function positionSelfEdges(g) {
  _.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    if (node.dummy === "selfedge") {
      var selfNode = g.node(node.e.v);
      var x = selfNode.x + selfNode.width / 2;
      var y = selfNode.y;
      var dx = node.x - x;
      var dy = selfNode.height / 2;
      g.setEdge(node.e, node.label);
      g.removeNode(v);
      node.label.points = [
        { x: x + 2 * dx / 3, y: y - dy },
        { x: x + 5 * dx / 6, y: y - dy },
        { x: x +     dx    , y: y },
        { x: x + 5 * dx / 6, y: y + dy },
        { x: x + 2 * dx / 3, y: y + dy }
      ];
      node.label.x = node.x;
      node.label.y = node.y;
    }
  });
}

function selectNumberAttrs(obj, attrs) {
  return _.mapValues(_.pick(obj, attrs), Number);
}

function canonicalize(attrs) {
  var newAttrs = {};
  _.forEach(attrs, function(v, k) {
    newAttrs[k.toLowerCase()] = v;
  });
  return newAttrs;
}


/***/ }),

/***/ "./node_modules/dagre/lib/lodash.js":
/*!******************************************!*\
  !*** ./node_modules/dagre/lib/lodash.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* global window */

var lodash;

if (true) {
  try {
    lodash = {
      cloneDeep: __webpack_require__(/*! lodash/cloneDeep */ "./node_modules/lodash/cloneDeep.js"),
      constant: __webpack_require__(/*! lodash/constant */ "./node_modules/lodash/constant.js"),
      defaults: __webpack_require__(/*! lodash/defaults */ "./node_modules/lodash/defaults.js"),
      each: __webpack_require__(/*! lodash/each */ "./node_modules/lodash/each.js"),
      filter: __webpack_require__(/*! lodash/filter */ "./node_modules/lodash/filter.js"),
      find: __webpack_require__(/*! lodash/find */ "./node_modules/lodash/find.js"),
      flatten: __webpack_require__(/*! lodash/flatten */ "./node_modules/lodash/flatten.js"),
      forEach: __webpack_require__(/*! lodash/forEach */ "./node_modules/lodash/forEach.js"),
      forIn: __webpack_require__(/*! lodash/forIn */ "./node_modules/lodash/forIn.js"),
      has:  __webpack_require__(/*! lodash/has */ "./node_modules/lodash/has.js"),
      isUndefined: __webpack_require__(/*! lodash/isUndefined */ "./node_modules/lodash/isUndefined.js"),
      last: __webpack_require__(/*! lodash/last */ "./node_modules/lodash/last.js"),
      map: __webpack_require__(/*! lodash/map */ "./node_modules/lodash/map.js"),
      mapValues: __webpack_require__(/*! lodash/mapValues */ "./node_modules/lodash/mapValues.js"),
      max: __webpack_require__(/*! lodash/max */ "./node_modules/lodash/max.js"),
      merge: __webpack_require__(/*! lodash/merge */ "./node_modules/lodash/merge.js"),
      min: __webpack_require__(/*! lodash/min */ "./node_modules/lodash/min.js"),
      minBy: __webpack_require__(/*! lodash/minBy */ "./node_modules/lodash/minBy.js"),
      now: __webpack_require__(/*! lodash/now */ "./node_modules/lodash/now.js"),
      pick: __webpack_require__(/*! lodash/pick */ "./node_modules/lodash/pick.js"),
      range: __webpack_require__(/*! lodash/range */ "./node_modules/lodash/range.js"),
      reduce: __webpack_require__(/*! lodash/reduce */ "./node_modules/lodash/reduce.js"),
      sortBy: __webpack_require__(/*! lodash/sortBy */ "./node_modules/lodash/sortBy.js"),
      uniqueId: __webpack_require__(/*! lodash/uniqueId */ "./node_modules/lodash/uniqueId.js"),
      values: __webpack_require__(/*! lodash/values */ "./node_modules/lodash/values.js"),
      zipObject: __webpack_require__(/*! lodash/zipObject */ "./node_modules/lodash/zipObject.js"),
    };
  } catch (e) {
    // continue regardless of error
  }
}

if (!lodash) {
  lodash = window._;
}

module.exports = lodash;


/***/ }),

/***/ "./node_modules/dagre/lib/nesting-graph.js":
/*!*************************************************!*\
  !*** ./node_modules/dagre/lib/nesting-graph.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js");

module.exports = {
  run: run,
  cleanup: cleanup
};

/*
 * A nesting graph creates dummy nodes for the tops and bottoms of subgraphs,
 * adds appropriate edges to ensure that all cluster nodes are placed between
 * these boundries, and ensures that the graph is connected.
 *
 * In addition we ensure, through the use of the minlen property, that nodes
 * and subgraph border nodes to not end up on the same rank.
 *
 * Preconditions:
 *
 *    1. Input graph is a DAG
 *    2. Nodes in the input graph has a minlen attribute
 *
 * Postconditions:
 *
 *    1. Input graph is connected.
 *    2. Dummy nodes are added for the tops and bottoms of subgraphs.
 *    3. The minlen attribute for nodes is adjusted to ensure nodes do not
 *       get placed on the same rank as subgraph border nodes.
 *
 * The nesting graph idea comes from Sander, "Layout of Compound Directed
 * Graphs."
 */
function run(g) {
  var root = util.addDummyNode(g, "root", {}, "_root");
  var depths = treeDepths(g);
  var height = _.max(_.values(depths)) - 1; // Note: depths is an Object not an array
  var nodeSep = 2 * height + 1;

  g.graph().nestingRoot = root;

  // Multiply minlen by nodeSep to align nodes on non-border ranks.
  _.forEach(g.edges(), function(e) { g.edge(e).minlen *= nodeSep; });

  // Calculate a weight that is sufficient to keep subgraphs vertically compact
  var weight = sumWeights(g) + 1;

  // Create border nodes and link them up
  _.forEach(g.children(), function(child) {
    dfs(g, root, nodeSep, weight, height, depths, child);
  });

  // Save the multiplier for node layers for later removal of empty border
  // layers.
  g.graph().nodeRankFactor = nodeSep;
}

function dfs(g, root, nodeSep, weight, height, depths, v) {
  var children = g.children(v);
  if (!children.length) {
    if (v !== root) {
      g.setEdge(root, v, { weight: 0, minlen: nodeSep });
    }
    return;
  }

  var top = util.addBorderNode(g, "_bt");
  var bottom = util.addBorderNode(g, "_bb");
  var label = g.node(v);

  g.setParent(top, v);
  label.borderTop = top;
  g.setParent(bottom, v);
  label.borderBottom = bottom;

  _.forEach(children, function(child) {
    dfs(g, root, nodeSep, weight, height, depths, child);

    var childNode = g.node(child);
    var childTop = childNode.borderTop ? childNode.borderTop : child;
    var childBottom = childNode.borderBottom ? childNode.borderBottom : child;
    var thisWeight = childNode.borderTop ? weight : 2 * weight;
    var minlen = childTop !== childBottom ? 1 : height - depths[v] + 1;

    g.setEdge(top, childTop, {
      weight: thisWeight,
      minlen: minlen,
      nestingEdge: true
    });

    g.setEdge(childBottom, bottom, {
      weight: thisWeight,
      minlen: minlen,
      nestingEdge: true
    });
  });

  if (!g.parent(v)) {
    g.setEdge(root, top, { weight: 0, minlen: height + depths[v] });
  }
}

function treeDepths(g) {
  var depths = {};
  function dfs(v, depth) {
    var children = g.children(v);
    if (children && children.length) {
      _.forEach(children, function(child) {
        dfs(child, depth + 1);
      });
    }
    depths[v] = depth;
  }
  _.forEach(g.children(), function(v) { dfs(v, 1); });
  return depths;
}

function sumWeights(g) {
  return _.reduce(g.edges(), function(acc, e) {
    return acc + g.edge(e).weight;
  }, 0);
}

function cleanup(g) {
  var graphLabel = g.graph();
  g.removeNode(graphLabel.nestingRoot);
  delete graphLabel.nestingRoot;
  _.forEach(g.edges(), function(e) {
    var edge = g.edge(e);
    if (edge.nestingEdge) {
      g.removeEdge(e);
    }
  });
}


/***/ }),

/***/ "./node_modules/dagre/lib/normalize.js":
/*!*********************************************!*\
  !*** ./node_modules/dagre/lib/normalize.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var util = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/util.js");

module.exports = {
  run: run,
  undo: undo
};

/*
 * Breaks any long edges in the graph into short segments that span 1 layer
 * each. This operation is undoable with the denormalize function.
 *
 * Pre-conditions:
 *
 *    1. The input graph is a DAG.
 *    2. Each node in the graph has a "rank" property.
 *
 * Post-condition:
 *
 *    1. All edges in the graph have a length of 1.
 *    2. Dummy nodes are added where edges have been split into segments.
 *    3. The graph is augmented with a "dummyChains" attribute which contains
 *       the first dummy in each chain of dummy nodes produced.
 */
function run(g) {
  g.graph().dummyChains = [];
  _.forEach(g.edges(), function(edge) { normalizeEdge(g, edge); });
}

function normalizeEdge(g, e) {
  var v = e.v;
  var vRank = g.node(v).rank;
  var w = e.w;
  var wRank = g.node(w).rank;
  var name = e.name;
  var edgeLabel = g.edge(e);
  var labelRank = edgeLabel.labelRank;

  if (wRank === vRank + 1) return;

  g.removeEdge(e);

  var dummy, attrs, i;
  for (i = 0, ++vRank; vRank < wRank; ++i, ++vRank) {
    edgeLabel.points = [];
    attrs = {
      width: 0, height: 0,
      edgeLabel: edgeLabel, edgeObj: e,
      rank: vRank
    };
    dummy = util.addDummyNode(g, "edge", attrs, "_d");
    if (vRank === labelRank) {
      attrs.width = edgeLabel.width;
      attrs.height = edgeLabel.height;
      attrs.dummy = "edge-label";
      attrs.labelpos = edgeLabel.labelpos;
    }
    g.setEdge(v, dummy, { weight: edgeLabel.weight }, name);
    if (i === 0) {
      g.graph().dummyChains.push(dummy);
    }
    v = dummy;
  }

  g.setEdge(v, w, { weight: edgeLabel.weight }, name);
}

function undo(g) {
  _.forEach(g.graph().dummyChains, function(v) {
    var node = g.node(v);
    var origLabel = node.edgeLabel;
    var w;
    g.setEdge(node.edgeObj, origLabel);
    while (node.dummy) {
      w = g.successors(v)[0];
      g.removeNode(v);
      origLabel.points.push({ x: node.x, y: node.y });
      if (node.dummy === "edge-label") {
        origLabel.x = node.x;
        origLabel.y = node.y;
        origLabel.width = node.width;
        origLabel.height = node.height;
      }
      v = w;
      node = g.node(v);
    }
  });
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/add-subgraph-constraints.js":
/*!******************************************************************!*\
  !*** ./node_modules/dagre/lib/order/add-subgraph-constraints.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = addSubgraphConstraints;

function addSubgraphConstraints(g, cg, vs) {
  var prev = {},
    rootPrev;

  _.forEach(vs, function(v) {
    var child = g.parent(v),
      parent,
      prevChild;
    while (child) {
      parent = g.parent(child);
      if (parent) {
        prevChild = prev[parent];
        prev[parent] = child;
      } else {
        prevChild = rootPrev;
        rootPrev = child;
      }
      if (prevChild && prevChild !== child) {
        cg.setEdge(prevChild, child);
        return;
      }
      child = parent;
    }
  });

  /*
  function dfs(v) {
    var children = v ? g.children(v) : g.children();
    if (children.length) {
      var min = Number.POSITIVE_INFINITY,
          subgraphs = [];
      _.each(children, function(child) {
        var childMin = dfs(child);
        if (g.children(child).length) {
          subgraphs.push({ v: child, order: childMin });
        }
        min = Math.min(min, childMin);
      });
      _.reduce(_.sortBy(subgraphs, "order"), function(prev, curr) {
        cg.setEdge(prev.v, curr.v);
        return curr;
      });
      return min;
    }
    return g.node(v).order;
  }
  dfs(undefined);
  */
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/barycenter.js":
/*!****************************************************!*\
  !*** ./node_modules/dagre/lib/order/barycenter.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = barycenter;

function barycenter(g, movable) {
  return _.map(movable, function(v) {
    var inV = g.inEdges(v);
    if (!inV.length) {
      return { v: v };
    } else {
      var result = _.reduce(inV, function(acc, e) {
        var edge = g.edge(e),
          nodeU = g.node(e.v);
        return {
          sum: acc.sum + (edge.weight * nodeU.order),
          weight: acc.weight + edge.weight
        };
      }, { sum: 0, weight: 0 });

      return {
        v: v,
        barycenter: result.sum / result.weight,
        weight: result.weight
      };
    }
  });
}



/***/ }),

/***/ "./node_modules/dagre/lib/order/build-layer-graph.js":
/*!***********************************************************!*\
  !*** ./node_modules/dagre/lib/order/build-layer-graph.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var Graph = (__webpack_require__(/*! ../graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph);

module.exports = buildLayerGraph;

/*
 * Constructs a graph that can be used to sort a layer of nodes. The graph will
 * contain all base and subgraph nodes from the request layer in their original
 * hierarchy and any edges that are incident on these nodes and are of the type
 * requested by the "relationship" parameter.
 *
 * Nodes from the requested rank that do not have parents are assigned a root
 * node in the output graph, which is set in the root graph attribute. This
 * makes it easy to walk the hierarchy of movable nodes during ordering.
 *
 * Pre-conditions:
 *
 *    1. Input graph is a DAG
 *    2. Base nodes in the input graph have a rank attribute
 *    3. Subgraph nodes in the input graph has minRank and maxRank attributes
 *    4. Edges have an assigned weight
 *
 * Post-conditions:
 *
 *    1. Output graph has all nodes in the movable rank with preserved
 *       hierarchy.
 *    2. Root nodes in the movable layer are made children of the node
 *       indicated by the root attribute of the graph.
 *    3. Non-movable nodes incident on movable nodes, selected by the
 *       relationship parameter, are included in the graph (without hierarchy).
 *    4. Edges incident on movable nodes, selected by the relationship
 *       parameter, are added to the output graph.
 *    5. The weights for copied edges are aggregated as need, since the output
 *       graph is not a multi-graph.
 */
function buildLayerGraph(g, rank, relationship) {
  var root = createRootNode(g),
    result = new Graph({ compound: true }).setGraph({ root: root })
      .setDefaultNodeLabel(function(v) { return g.node(v); });

  _.forEach(g.nodes(), function(v) {
    var node = g.node(v),
      parent = g.parent(v);

    if (node.rank === rank || node.minRank <= rank && rank <= node.maxRank) {
      result.setNode(v);
      result.setParent(v, parent || root);

      // This assumes we have only short edges!
      _.forEach(g[relationship](v), function(e) {
        var u = e.v === v ? e.w : e.v,
          edge = result.edge(u, v),
          weight = !_.isUndefined(edge) ? edge.weight : 0;
        result.setEdge(u, v, { weight: g.edge(e).weight + weight });
      });

      if (_.has(node, "minRank")) {
        result.setNode(v, {
          borderLeft: node.borderLeft[rank],
          borderRight: node.borderRight[rank]
        });
      }
    }
  });

  return result;
}

function createRootNode(g) {
  var v;
  while (g.hasNode((v = _.uniqueId("_root"))));
  return v;
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/cross-count.js":
/*!*****************************************************!*\
  !*** ./node_modules/dagre/lib/order/cross-count.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = crossCount;

/*
 * A function that takes a layering (an array of layers, each with an array of
 * ordererd nodes) and a graph and returns a weighted crossing count.
 *
 * Pre-conditions:
 *
 *    1. Input graph must be simple (not a multigraph), directed, and include
 *       only simple edges.
 *    2. Edges in the input graph must have assigned weights.
 *
 * Post-conditions:
 *
 *    1. The graph and layering matrix are left unchanged.
 *
 * This algorithm is derived from Barth, et al., "Bilayer Cross Counting."
 */
function crossCount(g, layering) {
  var cc = 0;
  for (var i = 1; i < layering.length; ++i) {
    cc += twoLayerCrossCount(g, layering[i-1], layering[i]);
  }
  return cc;
}

function twoLayerCrossCount(g, northLayer, southLayer) {
  // Sort all of the edges between the north and south layers by their position
  // in the north layer and then the south. Map these edges to the position of
  // their head in the south layer.
  var southPos = _.zipObject(southLayer,
    _.map(southLayer, function (v, i) { return i; }));
  var southEntries = _.flatten(_.map(northLayer, function(v) {
    return _.sortBy(_.map(g.outEdges(v), function(e) {
      return { pos: southPos[e.w], weight: g.edge(e).weight };
    }), "pos");
  }), true);

  // Build the accumulator tree
  var firstIndex = 1;
  while (firstIndex < southLayer.length) firstIndex <<= 1;
  var treeSize = 2 * firstIndex - 1;
  firstIndex -= 1;
  var tree = _.map(new Array(treeSize), function() { return 0; });

  // Calculate the weighted crossings
  var cc = 0;
  _.forEach(southEntries.forEach(function(entry) {
    var index = entry.pos + firstIndex;
    tree[index] += entry.weight;
    var weightSum = 0;
    while (index > 0) {
      if (index % 2) {
        weightSum += tree[index + 1];
      }
      index = (index - 1) >> 1;
      tree[index] += entry.weight;
    }
    cc += entry.weight * weightSum;
  }));

  return cc;
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/index.js":
/*!***********************************************!*\
  !*** ./node_modules/dagre/lib/order/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var initOrder = __webpack_require__(/*! ./init-order */ "./node_modules/dagre/lib/order/init-order.js");
var crossCount = __webpack_require__(/*! ./cross-count */ "./node_modules/dagre/lib/order/cross-count.js");
var sortSubgraph = __webpack_require__(/*! ./sort-subgraph */ "./node_modules/dagre/lib/order/sort-subgraph.js");
var buildLayerGraph = __webpack_require__(/*! ./build-layer-graph */ "./node_modules/dagre/lib/order/build-layer-graph.js");
var addSubgraphConstraints = __webpack_require__(/*! ./add-subgraph-constraints */ "./node_modules/dagre/lib/order/add-subgraph-constraints.js");
var Graph = (__webpack_require__(/*! ../graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph);
var util = __webpack_require__(/*! ../util */ "./node_modules/dagre/lib/util.js");

module.exports = order;

/*
 * Applies heuristics to minimize edge crossings in the graph and sets the best
 * order solution as an order attribute on each node.
 *
 * Pre-conditions:
 *
 *    1. Graph must be DAG
 *    2. Graph nodes must be objects with a "rank" attribute
 *    3. Graph edges must have the "weight" attribute
 *
 * Post-conditions:
 *
 *    1. Graph nodes will have an "order" attribute based on the results of the
 *       algorithm.
 */
function order(g) {
  var maxRank = util.maxRank(g),
    downLayerGraphs = buildLayerGraphs(g, _.range(1, maxRank + 1), "inEdges"),
    upLayerGraphs = buildLayerGraphs(g, _.range(maxRank - 1, -1, -1), "outEdges");

  var layering = initOrder(g);
  assignOrder(g, layering);

  var bestCC = Number.POSITIVE_INFINITY,
    best;

  for (var i = 0, lastBest = 0; lastBest < 4; ++i, ++lastBest) {
    sweepLayerGraphs(i % 2 ? downLayerGraphs : upLayerGraphs, i % 4 >= 2);

    layering = util.buildLayerMatrix(g);
    var cc = crossCount(g, layering);
    if (cc < bestCC) {
      lastBest = 0;
      best = _.cloneDeep(layering);
      bestCC = cc;
    }
  }

  assignOrder(g, best);
}

function buildLayerGraphs(g, ranks, relationship) {
  return _.map(ranks, function(rank) {
    return buildLayerGraph(g, rank, relationship);
  });
}

function sweepLayerGraphs(layerGraphs, biasRight) {
  var cg = new Graph();
  _.forEach(layerGraphs, function(lg) {
    var root = lg.graph().root;
    var sorted = sortSubgraph(lg, root, cg, biasRight);
    _.forEach(sorted.vs, function(v, i) {
      lg.node(v).order = i;
    });
    addSubgraphConstraints(lg, cg, sorted.vs);
  });
}

function assignOrder(g, layering) {
  _.forEach(layering, function(layer) {
    _.forEach(layer, function(v, i) {
      g.node(v).order = i;
    });
  });
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/init-order.js":
/*!****************************************************!*\
  !*** ./node_modules/dagre/lib/order/init-order.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = initOrder;

/*
 * Assigns an initial order value for each node by performing a DFS search
 * starting from nodes in the first rank. Nodes are assigned an order in their
 * rank as they are first visited.
 *
 * This approach comes from Gansner, et al., "A Technique for Drawing Directed
 * Graphs."
 *
 * Returns a layering matrix with an array per layer and each layer sorted by
 * the order of its nodes.
 */
function initOrder(g) {
  var visited = {};
  var simpleNodes = _.filter(g.nodes(), function(v) {
    return !g.children(v).length;
  });
  var maxRank = _.max(_.map(simpleNodes, function(v) { return g.node(v).rank; }));
  var layers = _.map(_.range(maxRank + 1), function() { return []; });

  function dfs(v) {
    if (_.has(visited, v)) return;
    visited[v] = true;
    var node = g.node(v);
    layers[node.rank].push(v);
    _.forEach(g.successors(v), dfs);
  }

  var orderedVs = _.sortBy(simpleNodes, function(v) { return g.node(v).rank; });
  _.forEach(orderedVs, dfs);

  return layers;
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/resolve-conflicts.js":
/*!***********************************************************!*\
  !*** ./node_modules/dagre/lib/order/resolve-conflicts.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = resolveConflicts;

/*
 * Given a list of entries of the form {v, barycenter, weight} and a
 * constraint graph this function will resolve any conflicts between the
 * constraint graph and the barycenters for the entries. If the barycenters for
 * an entry would violate a constraint in the constraint graph then we coalesce
 * the nodes in the conflict into a new node that respects the contraint and
 * aggregates barycenter and weight information.
 *
 * This implementation is based on the description in Forster, "A Fast and
 * Simple Hueristic for Constrained Two-Level Crossing Reduction," thought it
 * differs in some specific details.
 *
 * Pre-conditions:
 *
 *    1. Each entry has the form {v, barycenter, weight}, or if the node has
 *       no barycenter, then {v}.
 *
 * Returns:
 *
 *    A new list of entries of the form {vs, i, barycenter, weight}. The list
 *    `vs` may either be a singleton or it may be an aggregation of nodes
 *    ordered such that they do not violate constraints from the constraint
 *    graph. The property `i` is the lowest original index of any of the
 *    elements in `vs`.
 */
function resolveConflicts(entries, cg) {
  var mappedEntries = {};
  _.forEach(entries, function(entry, i) {
    var tmp = mappedEntries[entry.v] = {
      indegree: 0,
      "in": [],
      out: [],
      vs: [entry.v],
      i: i
    };
    if (!_.isUndefined(entry.barycenter)) {
      tmp.barycenter = entry.barycenter;
      tmp.weight = entry.weight;
    }
  });

  _.forEach(cg.edges(), function(e) {
    var entryV = mappedEntries[e.v];
    var entryW = mappedEntries[e.w];
    if (!_.isUndefined(entryV) && !_.isUndefined(entryW)) {
      entryW.indegree++;
      entryV.out.push(mappedEntries[e.w]);
    }
  });

  var sourceSet = _.filter(mappedEntries, function(entry) {
    return !entry.indegree;
  });

  return doResolveConflicts(sourceSet);
}

function doResolveConflicts(sourceSet) {
  var entries = [];

  function handleIn(vEntry) {
    return function(uEntry) {
      if (uEntry.merged) {
        return;
      }
      if (_.isUndefined(uEntry.barycenter) ||
          _.isUndefined(vEntry.barycenter) ||
          uEntry.barycenter >= vEntry.barycenter) {
        mergeEntries(vEntry, uEntry);
      }
    };
  }

  function handleOut(vEntry) {
    return function(wEntry) {
      wEntry["in"].push(vEntry);
      if (--wEntry.indegree === 0) {
        sourceSet.push(wEntry);
      }
    };
  }

  while (sourceSet.length) {
    var entry = sourceSet.pop();
    entries.push(entry);
    _.forEach(entry["in"].reverse(), handleIn(entry));
    _.forEach(entry.out, handleOut(entry));
  }

  return _.map(_.filter(entries, function(entry) { return !entry.merged; }),
    function(entry) {
      return _.pick(entry, ["vs", "i", "barycenter", "weight"]);
    });

}

function mergeEntries(target, source) {
  var sum = 0;
  var weight = 0;

  if (target.weight) {
    sum += target.barycenter * target.weight;
    weight += target.weight;
  }

  if (source.weight) {
    sum += source.barycenter * source.weight;
    weight += source.weight;
  }

  target.vs = source.vs.concat(target.vs);
  target.barycenter = sum / weight;
  target.weight = weight;
  target.i = Math.min(source.i, target.i);
  source.merged = true;
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/sort-subgraph.js":
/*!*******************************************************!*\
  !*** ./node_modules/dagre/lib/order/sort-subgraph.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var barycenter = __webpack_require__(/*! ./barycenter */ "./node_modules/dagre/lib/order/barycenter.js");
var resolveConflicts = __webpack_require__(/*! ./resolve-conflicts */ "./node_modules/dagre/lib/order/resolve-conflicts.js");
var sort = __webpack_require__(/*! ./sort */ "./node_modules/dagre/lib/order/sort.js");

module.exports = sortSubgraph;

function sortSubgraph(g, v, cg, biasRight) {
  var movable = g.children(v);
  var node = g.node(v);
  var bl = node ? node.borderLeft : undefined;
  var br = node ? node.borderRight: undefined;
  var subgraphs = {};

  if (bl) {
    movable = _.filter(movable, function(w) {
      return w !== bl && w !== br;
    });
  }

  var barycenters = barycenter(g, movable);
  _.forEach(barycenters, function(entry) {
    if (g.children(entry.v).length) {
      var subgraphResult = sortSubgraph(g, entry.v, cg, biasRight);
      subgraphs[entry.v] = subgraphResult;
      if (_.has(subgraphResult, "barycenter")) {
        mergeBarycenters(entry, subgraphResult);
      }
    }
  });

  var entries = resolveConflicts(barycenters, cg);
  expandSubgraphs(entries, subgraphs);

  var result = sort(entries, biasRight);

  if (bl) {
    result.vs = _.flatten([bl, result.vs, br], true);
    if (g.predecessors(bl).length) {
      var blPred = g.node(g.predecessors(bl)[0]),
        brPred = g.node(g.predecessors(br)[0]);
      if (!_.has(result, "barycenter")) {
        result.barycenter = 0;
        result.weight = 0;
      }
      result.barycenter = (result.barycenter * result.weight +
                           blPred.order + brPred.order) / (result.weight + 2);
      result.weight += 2;
    }
  }

  return result;
}

function expandSubgraphs(entries, subgraphs) {
  _.forEach(entries, function(entry) {
    entry.vs = _.flatten(entry.vs.map(function(v) {
      if (subgraphs[v]) {
        return subgraphs[v].vs;
      }
      return v;
    }), true);
  });
}

function mergeBarycenters(target, other) {
  if (!_.isUndefined(target.barycenter)) {
    target.barycenter = (target.barycenter * target.weight +
                         other.barycenter * other.weight) /
                        (target.weight + other.weight);
    target.weight += other.weight;
  } else {
    target.barycenter = other.barycenter;
    target.weight = other.weight;
  }
}


/***/ }),

/***/ "./node_modules/dagre/lib/order/sort.js":
/*!**********************************************!*\
  !*** ./node_modules/dagre/lib/order/sort.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var util = __webpack_require__(/*! ../util */ "./node_modules/dagre/lib/util.js");

module.exports = sort;

function sort(entries, biasRight) {
  var parts = util.partition(entries, function(entry) {
    return _.has(entry, "barycenter");
  });
  var sortable = parts.lhs,
    unsortable = _.sortBy(parts.rhs, function(entry) { return -entry.i; }),
    vs = [],
    sum = 0,
    weight = 0,
    vsIndex = 0;

  sortable.sort(compareWithBias(!!biasRight));

  vsIndex = consumeUnsortable(vs, unsortable, vsIndex);

  _.forEach(sortable, function (entry) {
    vsIndex += entry.vs.length;
    vs.push(entry.vs);
    sum += entry.barycenter * entry.weight;
    weight += entry.weight;
    vsIndex = consumeUnsortable(vs, unsortable, vsIndex);
  });

  var result = { vs: _.flatten(vs, true) };
  if (weight) {
    result.barycenter = sum / weight;
    result.weight = weight;
  }
  return result;
}

function consumeUnsortable(vs, unsortable, index) {
  var last;
  while (unsortable.length && (last = _.last(unsortable)).i <= index) {
    unsortable.pop();
    vs.push(last.vs);
    index++;
  }
  return index;
}

function compareWithBias(bias) {
  return function(entryV, entryW) {
    if (entryV.barycenter < entryW.barycenter) {
      return -1;
    } else if (entryV.barycenter > entryW.barycenter) {
      return 1;
    }

    return !bias ? entryV.i - entryW.i : entryW.i - entryV.i;
  };
}


/***/ }),

/***/ "./node_modules/dagre/lib/parent-dummy-chains.js":
/*!*******************************************************!*\
  !*** ./node_modules/dagre/lib/parent-dummy-chains.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = parentDummyChains;

function parentDummyChains(g) {
  var postorderNums = postorder(g);

  _.forEach(g.graph().dummyChains, function(v) {
    var node = g.node(v);
    var edgeObj = node.edgeObj;
    var pathData = findPath(g, postorderNums, edgeObj.v, edgeObj.w);
    var path = pathData.path;
    var lca = pathData.lca;
    var pathIdx = 0;
    var pathV = path[pathIdx];
    var ascending = true;

    while (v !== edgeObj.w) {
      node = g.node(v);

      if (ascending) {
        while ((pathV = path[pathIdx]) !== lca &&
               g.node(pathV).maxRank < node.rank) {
          pathIdx++;
        }

        if (pathV === lca) {
          ascending = false;
        }
      }

      if (!ascending) {
        while (pathIdx < path.length - 1 &&
               g.node(pathV = path[pathIdx + 1]).minRank <= node.rank) {
          pathIdx++;
        }
        pathV = path[pathIdx];
      }

      g.setParent(v, pathV);
      v = g.successors(v)[0];
    }
  });
}

// Find a path from v to w through the lowest common ancestor (LCA). Return the
// full path and the LCA.
function findPath(g, postorderNums, v, w) {
  var vPath = [];
  var wPath = [];
  var low = Math.min(postorderNums[v].low, postorderNums[w].low);
  var lim = Math.max(postorderNums[v].lim, postorderNums[w].lim);
  var parent;
  var lca;

  // Traverse up from v to find the LCA
  parent = v;
  do {
    parent = g.parent(parent);
    vPath.push(parent);
  } while (parent &&
           (postorderNums[parent].low > low || lim > postorderNums[parent].lim));
  lca = parent;

  // Traverse from w to LCA
  parent = w;
  while ((parent = g.parent(parent)) !== lca) {
    wPath.push(parent);
  }

  return { path: vPath.concat(wPath.reverse()), lca: lca };
}

function postorder(g) {
  var result = {};
  var lim = 0;

  function dfs(v) {
    var low = lim;
    _.forEach(g.children(v), dfs);
    result[v] = { low: low, lim: lim++ };
  }
  _.forEach(g.children(), dfs);

  return result;
}


/***/ }),

/***/ "./node_modules/dagre/lib/position/bk.js":
/*!***********************************************!*\
  !*** ./node_modules/dagre/lib/position/bk.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var Graph = (__webpack_require__(/*! ../graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph);
var util = __webpack_require__(/*! ../util */ "./node_modules/dagre/lib/util.js");

/*
 * This module provides coordinate assignment based on Brandes and Köpf, "Fast
 * and Simple Horizontal Coordinate Assignment."
 */

module.exports = {
  positionX: positionX,
  findType1Conflicts: findType1Conflicts,
  findType2Conflicts: findType2Conflicts,
  addConflict: addConflict,
  hasConflict: hasConflict,
  verticalAlignment: verticalAlignment,
  horizontalCompaction: horizontalCompaction,
  alignCoordinates: alignCoordinates,
  findSmallestWidthAlignment: findSmallestWidthAlignment,
  balance: balance
};

/*
 * Marks all edges in the graph with a type-1 conflict with the "type1Conflict"
 * property. A type-1 conflict is one where a non-inner segment crosses an
 * inner segment. An inner segment is an edge with both incident nodes marked
 * with the "dummy" property.
 *
 * This algorithm scans layer by layer, starting with the second, for type-1
 * conflicts between the current layer and the previous layer. For each layer
 * it scans the nodes from left to right until it reaches one that is incident
 * on an inner segment. It then scans predecessors to determine if they have
 * edges that cross that inner segment. At the end a final scan is done for all
 * nodes on the current rank to see if they cross the last visited inner
 * segment.
 *
 * This algorithm (safely) assumes that a dummy node will only be incident on a
 * single node in the layers being scanned.
 */
function findType1Conflicts(g, layering) {
  var conflicts = {};

  function visitLayer(prevLayer, layer) {
    var
      // last visited node in the previous layer that is incident on an inner
      // segment.
      k0 = 0,
      // Tracks the last node in this layer scanned for crossings with a type-1
      // segment.
      scanPos = 0,
      prevLayerLength = prevLayer.length,
      lastNode = _.last(layer);

    _.forEach(layer, function(v, i) {
      var w = findOtherInnerSegmentNode(g, v),
        k1 = w ? g.node(w).order : prevLayerLength;

      if (w || v === lastNode) {
        _.forEach(layer.slice(scanPos, i +1), function(scanNode) {
          _.forEach(g.predecessors(scanNode), function(u) {
            var uLabel = g.node(u),
              uPos = uLabel.order;
            if ((uPos < k0 || k1 < uPos) &&
                !(uLabel.dummy && g.node(scanNode).dummy)) {
              addConflict(conflicts, u, scanNode);
            }
          });
        });
        scanPos = i + 1;
        k0 = k1;
      }
    });

    return layer;
  }

  _.reduce(layering, visitLayer);
  return conflicts;
}

function findType2Conflicts(g, layering) {
  var conflicts = {};

  function scan(south, southPos, southEnd, prevNorthBorder, nextNorthBorder) {
    var v;
    _.forEach(_.range(southPos, southEnd), function(i) {
      v = south[i];
      if (g.node(v).dummy) {
        _.forEach(g.predecessors(v), function(u) {
          var uNode = g.node(u);
          if (uNode.dummy &&
              (uNode.order < prevNorthBorder || uNode.order > nextNorthBorder)) {
            addConflict(conflicts, u, v);
          }
        });
      }
    });
  }


  function visitLayer(north, south) {
    var prevNorthPos = -1,
      nextNorthPos,
      southPos = 0;

    _.forEach(south, function(v, southLookahead) {
      if (g.node(v).dummy === "border") {
        var predecessors = g.predecessors(v);
        if (predecessors.length) {
          nextNorthPos = g.node(predecessors[0]).order;
          scan(south, southPos, southLookahead, prevNorthPos, nextNorthPos);
          southPos = southLookahead;
          prevNorthPos = nextNorthPos;
        }
      }
      scan(south, southPos, south.length, nextNorthPos, north.length);
    });

    return south;
  }

  _.reduce(layering, visitLayer);
  return conflicts;
}

function findOtherInnerSegmentNode(g, v) {
  if (g.node(v).dummy) {
    return _.find(g.predecessors(v), function(u) {
      return g.node(u).dummy;
    });
  }
}

function addConflict(conflicts, v, w) {
  if (v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }

  var conflictsV = conflicts[v];
  if (!conflictsV) {
    conflicts[v] = conflictsV = {};
  }
  conflictsV[w] = true;
}

function hasConflict(conflicts, v, w) {
  if (v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }
  return _.has(conflicts[v], w);
}

/*
 * Try to align nodes into vertical "blocks" where possible. This algorithm
 * attempts to align a node with one of its median neighbors. If the edge
 * connecting a neighbor is a type-1 conflict then we ignore that possibility.
 * If a previous node has already formed a block with a node after the node
 * we're trying to form a block with, we also ignore that possibility - our
 * blocks would be split in that scenario.
 */
function verticalAlignment(g, layering, conflicts, neighborFn) {
  var root = {},
    align = {},
    pos = {};

  // We cache the position here based on the layering because the graph and
  // layering may be out of sync. The layering matrix is manipulated to
  // generate different extreme alignments.
  _.forEach(layering, function(layer) {
    _.forEach(layer, function(v, order) {
      root[v] = v;
      align[v] = v;
      pos[v] = order;
    });
  });

  _.forEach(layering, function(layer) {
    var prevIdx = -1;
    _.forEach(layer, function(v) {
      var ws = neighborFn(v);
      if (ws.length) {
        ws = _.sortBy(ws, function(w) { return pos[w]; });
        var mp = (ws.length - 1) / 2;
        for (var i = Math.floor(mp), il = Math.ceil(mp); i <= il; ++i) {
          var w = ws[i];
          if (align[v] === v &&
              prevIdx < pos[w] &&
              !hasConflict(conflicts, v, w)) {
            align[w] = v;
            align[v] = root[v] = root[w];
            prevIdx = pos[w];
          }
        }
      }
    });
  });

  return { root: root, align: align };
}

function horizontalCompaction(g, layering, root, align, reverseSep) {
  // This portion of the algorithm differs from BK due to a number of problems.
  // Instead of their algorithm we construct a new block graph and do two
  // sweeps. The first sweep places blocks with the smallest possible
  // coordinates. The second sweep removes unused space by moving blocks to the
  // greatest coordinates without violating separation.
  var xs = {},
    blockG = buildBlockGraph(g, layering, root, reverseSep),
    borderType = reverseSep ? "borderLeft" : "borderRight";

  function iterate(setXsFunc, nextNodesFunc) {
    var stack = blockG.nodes();
    var elem = stack.pop();
    var visited = {};
    while (elem) {
      if (visited[elem]) {
        setXsFunc(elem);
      } else {
        visited[elem] = true;
        stack.push(elem);
        stack = stack.concat(nextNodesFunc(elem));
      }

      elem = stack.pop();
    }
  }

  // First pass, assign smallest coordinates
  function pass1(elem) {
    xs[elem] = blockG.inEdges(elem).reduce(function(acc, e) {
      return Math.max(acc, xs[e.v] + blockG.edge(e));
    }, 0);
  }

  // Second pass, assign greatest coordinates
  function pass2(elem) {
    var min = blockG.outEdges(elem).reduce(function(acc, e) {
      return Math.min(acc, xs[e.w] - blockG.edge(e));
    }, Number.POSITIVE_INFINITY);

    var node = g.node(elem);
    if (min !== Number.POSITIVE_INFINITY && node.borderType !== borderType) {
      xs[elem] = Math.max(xs[elem], min);
    }
  }

  iterate(pass1, blockG.predecessors.bind(blockG));
  iterate(pass2, blockG.successors.bind(blockG));

  // Assign x coordinates to all nodes
  _.forEach(align, function(v) {
    xs[v] = xs[root[v]];
  });

  return xs;
}


function buildBlockGraph(g, layering, root, reverseSep) {
  var blockGraph = new Graph(),
    graphLabel = g.graph(),
    sepFn = sep(graphLabel.nodesep, graphLabel.edgesep, reverseSep);

  _.forEach(layering, function(layer) {
    var u;
    _.forEach(layer, function(v) {
      var vRoot = root[v];
      blockGraph.setNode(vRoot);
      if (u) {
        var uRoot = root[u],
          prevMax = blockGraph.edge(uRoot, vRoot);
        blockGraph.setEdge(uRoot, vRoot, Math.max(sepFn(g, v, u), prevMax || 0));
      }
      u = v;
    });
  });

  return blockGraph;
}

/*
 * Returns the alignment that has the smallest width of the given alignments.
 */
function findSmallestWidthAlignment(g, xss) {
  return _.minBy(_.values(xss), function (xs) {
    var max = Number.NEGATIVE_INFINITY;
    var min = Number.POSITIVE_INFINITY;

    _.forIn(xs, function (x, v) {
      var halfWidth = width(g, v) / 2;

      max = Math.max(x + halfWidth, max);
      min = Math.min(x - halfWidth, min);
    });

    return max - min;
  });
}

/*
 * Align the coordinates of each of the layout alignments such that
 * left-biased alignments have their minimum coordinate at the same point as
 * the minimum coordinate of the smallest width alignment and right-biased
 * alignments have their maximum coordinate at the same point as the maximum
 * coordinate of the smallest width alignment.
 */
function alignCoordinates(xss, alignTo) {
  var alignToVals = _.values(alignTo),
    alignToMin = _.min(alignToVals),
    alignToMax = _.max(alignToVals);

  _.forEach(["u", "d"], function(vert) {
    _.forEach(["l", "r"], function(horiz) {
      var alignment = vert + horiz,
        xs = xss[alignment],
        delta;
      if (xs === alignTo) return;

      var xsVals = _.values(xs);
      delta = horiz === "l" ? alignToMin - _.min(xsVals) : alignToMax - _.max(xsVals);

      if (delta) {
        xss[alignment] = _.mapValues(xs, function(x) { return x + delta; });
      }
    });
  });
}

function balance(xss, align) {
  return _.mapValues(xss.ul, function(ignore, v) {
    if (align) {
      return xss[align.toLowerCase()][v];
    } else {
      var xs = _.sortBy(_.map(xss, v));
      return (xs[1] + xs[2]) / 2;
    }
  });
}

function positionX(g) {
  var layering = util.buildLayerMatrix(g);
  var conflicts = _.merge(
    findType1Conflicts(g, layering),
    findType2Conflicts(g, layering));

  var xss = {};
  var adjustedLayering;
  _.forEach(["u", "d"], function(vert) {
    adjustedLayering = vert === "u" ? layering : _.values(layering).reverse();
    _.forEach(["l", "r"], function(horiz) {
      if (horiz === "r") {
        adjustedLayering = _.map(adjustedLayering, function(inner) {
          return _.values(inner).reverse();
        });
      }

      var neighborFn = (vert === "u" ? g.predecessors : g.successors).bind(g);
      var align = verticalAlignment(g, adjustedLayering, conflicts, neighborFn);
      var xs = horizontalCompaction(g, adjustedLayering,
        align.root, align.align, horiz === "r");
      if (horiz === "r") {
        xs = _.mapValues(xs, function(x) { return -x; });
      }
      xss[vert + horiz] = xs;
    });
  });

  var smallestWidth = findSmallestWidthAlignment(g, xss);
  alignCoordinates(xss, smallestWidth);
  return balance(xss, g.graph().align);
}

function sep(nodeSep, edgeSep, reverseSep) {
  return function(g, v, w) {
    var vLabel = g.node(v);
    var wLabel = g.node(w);
    var sum = 0;
    var delta;

    sum += vLabel.width / 2;
    if (_.has(vLabel, "labelpos")) {
      switch (vLabel.labelpos.toLowerCase()) {
      case "l": delta = -vLabel.width / 2; break;
      case "r": delta = vLabel.width / 2; break;
      }
    }
    if (delta) {
      sum += reverseSep ? delta : -delta;
    }
    delta = 0;

    sum += (vLabel.dummy ? edgeSep : nodeSep) / 2;
    sum += (wLabel.dummy ? edgeSep : nodeSep) / 2;

    sum += wLabel.width / 2;
    if (_.has(wLabel, "labelpos")) {
      switch (wLabel.labelpos.toLowerCase()) {
      case "l": delta = wLabel.width / 2; break;
      case "r": delta = -wLabel.width / 2; break;
      }
    }
    if (delta) {
      sum += reverseSep ? delta : -delta;
    }
    delta = 0;

    return sum;
  };
}

function width(g, v) {
  return g.node(v).width;
}


/***/ }),

/***/ "./node_modules/dagre/lib/position/index.js":
/*!**************************************************!*\
  !*** ./node_modules/dagre/lib/position/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var util = __webpack_require__(/*! ../util */ "./node_modules/dagre/lib/util.js");
var positionX = (__webpack_require__(/*! ./bk */ "./node_modules/dagre/lib/position/bk.js").positionX);

module.exports = position;

function position(g) {
  g = util.asNonCompoundGraph(g);

  positionY(g);
  _.forEach(positionX(g), function(x, v) {
    g.node(v).x = x;
  });
}

function positionY(g) {
  var layering = util.buildLayerMatrix(g);
  var rankSep = g.graph().ranksep;
  var prevY = 0;
  _.forEach(layering, function(layer) {
    var maxHeight = _.max(_.map(layer, function(v) { return g.node(v).height; }));
    _.forEach(layer, function(v) {
      g.node(v).y = prevY + maxHeight / 2;
    });
    prevY += maxHeight + rankSep;
  });
}



/***/ }),

/***/ "./node_modules/dagre/lib/rank/feasible-tree.js":
/*!******************************************************!*\
  !*** ./node_modules/dagre/lib/rank/feasible-tree.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var Graph = (__webpack_require__(/*! ../graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph);
var slack = (__webpack_require__(/*! ./util */ "./node_modules/dagre/lib/rank/util.js").slack);

module.exports = feasibleTree;

/*
 * Constructs a spanning tree with tight edges and adjusted the input node's
 * ranks to achieve this. A tight edge is one that is has a length that matches
 * its "minlen" attribute.
 *
 * The basic structure for this function is derived from Gansner, et al., "A
 * Technique for Drawing Directed Graphs."
 *
 * Pre-conditions:
 *
 *    1. Graph must be a DAG.
 *    2. Graph must be connected.
 *    3. Graph must have at least one node.
 *    5. Graph nodes must have been previously assigned a "rank" property that
 *       respects the "minlen" property of incident edges.
 *    6. Graph edges must have a "minlen" property.
 *
 * Post-conditions:
 *
 *    - Graph nodes will have their rank adjusted to ensure that all edges are
 *      tight.
 *
 * Returns a tree (undirected graph) that is constructed using only "tight"
 * edges.
 */
function feasibleTree(g) {
  var t = new Graph({ directed: false });

  // Choose arbitrary node from which to start our tree
  var start = g.nodes()[0];
  var size = g.nodeCount();
  t.setNode(start, {});

  var edge, delta;
  while (tightTree(t, g) < size) {
    edge = findMinSlackEdge(t, g);
    delta = t.hasNode(edge.v) ? slack(g, edge) : -slack(g, edge);
    shiftRanks(t, g, delta);
  }

  return t;
}

/*
 * Finds a maximal tree of tight edges and returns the number of nodes in the
 * tree.
 */
function tightTree(t, g) {
  function dfs(v) {
    _.forEach(g.nodeEdges(v), function(e) {
      var edgeV = e.v,
        w = (v === edgeV) ? e.w : edgeV;
      if (!t.hasNode(w) && !slack(g, e)) {
        t.setNode(w, {});
        t.setEdge(v, w, {});
        dfs(w);
      }
    });
  }

  _.forEach(t.nodes(), dfs);
  return t.nodeCount();
}

/*
 * Finds the edge with the smallest slack that is incident on tree and returns
 * it.
 */
function findMinSlackEdge(t, g) {
  return _.minBy(g.edges(), function(e) {
    if (t.hasNode(e.v) !== t.hasNode(e.w)) {
      return slack(g, e);
    }
  });
}

function shiftRanks(t, g, delta) {
  _.forEach(t.nodes(), function(v) {
    g.node(v).rank += delta;
  });
}


/***/ }),

/***/ "./node_modules/dagre/lib/rank/index.js":
/*!**********************************************!*\
  !*** ./node_modules/dagre/lib/rank/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var rankUtil = __webpack_require__(/*! ./util */ "./node_modules/dagre/lib/rank/util.js");
var longestPath = rankUtil.longestPath;
var feasibleTree = __webpack_require__(/*! ./feasible-tree */ "./node_modules/dagre/lib/rank/feasible-tree.js");
var networkSimplex = __webpack_require__(/*! ./network-simplex */ "./node_modules/dagre/lib/rank/network-simplex.js");

module.exports = rank;

/*
 * Assigns a rank to each node in the input graph that respects the "minlen"
 * constraint specified on edges between nodes.
 *
 * This basic structure is derived from Gansner, et al., "A Technique for
 * Drawing Directed Graphs."
 *
 * Pre-conditions:
 *
 *    1. Graph must be a connected DAG
 *    2. Graph nodes must be objects
 *    3. Graph edges must have "weight" and "minlen" attributes
 *
 * Post-conditions:
 *
 *    1. Graph nodes will have a "rank" attribute based on the results of the
 *       algorithm. Ranks can start at any index (including negative), we'll
 *       fix them up later.
 */
function rank(g) {
  switch(g.graph().ranker) {
  case "network-simplex": networkSimplexRanker(g); break;
  case "tight-tree": tightTreeRanker(g); break;
  case "longest-path": longestPathRanker(g); break;
  default: networkSimplexRanker(g);
  }
}

// A fast and simple ranker, but results are far from optimal.
var longestPathRanker = longestPath;

function tightTreeRanker(g) {
  longestPath(g);
  feasibleTree(g);
}

function networkSimplexRanker(g) {
  networkSimplex(g);
}


/***/ }),

/***/ "./node_modules/dagre/lib/rank/network-simplex.js":
/*!********************************************************!*\
  !*** ./node_modules/dagre/lib/rank/network-simplex.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");
var feasibleTree = __webpack_require__(/*! ./feasible-tree */ "./node_modules/dagre/lib/rank/feasible-tree.js");
var slack = (__webpack_require__(/*! ./util */ "./node_modules/dagre/lib/rank/util.js").slack);
var initRank = (__webpack_require__(/*! ./util */ "./node_modules/dagre/lib/rank/util.js").longestPath);
var preorder = (__webpack_require__(/*! ../graphlib */ "./node_modules/dagre/lib/graphlib.js").alg).preorder;
var postorder = (__webpack_require__(/*! ../graphlib */ "./node_modules/dagre/lib/graphlib.js").alg).postorder;
var simplify = (__webpack_require__(/*! ../util */ "./node_modules/dagre/lib/util.js").simplify);

module.exports = networkSimplex;

// Expose some internals for testing purposes
networkSimplex.initLowLimValues = initLowLimValues;
networkSimplex.initCutValues = initCutValues;
networkSimplex.calcCutValue = calcCutValue;
networkSimplex.leaveEdge = leaveEdge;
networkSimplex.enterEdge = enterEdge;
networkSimplex.exchangeEdges = exchangeEdges;

/*
 * The network simplex algorithm assigns ranks to each node in the input graph
 * and iteratively improves the ranking to reduce the length of edges.
 *
 * Preconditions:
 *
 *    1. The input graph must be a DAG.
 *    2. All nodes in the graph must have an object value.
 *    3. All edges in the graph must have "minlen" and "weight" attributes.
 *
 * Postconditions:
 *
 *    1. All nodes in the graph will have an assigned "rank" attribute that has
 *       been optimized by the network simplex algorithm. Ranks start at 0.
 *
 *
 * A rough sketch of the algorithm is as follows:
 *
 *    1. Assign initial ranks to each node. We use the longest path algorithm,
 *       which assigns ranks to the lowest position possible. In general this
 *       leads to very wide bottom ranks and unnecessarily long edges.
 *    2. Construct a feasible tight tree. A tight tree is one such that all
 *       edges in the tree have no slack (difference between length of edge
 *       and minlen for the edge). This by itself greatly improves the assigned
 *       rankings by shorting edges.
 *    3. Iteratively find edges that have negative cut values. Generally a
 *       negative cut value indicates that the edge could be removed and a new
 *       tree edge could be added to produce a more compact graph.
 *
 * Much of the algorithms here are derived from Gansner, et al., "A Technique
 * for Drawing Directed Graphs." The structure of the file roughly follows the
 * structure of the overall algorithm.
 */
function networkSimplex(g) {
  g = simplify(g);
  initRank(g);
  var t = feasibleTree(g);
  initLowLimValues(t);
  initCutValues(t, g);

  var e, f;
  while ((e = leaveEdge(t))) {
    f = enterEdge(t, g, e);
    exchangeEdges(t, g, e, f);
  }
}

/*
 * Initializes cut values for all edges in the tree.
 */
function initCutValues(t, g) {
  var vs = postorder(t, t.nodes());
  vs = vs.slice(0, vs.length - 1);
  _.forEach(vs, function(v) {
    assignCutValue(t, g, v);
  });
}

function assignCutValue(t, g, child) {
  var childLab = t.node(child);
  var parent = childLab.parent;
  t.edge(child, parent).cutvalue = calcCutValue(t, g, child);
}

/*
 * Given the tight tree, its graph, and a child in the graph calculate and
 * return the cut value for the edge between the child and its parent.
 */
function calcCutValue(t, g, child) {
  var childLab = t.node(child);
  var parent = childLab.parent;
  // True if the child is on the tail end of the edge in the directed graph
  var childIsTail = true;
  // The graph's view of the tree edge we're inspecting
  var graphEdge = g.edge(child, parent);
  // The accumulated cut value for the edge between this node and its parent
  var cutValue = 0;

  if (!graphEdge) {
    childIsTail = false;
    graphEdge = g.edge(parent, child);
  }

  cutValue = graphEdge.weight;

  _.forEach(g.nodeEdges(child), function(e) {
    var isOutEdge = e.v === child,
      other = isOutEdge ? e.w : e.v;

    if (other !== parent) {
      var pointsToHead = isOutEdge === childIsTail,
        otherWeight = g.edge(e).weight;

      cutValue += pointsToHead ? otherWeight : -otherWeight;
      if (isTreeEdge(t, child, other)) {
        var otherCutValue = t.edge(child, other).cutvalue;
        cutValue += pointsToHead ? -otherCutValue : otherCutValue;
      }
    }
  });

  return cutValue;
}

function initLowLimValues(tree, root) {
  if (arguments.length < 2) {
    root = tree.nodes()[0];
  }
  dfsAssignLowLim(tree, {}, 1, root);
}

function dfsAssignLowLim(tree, visited, nextLim, v, parent) {
  var low = nextLim;
  var label = tree.node(v);

  visited[v] = true;
  _.forEach(tree.neighbors(v), function(w) {
    if (!_.has(visited, w)) {
      nextLim = dfsAssignLowLim(tree, visited, nextLim, w, v);
    }
  });

  label.low = low;
  label.lim = nextLim++;
  if (parent) {
    label.parent = parent;
  } else {
    // TODO should be able to remove this when we incrementally update low lim
    delete label.parent;
  }

  return nextLim;
}

function leaveEdge(tree) {
  return _.find(tree.edges(), function(e) {
    return tree.edge(e).cutvalue < 0;
  });
}

function enterEdge(t, g, edge) {
  var v = edge.v;
  var w = edge.w;

  // For the rest of this function we assume that v is the tail and w is the
  // head, so if we don't have this edge in the graph we should flip it to
  // match the correct orientation.
  if (!g.hasEdge(v, w)) {
    v = edge.w;
    w = edge.v;
  }

  var vLabel = t.node(v);
  var wLabel = t.node(w);
  var tailLabel = vLabel;
  var flip = false;

  // If the root is in the tail of the edge then we need to flip the logic that
  // checks for the head and tail nodes in the candidates function below.
  if (vLabel.lim > wLabel.lim) {
    tailLabel = wLabel;
    flip = true;
  }

  var candidates = _.filter(g.edges(), function(edge) {
    return flip === isDescendant(t, t.node(edge.v), tailLabel) &&
           flip !== isDescendant(t, t.node(edge.w), tailLabel);
  });

  return _.minBy(candidates, function(edge) { return slack(g, edge); });
}

function exchangeEdges(t, g, e, f) {
  var v = e.v;
  var w = e.w;
  t.removeEdge(v, w);
  t.setEdge(f.v, f.w, {});
  initLowLimValues(t);
  initCutValues(t, g);
  updateRanks(t, g);
}

function updateRanks(t, g) {
  var root = _.find(t.nodes(), function(v) { return !g.node(v).parent; });
  var vs = preorder(t, root);
  vs = vs.slice(1);
  _.forEach(vs, function(v) {
    var parent = t.node(v).parent,
      edge = g.edge(v, parent),
      flipped = false;

    if (!edge) {
      edge = g.edge(parent, v);
      flipped = true;
    }

    g.node(v).rank = g.node(parent).rank + (flipped ? edge.minlen : -edge.minlen);
  });
}

/*
 * Returns true if the edge is in the tree.
 */
function isTreeEdge(tree, u, v) {
  return tree.hasEdge(u, v);
}

/*
 * Returns true if the specified node is descendant of the root node per the
 * assigned low and lim attributes in the tree.
 */
function isDescendant(tree, vLabel, rootLabel) {
  return rootLabel.low <= vLabel.lim && vLabel.lim <= rootLabel.lim;
}


/***/ }),

/***/ "./node_modules/dagre/lib/rank/util.js":
/*!*********************************************!*\
  !*** ./node_modules/dagre/lib/rank/util.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ../lodash */ "./node_modules/dagre/lib/lodash.js");

module.exports = {
  longestPath: longestPath,
  slack: slack
};

/*
 * Initializes ranks for the input graph using the longest path algorithm. This
 * algorithm scales well and is fast in practice, it yields rather poor
 * solutions. Nodes are pushed to the lowest layer possible, leaving the bottom
 * ranks wide and leaving edges longer than necessary. However, due to its
 * speed, this algorithm is good for getting an initial ranking that can be fed
 * into other algorithms.
 *
 * This algorithm does not normalize layers because it will be used by other
 * algorithms in most cases. If using this algorithm directly, be sure to
 * run normalize at the end.
 *
 * Pre-conditions:
 *
 *    1. Input graph is a DAG.
 *    2. Input graph node labels can be assigned properties.
 *
 * Post-conditions:
 *
 *    1. Each node will be assign an (unnormalized) "rank" property.
 */
function longestPath(g) {
  var visited = {};

  function dfs(v) {
    var label = g.node(v);
    if (_.has(visited, v)) {
      return label.rank;
    }
    visited[v] = true;

    var rank = _.min(_.map(g.outEdges(v), function(e) {
      return dfs(e.w) - g.edge(e).minlen;
    }));

    if (rank === Number.POSITIVE_INFINITY || // return value of _.map([]) for Lodash 3
        rank === undefined || // return value of _.map([]) for Lodash 4
        rank === null) { // return value of _.map([null])
      rank = 0;
    }

    return (label.rank = rank);
  }

  _.forEach(g.sources(), dfs);
}

/*
 * Returns the amount of slack for the given edge. The slack is defined as the
 * difference between the length of the edge and its minimum length.
 */
function slack(g, e) {
  return g.node(e.w).rank - g.node(e.v).rank - g.edge(e).minlen;
}


/***/ }),

/***/ "./node_modules/dagre/lib/util.js":
/*!****************************************!*\
  !*** ./node_modules/dagre/lib/util.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint "no-console": off */



var _ = __webpack_require__(/*! ./lodash */ "./node_modules/dagre/lib/lodash.js");
var Graph = (__webpack_require__(/*! ./graphlib */ "./node_modules/dagre/lib/graphlib.js").Graph);

module.exports = {
  addDummyNode: addDummyNode,
  simplify: simplify,
  asNonCompoundGraph: asNonCompoundGraph,
  successorWeights: successorWeights,
  predecessorWeights: predecessorWeights,
  intersectRect: intersectRect,
  buildLayerMatrix: buildLayerMatrix,
  normalizeRanks: normalizeRanks,
  removeEmptyRanks: removeEmptyRanks,
  addBorderNode: addBorderNode,
  maxRank: maxRank,
  partition: partition,
  time: time,
  notime: notime
};

/*
 * Adds a dummy node to the graph and return v.
 */
function addDummyNode(g, type, attrs, name) {
  var v;
  do {
    v = _.uniqueId(name);
  } while (g.hasNode(v));

  attrs.dummy = type;
  g.setNode(v, attrs);
  return v;
}

/*
 * Returns a new graph with only simple edges. Handles aggregation of data
 * associated with multi-edges.
 */
function simplify(g) {
  var simplified = new Graph().setGraph(g.graph());
  _.forEach(g.nodes(), function(v) { simplified.setNode(v, g.node(v)); });
  _.forEach(g.edges(), function(e) {
    var simpleLabel = simplified.edge(e.v, e.w) || { weight: 0, minlen: 1 };
    var label = g.edge(e);
    simplified.setEdge(e.v, e.w, {
      weight: simpleLabel.weight + label.weight,
      minlen: Math.max(simpleLabel.minlen, label.minlen)
    });
  });
  return simplified;
}

function asNonCompoundGraph(g) {
  var simplified = new Graph({ multigraph: g.isMultigraph() }).setGraph(g.graph());
  _.forEach(g.nodes(), function(v) {
    if (!g.children(v).length) {
      simplified.setNode(v, g.node(v));
    }
  });
  _.forEach(g.edges(), function(e) {
    simplified.setEdge(e, g.edge(e));
  });
  return simplified;
}

function successorWeights(g) {
  var weightMap = _.map(g.nodes(), function(v) {
    var sucs = {};
    _.forEach(g.outEdges(v), function(e) {
      sucs[e.w] = (sucs[e.w] || 0) + g.edge(e).weight;
    });
    return sucs;
  });
  return _.zipObject(g.nodes(), weightMap);
}

function predecessorWeights(g) {
  var weightMap = _.map(g.nodes(), function(v) {
    var preds = {};
    _.forEach(g.inEdges(v), function(e) {
      preds[e.v] = (preds[e.v] || 0) + g.edge(e).weight;
    });
    return preds;
  });
  return _.zipObject(g.nodes(), weightMap);
}

/*
 * Finds where a line starting at point ({x, y}) would intersect a rectangle
 * ({x, y, width, height}) if it were pointing at the rectangle's center.
 */
function intersectRect(rect, point) {
  var x = rect.x;
  var y = rect.y;

  // Rectangle intersection algorithm from:
  // http://math.stackexchange.com/questions/108113/find-edge-between-two-boxes
  var dx = point.x - x;
  var dy = point.y - y;
  var w = rect.width / 2;
  var h = rect.height / 2;

  if (!dx && !dy) {
    throw new Error("Not possible to find intersection inside of the rectangle");
  }

  var sx, sy;
  if (Math.abs(dy) * w > Math.abs(dx) * h) {
    // Intersection is top or bottom of rect.
    if (dy < 0) {
      h = -h;
    }
    sx = h * dx / dy;
    sy = h;
  } else {
    // Intersection is left or right of rect.
    if (dx < 0) {
      w = -w;
    }
    sx = w;
    sy = w * dy / dx;
  }

  return { x: x + sx, y: y + sy };
}

/*
 * Given a DAG with each node assigned "rank" and "order" properties, this
 * function will produce a matrix with the ids of each node.
 */
function buildLayerMatrix(g) {
  var layering = _.map(_.range(maxRank(g) + 1), function() { return []; });
  _.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    var rank = node.rank;
    if (!_.isUndefined(rank)) {
      layering[rank][node.order] = v;
    }
  });
  return layering;
}

/*
 * Adjusts the ranks for all nodes in the graph such that all nodes v have
 * rank(v) >= 0 and at least one node w has rank(w) = 0.
 */
function normalizeRanks(g) {
  var min = _.min(_.map(g.nodes(), function(v) { return g.node(v).rank; }));
  _.forEach(g.nodes(), function(v) {
    var node = g.node(v);
    if (_.has(node, "rank")) {
      node.rank -= min;
    }
  });
}

function removeEmptyRanks(g) {
  // Ranks may not start at 0, so we need to offset them
  var offset = _.min(_.map(g.nodes(), function(v) { return g.node(v).rank; }));

  var layers = [];
  _.forEach(g.nodes(), function(v) {
    var rank = g.node(v).rank - offset;
    if (!layers[rank]) {
      layers[rank] = [];
    }
    layers[rank].push(v);
  });

  var delta = 0;
  var nodeRankFactor = g.graph().nodeRankFactor;
  _.forEach(layers, function(vs, i) {
    if (_.isUndefined(vs) && i % nodeRankFactor !== 0) {
      --delta;
    } else if (delta) {
      _.forEach(vs, function(v) { g.node(v).rank += delta; });
    }
  });
}

function addBorderNode(g, prefix, rank, order) {
  var node = {
    width: 0,
    height: 0
  };
  if (arguments.length >= 4) {
    node.rank = rank;
    node.order = order;
  }
  return addDummyNode(g, "border", node, prefix);
}

function maxRank(g) {
  return _.max(_.map(g.nodes(), function(v) {
    var rank = g.node(v).rank;
    if (!_.isUndefined(rank)) {
      return rank;
    }
  }));
}

/*
 * Partition a collection into two groups: `lhs` and `rhs`. If the supplied
 * function returns true for an entry it goes into `lhs`. Otherwise it goes
 * into `rhs.
 */
function partition(collection, fn) {
  var result = { lhs: [], rhs: [] };
  _.forEach(collection, function(value) {
    if (fn(value)) {
      result.lhs.push(value);
    } else {
      result.rhs.push(value);
    }
  });
  return result;
}

/*
 * Returns a new function that wraps `fn` with a timer. The wrapper logs the
 * time it takes to execute the function.
 */
function time(name, fn) {
  var start = _.now();
  try {
    return fn();
  } finally {
    console.log(name + " time: " + (_.now() - start) + "ms");
  }
}

function notime(name, fn) {
  return fn();
}


/***/ }),

/***/ "./node_modules/dagre/lib/version.js":
/*!*******************************************!*\
  !*** ./node_modules/dagre/lib/version.js ***!
  \*******************************************/
/***/ ((module) => {

module.exports = "0.8.5";


/***/ }),

/***/ "./node_modules/graphlib/index.js":
/*!****************************************!*\
  !*** ./node_modules/graphlib/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Copyright (c) 2014, Chris Pettitt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 * list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of the copyright holder nor the names of its contributors
 * may be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var lib = __webpack_require__(/*! ./lib */ "./node_modules/graphlib/lib/index.js");

module.exports = {
  Graph: lib.Graph,
  json: __webpack_require__(/*! ./lib/json */ "./node_modules/graphlib/lib/json.js"),
  alg: __webpack_require__(/*! ./lib/alg */ "./node_modules/graphlib/lib/alg/index.js"),
  version: lib.version
};


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/components.js":
/*!*****************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/components.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = components;

function components(g) {
  var visited = {};
  var cmpts = [];
  var cmpt;

  function dfs(v) {
    if (_.has(visited, v)) return;
    visited[v] = true;
    cmpt.push(v);
    _.each(g.successors(v), dfs);
    _.each(g.predecessors(v), dfs);
  }

  _.each(g.nodes(), function(v) {
    cmpt = [];
    dfs(v);
    if (cmpt.length) {
      cmpts.push(cmpt);
    }
  });

  return cmpts;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/dfs.js":
/*!**********************************************!*\
  !*** ./node_modules/graphlib/lib/alg/dfs.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = dfs;

/*
 * A helper that preforms a pre- or post-order traversal on the input graph
 * and returns the nodes in the order they were visited. If the graph is
 * undirected then this algorithm will navigate using neighbors. If the graph
 * is directed then this algorithm will navigate using successors.
 *
 * Order must be one of "pre" or "post".
 */
function dfs(g, vs, order) {
  if (!_.isArray(vs)) {
    vs = [vs];
  }

  var navigation = (g.isDirected() ? g.successors : g.neighbors).bind(g);

  var acc = [];
  var visited = {};
  _.each(vs, function(v) {
    if (!g.hasNode(v)) {
      throw new Error("Graph does not have node: " + v);
    }

    doDfs(g, v, order === "post", visited, navigation, acc);
  });
  return acc;
}

function doDfs(g, v, postorder, visited, navigation, acc) {
  if (!_.has(visited, v)) {
    visited[v] = true;

    if (!postorder) { acc.push(v); }
    _.each(navigation(v), function(w) {
      doDfs(g, w, postorder, visited, navigation, acc);
    });
    if (postorder) { acc.push(v); }
  }
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/dijkstra-all.js":
/*!*******************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/dijkstra-all.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var dijkstra = __webpack_require__(/*! ./dijkstra */ "./node_modules/graphlib/lib/alg/dijkstra.js");
var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = dijkstraAll;

function dijkstraAll(g, weightFunc, edgeFunc) {
  return _.transform(g.nodes(), function(acc, v) {
    acc[v] = dijkstra(g, v, weightFunc, edgeFunc);
  }, {});
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/dijkstra.js":
/*!***************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/dijkstra.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");
var PriorityQueue = __webpack_require__(/*! ../data/priority-queue */ "./node_modules/graphlib/lib/data/priority-queue.js");

module.exports = dijkstra;

var DEFAULT_WEIGHT_FUNC = _.constant(1);

function dijkstra(g, source, weightFn, edgeFn) {
  return runDijkstra(g, String(source),
    weightFn || DEFAULT_WEIGHT_FUNC,
    edgeFn || function(v) { return g.outEdges(v); });
}

function runDijkstra(g, source, weightFn, edgeFn) {
  var results = {};
  var pq = new PriorityQueue();
  var v, vEntry;

  var updateNeighbors = function(edge) {
    var w = edge.v !== v ? edge.v : edge.w;
    var wEntry = results[w];
    var weight = weightFn(edge);
    var distance = vEntry.distance + weight;

    if (weight < 0) {
      throw new Error("dijkstra does not allow negative edge weights. " +
                      "Bad edge: " + edge + " Weight: " + weight);
    }

    if (distance < wEntry.distance) {
      wEntry.distance = distance;
      wEntry.predecessor = v;
      pq.decrease(w, distance);
    }
  };

  g.nodes().forEach(function(v) {
    var distance = v === source ? 0 : Number.POSITIVE_INFINITY;
    results[v] = { distance: distance };
    pq.add(v, distance);
  });

  while (pq.size() > 0) {
    v = pq.removeMin();
    vEntry = results[v];
    if (vEntry.distance === Number.POSITIVE_INFINITY) {
      break;
    }

    edgeFn(v).forEach(updateNeighbors);
  }

  return results;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/find-cycles.js":
/*!******************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/find-cycles.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");
var tarjan = __webpack_require__(/*! ./tarjan */ "./node_modules/graphlib/lib/alg/tarjan.js");

module.exports = findCycles;

function findCycles(g) {
  return _.filter(tarjan(g), function(cmpt) {
    return cmpt.length > 1 || (cmpt.length === 1 && g.hasEdge(cmpt[0], cmpt[0]));
  });
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/floyd-warshall.js":
/*!*********************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/floyd-warshall.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = floydWarshall;

var DEFAULT_WEIGHT_FUNC = _.constant(1);

function floydWarshall(g, weightFn, edgeFn) {
  return runFloydWarshall(g,
    weightFn || DEFAULT_WEIGHT_FUNC,
    edgeFn || function(v) { return g.outEdges(v); });
}

function runFloydWarshall(g, weightFn, edgeFn) {
  var results = {};
  var nodes = g.nodes();

  nodes.forEach(function(v) {
    results[v] = {};
    results[v][v] = { distance: 0 };
    nodes.forEach(function(w) {
      if (v !== w) {
        results[v][w] = { distance: Number.POSITIVE_INFINITY };
      }
    });
    edgeFn(v).forEach(function(edge) {
      var w = edge.v === v ? edge.w : edge.v;
      var d = weightFn(edge);
      results[v][w] = { distance: d, predecessor: v };
    });
  });

  nodes.forEach(function(k) {
    var rowK = results[k];
    nodes.forEach(function(i) {
      var rowI = results[i];
      nodes.forEach(function(j) {
        var ik = rowI[k];
        var kj = rowK[j];
        var ij = rowI[j];
        var altDistance = ik.distance + kj.distance;
        if (altDistance < ij.distance) {
          ij.distance = altDistance;
          ij.predecessor = kj.predecessor;
        }
      });
    });
  });

  return results;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/index.js":
/*!************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  components: __webpack_require__(/*! ./components */ "./node_modules/graphlib/lib/alg/components.js"),
  dijkstra: __webpack_require__(/*! ./dijkstra */ "./node_modules/graphlib/lib/alg/dijkstra.js"),
  dijkstraAll: __webpack_require__(/*! ./dijkstra-all */ "./node_modules/graphlib/lib/alg/dijkstra-all.js"),
  findCycles: __webpack_require__(/*! ./find-cycles */ "./node_modules/graphlib/lib/alg/find-cycles.js"),
  floydWarshall: __webpack_require__(/*! ./floyd-warshall */ "./node_modules/graphlib/lib/alg/floyd-warshall.js"),
  isAcyclic: __webpack_require__(/*! ./is-acyclic */ "./node_modules/graphlib/lib/alg/is-acyclic.js"),
  postorder: __webpack_require__(/*! ./postorder */ "./node_modules/graphlib/lib/alg/postorder.js"),
  preorder: __webpack_require__(/*! ./preorder */ "./node_modules/graphlib/lib/alg/preorder.js"),
  prim: __webpack_require__(/*! ./prim */ "./node_modules/graphlib/lib/alg/prim.js"),
  tarjan: __webpack_require__(/*! ./tarjan */ "./node_modules/graphlib/lib/alg/tarjan.js"),
  topsort: __webpack_require__(/*! ./topsort */ "./node_modules/graphlib/lib/alg/topsort.js")
};


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/is-acyclic.js":
/*!*****************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/is-acyclic.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var topsort = __webpack_require__(/*! ./topsort */ "./node_modules/graphlib/lib/alg/topsort.js");

module.exports = isAcyclic;

function isAcyclic(g) {
  try {
    topsort(g);
  } catch (e) {
    if (e instanceof topsort.CycleException) {
      return false;
    }
    throw e;
  }
  return true;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/postorder.js":
/*!****************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/postorder.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var dfs = __webpack_require__(/*! ./dfs */ "./node_modules/graphlib/lib/alg/dfs.js");

module.exports = postorder;

function postorder(g, vs) {
  return dfs(g, vs, "post");
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/preorder.js":
/*!***************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/preorder.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var dfs = __webpack_require__(/*! ./dfs */ "./node_modules/graphlib/lib/alg/dfs.js");

module.exports = preorder;

function preorder(g, vs) {
  return dfs(g, vs, "pre");
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/prim.js":
/*!***********************************************!*\
  !*** ./node_modules/graphlib/lib/alg/prim.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");
var Graph = __webpack_require__(/*! ../graph */ "./node_modules/graphlib/lib/graph.js");
var PriorityQueue = __webpack_require__(/*! ../data/priority-queue */ "./node_modules/graphlib/lib/data/priority-queue.js");

module.exports = prim;

function prim(g, weightFunc) {
  var result = new Graph();
  var parents = {};
  var pq = new PriorityQueue();
  var v;

  function updateNeighbors(edge) {
    var w = edge.v === v ? edge.w : edge.v;
    var pri = pq.priority(w);
    if (pri !== undefined) {
      var edgeWeight = weightFunc(edge);
      if (edgeWeight < pri) {
        parents[w] = v;
        pq.decrease(w, edgeWeight);
      }
    }
  }

  if (g.nodeCount() === 0) {
    return result;
  }

  _.each(g.nodes(), function(v) {
    pq.add(v, Number.POSITIVE_INFINITY);
    result.setNode(v);
  });

  // Start from an arbitrary node
  pq.decrease(g.nodes()[0], 0);

  var init = false;
  while (pq.size() > 0) {
    v = pq.removeMin();
    if (_.has(parents, v)) {
      result.setEdge(v, parents[v]);
    } else if (init) {
      throw new Error("Input graph is not connected: " + g);
    } else {
      init = true;
    }

    g.nodeEdges(v).forEach(updateNeighbors);
  }

  return result;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/tarjan.js":
/*!*************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/tarjan.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = tarjan;

function tarjan(g) {
  var index = 0;
  var stack = [];
  var visited = {}; // node id -> { onStack, lowlink, index }
  var results = [];

  function dfs(v) {
    var entry = visited[v] = {
      onStack: true,
      lowlink: index,
      index: index++
    };
    stack.push(v);

    g.successors(v).forEach(function(w) {
      if (!_.has(visited, w)) {
        dfs(w);
        entry.lowlink = Math.min(entry.lowlink, visited[w].lowlink);
      } else if (visited[w].onStack) {
        entry.lowlink = Math.min(entry.lowlink, visited[w].index);
      }
    });

    if (entry.lowlink === entry.index) {
      var cmpt = [];
      var w;
      do {
        w = stack.pop();
        visited[w].onStack = false;
        cmpt.push(w);
      } while (v !== w);
      results.push(cmpt);
    }
  }

  g.nodes().forEach(function(v) {
    if (!_.has(visited, v)) {
      dfs(v);
    }
  });

  return results;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/alg/topsort.js":
/*!**************************************************!*\
  !*** ./node_modules/graphlib/lib/alg/topsort.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = topsort;
topsort.CycleException = CycleException;

function topsort(g) {
  var visited = {};
  var stack = {};
  var results = [];

  function visit(node) {
    if (_.has(stack, node)) {
      throw new CycleException();
    }

    if (!_.has(visited, node)) {
      stack[node] = true;
      visited[node] = true;
      _.each(g.predecessors(node), visit);
      delete stack[node];
      results.push(node);
    }
  }

  _.each(g.sinks(), visit);

  if (_.size(visited) !== g.nodeCount()) {
    throw new CycleException();
  }

  return results;
}

function CycleException() {}
CycleException.prototype = new Error(); // must be an instance of Error to pass testing

/***/ }),

/***/ "./node_modules/graphlib/lib/data/priority-queue.js":
/*!**********************************************************!*\
  !*** ./node_modules/graphlib/lib/data/priority-queue.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ../lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = PriorityQueue;

/**
 * A min-priority queue data structure. This algorithm is derived from Cormen,
 * et al., "Introduction to Algorithms". The basic idea of a min-priority
 * queue is that you can efficiently (in O(1) time) get the smallest key in
 * the queue. Adding and removing elements takes O(log n) time. A key can
 * have its priority decreased in O(log n) time.
 */
function PriorityQueue() {
  this._arr = [];
  this._keyIndices = {};
}

/**
 * Returns the number of elements in the queue. Takes `O(1)` time.
 */
PriorityQueue.prototype.size = function() {
  return this._arr.length;
};

/**
 * Returns the keys that are in the queue. Takes `O(n)` time.
 */
PriorityQueue.prototype.keys = function() {
  return this._arr.map(function(x) { return x.key; });
};

/**
 * Returns `true` if **key** is in the queue and `false` if not.
 */
PriorityQueue.prototype.has = function(key) {
  return _.has(this._keyIndices, key);
};

/**
 * Returns the priority for **key**. If **key** is not present in the queue
 * then this function returns `undefined`. Takes `O(1)` time.
 *
 * @param {Object} key
 */
PriorityQueue.prototype.priority = function(key) {
  var index = this._keyIndices[key];
  if (index !== undefined) {
    return this._arr[index].priority;
  }
};

/**
 * Returns the key for the minimum element in this queue. If the queue is
 * empty this function throws an Error. Takes `O(1)` time.
 */
PriorityQueue.prototype.min = function() {
  if (this.size() === 0) {
    throw new Error("Queue underflow");
  }
  return this._arr[0].key;
};

/**
 * Inserts a new key into the priority queue. If the key already exists in
 * the queue this function returns `false`; otherwise it will return `true`.
 * Takes `O(n)` time.
 *
 * @param {Object} key the key to add
 * @param {Number} priority the initial priority for the key
 */
PriorityQueue.prototype.add = function(key, priority) {
  var keyIndices = this._keyIndices;
  key = String(key);
  if (!_.has(keyIndices, key)) {
    var arr = this._arr;
    var index = arr.length;
    keyIndices[key] = index;
    arr.push({key: key, priority: priority});
    this._decrease(index);
    return true;
  }
  return false;
};

/**
 * Removes and returns the smallest key in the queue. Takes `O(log n)` time.
 */
PriorityQueue.prototype.removeMin = function() {
  this._swap(0, this._arr.length - 1);
  var min = this._arr.pop();
  delete this._keyIndices[min.key];
  this._heapify(0);
  return min.key;
};

/**
 * Decreases the priority for **key** to **priority**. If the new priority is
 * greater than the previous priority, this function will throw an Error.
 *
 * @param {Object} key the key for which to raise priority
 * @param {Number} priority the new priority for the key
 */
PriorityQueue.prototype.decrease = function(key, priority) {
  var index = this._keyIndices[key];
  if (priority > this._arr[index].priority) {
    throw new Error("New priority is greater than current priority. " +
        "Key: " + key + " Old: " + this._arr[index].priority + " New: " + priority);
  }
  this._arr[index].priority = priority;
  this._decrease(index);
};

PriorityQueue.prototype._heapify = function(i) {
  var arr = this._arr;
  var l = 2 * i;
  var r = l + 1;
  var largest = i;
  if (l < arr.length) {
    largest = arr[l].priority < arr[largest].priority ? l : largest;
    if (r < arr.length) {
      largest = arr[r].priority < arr[largest].priority ? r : largest;
    }
    if (largest !== i) {
      this._swap(i, largest);
      this._heapify(largest);
    }
  }
};

PriorityQueue.prototype._decrease = function(index) {
  var arr = this._arr;
  var priority = arr[index].priority;
  var parent;
  while (index !== 0) {
    parent = index >> 1;
    if (arr[parent].priority < priority) {
      break;
    }
    this._swap(index, parent);
    index = parent;
  }
};

PriorityQueue.prototype._swap = function(i, j) {
  var arr = this._arr;
  var keyIndices = this._keyIndices;
  var origArrI = arr[i];
  var origArrJ = arr[j];
  arr[i] = origArrJ;
  arr[j] = origArrI;
  keyIndices[origArrJ.key] = i;
  keyIndices[origArrI.key] = j;
};


/***/ }),

/***/ "./node_modules/graphlib/lib/graph.js":
/*!********************************************!*\
  !*** ./node_modules/graphlib/lib/graph.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _ = __webpack_require__(/*! ./lodash */ "./node_modules/graphlib/lib/lodash.js");

module.exports = Graph;

var DEFAULT_EDGE_NAME = "\x00";
var GRAPH_NODE = "\x00";
var EDGE_KEY_DELIM = "\x01";

// Implementation notes:
//
//  * Node id query functions should return string ids for the nodes
//  * Edge id query functions should return an "edgeObj", edge object, that is
//    composed of enough information to uniquely identify an edge: {v, w, name}.
//  * Internally we use an "edgeId", a stringified form of the edgeObj, to
//    reference edges. This is because we need a performant way to look these
//    edges up and, object properties, which have string keys, are the closest
//    we're going to get to a performant hashtable in JavaScript.

function Graph(opts) {
  this._isDirected = _.has(opts, "directed") ? opts.directed : true;
  this._isMultigraph = _.has(opts, "multigraph") ? opts.multigraph : false;
  this._isCompound = _.has(opts, "compound") ? opts.compound : false;

  // Label for the graph itself
  this._label = undefined;

  // Defaults to be set when creating a new node
  this._defaultNodeLabelFn = _.constant(undefined);

  // Defaults to be set when creating a new edge
  this._defaultEdgeLabelFn = _.constant(undefined);

  // v -> label
  this._nodes = {};

  if (this._isCompound) {
    // v -> parent
    this._parent = {};

    // v -> children
    this._children = {};
    this._children[GRAPH_NODE] = {};
  }

  // v -> edgeObj
  this._in = {};

  // u -> v -> Number
  this._preds = {};

  // v -> edgeObj
  this._out = {};

  // v -> w -> Number
  this._sucs = {};

  // e -> edgeObj
  this._edgeObjs = {};

  // e -> label
  this._edgeLabels = {};
}

/* Number of nodes in the graph. Should only be changed by the implementation. */
Graph.prototype._nodeCount = 0;

/* Number of edges in the graph. Should only be changed by the implementation. */
Graph.prototype._edgeCount = 0;


/* === Graph functions ========= */

Graph.prototype.isDirected = function() {
  return this._isDirected;
};

Graph.prototype.isMultigraph = function() {
  return this._isMultigraph;
};

Graph.prototype.isCompound = function() {
  return this._isCompound;
};

Graph.prototype.setGraph = function(label) {
  this._label = label;
  return this;
};

Graph.prototype.graph = function() {
  return this._label;
};


/* === Node functions ========== */

Graph.prototype.setDefaultNodeLabel = function(newDefault) {
  if (!_.isFunction(newDefault)) {
    newDefault = _.constant(newDefault);
  }
  this._defaultNodeLabelFn = newDefault;
  return this;
};

Graph.prototype.nodeCount = function() {
  return this._nodeCount;
};

Graph.prototype.nodes = function() {
  return _.keys(this._nodes);
};

Graph.prototype.sources = function() {
  var self = this;
  return _.filter(this.nodes(), function(v) {
    return _.isEmpty(self._in[v]);
  });
};

Graph.prototype.sinks = function() {
  var self = this;
  return _.filter(this.nodes(), function(v) {
    return _.isEmpty(self._out[v]);
  });
};

Graph.prototype.setNodes = function(vs, value) {
  var args = arguments;
  var self = this;
  _.each(vs, function(v) {
    if (args.length > 1) {
      self.setNode(v, value);
    } else {
      self.setNode(v);
    }
  });
  return this;
};

Graph.prototype.setNode = function(v, value) {
  if (_.has(this._nodes, v)) {
    if (arguments.length > 1) {
      this._nodes[v] = value;
    }
    return this;
  }

  this._nodes[v] = arguments.length > 1 ? value : this._defaultNodeLabelFn(v);
  if (this._isCompound) {
    this._parent[v] = GRAPH_NODE;
    this._children[v] = {};
    this._children[GRAPH_NODE][v] = true;
  }
  this._in[v] = {};
  this._preds[v] = {};
  this._out[v] = {};
  this._sucs[v] = {};
  ++this._nodeCount;
  return this;
};

Graph.prototype.node = function(v) {
  return this._nodes[v];
};

Graph.prototype.hasNode = function(v) {
  return _.has(this._nodes, v);
};

Graph.prototype.removeNode =  function(v) {
  var self = this;
  if (_.has(this._nodes, v)) {
    var removeEdge = function(e) { self.removeEdge(self._edgeObjs[e]); };
    delete this._nodes[v];
    if (this._isCompound) {
      this._removeFromParentsChildList(v);
      delete this._parent[v];
      _.each(this.children(v), function(child) {
        self.setParent(child);
      });
      delete this._children[v];
    }
    _.each(_.keys(this._in[v]), removeEdge);
    delete this._in[v];
    delete this._preds[v];
    _.each(_.keys(this._out[v]), removeEdge);
    delete this._out[v];
    delete this._sucs[v];
    --this._nodeCount;
  }
  return this;
};

Graph.prototype.setParent = function(v, parent) {
  if (!this._isCompound) {
    throw new Error("Cannot set parent in a non-compound graph");
  }

  if (_.isUndefined(parent)) {
    parent = GRAPH_NODE;
  } else {
    // Coerce parent to string
    parent += "";
    for (var ancestor = parent;
      !_.isUndefined(ancestor);
      ancestor = this.parent(ancestor)) {
      if (ancestor === v) {
        throw new Error("Setting " + parent+ " as parent of " + v +
                        " would create a cycle");
      }
    }

    this.setNode(parent);
  }

  this.setNode(v);
  this._removeFromParentsChildList(v);
  this._parent[v] = parent;
  this._children[parent][v] = true;
  return this;
};

Graph.prototype._removeFromParentsChildList = function(v) {
  delete this._children[this._parent[v]][v];
};

Graph.prototype.parent = function(v) {
  if (this._isCompound) {
    var parent = this._parent[v];
    if (parent !== GRAPH_NODE) {
      return parent;
    }
  }
};

Graph.prototype.children = function(v) {
  if (_.isUndefined(v)) {
    v = GRAPH_NODE;
  }

  if (this._isCompound) {
    var children = this._children[v];
    if (children) {
      return _.keys(children);
    }
  } else if (v === GRAPH_NODE) {
    return this.nodes();
  } else if (this.hasNode(v)) {
    return [];
  }
};

Graph.prototype.predecessors = function(v) {
  var predsV = this._preds[v];
  if (predsV) {
    return _.keys(predsV);
  }
};

Graph.prototype.successors = function(v) {
  var sucsV = this._sucs[v];
  if (sucsV) {
    return _.keys(sucsV);
  }
};

Graph.prototype.neighbors = function(v) {
  var preds = this.predecessors(v);
  if (preds) {
    return _.union(preds, this.successors(v));
  }
};

Graph.prototype.isLeaf = function (v) {
  var neighbors;
  if (this.isDirected()) {
    neighbors = this.successors(v);
  } else {
    neighbors = this.neighbors(v);
  }
  return neighbors.length === 0;
};

Graph.prototype.filterNodes = function(filter) {
  var copy = new this.constructor({
    directed: this._isDirected,
    multigraph: this._isMultigraph,
    compound: this._isCompound
  });

  copy.setGraph(this.graph());

  var self = this;
  _.each(this._nodes, function(value, v) {
    if (filter(v)) {
      copy.setNode(v, value);
    }
  });

  _.each(this._edgeObjs, function(e) {
    if (copy.hasNode(e.v) && copy.hasNode(e.w)) {
      copy.setEdge(e, self.edge(e));
    }
  });

  var parents = {};
  function findParent(v) {
    var parent = self.parent(v);
    if (parent === undefined || copy.hasNode(parent)) {
      parents[v] = parent;
      return parent;
    } else if (parent in parents) {
      return parents[parent];
    } else {
      return findParent(parent);
    }
  }

  if (this._isCompound) {
    _.each(copy.nodes(), function(v) {
      copy.setParent(v, findParent(v));
    });
  }

  return copy;
};

/* === Edge functions ========== */

Graph.prototype.setDefaultEdgeLabel = function(newDefault) {
  if (!_.isFunction(newDefault)) {
    newDefault = _.constant(newDefault);
  }
  this._defaultEdgeLabelFn = newDefault;
  return this;
};

Graph.prototype.edgeCount = function() {
  return this._edgeCount;
};

Graph.prototype.edges = function() {
  return _.values(this._edgeObjs);
};

Graph.prototype.setPath = function(vs, value) {
  var self = this;
  var args = arguments;
  _.reduce(vs, function(v, w) {
    if (args.length > 1) {
      self.setEdge(v, w, value);
    } else {
      self.setEdge(v, w);
    }
    return w;
  });
  return this;
};

/*
 * setEdge(v, w, [value, [name]])
 * setEdge({ v, w, [name] }, [value])
 */
Graph.prototype.setEdge = function() {
  var v, w, name, value;
  var valueSpecified = false;
  var arg0 = arguments[0];

  if (typeof arg0 === "object" && arg0 !== null && "v" in arg0) {
    v = arg0.v;
    w = arg0.w;
    name = arg0.name;
    if (arguments.length === 2) {
      value = arguments[1];
      valueSpecified = true;
    }
  } else {
    v = arg0;
    w = arguments[1];
    name = arguments[3];
    if (arguments.length > 2) {
      value = arguments[2];
      valueSpecified = true;
    }
  }

  v = "" + v;
  w = "" + w;
  if (!_.isUndefined(name)) {
    name = "" + name;
  }

  var e = edgeArgsToId(this._isDirected, v, w, name);
  if (_.has(this._edgeLabels, e)) {
    if (valueSpecified) {
      this._edgeLabels[e] = value;
    }
    return this;
  }

  if (!_.isUndefined(name) && !this._isMultigraph) {
    throw new Error("Cannot set a named edge when isMultigraph = false");
  }

  // It didn't exist, so we need to create it.
  // First ensure the nodes exist.
  this.setNode(v);
  this.setNode(w);

  this._edgeLabels[e] = valueSpecified ? value : this._defaultEdgeLabelFn(v, w, name);

  var edgeObj = edgeArgsToObj(this._isDirected, v, w, name);
  // Ensure we add undirected edges in a consistent way.
  v = edgeObj.v;
  w = edgeObj.w;

  Object.freeze(edgeObj);
  this._edgeObjs[e] = edgeObj;
  incrementOrInitEntry(this._preds[w], v);
  incrementOrInitEntry(this._sucs[v], w);
  this._in[w][e] = edgeObj;
  this._out[v][e] = edgeObj;
  this._edgeCount++;
  return this;
};

Graph.prototype.edge = function(v, w, name) {
  var e = (arguments.length === 1
    ? edgeObjToId(this._isDirected, arguments[0])
    : edgeArgsToId(this._isDirected, v, w, name));
  return this._edgeLabels[e];
};

Graph.prototype.hasEdge = function(v, w, name) {
  var e = (arguments.length === 1
    ? edgeObjToId(this._isDirected, arguments[0])
    : edgeArgsToId(this._isDirected, v, w, name));
  return _.has(this._edgeLabels, e);
};

Graph.prototype.removeEdge = function(v, w, name) {
  var e = (arguments.length === 1
    ? edgeObjToId(this._isDirected, arguments[0])
    : edgeArgsToId(this._isDirected, v, w, name));
  var edge = this._edgeObjs[e];
  if (edge) {
    v = edge.v;
    w = edge.w;
    delete this._edgeLabels[e];
    delete this._edgeObjs[e];
    decrementOrRemoveEntry(this._preds[w], v);
    decrementOrRemoveEntry(this._sucs[v], w);
    delete this._in[w][e];
    delete this._out[v][e];
    this._edgeCount--;
  }
  return this;
};

Graph.prototype.inEdges = function(v, u) {
  var inV = this._in[v];
  if (inV) {
    var edges = _.values(inV);
    if (!u) {
      return edges;
    }
    return _.filter(edges, function(edge) { return edge.v === u; });
  }
};

Graph.prototype.outEdges = function(v, w) {
  var outV = this._out[v];
  if (outV) {
    var edges = _.values(outV);
    if (!w) {
      return edges;
    }
    return _.filter(edges, function(edge) { return edge.w === w; });
  }
};

Graph.prototype.nodeEdges = function(v, w) {
  var inEdges = this.inEdges(v, w);
  if (inEdges) {
    return inEdges.concat(this.outEdges(v, w));
  }
};

function incrementOrInitEntry(map, k) {
  if (map[k]) {
    map[k]++;
  } else {
    map[k] = 1;
  }
}

function decrementOrRemoveEntry(map, k) {
  if (!--map[k]) { delete map[k]; }
}

function edgeArgsToId(isDirected, v_, w_, name) {
  var v = "" + v_;
  var w = "" + w_;
  if (!isDirected && v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }
  return v + EDGE_KEY_DELIM + w + EDGE_KEY_DELIM +
             (_.isUndefined(name) ? DEFAULT_EDGE_NAME : name);
}

function edgeArgsToObj(isDirected, v_, w_, name) {
  var v = "" + v_;
  var w = "" + w_;
  if (!isDirected && v > w) {
    var tmp = v;
    v = w;
    w = tmp;
  }
  var edgeObj =  { v: v, w: w };
  if (name) {
    edgeObj.name = name;
  }
  return edgeObj;
}

function edgeObjToId(isDirected, edgeObj) {
  return edgeArgsToId(isDirected, edgeObj.v, edgeObj.w, edgeObj.name);
}


/***/ }),

/***/ "./node_modules/graphlib/lib/index.js":
/*!********************************************!*\
  !*** ./node_modules/graphlib/lib/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Includes only the "core" of graphlib
module.exports = {
  Graph: __webpack_require__(/*! ./graph */ "./node_modules/graphlib/lib/graph.js"),
  version: __webpack_require__(/*! ./version */ "./node_modules/graphlib/lib/version.js")
};


/***/ }),

/***/ "./node_modules/graphlib/lib/json.js":
/*!*******************************************!*\
  !*** ./node_modules/graphlib/lib/json.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _ = __webpack_require__(/*! ./lodash */ "./node_modules/graphlib/lib/lodash.js");
var Graph = __webpack_require__(/*! ./graph */ "./node_modules/graphlib/lib/graph.js");

module.exports = {
  write: write,
  read: read
};

function write(g) {
  var json = {
    options: {
      directed: g.isDirected(),
      multigraph: g.isMultigraph(),
      compound: g.isCompound()
    },
    nodes: writeNodes(g),
    edges: writeEdges(g)
  };
  if (!_.isUndefined(g.graph())) {
    json.value = _.clone(g.graph());
  }
  return json;
}

function writeNodes(g) {
  return _.map(g.nodes(), function(v) {
    var nodeValue = g.node(v);
    var parent = g.parent(v);
    var node = { v: v };
    if (!_.isUndefined(nodeValue)) {
      node.value = nodeValue;
    }
    if (!_.isUndefined(parent)) {
      node.parent = parent;
    }
    return node;
  });
}

function writeEdges(g) {
  return _.map(g.edges(), function(e) {
    var edgeValue = g.edge(e);
    var edge = { v: e.v, w: e.w };
    if (!_.isUndefined(e.name)) {
      edge.name = e.name;
    }
    if (!_.isUndefined(edgeValue)) {
      edge.value = edgeValue;
    }
    return edge;
  });
}

function read(json) {
  var g = new Graph(json.options).setGraph(json.value);
  _.each(json.nodes, function(entry) {
    g.setNode(entry.v, entry.value);
    if (entry.parent) {
      g.setParent(entry.v, entry.parent);
    }
  });
  _.each(json.edges, function(entry) {
    g.setEdge({ v: entry.v, w: entry.w, name: entry.name }, entry.value);
  });
  return g;
}


/***/ }),

/***/ "./node_modules/graphlib/lib/lodash.js":
/*!*********************************************!*\
  !*** ./node_modules/graphlib/lib/lodash.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* global window */

var lodash;

if (true) {
  try {
    lodash = {
      clone: __webpack_require__(/*! lodash/clone */ "./node_modules/lodash/clone.js"),
      constant: __webpack_require__(/*! lodash/constant */ "./node_modules/lodash/constant.js"),
      each: __webpack_require__(/*! lodash/each */ "./node_modules/lodash/each.js"),
      filter: __webpack_require__(/*! lodash/filter */ "./node_modules/lodash/filter.js"),
      has:  __webpack_require__(/*! lodash/has */ "./node_modules/lodash/has.js"),
      isArray: __webpack_require__(/*! lodash/isArray */ "./node_modules/lodash/isArray.js"),
      isEmpty: __webpack_require__(/*! lodash/isEmpty */ "./node_modules/lodash/isEmpty.js"),
      isFunction: __webpack_require__(/*! lodash/isFunction */ "./node_modules/lodash/isFunction.js"),
      isUndefined: __webpack_require__(/*! lodash/isUndefined */ "./node_modules/lodash/isUndefined.js"),
      keys: __webpack_require__(/*! lodash/keys */ "./node_modules/lodash/keys.js"),
      map: __webpack_require__(/*! lodash/map */ "./node_modules/lodash/map.js"),
      reduce: __webpack_require__(/*! lodash/reduce */ "./node_modules/lodash/reduce.js"),
      size: __webpack_require__(/*! lodash/size */ "./node_modules/lodash/size.js"),
      transform: __webpack_require__(/*! lodash/transform */ "./node_modules/lodash/transform.js"),
      union: __webpack_require__(/*! lodash/union */ "./node_modules/lodash/union.js"),
      values: __webpack_require__(/*! lodash/values */ "./node_modules/lodash/values.js")
    };
  } catch (e) {
    // continue regardless of error
  }
}

if (!lodash) {
  lodash = window._;
}

module.exports = lodash;


/***/ }),

/***/ "./node_modules/graphlib/lib/version.js":
/*!**********************************************!*\
  !*** ./node_modules/graphlib/lib/version.js ***!
  \**********************************************/
/***/ ((module) => {

module.exports = '2.1.8';


/***/ }),

/***/ "./node_modules/is-any-array/lib-esm/index.js":
/*!****************************************************!*\
  !*** ./node_modules/is-any-array/lib-esm/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isAnyArray: () => (/* binding */ isAnyArray)
/* harmony export */ });
// eslint-disable-next-line @typescript-eslint/unbound-method
const toString = Object.prototype.toString;
/**
 * Checks if an object is an instance of an Array (array or typed array, except those that contain bigint values).
 *
 * @param value - Object to check.
 * @returns True if the object is an array or a typed array.
 */
function isAnyArray(value) {
    const tag = toString.call(value);
    return tag.endsWith('Array]') && !tag.includes('Big');
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/lodash/_DataView.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_DataView.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),

/***/ "./node_modules/lodash/_Hash.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_Hash.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hashClear = __webpack_require__(/*! ./_hashClear */ "./node_modules/lodash/_hashClear.js"),
    hashDelete = __webpack_require__(/*! ./_hashDelete */ "./node_modules/lodash/_hashDelete.js"),
    hashGet = __webpack_require__(/*! ./_hashGet */ "./node_modules/lodash/_hashGet.js"),
    hashHas = __webpack_require__(/*! ./_hashHas */ "./node_modules/lodash/_hashHas.js"),
    hashSet = __webpack_require__(/*! ./_hashSet */ "./node_modules/lodash/_hashSet.js");

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),

/***/ "./node_modules/lodash/_ListCache.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_ListCache.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var listCacheClear = __webpack_require__(/*! ./_listCacheClear */ "./node_modules/lodash/_listCacheClear.js"),
    listCacheDelete = __webpack_require__(/*! ./_listCacheDelete */ "./node_modules/lodash/_listCacheDelete.js"),
    listCacheGet = __webpack_require__(/*! ./_listCacheGet */ "./node_modules/lodash/_listCacheGet.js"),
    listCacheHas = __webpack_require__(/*! ./_listCacheHas */ "./node_modules/lodash/_listCacheHas.js"),
    listCacheSet = __webpack_require__(/*! ./_listCacheSet */ "./node_modules/lodash/_listCacheSet.js");

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),

/***/ "./node_modules/lodash/_Map.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Map.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),

/***/ "./node_modules/lodash/_MapCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_MapCache.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mapCacheClear = __webpack_require__(/*! ./_mapCacheClear */ "./node_modules/lodash/_mapCacheClear.js"),
    mapCacheDelete = __webpack_require__(/*! ./_mapCacheDelete */ "./node_modules/lodash/_mapCacheDelete.js"),
    mapCacheGet = __webpack_require__(/*! ./_mapCacheGet */ "./node_modules/lodash/_mapCacheGet.js"),
    mapCacheHas = __webpack_require__(/*! ./_mapCacheHas */ "./node_modules/lodash/_mapCacheHas.js"),
    mapCacheSet = __webpack_require__(/*! ./_mapCacheSet */ "./node_modules/lodash/_mapCacheSet.js");

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),

/***/ "./node_modules/lodash/_Promise.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_Promise.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),

/***/ "./node_modules/lodash/_Set.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/_Set.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),

/***/ "./node_modules/lodash/_SetCache.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_SetCache.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js"),
    setCacheAdd = __webpack_require__(/*! ./_setCacheAdd */ "./node_modules/lodash/_setCacheAdd.js"),
    setCacheHas = __webpack_require__(/*! ./_setCacheHas */ "./node_modules/lodash/_setCacheHas.js");

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),

/***/ "./node_modules/lodash/_Stack.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_Stack.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    stackClear = __webpack_require__(/*! ./_stackClear */ "./node_modules/lodash/_stackClear.js"),
    stackDelete = __webpack_require__(/*! ./_stackDelete */ "./node_modules/lodash/_stackDelete.js"),
    stackGet = __webpack_require__(/*! ./_stackGet */ "./node_modules/lodash/_stackGet.js"),
    stackHas = __webpack_require__(/*! ./_stackHas */ "./node_modules/lodash/_stackHas.js"),
    stackSet = __webpack_require__(/*! ./_stackSet */ "./node_modules/lodash/_stackSet.js");

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ "./node_modules/lodash/_Uint8Array.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_Uint8Array.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),

/***/ "./node_modules/lodash/_WeakMap.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_WeakMap.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js"),
    root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),

/***/ "./node_modules/lodash/_apply.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_apply.js ***!
  \***************************************/
/***/ ((module) => {

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;


/***/ }),

/***/ "./node_modules/lodash/_arrayEach.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayEach.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

module.exports = arrayEach;


/***/ }),

/***/ "./node_modules/lodash/_arrayFilter.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_arrayFilter.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),

/***/ "./node_modules/lodash/_arrayIncludes.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayIncludes.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIndexOf = __webpack_require__(/*! ./_baseIndexOf */ "./node_modules/lodash/_baseIndexOf.js");

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array == null ? 0 : array.length;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

module.exports = arrayIncludes;


/***/ }),

/***/ "./node_modules/lodash/_arrayIncludesWith.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash/_arrayIncludesWith.js ***!
  \***************************************************/
/***/ ((module) => {

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

module.exports = arrayIncludesWith;


/***/ }),

/***/ "./node_modules/lodash/_arrayLikeKeys.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_arrayLikeKeys.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTimes = __webpack_require__(/*! ./_baseTimes */ "./node_modules/lodash/_baseTimes.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),

/***/ "./node_modules/lodash/_arrayMap.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_arrayMap.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;


/***/ }),

/***/ "./node_modules/lodash/_arrayPush.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arrayPush.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),

/***/ "./node_modules/lodash/_arrayReduce.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_arrayReduce.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

module.exports = arrayReduce;


/***/ }),

/***/ "./node_modules/lodash/_arraySome.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_arraySome.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),

/***/ "./node_modules/lodash/_asciiSize.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_asciiSize.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseProperty = __webpack_require__(/*! ./_baseProperty */ "./node_modules/lodash/_baseProperty.js");

/**
 * Gets the size of an ASCII `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */
var asciiSize = baseProperty('length');

module.exports = asciiSize;


/***/ }),

/***/ "./node_modules/lodash/_assignMergeValue.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_assignMergeValue.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignMergeValue;


/***/ }),

/***/ "./node_modules/lodash/_assignValue.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_assignValue.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

module.exports = assignValue;


/***/ }),

/***/ "./node_modules/lodash/_assocIndexOf.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_assocIndexOf.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js");

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),

/***/ "./node_modules/lodash/_baseAssign.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseAssign.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && copyObject(source, keys(source), object);
}

module.exports = baseAssign;


/***/ }),

/***/ "./node_modules/lodash/_baseAssignIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseAssignIn.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && copyObject(source, keysIn(source), object);
}

module.exports = baseAssignIn;


/***/ }),

/***/ "./node_modules/lodash/_baseAssignValue.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseAssignValue.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defineProperty = __webpack_require__(/*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js");

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

module.exports = baseAssignValue;


/***/ }),

/***/ "./node_modules/lodash/_baseClone.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseClone.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseAssign = __webpack_require__(/*! ./_baseAssign */ "./node_modules/lodash/_baseAssign.js"),
    baseAssignIn = __webpack_require__(/*! ./_baseAssignIn */ "./node_modules/lodash/_baseAssignIn.js"),
    cloneBuffer = __webpack_require__(/*! ./_cloneBuffer */ "./node_modules/lodash/_cloneBuffer.js"),
    copyArray = __webpack_require__(/*! ./_copyArray */ "./node_modules/lodash/_copyArray.js"),
    copySymbols = __webpack_require__(/*! ./_copySymbols */ "./node_modules/lodash/_copySymbols.js"),
    copySymbolsIn = __webpack_require__(/*! ./_copySymbolsIn */ "./node_modules/lodash/_copySymbolsIn.js"),
    getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js"),
    getAllKeysIn = __webpack_require__(/*! ./_getAllKeysIn */ "./node_modules/lodash/_getAllKeysIn.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    initCloneArray = __webpack_require__(/*! ./_initCloneArray */ "./node_modules/lodash/_initCloneArray.js"),
    initCloneByTag = __webpack_require__(/*! ./_initCloneByTag */ "./node_modules/lodash/_initCloneByTag.js"),
    initCloneObject = __webpack_require__(/*! ./_initCloneObject */ "./node_modules/lodash/_initCloneObject.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isMap = __webpack_require__(/*! ./isMap */ "./node_modules/lodash/isMap.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isSet = __webpack_require__(/*! ./isSet */ "./node_modules/lodash/isSet.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] =
cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
cloneableTags[boolTag] = cloneableTags[dateTag] =
cloneableTags[float32Tag] = cloneableTags[float64Tag] =
cloneableTags[int8Tag] = cloneableTags[int16Tag] =
cloneableTags[int32Tag] = cloneableTags[mapTag] =
cloneableTags[numberTag] = cloneableTags[objectTag] =
cloneableTags[regexpTag] = cloneableTags[setTag] =
cloneableTags[stringTag] = cloneableTags[symbolTag] =
cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
cloneableTags[errorTag] = cloneableTags[funcTag] =
cloneableTags[weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!isObject(value)) {
    return value;
  }
  var isArr = isArray(value);
  if (isArr) {
    result = initCloneArray(value);
    if (!isDeep) {
      return copyArray(value, result);
    }
  } else {
    var tag = getTag(value),
        isFunc = tag == funcTag || tag == genTag;

    if (isBuffer(value)) {
      return cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? copySymbolsIn(value, baseAssignIn(result, value))
          : copySymbols(value, baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? getAllKeysIn : getAllKeys)
    : (isFlat ? keysIn : keys);

  var props = isArr ? undefined : keysFunc(value);
  arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

module.exports = baseClone;


/***/ }),

/***/ "./node_modules/lodash/_baseCreate.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseCreate.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

module.exports = baseCreate;


/***/ }),

/***/ "./node_modules/lodash/_baseEach.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseEach.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseForOwn = __webpack_require__(/*! ./_baseForOwn */ "./node_modules/lodash/_baseForOwn.js"),
    createBaseEach = __webpack_require__(/*! ./_createBaseEach */ "./node_modules/lodash/_createBaseEach.js");

/**
 * The base implementation of `_.forEach` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 */
var baseEach = createBaseEach(baseForOwn);

module.exports = baseEach;


/***/ }),

/***/ "./node_modules/lodash/_baseExtremum.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseExtremum.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/**
 * The base implementation of methods like `_.max` and `_.min` which accepts a
 * `comparator` to determine the extremum value.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The iteratee invoked per iteration.
 * @param {Function} comparator The comparator used to compare values.
 * @returns {*} Returns the extremum value.
 */
function baseExtremum(array, iteratee, comparator) {
  var index = -1,
      length = array.length;

  while (++index < length) {
    var value = array[index],
        current = iteratee(value);

    if (current != null && (computed === undefined
          ? (current === current && !isSymbol(current))
          : comparator(current, computed)
        )) {
      var computed = current,
          result = value;
    }
  }
  return result;
}

module.exports = baseExtremum;


/***/ }),

/***/ "./node_modules/lodash/_baseFilter.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseFilter.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js");

/**
 * The base implementation of `_.filter` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function baseFilter(collection, predicate) {
  var result = [];
  baseEach(collection, function(value, index, collection) {
    if (predicate(value, index, collection)) {
      result.push(value);
    }
  });
  return result;
}

module.exports = baseFilter;


/***/ }),

/***/ "./node_modules/lodash/_baseFindIndex.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_baseFindIndex.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

module.exports = baseFindIndex;


/***/ }),

/***/ "./node_modules/lodash/_baseFlatten.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseFlatten.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    isFlattenable = __webpack_require__(/*! ./_isFlattenable */ "./node_modules/lodash/_isFlattenable.js");

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

module.exports = baseFlatten;


/***/ }),

/***/ "./node_modules/lodash/_baseFor.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseFor.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createBaseFor = __webpack_require__(/*! ./_createBaseFor */ "./node_modules/lodash/_createBaseFor.js");

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

module.exports = baseFor;


/***/ }),

/***/ "./node_modules/lodash/_baseForOwn.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseForOwn.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFor = __webpack_require__(/*! ./_baseFor */ "./node_modules/lodash/_baseFor.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * The base implementation of `_.forOwn` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Object} Returns `object`.
 */
function baseForOwn(object, iteratee) {
  return object && baseFor(object, iteratee, keys);
}

module.exports = baseForOwn;


/***/ }),

/***/ "./node_modules/lodash/_baseGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseGet.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

module.exports = baseGet;


/***/ }),

/***/ "./node_modules/lodash/_baseGetAllKeys.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_baseGetAllKeys.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    getRawTag = __webpack_require__(/*! ./_getRawTag */ "./node_modules/lodash/_getRawTag.js"),
    objectToString = __webpack_require__(/*! ./_objectToString */ "./node_modules/lodash/_objectToString.js");

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ "./node_modules/lodash/_baseGt.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_baseGt.js ***!
  \****************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.gt` which doesn't coerce arguments.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is greater than `other`,
 *  else `false`.
 */
function baseGt(value, other) {
  return value > other;
}

module.exports = baseGt;


/***/ }),

/***/ "./node_modules/lodash/_baseHas.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseHas.js ***!
  \*****************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  return object != null && hasOwnProperty.call(object, key);
}

module.exports = baseHas;


/***/ }),

/***/ "./node_modules/lodash/_baseHasIn.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseHasIn.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

module.exports = baseHasIn;


/***/ }),

/***/ "./node_modules/lodash/_baseIndexOf.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIndexOf.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFindIndex = __webpack_require__(/*! ./_baseFindIndex */ "./node_modules/lodash/_baseFindIndex.js"),
    baseIsNaN = __webpack_require__(/*! ./_baseIsNaN */ "./node_modules/lodash/_baseIsNaN.js"),
    strictIndexOf = __webpack_require__(/*! ./_strictIndexOf */ "./node_modules/lodash/_strictIndexOf.js");

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  return value === value
    ? strictIndexOf(array, value, fromIndex)
    : baseFindIndex(array, baseIsNaN, fromIndex);
}

module.exports = baseIndexOf;


/***/ }),

/***/ "./node_modules/lodash/_baseIsArguments.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsArguments.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),

/***/ "./node_modules/lodash/_baseIsEqual.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIsEqual.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqualDeep = __webpack_require__(/*! ./_baseIsEqualDeep */ "./node_modules/lodash/_baseIsEqualDeep.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;


/***/ }),

/***/ "./node_modules/lodash/_baseIsEqualDeep.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseIsEqualDeep.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    equalArrays = __webpack_require__(/*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"),
    equalByTag = __webpack_require__(/*! ./_equalByTag */ "./node_modules/lodash/_equalByTag.js"),
    equalObjects = __webpack_require__(/*! ./_equalObjects */ "./node_modules/lodash/_equalObjects.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),

/***/ "./node_modules/lodash/_baseIsMap.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsMap.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return isObjectLike(value) && getTag(value) == mapTag;
}

module.exports = baseIsMap;


/***/ }),

/***/ "./node_modules/lodash/_baseIsMatch.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseIsMatch.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.isMatch` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The object to inspect.
 * @param {Object} source The object of property values to match.
 * @param {Array} matchData The property names, values, and compare flags to match.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if `object` is a match, else `false`.
 */
function baseIsMatch(object, source, matchData, customizer) {
  var index = matchData.length,
      length = index,
      noCustomizer = !customizer;

  if (object == null) {
    return !length;
  }
  object = Object(object);
  while (index--) {
    var data = matchData[index];
    if ((noCustomizer && data[2])
          ? data[1] !== object[data[0]]
          : !(data[0] in object)
        ) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0],
        objValue = object[key],
        srcValue = data[1];

    if (noCustomizer && data[2]) {
      if (objValue === undefined && !(key in object)) {
        return false;
      }
    } else {
      var stack = new Stack;
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object, source, stack);
      }
      if (!(result === undefined
            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
            : result
          )) {
        return false;
      }
    }
  }
  return true;
}

module.exports = baseIsMatch;


/***/ }),

/***/ "./node_modules/lodash/_baseIsNaN.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsNaN.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

module.exports = baseIsNaN;


/***/ }),

/***/ "./node_modules/lodash/_baseIsNative.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIsNative.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isMasked = __webpack_require__(/*! ./_isMasked */ "./node_modules/lodash/_isMasked.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),

/***/ "./node_modules/lodash/_baseIsSet.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseIsSet.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return isObjectLike(value) && getTag(value) == setTag;
}

module.exports = baseIsSet;


/***/ }),

/***/ "./node_modules/lodash/_baseIsTypedArray.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_baseIsTypedArray.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),

/***/ "./node_modules/lodash/_baseIteratee.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseIteratee.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseMatches = __webpack_require__(/*! ./_baseMatches */ "./node_modules/lodash/_baseMatches.js"),
    baseMatchesProperty = __webpack_require__(/*! ./_baseMatchesProperty */ "./node_modules/lodash/_baseMatchesProperty.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    property = __webpack_require__(/*! ./property */ "./node_modules/lodash/property.js");

/**
 * The base implementation of `_.iteratee`.
 *
 * @private
 * @param {*} [value=_.identity] The value to convert to an iteratee.
 * @returns {Function} Returns the iteratee.
 */
function baseIteratee(value) {
  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if (typeof value == 'function') {
    return value;
  }
  if (value == null) {
    return identity;
  }
  if (typeof value == 'object') {
    return isArray(value)
      ? baseMatchesProperty(value[0], value[1])
      : baseMatches(value);
  }
  return property(value);
}

module.exports = baseIteratee;


/***/ }),

/***/ "./node_modules/lodash/_baseKeys.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseKeys.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeys = __webpack_require__(/*! ./_nativeKeys */ "./node_modules/lodash/_nativeKeys.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),

/***/ "./node_modules/lodash/_baseKeysIn.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseKeysIn.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    nativeKeysIn = __webpack_require__(/*! ./_nativeKeysIn */ "./node_modules/lodash/_nativeKeysIn.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_baseLt.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_baseLt.js ***!
  \****************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.lt` which doesn't coerce arguments.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if `value` is less than `other`,
 *  else `false`.
 */
function baseLt(value, other) {
  return value < other;
}

module.exports = baseLt;


/***/ }),

/***/ "./node_modules/lodash/_baseMap.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseMap.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * The base implementation of `_.map` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function baseMap(collection, iteratee) {
  var index = -1,
      result = isArrayLike(collection) ? Array(collection.length) : [];

  baseEach(collection, function(value, key, collection) {
    result[++index] = iteratee(value, key, collection);
  });
  return result;
}

module.exports = baseMap;


/***/ }),

/***/ "./node_modules/lodash/_baseMatches.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseMatches.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMatch = __webpack_require__(/*! ./_baseIsMatch */ "./node_modules/lodash/_baseIsMatch.js"),
    getMatchData = __webpack_require__(/*! ./_getMatchData */ "./node_modules/lodash/_getMatchData.js"),
    matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ "./node_modules/lodash/_matchesStrictComparable.js");

/**
 * The base implementation of `_.matches` which doesn't clone `source`.
 *
 * @private
 * @param {Object} source The object of property values to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatches(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object) {
    return object === source || baseIsMatch(object, source, matchData);
  };
}

module.exports = baseMatches;


/***/ }),

/***/ "./node_modules/lodash/_baseMatchesProperty.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash/_baseMatchesProperty.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqual = __webpack_require__(/*! ./_baseIsEqual */ "./node_modules/lodash/_baseIsEqual.js"),
    get = __webpack_require__(/*! ./get */ "./node_modules/lodash/get.js"),
    hasIn = __webpack_require__(/*! ./hasIn */ "./node_modules/lodash/hasIn.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ "./node_modules/lodash/_isStrictComparable.js"),
    matchesStrictComparable = __webpack_require__(/*! ./_matchesStrictComparable */ "./node_modules/lodash/_matchesStrictComparable.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
 *
 * @private
 * @param {string} path The path of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function baseMatchesProperty(path, srcValue) {
  if (isKey(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey(path), srcValue);
  }
  return function(object) {
    var objValue = get(object, path);
    return (objValue === undefined && objValue === srcValue)
      ? hasIn(object, path)
      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}

module.exports = baseMatchesProperty;


/***/ }),

/***/ "./node_modules/lodash/_baseMerge.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseMerge.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(/*! ./_Stack */ "./node_modules/lodash/_Stack.js"),
    assignMergeValue = __webpack_require__(/*! ./_assignMergeValue */ "./node_modules/lodash/_assignMergeValue.js"),
    baseFor = __webpack_require__(/*! ./_baseFor */ "./node_modules/lodash/_baseFor.js"),
    baseMergeDeep = __webpack_require__(/*! ./_baseMergeDeep */ "./node_modules/lodash/_baseMergeDeep.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js"),
    safeGet = __webpack_require__(/*! ./_safeGet */ "./node_modules/lodash/_safeGet.js");

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

module.exports = baseMerge;


/***/ }),

/***/ "./node_modules/lodash/_baseMergeDeep.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_baseMergeDeep.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignMergeValue = __webpack_require__(/*! ./_assignMergeValue */ "./node_modules/lodash/_assignMergeValue.js"),
    cloneBuffer = __webpack_require__(/*! ./_cloneBuffer */ "./node_modules/lodash/_cloneBuffer.js"),
    cloneTypedArray = __webpack_require__(/*! ./_cloneTypedArray */ "./node_modules/lodash/_cloneTypedArray.js"),
    copyArray = __webpack_require__(/*! ./_copyArray */ "./node_modules/lodash/_copyArray.js"),
    initCloneObject = __webpack_require__(/*! ./_initCloneObject */ "./node_modules/lodash/_initCloneObject.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isArrayLikeObject = __webpack_require__(/*! ./isArrayLikeObject */ "./node_modules/lodash/isArrayLikeObject.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isPlainObject = __webpack_require__(/*! ./isPlainObject */ "./node_modules/lodash/isPlainObject.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js"),
    safeGet = __webpack_require__(/*! ./_safeGet */ "./node_modules/lodash/_safeGet.js"),
    toPlainObject = __webpack_require__(/*! ./toPlainObject */ "./node_modules/lodash/toPlainObject.js");

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

module.exports = baseMergeDeep;


/***/ }),

/***/ "./node_modules/lodash/_baseOrderBy.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_baseOrderBy.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    baseMap = __webpack_require__(/*! ./_baseMap */ "./node_modules/lodash/_baseMap.js"),
    baseSortBy = __webpack_require__(/*! ./_baseSortBy */ "./node_modules/lodash/_baseSortBy.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    compareMultiple = __webpack_require__(/*! ./_compareMultiple */ "./node_modules/lodash/_compareMultiple.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * The base implementation of `_.orderBy` without param guards.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
 * @param {string[]} orders The sort orders of `iteratees`.
 * @returns {Array} Returns the new sorted array.
 */
function baseOrderBy(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap(iteratees, function(iteratee) {
      if (isArray(iteratee)) {
        return function(value) {
          return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        }
      }
      return iteratee;
    });
  } else {
    iteratees = [identity];
  }

  var index = -1;
  iteratees = arrayMap(iteratees, baseUnary(baseIteratee));

  var result = baseMap(collection, function(value, key, collection) {
    var criteria = arrayMap(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { 'criteria': criteria, 'index': ++index, 'value': value };
  });

  return baseSortBy(result, function(object, other) {
    return compareMultiple(object, other, orders);
  });
}

module.exports = baseOrderBy;


/***/ }),

/***/ "./node_modules/lodash/_basePick.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_basePick.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var basePickBy = __webpack_require__(/*! ./_basePickBy */ "./node_modules/lodash/_basePickBy.js"),
    hasIn = __webpack_require__(/*! ./hasIn */ "./node_modules/lodash/hasIn.js");

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}

module.exports = basePick;


/***/ }),

/***/ "./node_modules/lodash/_basePickBy.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_basePickBy.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js"),
    baseSet = __webpack_require__(/*! ./_baseSet */ "./node_modules/lodash/_baseSet.js"),
    castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js");

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}

module.exports = basePickBy;


/***/ }),

/***/ "./node_modules/lodash/_baseProperty.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseProperty.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;


/***/ }),

/***/ "./node_modules/lodash/_basePropertyDeep.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_basePropertyDeep.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js");

/**
 * A specialized version of `baseProperty` which supports deep paths.
 *
 * @private
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyDeep(path) {
  return function(object) {
    return baseGet(object, path);
  };
}

module.exports = basePropertyDeep;


/***/ }),

/***/ "./node_modules/lodash/_baseRange.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseRange.js ***!
  \*******************************************/
/***/ ((module) => {

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil,
    nativeMax = Math.max;

/**
 * The base implementation of `_.range` and `_.rangeRight` which doesn't
 * coerce arguments.
 *
 * @private
 * @param {number} start The start of the range.
 * @param {number} end The end of the range.
 * @param {number} step The value to increment or decrement by.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Array} Returns the range of numbers.
 */
function baseRange(start, end, step, fromRight) {
  var index = -1,
      length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
      result = Array(length);

  while (length--) {
    result[fromRight ? length : ++index] = start;
    start += step;
  }
  return result;
}

module.exports = baseRange;


/***/ }),

/***/ "./node_modules/lodash/_baseReduce.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseReduce.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.reduce` and `_.reduceRight`, without support
 * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} accumulator The initial value.
 * @param {boolean} initAccum Specify using the first or last element of
 *  `collection` as the initial value.
 * @param {Function} eachFunc The function to iterate over `collection`.
 * @returns {*} Returns the accumulated value.
 */
function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
  eachFunc(collection, function(value, index, collection) {
    accumulator = initAccum
      ? (initAccum = false, value)
      : iteratee(accumulator, value, index, collection);
  });
  return accumulator;
}

module.exports = baseReduce;


/***/ }),

/***/ "./node_modules/lodash/_baseRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseRest.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js"),
    overRest = __webpack_require__(/*! ./_overRest */ "./node_modules/lodash/_overRest.js"),
    setToString = __webpack_require__(/*! ./_setToString */ "./node_modules/lodash/_setToString.js");

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

module.exports = baseRest;


/***/ }),

/***/ "./node_modules/lodash/_baseSet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_baseSet.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!isObject(object)) {
    return object;
  }
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = toKey(path[index]),
        newValue = value;

    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
      return object;
    }

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = isObject(objValue)
          ? objValue
          : (isIndex(path[index + 1]) ? [] : {});
      }
    }
    assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

module.exports = baseSet;


/***/ }),

/***/ "./node_modules/lodash/_baseSetToString.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_baseSetToString.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var constant = __webpack_require__(/*! ./constant */ "./node_modules/lodash/constant.js"),
    defineProperty = __webpack_require__(/*! ./_defineProperty */ "./node_modules/lodash/_defineProperty.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

module.exports = baseSetToString;


/***/ }),

/***/ "./node_modules/lodash/_baseSortBy.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseSortBy.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.sortBy` which uses `comparer` to define the
 * sort order of `array` and replaces criteria objects with their corresponding
 * values.
 *
 * @private
 * @param {Array} array The array to sort.
 * @param {Function} comparer The function to define sort order.
 * @returns {Array} Returns `array`.
 */
function baseSortBy(array, comparer) {
  var length = array.length;

  array.sort(comparer);
  while (length--) {
    array[length] = array[length].value;
  }
  return array;
}

module.exports = baseSortBy;


/***/ }),

/***/ "./node_modules/lodash/_baseTimes.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseTimes.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),

/***/ "./node_modules/lodash/_baseToString.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_baseToString.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;


/***/ }),

/***/ "./node_modules/lodash/_baseTrim.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseTrim.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var trimmedEndIndex = __webpack_require__(/*! ./_trimmedEndIndex */ "./node_modules/lodash/_trimmedEndIndex.js");

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

module.exports = baseTrim;


/***/ }),

/***/ "./node_modules/lodash/_baseUnary.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_baseUnary.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),

/***/ "./node_modules/lodash/_baseUniq.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_baseUniq.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SetCache = __webpack_require__(/*! ./_SetCache */ "./node_modules/lodash/_SetCache.js"),
    arrayIncludes = __webpack_require__(/*! ./_arrayIncludes */ "./node_modules/lodash/_arrayIncludes.js"),
    arrayIncludesWith = __webpack_require__(/*! ./_arrayIncludesWith */ "./node_modules/lodash/_arrayIncludesWith.js"),
    cacheHas = __webpack_require__(/*! ./_cacheHas */ "./node_modules/lodash/_cacheHas.js"),
    createSet = __webpack_require__(/*! ./_createSet */ "./node_modules/lodash/_createSet.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of `_.uniqBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 */
function baseUniq(array, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      length = array.length,
      isCommon = true,
      result = [],
      seen = result;

  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  }
  else if (length >= LARGE_ARRAY_SIZE) {
    var set = iteratee ? null : createSet(array);
    if (set) {
      return setToArray(set);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache;
  }
  else {
    seen = iteratee ? [] : result;
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var seenIndex = seen.length;
      while (seenIndex--) {
        if (seen[seenIndex] === computed) {
          continue outer;
        }
      }
      if (iteratee) {
        seen.push(computed);
      }
      result.push(value);
    }
    else if (!includes(seen, computed, comparator)) {
      if (seen !== result) {
        seen.push(computed);
      }
      result.push(value);
    }
  }
  return result;
}

module.exports = baseUniq;


/***/ }),

/***/ "./node_modules/lodash/_baseValues.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseValues.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js");

/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */
function baseValues(object, props) {
  return arrayMap(props, function(key) {
    return object[key];
  });
}

module.exports = baseValues;


/***/ }),

/***/ "./node_modules/lodash/_baseZipObject.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_baseZipObject.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
 *
 * @private
 * @param {Array} props The property identifiers.
 * @param {Array} values The property values.
 * @param {Function} assignFunc The function to assign values.
 * @returns {Object} Returns the new object.
 */
function baseZipObject(props, values, assignFunc) {
  var index = -1,
      length = props.length,
      valsLength = values.length,
      result = {};

  while (++index < length) {
    var value = index < valsLength ? values[index] : undefined;
    assignFunc(result, props[index], value);
  }
  return result;
}

module.exports = baseZipObject;


/***/ }),

/***/ "./node_modules/lodash/_cacheHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_cacheHas.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),

/***/ "./node_modules/lodash/_castFunction.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_castFunction.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");

/**
 * Casts `value` to `identity` if it's not a function.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Function} Returns cast function.
 */
function castFunction(value) {
  return typeof value == 'function' ? value : identity;
}

module.exports = castFunction;


/***/ }),

/***/ "./node_modules/lodash/_castPath.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_castPath.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    stringToPath = __webpack_require__(/*! ./_stringToPath */ "./node_modules/lodash/_stringToPath.js"),
    toString = __webpack_require__(/*! ./toString */ "./node_modules/lodash/toString.js");

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (isArray(value)) {
    return value;
  }
  return isKey(value, object) ? [value] : stringToPath(toString(value));
}

module.exports = castPath;


/***/ }),

/***/ "./node_modules/lodash/_cloneArrayBuffer.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_cloneArrayBuffer.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js");

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  return result;
}

module.exports = cloneArrayBuffer;


/***/ }),

/***/ "./node_modules/lodash/_cloneBuffer.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneBuffer.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

module.exports = cloneBuffer;


/***/ }),

/***/ "./node_modules/lodash/_cloneDataView.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_cloneDataView.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js");

/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

module.exports = cloneDataView;


/***/ }),

/***/ "./node_modules/lodash/_cloneRegExp.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneRegExp.js ***!
  \*********************************************/
/***/ ((module) => {

/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

module.exports = cloneRegExp;


/***/ }),

/***/ "./node_modules/lodash/_cloneSymbol.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_cloneSymbol.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

module.exports = cloneSymbol;


/***/ }),

/***/ "./node_modules/lodash/_cloneTypedArray.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_cloneTypedArray.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js");

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

module.exports = cloneTypedArray;


/***/ }),

/***/ "./node_modules/lodash/_compareAscending.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/_compareAscending.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/**
 * Compares values to sort them in ascending order.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {number} Returns the sort order indicator for `value`.
 */
function compareAscending(value, other) {
  if (value !== other) {
    var valIsDefined = value !== undefined,
        valIsNull = value === null,
        valIsReflexive = value === value,
        valIsSymbol = isSymbol(value);

    var othIsDefined = other !== undefined,
        othIsNull = other === null,
        othIsReflexive = other === other,
        othIsSymbol = isSymbol(other);

    if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
        (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
        (valIsNull && othIsDefined && othIsReflexive) ||
        (!valIsDefined && othIsReflexive) ||
        !valIsReflexive) {
      return 1;
    }
    if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
        (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
        (othIsNull && valIsDefined && valIsReflexive) ||
        (!othIsDefined && valIsReflexive) ||
        !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}

module.exports = compareAscending;


/***/ }),

/***/ "./node_modules/lodash/_compareMultiple.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_compareMultiple.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var compareAscending = __webpack_require__(/*! ./_compareAscending */ "./node_modules/lodash/_compareAscending.js");

/**
 * Used by `_.orderBy` to compare multiple properties of a value to another
 * and stable sort them.
 *
 * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
 * specify an order of "desc" for descending or "asc" for ascending sort order
 * of corresponding values.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {boolean[]|string[]} orders The order to sort by for each property.
 * @returns {number} Returns the sort order indicator for `object`.
 */
function compareMultiple(object, other, orders) {
  var index = -1,
      objCriteria = object.criteria,
      othCriteria = other.criteria,
      length = objCriteria.length,
      ordersLength = orders.length;

  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == 'desc' ? -1 : 1);
    }
  }
  // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index - other.index;
}

module.exports = compareMultiple;


/***/ }),

/***/ "./node_modules/lodash/_copyArray.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_copyArray.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;


/***/ }),

/***/ "./node_modules/lodash/_copyObject.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_copyObject.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js");

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

module.exports = copyObject;


/***/ }),

/***/ "./node_modules/lodash/_copySymbols.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_copySymbols.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js");

/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return copyObject(source, getSymbols(source), object);
}

module.exports = copySymbols;


/***/ }),

/***/ "./node_modules/lodash/_copySymbolsIn.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_copySymbolsIn.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js");

/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return copyObject(source, getSymbolsIn(source), object);
}

module.exports = copySymbolsIn;


/***/ }),

/***/ "./node_modules/lodash/_coreJsData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_coreJsData.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),

/***/ "./node_modules/lodash/_createAssigner.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_createAssigner.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js");

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

module.exports = createAssigner;


/***/ }),

/***/ "./node_modules/lodash/_createBaseEach.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_createBaseEach.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * Creates a `baseEach` or `baseEachRight` function.
 *
 * @private
 * @param {Function} eachFunc The function to iterate over a collection.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length,
        index = fromRight ? length : -1,
        iterable = Object(collection);

    while ((fromRight ? index-- : ++index < length)) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}

module.exports = createBaseEach;


/***/ }),

/***/ "./node_modules/lodash/_createBaseFor.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_createBaseFor.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

module.exports = createBaseFor;


/***/ }),

/***/ "./node_modules/lodash/_createFind.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_createFind.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Creates a `_.find` or `_.findLast` function.
 *
 * @private
 * @param {Function} findIndexFunc The function to find the collection index.
 * @returns {Function} Returns the new find function.
 */
function createFind(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee(predicate, 3);
      collection = keys(collection);
      predicate = function(key) { return iteratee(iterable[key], key, iterable); };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
  };
}

module.exports = createFind;


/***/ }),

/***/ "./node_modules/lodash/_createRange.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_createRange.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseRange = __webpack_require__(/*! ./_baseRange */ "./node_modules/lodash/_baseRange.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js"),
    toFinite = __webpack_require__(/*! ./toFinite */ "./node_modules/lodash/toFinite.js");

/**
 * Creates a `_.range` or `_.rangeRight` function.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new range function.
 */
function createRange(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
      end = step = undefined;
    }
    // Ensure the sign of `-0` is preserved.
    start = toFinite(start);
    if (end === undefined) {
      end = start;
      start = 0;
    } else {
      end = toFinite(end);
    }
    step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
    return baseRange(start, end, step, fromRight);
  };
}

module.exports = createRange;


/***/ }),

/***/ "./node_modules/lodash/_createSet.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_createSet.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Set = __webpack_require__(/*! ./_Set */ "./node_modules/lodash/_Set.js"),
    noop = __webpack_require__(/*! ./noop */ "./node_modules/lodash/noop.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Creates a set object of `values`.
 *
 * @private
 * @param {Array} values The values to add to the set.
 * @returns {Object} Returns the new set.
 */
var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  return new Set(values);
};

module.exports = createSet;


/***/ }),

/***/ "./node_modules/lodash/_defineProperty.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_defineProperty.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

module.exports = defineProperty;


/***/ }),

/***/ "./node_modules/lodash/_equalArrays.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_equalArrays.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SetCache = __webpack_require__(/*! ./_SetCache */ "./node_modules/lodash/_SetCache.js"),
    arraySome = __webpack_require__(/*! ./_arraySome */ "./node_modules/lodash/_arraySome.js"),
    cacheHas = __webpack_require__(/*! ./_cacheHas */ "./node_modules/lodash/_cacheHas.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),

/***/ "./node_modules/lodash/_equalByTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_equalByTag.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    Uint8Array = __webpack_require__(/*! ./_Uint8Array */ "./node_modules/lodash/_Uint8Array.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
    equalArrays = __webpack_require__(/*! ./_equalArrays */ "./node_modules/lodash/_equalArrays.js"),
    mapToArray = __webpack_require__(/*! ./_mapToArray */ "./node_modules/lodash/_mapToArray.js"),
    setToArray = __webpack_require__(/*! ./_setToArray */ "./node_modules/lodash/_setToArray.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),

/***/ "./node_modules/lodash/_equalObjects.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_equalObjects.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getAllKeys = __webpack_require__(/*! ./_getAllKeys */ "./node_modules/lodash/_getAllKeys.js");

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),

/***/ "./node_modules/lodash/_flatRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_flatRest.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var flatten = __webpack_require__(/*! ./flatten */ "./node_modules/lodash/flatten.js"),
    overRest = __webpack_require__(/*! ./_overRest */ "./node_modules/lodash/_overRest.js"),
    setToString = __webpack_require__(/*! ./_setToString */ "./node_modules/lodash/_setToString.js");

/**
 * A specialized version of `baseRest` which flattens the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @returns {Function} Returns the new function.
 */
function flatRest(func) {
  return setToString(overRest(func, undefined, flatten), func + '');
}

module.exports = flatRest;


/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

module.exports = freeGlobal;


/***/ }),

/***/ "./node_modules/lodash/_getAllKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getAllKeys.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),

/***/ "./node_modules/lodash/_getAllKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getAllKeysIn.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(/*! ./_baseGetAllKeys */ "./node_modules/lodash/_baseGetAllKeys.js"),
    getSymbolsIn = __webpack_require__(/*! ./_getSymbolsIn */ "./node_modules/lodash/_getSymbolsIn.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

module.exports = getAllKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_getMapData.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getMapData.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isKeyable = __webpack_require__(/*! ./_isKeyable */ "./node_modules/lodash/_isKeyable.js");

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),

/***/ "./node_modules/lodash/_getMatchData.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getMatchData.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isStrictComparable = __webpack_require__(/*! ./_isStrictComparable */ "./node_modules/lodash/_isStrictComparable.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Gets the property names, values, and compare flags of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the match data of `object`.
 */
function getMatchData(object) {
  var result = keys(object),
      length = result.length;

  while (length--) {
    var key = result[length],
        value = object[key];

    result[length] = [key, value, isStrictComparable(value)];
  }
  return result;
}

module.exports = getMatchData;


/***/ }),

/***/ "./node_modules/lodash/_getNative.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getNative.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsNative = __webpack_require__(/*! ./_baseIsNative */ "./node_modules/lodash/_baseIsNative.js"),
    getValue = __webpack_require__(/*! ./_getValue */ "./node_modules/lodash/_getValue.js");

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),

/***/ "./node_modules/lodash/_getPrototype.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getPrototype.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

module.exports = getPrototype;


/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ "./node_modules/lodash/_getSymbols.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_getSymbols.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayFilter = __webpack_require__(/*! ./_arrayFilter */ "./node_modules/lodash/_arrayFilter.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),

/***/ "./node_modules/lodash/_getSymbolsIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getSymbolsIn.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(/*! ./_arrayPush */ "./node_modules/lodash/_arrayPush.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    getSymbols = __webpack_require__(/*! ./_getSymbols */ "./node_modules/lodash/_getSymbols.js"),
    stubArray = __webpack_require__(/*! ./stubArray */ "./node_modules/lodash/stubArray.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

module.exports = getSymbolsIn;


/***/ }),

/***/ "./node_modules/lodash/_getTag.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_getTag.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DataView = __webpack_require__(/*! ./_DataView */ "./node_modules/lodash/_DataView.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    Promise = __webpack_require__(/*! ./_Promise */ "./node_modules/lodash/_Promise.js"),
    Set = __webpack_require__(/*! ./_Set */ "./node_modules/lodash/_Set.js"),
    WeakMap = __webpack_require__(/*! ./_WeakMap */ "./node_modules/lodash/_WeakMap.js"),
    baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    toSource = __webpack_require__(/*! ./_toSource */ "./node_modules/lodash/_toSource.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),

/***/ "./node_modules/lodash/_getValue.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_getValue.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ "./node_modules/lodash/_hasPath.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hasPath.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = castPath(path, object);

  var index = -1,
      length = path.length,
      result = false;

  while (++index < length) {
    var key = toKey(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object == null ? 0 : object.length;
  return !!length && isLength(length) && isIndex(key, length) &&
    (isArray(object) || isArguments(object));
}

module.exports = hasPath;


/***/ }),

/***/ "./node_modules/lodash/_hasUnicode.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_hasUnicode.js ***!
  \********************************************/
/***/ ((module) => {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

module.exports = hasUnicode;


/***/ }),

/***/ "./node_modules/lodash/_hashClear.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_hashClear.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),

/***/ "./node_modules/lodash/_hashDelete.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_hashDelete.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),

/***/ "./node_modules/lodash/_hashGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashGet.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),

/***/ "./node_modules/lodash/_hashHas.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashHas.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),

/***/ "./node_modules/lodash/_hashSet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_hashSet.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(/*! ./_nativeCreate */ "./node_modules/lodash/_nativeCreate.js");

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),

/***/ "./node_modules/lodash/_initCloneArray.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneArray.js ***!
  \************************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

module.exports = initCloneArray;


/***/ }),

/***/ "./node_modules/lodash/_initCloneByTag.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_initCloneByTag.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var cloneArrayBuffer = __webpack_require__(/*! ./_cloneArrayBuffer */ "./node_modules/lodash/_cloneArrayBuffer.js"),
    cloneDataView = __webpack_require__(/*! ./_cloneDataView */ "./node_modules/lodash/_cloneDataView.js"),
    cloneRegExp = __webpack_require__(/*! ./_cloneRegExp */ "./node_modules/lodash/_cloneRegExp.js"),
    cloneSymbol = __webpack_require__(/*! ./_cloneSymbol */ "./node_modules/lodash/_cloneSymbol.js"),
    cloneTypedArray = __webpack_require__(/*! ./_cloneTypedArray */ "./node_modules/lodash/_cloneTypedArray.js");

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case arrayBufferTag:
      return cloneArrayBuffer(object);

    case boolTag:
    case dateTag:
      return new Ctor(+object);

    case dataViewTag:
      return cloneDataView(object, isDeep);

    case float32Tag: case float64Tag:
    case int8Tag: case int16Tag: case int32Tag:
    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
      return cloneTypedArray(object, isDeep);

    case mapTag:
      return new Ctor;

    case numberTag:
    case stringTag:
      return new Ctor(object);

    case regexpTag:
      return cloneRegExp(object);

    case setTag:
      return new Ctor;

    case symbolTag:
      return cloneSymbol(object);
  }
}

module.exports = initCloneByTag;


/***/ }),

/***/ "./node_modules/lodash/_initCloneObject.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_initCloneObject.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseCreate = __webpack_require__(/*! ./_baseCreate */ "./node_modules/lodash/_baseCreate.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js");

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

module.exports = initCloneObject;


/***/ }),

/***/ "./node_modules/lodash/_isFlattenable.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_isFlattenable.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(/*! ./_Symbol */ "./node_modules/lodash/_Symbol.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/** Built-in value references. */
var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

module.exports = isFlattenable;


/***/ }),

/***/ "./node_modules/lodash/_isIndex.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_isIndex.js ***!
  \*****************************************/
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),

/***/ "./node_modules/lodash/_isIterateeCall.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_isIterateeCall.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isIndex = __webpack_require__(/*! ./_isIndex */ "./node_modules/lodash/_isIndex.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

module.exports = isIterateeCall;


/***/ }),

/***/ "./node_modules/lodash/_isKey.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_isKey.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

module.exports = isKey;


/***/ }),

/***/ "./node_modules/lodash/_isKeyable.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_isKeyable.js ***!
  \*******************************************/
/***/ ((module) => {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),

/***/ "./node_modules/lodash/_isMasked.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_isMasked.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var coreJsData = __webpack_require__(/*! ./_coreJsData */ "./node_modules/lodash/_coreJsData.js");

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),

/***/ "./node_modules/lodash/_isPrototype.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_isPrototype.js ***!
  \*********************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),

/***/ "./node_modules/lodash/_isStrictComparable.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash/_isStrictComparable.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/**
 * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` if suitable for strict
 *  equality comparisons, else `false`.
 */
function isStrictComparable(value) {
  return value === value && !isObject(value);
}

module.exports = isStrictComparable;


/***/ }),

/***/ "./node_modules/lodash/_listCacheClear.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_listCacheClear.js ***!
  \************************************************/
/***/ ((module) => {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),

/***/ "./node_modules/lodash/_listCacheDelete.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_listCacheDelete.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),

/***/ "./node_modules/lodash/_listCacheGet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheGet.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),

/***/ "./node_modules/lodash/_listCacheHas.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheHas.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_listCacheSet.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_listCacheSet.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(/*! ./_assocIndexOf */ "./node_modules/lodash/_assocIndexOf.js");

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheClear.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_mapCacheClear.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Hash = __webpack_require__(/*! ./_Hash */ "./node_modules/lodash/_Hash.js"),
    ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js");

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheDelete.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_mapCacheDelete.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheGet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheGet.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheHas.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_mapCacheSet.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_mapCacheSet.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(/*! ./_getMapData */ "./node_modules/lodash/_getMapData.js");

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),

/***/ "./node_modules/lodash/_mapToArray.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_mapToArray.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),

/***/ "./node_modules/lodash/_matchesStrictComparable.js":
/*!*********************************************************!*\
  !*** ./node_modules/lodash/_matchesStrictComparable.js ***!
  \*********************************************************/
/***/ ((module) => {

/**
 * A specialized version of `matchesProperty` for source values suitable
 * for strict equality comparisons, i.e. `===`.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @param {*} srcValue The value to match.
 * @returns {Function} Returns the new spec function.
 */
function matchesStrictComparable(key, srcValue) {
  return function(object) {
    if (object == null) {
      return false;
    }
    return object[key] === srcValue &&
      (srcValue !== undefined || (key in Object(object)));
  };
}

module.exports = matchesStrictComparable;


/***/ }),

/***/ "./node_modules/lodash/_memoizeCapped.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_memoizeCapped.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoize = __webpack_require__(/*! ./memoize */ "./node_modules/lodash/memoize.js");

/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

module.exports = memoizeCapped;


/***/ }),

/***/ "./node_modules/lodash/_nativeCreate.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeCreate.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(/*! ./_getNative */ "./node_modules/lodash/_getNative.js");

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),

/***/ "./node_modules/lodash/_nativeKeys.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_nativeKeys.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(/*! ./_overArg */ "./node_modules/lodash/_overArg.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ "./node_modules/lodash/_nativeKeysIn.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_nativeKeysIn.js ***!
  \**********************************************/
/***/ ((module) => {

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

module.exports = nativeKeysIn;


/***/ }),

/***/ "./node_modules/lodash/_nodeUtil.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_nodeUtil.js ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;


/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ "./node_modules/lodash/_overArg.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_overArg.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ "./node_modules/lodash/_overRest.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_overRest.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var apply = __webpack_require__(/*! ./_apply */ "./node_modules/lodash/_apply.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

module.exports = overRest;


/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ "./node_modules/lodash/_freeGlobal.js");

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ "./node_modules/lodash/_safeGet.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_safeGet.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

module.exports = safeGet;


/***/ }),

/***/ "./node_modules/lodash/_setCacheAdd.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setCacheAdd.js ***!
  \*********************************************/
/***/ ((module) => {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),

/***/ "./node_modules/lodash/_setCacheHas.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setCacheHas.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),

/***/ "./node_modules/lodash/_setToArray.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_setToArray.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),

/***/ "./node_modules/lodash/_setToString.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_setToString.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseSetToString = __webpack_require__(/*! ./_baseSetToString */ "./node_modules/lodash/_baseSetToString.js"),
    shortOut = __webpack_require__(/*! ./_shortOut */ "./node_modules/lodash/_shortOut.js");

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

module.exports = setToString;


/***/ }),

/***/ "./node_modules/lodash/_shortOut.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_shortOut.js ***!
  \******************************************/
/***/ ((module) => {

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

module.exports = shortOut;


/***/ }),

/***/ "./node_modules/lodash/_stackClear.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_stackClear.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js");

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),

/***/ "./node_modules/lodash/_stackDelete.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_stackDelete.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),

/***/ "./node_modules/lodash/_stackGet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackGet.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),

/***/ "./node_modules/lodash/_stackHas.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackHas.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),

/***/ "./node_modules/lodash/_stackSet.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_stackSet.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(/*! ./_ListCache */ "./node_modules/lodash/_ListCache.js"),
    Map = __webpack_require__(/*! ./_Map */ "./node_modules/lodash/_Map.js"),
    MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js");

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),

/***/ "./node_modules/lodash/_strictIndexOf.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash/_strictIndexOf.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * A specialized version of `_.indexOf` which performs strict equality
 * comparisons of values, i.e. `===`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function strictIndexOf(array, value, fromIndex) {
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

module.exports = strictIndexOf;


/***/ }),

/***/ "./node_modules/lodash/_stringSize.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_stringSize.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var asciiSize = __webpack_require__(/*! ./_asciiSize */ "./node_modules/lodash/_asciiSize.js"),
    hasUnicode = __webpack_require__(/*! ./_hasUnicode */ "./node_modules/lodash/_hasUnicode.js"),
    unicodeSize = __webpack_require__(/*! ./_unicodeSize */ "./node_modules/lodash/_unicodeSize.js");

/**
 * Gets the number of symbols in `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the string size.
 */
function stringSize(string) {
  return hasUnicode(string)
    ? unicodeSize(string)
    : asciiSize(string);
}

module.exports = stringSize;


/***/ }),

/***/ "./node_modules/lodash/_stringToPath.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_stringToPath.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var memoizeCapped = __webpack_require__(/*! ./_memoizeCapped */ "./node_modules/lodash/_memoizeCapped.js");

/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

module.exports = stringToPath;


/***/ }),

/***/ "./node_modules/lodash/_toKey.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/_toKey.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = toKey;


/***/ }),

/***/ "./node_modules/lodash/_toSource.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_toSource.js ***!
  \******************************************/
/***/ ((module) => {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),

/***/ "./node_modules/lodash/_trimmedEndIndex.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash/_trimmedEndIndex.js ***!
  \*************************************************/
/***/ ((module) => {

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

module.exports = trimmedEndIndex;


/***/ }),

/***/ "./node_modules/lodash/_unicodeSize.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/_unicodeSize.js ***!
  \*********************************************/
/***/ ((module) => {

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Gets the size of a Unicode `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */
function unicodeSize(string) {
  var result = reUnicode.lastIndex = 0;
  while (reUnicode.test(string)) {
    ++result;
  }
  return result;
}

module.exports = unicodeSize;


/***/ }),

/***/ "./node_modules/lodash/clone.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/clone.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseClone = __webpack_require__(/*! ./_baseClone */ "./node_modules/lodash/_baseClone.js");

/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return baseClone(value, CLONE_SYMBOLS_FLAG);
}

module.exports = clone;


/***/ }),

/***/ "./node_modules/lodash/cloneDeep.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/cloneDeep.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseClone = __webpack_require__(/*! ./_baseClone */ "./node_modules/lodash/_baseClone.js");

/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
}

module.exports = cloneDeep;


/***/ }),

/***/ "./node_modules/lodash/constant.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/constant.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

module.exports = constant;


/***/ }),

/***/ "./node_modules/lodash/defaults.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/defaults.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    eq = __webpack_require__(/*! ./eq */ "./node_modules/lodash/eq.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns own and inherited enumerable string keyed properties of source
 * objects to the destination object for all destination properties that
 * resolve to `undefined`. Source objects are applied from left to right.
 * Once a property is set, additional values of the same property are ignored.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.defaultsDeep
 * @example
 *
 * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
 * // => { 'a': 1, 'b': 2 }
 */
var defaults = baseRest(function(object, sources) {
  object = Object(object);

  var index = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : undefined;

  if (guard && isIterateeCall(sources[0], sources[1], guard)) {
    length = 1;
  }

  while (++index < length) {
    var source = sources[index];
    var props = keysIn(source);
    var propsIndex = -1;
    var propsLength = props.length;

    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object[key];

      if (value === undefined ||
          (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        object[key] = source[key];
      }
    }
  }

  return object;
});

module.exports = defaults;


/***/ }),

/***/ "./node_modules/lodash/each.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/each.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./forEach */ "./node_modules/lodash/forEach.js");


/***/ }),

/***/ "./node_modules/lodash/eq.js":
/*!***********************************!*\
  !*** ./node_modules/lodash/eq.js ***!
  \***********************************/
/***/ ((module) => {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ "./node_modules/lodash/filter.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/filter.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayFilter = __webpack_require__(/*! ./_arrayFilter */ "./node_modules/lodash/_arrayFilter.js"),
    baseFilter = __webpack_require__(/*! ./_baseFilter */ "./node_modules/lodash/_baseFilter.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * Iterates over elements of `collection`, returning an array of all elements
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * **Note:** Unlike `_.remove`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.reject
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': true },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * _.filter(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.filter(users, { 'age': 36, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.filter(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.filter(users, 'active');
 * // => objects for ['barney']
 *
 * // Combining several predicates using `_.overEvery` or `_.overSome`.
 * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
 * // => objects for ['fred', 'barney']
 */
function filter(collection, predicate) {
  var func = isArray(collection) ? arrayFilter : baseFilter;
  return func(collection, baseIteratee(predicate, 3));
}

module.exports = filter;


/***/ }),

/***/ "./node_modules/lodash/find.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/find.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createFind = __webpack_require__(/*! ./_createFind */ "./node_modules/lodash/_createFind.js"),
    findIndex = __webpack_require__(/*! ./findIndex */ "./node_modules/lodash/findIndex.js");

/**
 * Iterates over elements of `collection`, returning the first element
 * `predicate` returns truthy for. The predicate is invoked with three
 * arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {*} Returns the matched element, else `undefined`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'age': 36, 'active': true },
 *   { 'user': 'fred',    'age': 40, 'active': false },
 *   { 'user': 'pebbles', 'age': 1,  'active': true }
 * ];
 *
 * _.find(users, function(o) { return o.age < 40; });
 * // => object for 'barney'
 *
 * // The `_.matches` iteratee shorthand.
 * _.find(users, { 'age': 1, 'active': true });
 * // => object for 'pebbles'
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.find(users, ['active', false]);
 * // => object for 'fred'
 *
 * // The `_.property` iteratee shorthand.
 * _.find(users, 'active');
 * // => object for 'barney'
 */
var find = createFind(findIndex);

module.exports = find;


/***/ }),

/***/ "./node_modules/lodash/findIndex.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/findIndex.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFindIndex = __webpack_require__(/*! ./_baseFindIndex */ "./node_modules/lodash/_baseFindIndex.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    toInteger = __webpack_require__(/*! ./toInteger */ "./node_modules/lodash/toInteger.js");

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This method is like `_.find` except that it returns the index of the first
 * element `predicate` returns truthy for instead of the element itself.
 *
 * @static
 * @memberOf _
 * @since 1.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the found element, else `-1`.
 * @example
 *
 * var users = [
 *   { 'user': 'barney',  'active': false },
 *   { 'user': 'fred',    'active': false },
 *   { 'user': 'pebbles', 'active': true }
 * ];
 *
 * _.findIndex(users, function(o) { return o.user == 'barney'; });
 * // => 0
 *
 * // The `_.matches` iteratee shorthand.
 * _.findIndex(users, { 'user': 'fred', 'active': false });
 * // => 1
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.findIndex(users, ['active', false]);
 * // => 0
 *
 * // The `_.property` iteratee shorthand.
 * _.findIndex(users, 'active');
 * // => 2
 */
function findIndex(array, predicate, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return baseFindIndex(array, baseIteratee(predicate, 3), index);
}

module.exports = findIndex;


/***/ }),

/***/ "./node_modules/lodash/flatten.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/flatten.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFlatten = __webpack_require__(/*! ./_baseFlatten */ "./node_modules/lodash/_baseFlatten.js");

/**
 * Flattens `array` a single level deep.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to flatten.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * _.flatten([1, [2, [3, [4]], 5]]);
 * // => [1, 2, [3, [4]], 5]
 */
function flatten(array) {
  var length = array == null ? 0 : array.length;
  return length ? baseFlatten(array, 1) : [];
}

module.exports = flatten;


/***/ }),

/***/ "./node_modules/lodash/forEach.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/forEach.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js"),
    castFunction = __webpack_require__(/*! ./_castFunction */ "./node_modules/lodash/_castFunction.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * Iterates over elements of `collection` and invokes `iteratee` for each element.
 * The iteratee is invoked with three arguments: (value, index|key, collection).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * **Note:** As with other "Collections" methods, objects with a "length"
 * property are iterated like arrays. To avoid this behavior use `_.forIn`
 * or `_.forOwn` for object iteration.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias each
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array|Object} Returns `collection`.
 * @see _.forEachRight
 * @example
 *
 * _.forEach([1, 2], function(value) {
 *   console.log(value);
 * });
 * // => Logs `1` then `2`.
 *
 * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a' then 'b' (iteration order is not guaranteed).
 */
function forEach(collection, iteratee) {
  var func = isArray(collection) ? arrayEach : baseEach;
  return func(collection, castFunction(iteratee));
}

module.exports = forEach;


/***/ }),

/***/ "./node_modules/lodash/forIn.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/forIn.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFor = __webpack_require__(/*! ./_baseFor */ "./node_modules/lodash/_baseFor.js"),
    castFunction = __webpack_require__(/*! ./_castFunction */ "./node_modules/lodash/_castFunction.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * Iterates over own and inherited enumerable string keyed properties of an
 * object and invokes `iteratee` for each property. The iteratee is invoked
 * with three arguments: (value, key, object). Iteratee functions may exit
 * iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 0.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns `object`.
 * @see _.forInRight
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.forIn(new Foo, function(value, key) {
 *   console.log(key);
 * });
 * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
 */
function forIn(object, iteratee) {
  return object == null
    ? object
    : baseFor(object, castFunction(iteratee), keysIn);
}

module.exports = forIn;


/***/ }),

/***/ "./node_modules/lodash/get.js":
/*!************************************!*\
  !*** ./node_modules/lodash/get.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js");

/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function get(object, path, defaultValue) {
  var result = object == null ? undefined : baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

module.exports = get;


/***/ }),

/***/ "./node_modules/lodash/has.js":
/*!************************************!*\
  !*** ./node_modules/lodash/has.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseHas = __webpack_require__(/*! ./_baseHas */ "./node_modules/lodash/_baseHas.js"),
    hasPath = __webpack_require__(/*! ./_hasPath */ "./node_modules/lodash/_hasPath.js");

/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has(object, path) {
  return object != null && hasPath(object, path, baseHas);
}

module.exports = has;


/***/ }),

/***/ "./node_modules/lodash/hasIn.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/hasIn.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseHasIn = __webpack_require__(/*! ./_baseHasIn */ "./node_modules/lodash/_baseHasIn.js"),
    hasPath = __webpack_require__(/*! ./_hasPath */ "./node_modules/lodash/_hasPath.js");

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

module.exports = hasIn;


/***/ }),

/***/ "./node_modules/lodash/identity.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/identity.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;


/***/ }),

/***/ "./node_modules/lodash/isArguments.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArguments.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsArguments = __webpack_require__(/*! ./_baseIsArguments */ "./node_modules/lodash/_baseIsArguments.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),

/***/ "./node_modules/lodash/isArray.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isArray.js ***!
  \****************************************/
/***/ ((module) => {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ "./node_modules/lodash/isArrayLike.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isArrayLike.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isLength = __webpack_require__(/*! ./isLength */ "./node_modules/lodash/isLength.js");

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),

/***/ "./node_modules/lodash/isArrayLikeObject.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash/isArrayLikeObject.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

module.exports = isArrayLikeObject;


/***/ }),

/***/ "./node_modules/lodash/isBuffer.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isBuffer.js ***!
  \*****************************************/
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js"),
    stubFalse = __webpack_require__(/*! ./stubFalse */ "./node_modules/lodash/stubFalse.js");

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;


/***/ }),

/***/ "./node_modules/lodash/isEmpty.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/isEmpty.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArguments = __webpack_require__(/*! ./isArguments */ "./node_modules/lodash/isArguments.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isPrototype = __webpack_require__(/*! ./_isPrototype */ "./node_modules/lodash/_isPrototype.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) &&
      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }
  var tag = getTag(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

module.exports = isEmpty;


/***/ }),

/***/ "./node_modules/lodash/isFunction.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/isFunction.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js");

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ "./node_modules/lodash/isLength.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isLength.js ***!
  \*****************************************/
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ "./node_modules/lodash/isMap.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/isMap.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsMap = __webpack_require__(/*! ./_baseIsMap */ "./node_modules/lodash/_baseIsMap.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsMap = nodeUtil && nodeUtil.isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

module.exports = isMap;


/***/ }),

/***/ "./node_modules/lodash/isObject.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isObject.js ***!
  \*****************************************/
/***/ ((module) => {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/***/ ((module) => {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ "./node_modules/lodash/isPlainObject.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/isPlainObject.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

module.exports = isPlainObject;


/***/ }),

/***/ "./node_modules/lodash/isSet.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/isSet.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsSet = __webpack_require__(/*! ./_baseIsSet */ "./node_modules/lodash/_baseIsSet.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsSet = nodeUtil && nodeUtil.isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

module.exports = isSet;


/***/ }),

/***/ "./node_modules/lodash/isString.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isString.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;


/***/ }),

/***/ "./node_modules/lodash/isSymbol.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/isSymbol.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ "./node_modules/lodash/_baseGetTag.js"),
    isObjectLike = __webpack_require__(/*! ./isObjectLike */ "./node_modules/lodash/isObjectLike.js");

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;


/***/ }),

/***/ "./node_modules/lodash/isTypedArray.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isTypedArray.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsTypedArray = __webpack_require__(/*! ./_baseIsTypedArray */ "./node_modules/lodash/_baseIsTypedArray.js"),
    baseUnary = __webpack_require__(/*! ./_baseUnary */ "./node_modules/lodash/_baseUnary.js"),
    nodeUtil = __webpack_require__(/*! ./_nodeUtil */ "./node_modules/lodash/_nodeUtil.js");

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),

/***/ "./node_modules/lodash/isUndefined.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/isUndefined.js ***!
  \********************************************/
/***/ ((module) => {

/**
 * Checks if `value` is `undefined`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
 * @example
 *
 * _.isUndefined(void 0);
 * // => true
 *
 * _.isUndefined(null);
 * // => false
 */
function isUndefined(value) {
  return value === undefined;
}

module.exports = isUndefined;


/***/ }),

/***/ "./node_modules/lodash/keys.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/keys.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),

/***/ "./node_modules/lodash/keysIn.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/keysIn.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(/*! ./_arrayLikeKeys */ "./node_modules/lodash/_arrayLikeKeys.js"),
    baseKeysIn = __webpack_require__(/*! ./_baseKeysIn */ "./node_modules/lodash/_baseKeysIn.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js");

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

module.exports = keysIn;


/***/ }),

/***/ "./node_modules/lodash/last.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/last.js ***!
  \*************************************/
/***/ ((module) => {

/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

module.exports = last;


/***/ }),

/***/ "./node_modules/lodash/map.js":
/*!************************************!*\
  !*** ./node_modules/lodash/map.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayMap = __webpack_require__(/*! ./_arrayMap */ "./node_modules/lodash/_arrayMap.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    baseMap = __webpack_require__(/*! ./_baseMap */ "./node_modules/lodash/_baseMap.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * Creates an array of values by running each element in `collection` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
 *
 * The guarded methods are:
 * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
 * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
 * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
 * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * _.map([4, 8], square);
 * // => [16, 64]
 *
 * _.map({ 'a': 4, 'b': 8 }, square);
 * // => [16, 64] (iteration order is not guaranteed)
 *
 * var users = [
 *   { 'user': 'barney' },
 *   { 'user': 'fred' }
 * ];
 *
 * // The `_.property` iteratee shorthand.
 * _.map(users, 'user');
 * // => ['barney', 'fred']
 */
function map(collection, iteratee) {
  var func = isArray(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee(iteratee, 3));
}

module.exports = map;


/***/ }),

/***/ "./node_modules/lodash/mapValues.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/mapValues.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseAssignValue = __webpack_require__(/*! ./_baseAssignValue */ "./node_modules/lodash/_baseAssignValue.js"),
    baseForOwn = __webpack_require__(/*! ./_baseForOwn */ "./node_modules/lodash/_baseForOwn.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js");

/**
 * Creates an object with the same keys as `object` and values generated
 * by running each own enumerable string keyed property of `object` thru
 * `iteratee`. The iteratee is invoked with three arguments:
 * (value, key, object).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Object} Returns the new mapped object.
 * @see _.mapKeys
 * @example
 *
 * var users = {
 *   'fred':    { 'user': 'fred',    'age': 40 },
 *   'pebbles': { 'user': 'pebbles', 'age': 1 }
 * };
 *
 * _.mapValues(users, function(o) { return o.age; });
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 *
 * // The `_.property` iteratee shorthand.
 * _.mapValues(users, 'age');
 * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
 */
function mapValues(object, iteratee) {
  var result = {};
  iteratee = baseIteratee(iteratee, 3);

  baseForOwn(object, function(value, key, object) {
    baseAssignValue(result, key, iteratee(value, key, object));
  });
  return result;
}

module.exports = mapValues;


/***/ }),

/***/ "./node_modules/lodash/max.js":
/*!************************************!*\
  !*** ./node_modules/lodash/max.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseExtremum = __webpack_require__(/*! ./_baseExtremum */ "./node_modules/lodash/_baseExtremum.js"),
    baseGt = __webpack_require__(/*! ./_baseGt */ "./node_modules/lodash/_baseGt.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");

/**
 * Computes the maximum value of `array`. If `array` is empty or falsey,
 * `undefined` is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {*} Returns the maximum value.
 * @example
 *
 * _.max([4, 2, 8, 6]);
 * // => 8
 *
 * _.max([]);
 * // => undefined
 */
function max(array) {
  return (array && array.length)
    ? baseExtremum(array, identity, baseGt)
    : undefined;
}

module.exports = max;


/***/ }),

/***/ "./node_modules/lodash/memoize.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/memoize.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__(/*! ./_MapCache */ "./node_modules/lodash/_MapCache.js");

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

module.exports = memoize;


/***/ }),

/***/ "./node_modules/lodash/merge.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/merge.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseMerge = __webpack_require__(/*! ./_baseMerge */ "./node_modules/lodash/_baseMerge.js"),
    createAssigner = __webpack_require__(/*! ./_createAssigner */ "./node_modules/lodash/_createAssigner.js");

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

module.exports = merge;


/***/ }),

/***/ "./node_modules/lodash/min.js":
/*!************************************!*\
  !*** ./node_modules/lodash/min.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseExtremum = __webpack_require__(/*! ./_baseExtremum */ "./node_modules/lodash/_baseExtremum.js"),
    baseLt = __webpack_require__(/*! ./_baseLt */ "./node_modules/lodash/_baseLt.js"),
    identity = __webpack_require__(/*! ./identity */ "./node_modules/lodash/identity.js");

/**
 * Computes the minimum value of `array`. If `array` is empty or falsey,
 * `undefined` is returned.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {*} Returns the minimum value.
 * @example
 *
 * _.min([4, 2, 8, 6]);
 * // => 2
 *
 * _.min([]);
 * // => undefined
 */
function min(array) {
  return (array && array.length)
    ? baseExtremum(array, identity, baseLt)
    : undefined;
}

module.exports = min;


/***/ }),

/***/ "./node_modules/lodash/minBy.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/minBy.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseExtremum = __webpack_require__(/*! ./_baseExtremum */ "./node_modules/lodash/_baseExtremum.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    baseLt = __webpack_require__(/*! ./_baseLt */ "./node_modules/lodash/_baseLt.js");

/**
 * This method is like `_.min` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * the value is ranked. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {*} Returns the minimum value.
 * @example
 *
 * var objects = [{ 'n': 1 }, { 'n': 2 }];
 *
 * _.minBy(objects, function(o) { return o.n; });
 * // => { 'n': 1 }
 *
 * // The `_.property` iteratee shorthand.
 * _.minBy(objects, 'n');
 * // => { 'n': 1 }
 */
function minBy(array, iteratee) {
  return (array && array.length)
    ? baseExtremum(array, baseIteratee(iteratee, 2), baseLt)
    : undefined;
}

module.exports = minBy;


/***/ }),

/***/ "./node_modules/lodash/noop.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/noop.js ***!
  \*************************************/
/***/ ((module) => {

/**
 * This method returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;


/***/ }),

/***/ "./node_modules/lodash/now.js":
/*!************************************!*\
  !*** ./node_modules/lodash/now.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(/*! ./_root */ "./node_modules/lodash/_root.js");

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;


/***/ }),

/***/ "./node_modules/lodash/pick.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/pick.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var basePick = __webpack_require__(/*! ./_basePick */ "./node_modules/lodash/_basePick.js"),
    flatRest = __webpack_require__(/*! ./_flatRest */ "./node_modules/lodash/_flatRest.js");

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});

module.exports = pick;


/***/ }),

/***/ "./node_modules/lodash/property.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/property.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseProperty = __webpack_require__(/*! ./_baseProperty */ "./node_modules/lodash/_baseProperty.js"),
    basePropertyDeep = __webpack_require__(/*! ./_basePropertyDeep */ "./node_modules/lodash/_basePropertyDeep.js"),
    isKey = __webpack_require__(/*! ./_isKey */ "./node_modules/lodash/_isKey.js"),
    toKey = __webpack_require__(/*! ./_toKey */ "./node_modules/lodash/_toKey.js");

/**
 * Creates a function that returns the value at `path` of a given object.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {Array|string} path The path of the property to get.
 * @returns {Function} Returns the new accessor function.
 * @example
 *
 * var objects = [
 *   { 'a': { 'b': 2 } },
 *   { 'a': { 'b': 1 } }
 * ];
 *
 * _.map(objects, _.property('a.b'));
 * // => [2, 1]
 *
 * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
 * // => [1, 2]
 */
function property(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}

module.exports = property;


/***/ }),

/***/ "./node_modules/lodash/range.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/range.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var createRange = __webpack_require__(/*! ./_createRange */ "./node_modules/lodash/_createRange.js");

/**
 * Creates an array of numbers (positive and/or negative) progressing from
 * `start` up to, but not including, `end`. A step of `-1` is used if a negative
 * `start` is specified without an `end` or `step`. If `end` is not specified,
 * it's set to `start` with `start` then set to `0`.
 *
 * **Note:** JavaScript follows the IEEE-754 standard for resolving
 * floating-point values which can produce unexpected results.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {number} [start=0] The start of the range.
 * @param {number} end The end of the range.
 * @param {number} [step=1] The value to increment or decrement by.
 * @returns {Array} Returns the range of numbers.
 * @see _.inRange, _.rangeRight
 * @example
 *
 * _.range(4);
 * // => [0, 1, 2, 3]
 *
 * _.range(-4);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 5);
 * // => [1, 2, 3, 4]
 *
 * _.range(0, 20, 5);
 * // => [0, 5, 10, 15]
 *
 * _.range(0, -4, -1);
 * // => [0, -1, -2, -3]
 *
 * _.range(1, 4, 0);
 * // => [1, 1, 1]
 *
 * _.range(0);
 * // => []
 */
var range = createRange();

module.exports = range;


/***/ }),

/***/ "./node_modules/lodash/reduce.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/reduce.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayReduce = __webpack_require__(/*! ./_arrayReduce */ "./node_modules/lodash/_arrayReduce.js"),
    baseEach = __webpack_require__(/*! ./_baseEach */ "./node_modules/lodash/_baseEach.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    baseReduce = __webpack_require__(/*! ./_baseReduce */ "./node_modules/lodash/_baseReduce.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js");

/**
 * Reduces `collection` to a value which is the accumulated result of running
 * each element in `collection` thru `iteratee`, where each successive
 * invocation is supplied the return value of the previous. If `accumulator`
 * is not given, the first element of `collection` is used as the initial
 * value. The iteratee is invoked with four arguments:
 * (accumulator, value, index|key, collection).
 *
 * Many lodash methods are guarded to work as iteratees for methods like
 * `_.reduce`, `_.reduceRight`, and `_.transform`.
 *
 * The guarded methods are:
 * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
 * and `sortBy`
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @returns {*} Returns the accumulated value.
 * @see _.reduceRight
 * @example
 *
 * _.reduce([1, 2], function(sum, n) {
 *   return sum + n;
 * }, 0);
 * // => 3
 *
 * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 *   return result;
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
 */
function reduce(collection, iteratee, accumulator) {
  var func = isArray(collection) ? arrayReduce : baseReduce,
      initAccum = arguments.length < 3;

  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);
}

module.exports = reduce;


/***/ }),

/***/ "./node_modules/lodash/size.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/size.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseKeys = __webpack_require__(/*! ./_baseKeys */ "./node_modules/lodash/_baseKeys.js"),
    getTag = __webpack_require__(/*! ./_getTag */ "./node_modules/lodash/_getTag.js"),
    isArrayLike = __webpack_require__(/*! ./isArrayLike */ "./node_modules/lodash/isArrayLike.js"),
    isString = __webpack_require__(/*! ./isString */ "./node_modules/lodash/isString.js"),
    stringSize = __webpack_require__(/*! ./_stringSize */ "./node_modules/lodash/_stringSize.js");

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/**
 * Gets the size of `collection` by returning its length for array-like
 * values or the number of own enumerable string keyed properties for objects.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @returns {number} Returns the collection size.
 * @example
 *
 * _.size([1, 2, 3]);
 * // => 3
 *
 * _.size({ 'a': 1, 'b': 2 });
 * // => 2
 *
 * _.size('pebbles');
 * // => 7
 */
function size(collection) {
  if (collection == null) {
    return 0;
  }
  if (isArrayLike(collection)) {
    return isString(collection) ? stringSize(collection) : collection.length;
  }
  var tag = getTag(collection);
  if (tag == mapTag || tag == setTag) {
    return collection.size;
  }
  return baseKeys(collection).length;
}

module.exports = size;


/***/ }),

/***/ "./node_modules/lodash/sortBy.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/sortBy.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFlatten = __webpack_require__(/*! ./_baseFlatten */ "./node_modules/lodash/_baseFlatten.js"),
    baseOrderBy = __webpack_require__(/*! ./_baseOrderBy */ "./node_modules/lodash/_baseOrderBy.js"),
    baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    isIterateeCall = __webpack_require__(/*! ./_isIterateeCall */ "./node_modules/lodash/_isIterateeCall.js");

/**
 * Creates an array of elements, sorted in ascending order by the results of
 * running each element in a collection thru each iteratee. This method
 * performs a stable sort, that is, it preserves the original sort order of
 * equal elements. The iteratees are invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {...(Function|Function[])} [iteratees=[_.identity]]
 *  The iteratees to sort by.
 * @returns {Array} Returns the new sorted array.
 * @example
 *
 * var users = [
 *   { 'user': 'fred',   'age': 48 },
 *   { 'user': 'barney', 'age': 36 },
 *   { 'user': 'fred',   'age': 30 },
 *   { 'user': 'barney', 'age': 34 }
 * ];
 *
 * _.sortBy(users, [function(o) { return o.user; }]);
 * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
 *
 * _.sortBy(users, ['user', 'age']);
 * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
 */
var sortBy = baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
});

module.exports = sortBy;


/***/ }),

/***/ "./node_modules/lodash/stubArray.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubArray.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),

/***/ "./node_modules/lodash/stubFalse.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/stubFalse.js ***!
  \******************************************/
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ "./node_modules/lodash/toFinite.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toFinite.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toNumber = __webpack_require__(/*! ./toNumber */ "./node_modules/lodash/toNumber.js");

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;


/***/ }),

/***/ "./node_modules/lodash/toInteger.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/toInteger.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toFinite = __webpack_require__(/*! ./toFinite */ "./node_modules/lodash/toFinite.js");

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;


/***/ }),

/***/ "./node_modules/lodash/toNumber.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toNumber.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTrim = __webpack_require__(/*! ./_baseTrim */ "./node_modules/lodash/_baseTrim.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isSymbol = __webpack_require__(/*! ./isSymbol */ "./node_modules/lodash/isSymbol.js");

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;


/***/ }),

/***/ "./node_modules/lodash/toPlainObject.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/toPlainObject.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var copyObject = __webpack_require__(/*! ./_copyObject */ "./node_modules/lodash/_copyObject.js"),
    keysIn = __webpack_require__(/*! ./keysIn */ "./node_modules/lodash/keysIn.js");

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

module.exports = toPlainObject;


/***/ }),

/***/ "./node_modules/lodash/toString.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/toString.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseToString = __webpack_require__(/*! ./_baseToString */ "./node_modules/lodash/_baseToString.js");

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;


/***/ }),

/***/ "./node_modules/lodash/transform.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/transform.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayEach = __webpack_require__(/*! ./_arrayEach */ "./node_modules/lodash/_arrayEach.js"),
    baseCreate = __webpack_require__(/*! ./_baseCreate */ "./node_modules/lodash/_baseCreate.js"),
    baseForOwn = __webpack_require__(/*! ./_baseForOwn */ "./node_modules/lodash/_baseForOwn.js"),
    baseIteratee = __webpack_require__(/*! ./_baseIteratee */ "./node_modules/lodash/_baseIteratee.js"),
    getPrototype = __webpack_require__(/*! ./_getPrototype */ "./node_modules/lodash/_getPrototype.js"),
    isArray = __webpack_require__(/*! ./isArray */ "./node_modules/lodash/isArray.js"),
    isBuffer = __webpack_require__(/*! ./isBuffer */ "./node_modules/lodash/isBuffer.js"),
    isFunction = __webpack_require__(/*! ./isFunction */ "./node_modules/lodash/isFunction.js"),
    isObject = __webpack_require__(/*! ./isObject */ "./node_modules/lodash/isObject.js"),
    isTypedArray = __webpack_require__(/*! ./isTypedArray */ "./node_modules/lodash/isTypedArray.js");

/**
 * An alternative to `_.reduce`; this method transforms `object` to a new
 * `accumulator` object which is the result of running each of its own
 * enumerable string keyed properties thru `iteratee`, with each invocation
 * potentially mutating the `accumulator` object. If `accumulator` is not
 * provided, a new object with the same `[[Prototype]]` will be used. The
 * iteratee is invoked with four arguments: (accumulator, value, key, object).
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @static
 * @memberOf _
 * @since 1.3.0
 * @category Object
 * @param {Object} object The object to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @param {*} [accumulator] The custom accumulator value.
 * @returns {*} Returns the accumulated value.
 * @example
 *
 * _.transform([2, 3, 4], function(result, n) {
 *   result.push(n *= n);
 *   return n % 2 == 0;
 * }, []);
 * // => [4, 9]
 *
 * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
 *   (result[value] || (result[value] = [])).push(key);
 * }, {});
 * // => { '1': ['a', 'c'], '2': ['b'] }
 */
function transform(object, iteratee, accumulator) {
  var isArr = isArray(object),
      isArrLike = isArr || isBuffer(object) || isTypedArray(object);

  iteratee = baseIteratee(iteratee, 4);
  if (accumulator == null) {
    var Ctor = object && object.constructor;
    if (isArrLike) {
      accumulator = isArr ? new Ctor : [];
    }
    else if (isObject(object)) {
      accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
    }
    else {
      accumulator = {};
    }
  }
  (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
    return iteratee(accumulator, value, index, object);
  });
  return accumulator;
}

module.exports = transform;


/***/ }),

/***/ "./node_modules/lodash/union.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/union.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseFlatten = __webpack_require__(/*! ./_baseFlatten */ "./node_modules/lodash/_baseFlatten.js"),
    baseRest = __webpack_require__(/*! ./_baseRest */ "./node_modules/lodash/_baseRest.js"),
    baseUniq = __webpack_require__(/*! ./_baseUniq */ "./node_modules/lodash/_baseUniq.js"),
    isArrayLikeObject = __webpack_require__(/*! ./isArrayLikeObject */ "./node_modules/lodash/isArrayLikeObject.js");

/**
 * Creates an array of unique values, in order, from all given arrays using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {...Array} [arrays] The arrays to inspect.
 * @returns {Array} Returns the new array of combined values.
 * @example
 *
 * _.union([2], [1, 2]);
 * // => [2, 1]
 */
var union = baseRest(function(arrays) {
  return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
});

module.exports = union;


/***/ }),

/***/ "./node_modules/lodash/uniqueId.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/uniqueId.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toString = __webpack_require__(/*! ./toString */ "./node_modules/lodash/toString.js");

/** Used to generate unique IDs. */
var idCounter = 0;

/**
 * Generates a unique ID. If `prefix` is given, the ID is appended to it.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {string} [prefix=''] The value to prefix the ID with.
 * @returns {string} Returns the unique ID.
 * @example
 *
 * _.uniqueId('contact_');
 * // => 'contact_104'
 *
 * _.uniqueId();
 * // => '105'
 */
function uniqueId(prefix) {
  var id = ++idCounter;
  return toString(prefix) + id;
}

module.exports = uniqueId;


/***/ }),

/***/ "./node_modules/lodash/values.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/values.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseValues = __webpack_require__(/*! ./_baseValues */ "./node_modules/lodash/_baseValues.js"),
    keys = __webpack_require__(/*! ./keys */ "./node_modules/lodash/keys.js");

/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */
function values(object) {
  return object == null ? [] : baseValues(object, keys(object));
}

module.exports = values;


/***/ }),

/***/ "./node_modules/lodash/zipObject.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/zipObject.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assignValue = __webpack_require__(/*! ./_assignValue */ "./node_modules/lodash/_assignValue.js"),
    baseZipObject = __webpack_require__(/*! ./_baseZipObject */ "./node_modules/lodash/_baseZipObject.js");

/**
 * This method is like `_.fromPairs` except that it accepts two arrays,
 * one of property identifiers and one of corresponding values.
 *
 * @static
 * @memberOf _
 * @since 0.4.0
 * @category Array
 * @param {Array} [props=[]] The property identifiers.
 * @param {Array} [values=[]] The property values.
 * @returns {Object} Returns the new object.
 * @example
 *
 * _.zipObject(['a', 'b'], [1, 2]);
 * // => { 'a': 1, 'b': 2 }
 */
function zipObject(props, values) {
  return baseZipObject(props || [], values || [], assignValue);
}

module.exports = zipObject;


/***/ }),

/***/ "./node_modules/ml-array-max/lib-es6/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ml-array-max/lib-es6/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ max)
/* harmony export */ });
/* harmony import */ var is_any_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-any-array */ "./node_modules/is-any-array/lib-esm/index.js");


function max(input) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!(0,is_any_array__WEBPACK_IMPORTED_MODULE_0__.isAnyArray)(input)) {
    throw new TypeError('input must be an array');
  }

  if (input.length === 0) {
    throw new TypeError('input must not be empty');
  }

  var _options$fromIndex = options.fromIndex,
      fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex,
      _options$toIndex = options.toIndex,
      toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;

  if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
    throw new Error('fromIndex must be a positive integer smaller than length');
  }

  if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
    throw new Error('toIndex must be an integer greater than fromIndex and at most equal to length');
  }

  var maxValue = input[fromIndex];

  for (var i = fromIndex + 1; i < toIndex; i++) {
    if (input[i] > maxValue) maxValue = input[i];
  }

  return maxValue;
}




/***/ }),

/***/ "./node_modules/ml-array-min/lib-es6/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ml-array-min/lib-es6/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ min)
/* harmony export */ });
/* harmony import */ var is_any_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-any-array */ "./node_modules/is-any-array/lib-esm/index.js");


function min(input) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!(0,is_any_array__WEBPACK_IMPORTED_MODULE_0__.isAnyArray)(input)) {
    throw new TypeError('input must be an array');
  }

  if (input.length === 0) {
    throw new TypeError('input must not be empty');
  }

  var _options$fromIndex = options.fromIndex,
      fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex,
      _options$toIndex = options.toIndex,
      toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;

  if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {
    throw new Error('fromIndex must be a positive integer smaller than length');
  }

  if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {
    throw new Error('toIndex must be an integer greater than fromIndex and at most equal to length');
  }

  var minValue = input[fromIndex];

  for (var i = fromIndex + 1; i < toIndex; i++) {
    if (input[i] < minValue) minValue = input[i];
  }

  return minValue;
}




/***/ }),

/***/ "./node_modules/ml-array-rescale/lib-es6/index.js":
/*!********************************************************!*\
  !*** ./node_modules/ml-array-rescale/lib-es6/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ rescale)
/* harmony export */ });
/* harmony import */ var is_any_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-any-array */ "./node_modules/is-any-array/lib-esm/index.js");
/* harmony import */ var ml_array_max__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ml-array-max */ "./node_modules/ml-array-max/lib-es6/index.js");
/* harmony import */ var ml_array_min__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ml-array-min */ "./node_modules/ml-array-min/lib-es6/index.js");




function rescale(input) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!(0,is_any_array__WEBPACK_IMPORTED_MODULE_0__.isAnyArray)(input)) {
    throw new TypeError('input must be an array');
  } else if (input.length === 0) {
    throw new TypeError('input must not be empty');
  }

  var output;

  if (options.output !== undefined) {
    if (!(0,is_any_array__WEBPACK_IMPORTED_MODULE_0__.isAnyArray)(options.output)) {
      throw new TypeError('output option must be an array if specified');
    }

    output = options.output;
  } else {
    output = new Array(input.length);
  }

  var currentMin = (0,ml_array_min__WEBPACK_IMPORTED_MODULE_2__["default"])(input);
  var currentMax = (0,ml_array_max__WEBPACK_IMPORTED_MODULE_1__["default"])(input);

  if (currentMin === currentMax) {
    throw new RangeError('minimum and maximum input values are equal. Cannot rescale a constant array');
  }

  var _options$min = options.min,
      minValue = _options$min === void 0 ? options.autoMinMax ? currentMin : 0 : _options$min,
      _options$max = options.max,
      maxValue = _options$max === void 0 ? options.autoMinMax ? currentMax : 1 : _options$max;

  if (minValue >= maxValue) {
    throw new RangeError('min option must be smaller than max option');
  }

  var factor = (maxValue - minValue) / (currentMax - currentMin);

  for (var i = 0; i < input.length; i++) {
    output[i] = (input[i] - currentMin) * factor + minValue;
  }

  return output;
}




/***/ }),

/***/ "./node_modules/ml-matrix/matrix.js":
/*!******************************************!*\
  !*** ./node_modules/ml-matrix/matrix.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({ value: true }));

var isAnyArray = __webpack_require__(/*! is-any-array */ "./node_modules/is-any-array/lib-esm/index.js");
var rescale = __webpack_require__(/*! ml-array-rescale */ "./node_modules/ml-array-rescale/lib-es6/index.js");

const indent = ' '.repeat(2);
const indentData = ' '.repeat(4);

/**
 * @this {Matrix}
 * @returns {string}
 */
function inspectMatrix() {
  return inspectMatrixWithOptions(this);
}

function inspectMatrixWithOptions(matrix, options = {}) {
  const {
    maxRows = 15,
    maxColumns = 10,
    maxNumSize = 8,
    padMinus = 'auto',
  } = options;
  return `${matrix.constructor.name} {
${indent}[
${indentData}${inspectData(matrix, maxRows, maxColumns, maxNumSize, padMinus)}
${indent}]
${indent}rows: ${matrix.rows}
${indent}columns: ${matrix.columns}
}`;
}

function inspectData(matrix, maxRows, maxColumns, maxNumSize, padMinus) {
  const { rows, columns } = matrix;
  const maxI = Math.min(rows, maxRows);
  const maxJ = Math.min(columns, maxColumns);
  const result = [];

  if (padMinus === 'auto') {
    padMinus = false;
    loop: for (let i = 0; i < maxI; i++) {
      for (let j = 0; j < maxJ; j++) {
        if (matrix.get(i, j) < 0) {
          padMinus = true;
          break loop;
        }
      }
    }
  }

  for (let i = 0; i < maxI; i++) {
    let line = [];
    for (let j = 0; j < maxJ; j++) {
      line.push(formatNumber(matrix.get(i, j), maxNumSize, padMinus));
    }
    result.push(`${line.join(' ')}`);
  }
  if (maxJ !== columns) {
    result[result.length - 1] += ` ... ${columns - maxColumns} more columns`;
  }
  if (maxI !== rows) {
    result.push(`... ${rows - maxRows} more rows`);
  }
  return result.join(`\n${indentData}`);
}

function formatNumber(num, maxNumSize, padMinus) {
  return (
    num >= 0 && padMinus
      ? ` ${formatNumber2(num, maxNumSize - 1)}`
      : formatNumber2(num, maxNumSize)
  ).padEnd(maxNumSize);
}

function formatNumber2(num, len) {
  // small.length numbers should be as is
  let str = num.toString();
  if (str.length <= len) return str;

  // (7)'0.00123' is better then (7)'1.23e-2'
  // (8)'0.000123' is worse then (7)'1.23e-3',
  let fix = num.toFixed(len);
  if (fix.length > len) {
    fix = num.toFixed(Math.max(0, len - (fix.length - len)));
  }
  if (
    fix.length <= len &&
    !fix.startsWith('0.000') &&
    !fix.startsWith('-0.000')
  ) {
    return fix;
  }

  // well, if it's still too long the user should've used longer numbers
  let exp = num.toExponential(len);
  if (exp.length > len) {
    exp = num.toExponential(Math.max(0, len - (exp.length - len)));
  }
  return exp.slice(0);
}

function installMathOperations(AbstractMatrix, Matrix) {
  AbstractMatrix.prototype.add = function add(value) {
    if (typeof value === 'number') return this.addS(value);
    return this.addM(value);
  };

  AbstractMatrix.prototype.addS = function addS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) + value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.addM = function addM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) + matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.add = function add(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.add(value);
  };

  AbstractMatrix.prototype.sub = function sub(value) {
    if (typeof value === 'number') return this.subS(value);
    return this.subM(value);
  };

  AbstractMatrix.prototype.subS = function subS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) - value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.subM = function subM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) - matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.sub = function sub(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.sub(value);
  };
  AbstractMatrix.prototype.subtract = AbstractMatrix.prototype.sub;
  AbstractMatrix.prototype.subtractS = AbstractMatrix.prototype.subS;
  AbstractMatrix.prototype.subtractM = AbstractMatrix.prototype.subM;
  AbstractMatrix.subtract = AbstractMatrix.sub;

  AbstractMatrix.prototype.mul = function mul(value) {
    if (typeof value === 'number') return this.mulS(value);
    return this.mulM(value);
  };

  AbstractMatrix.prototype.mulS = function mulS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) * value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.mulM = function mulM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) * matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.mul = function mul(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.mul(value);
  };
  AbstractMatrix.prototype.multiply = AbstractMatrix.prototype.mul;
  AbstractMatrix.prototype.multiplyS = AbstractMatrix.prototype.mulS;
  AbstractMatrix.prototype.multiplyM = AbstractMatrix.prototype.mulM;
  AbstractMatrix.multiply = AbstractMatrix.mul;

  AbstractMatrix.prototype.div = function div(value) {
    if (typeof value === 'number') return this.divS(value);
    return this.divM(value);
  };

  AbstractMatrix.prototype.divS = function divS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) / value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.divM = function divM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) / matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.div = function div(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.div(value);
  };
  AbstractMatrix.prototype.divide = AbstractMatrix.prototype.div;
  AbstractMatrix.prototype.divideS = AbstractMatrix.prototype.divS;
  AbstractMatrix.prototype.divideM = AbstractMatrix.prototype.divM;
  AbstractMatrix.divide = AbstractMatrix.div;

  AbstractMatrix.prototype.mod = function mod(value) {
    if (typeof value === 'number') return this.modS(value);
    return this.modM(value);
  };

  AbstractMatrix.prototype.modS = function modS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) % value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.modM = function modM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) % matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.mod = function mod(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.mod(value);
  };
  AbstractMatrix.prototype.modulus = AbstractMatrix.prototype.mod;
  AbstractMatrix.prototype.modulusS = AbstractMatrix.prototype.modS;
  AbstractMatrix.prototype.modulusM = AbstractMatrix.prototype.modM;
  AbstractMatrix.modulus = AbstractMatrix.mod;

  AbstractMatrix.prototype.and = function and(value) {
    if (typeof value === 'number') return this.andS(value);
    return this.andM(value);
  };

  AbstractMatrix.prototype.andS = function andS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) & value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.andM = function andM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) & matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.and = function and(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.and(value);
  };

  AbstractMatrix.prototype.or = function or(value) {
    if (typeof value === 'number') return this.orS(value);
    return this.orM(value);
  };

  AbstractMatrix.prototype.orS = function orS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) | value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.orM = function orM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) | matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.or = function or(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.or(value);
  };

  AbstractMatrix.prototype.xor = function xor(value) {
    if (typeof value === 'number') return this.xorS(value);
    return this.xorM(value);
  };

  AbstractMatrix.prototype.xorS = function xorS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) ^ value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.xorM = function xorM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) ^ matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.xor = function xor(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.xor(value);
  };

  AbstractMatrix.prototype.leftShift = function leftShift(value) {
    if (typeof value === 'number') return this.leftShiftS(value);
    return this.leftShiftM(value);
  };

  AbstractMatrix.prototype.leftShiftS = function leftShiftS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) << value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.leftShiftM = function leftShiftM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) << matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.leftShift = function leftShift(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.leftShift(value);
  };

  AbstractMatrix.prototype.signPropagatingRightShift = function signPropagatingRightShift(value) {
    if (typeof value === 'number') return this.signPropagatingRightShiftS(value);
    return this.signPropagatingRightShiftM(value);
  };

  AbstractMatrix.prototype.signPropagatingRightShiftS = function signPropagatingRightShiftS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) >> value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.signPropagatingRightShiftM = function signPropagatingRightShiftM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) >> matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.signPropagatingRightShift = function signPropagatingRightShift(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.signPropagatingRightShift(value);
  };

  AbstractMatrix.prototype.rightShift = function rightShift(value) {
    if (typeof value === 'number') return this.rightShiftS(value);
    return this.rightShiftM(value);
  };

  AbstractMatrix.prototype.rightShiftS = function rightShiftS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) >>> value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.rightShiftM = function rightShiftM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) >>> matrix.get(i, j));
      }
    }
    return this;
  };

  AbstractMatrix.rightShift = function rightShift(matrix, value) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.rightShift(value);
  };
  AbstractMatrix.prototype.zeroFillRightShift = AbstractMatrix.prototype.rightShift;
  AbstractMatrix.prototype.zeroFillRightShiftS = AbstractMatrix.prototype.rightShiftS;
  AbstractMatrix.prototype.zeroFillRightShiftM = AbstractMatrix.prototype.rightShiftM;
  AbstractMatrix.zeroFillRightShift = AbstractMatrix.rightShift;

  AbstractMatrix.prototype.not = function not() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, ~(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.not = function not(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.not();
  };

  AbstractMatrix.prototype.abs = function abs() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.abs(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.abs = function abs(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.abs();
  };

  AbstractMatrix.prototype.acos = function acos() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.acos(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.acos = function acos(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.acos();
  };

  AbstractMatrix.prototype.acosh = function acosh() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.acosh(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.acosh = function acosh(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.acosh();
  };

  AbstractMatrix.prototype.asin = function asin() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.asin(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.asin = function asin(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.asin();
  };

  AbstractMatrix.prototype.asinh = function asinh() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.asinh(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.asinh = function asinh(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.asinh();
  };

  AbstractMatrix.prototype.atan = function atan() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.atan(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.atan = function atan(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.atan();
  };

  AbstractMatrix.prototype.atanh = function atanh() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.atanh(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.atanh = function atanh(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.atanh();
  };

  AbstractMatrix.prototype.cbrt = function cbrt() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.cbrt(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.cbrt = function cbrt(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.cbrt();
  };

  AbstractMatrix.prototype.ceil = function ceil() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.ceil(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.ceil = function ceil(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.ceil();
  };

  AbstractMatrix.prototype.clz32 = function clz32() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.clz32(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.clz32 = function clz32(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.clz32();
  };

  AbstractMatrix.prototype.cos = function cos() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.cos(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.cos = function cos(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.cos();
  };

  AbstractMatrix.prototype.cosh = function cosh() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.cosh(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.cosh = function cosh(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.cosh();
  };

  AbstractMatrix.prototype.exp = function exp() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.exp(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.exp = function exp(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.exp();
  };

  AbstractMatrix.prototype.expm1 = function expm1() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.expm1(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.expm1 = function expm1(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.expm1();
  };

  AbstractMatrix.prototype.floor = function floor() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.floor(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.floor = function floor(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.floor();
  };

  AbstractMatrix.prototype.fround = function fround() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.fround(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.fround = function fround(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.fround();
  };

  AbstractMatrix.prototype.log = function log() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.log(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.log = function log(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.log();
  };

  AbstractMatrix.prototype.log1p = function log1p() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.log1p(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.log1p = function log1p(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.log1p();
  };

  AbstractMatrix.prototype.log10 = function log10() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.log10(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.log10 = function log10(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.log10();
  };

  AbstractMatrix.prototype.log2 = function log2() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.log2(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.log2 = function log2(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.log2();
  };

  AbstractMatrix.prototype.round = function round() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.round(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.round = function round(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.round();
  };

  AbstractMatrix.prototype.sign = function sign() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.sign(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.sign = function sign(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.sign();
  };

  AbstractMatrix.prototype.sin = function sin() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.sin(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.sin = function sin(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.sin();
  };

  AbstractMatrix.prototype.sinh = function sinh() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.sinh(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.sinh = function sinh(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.sinh();
  };

  AbstractMatrix.prototype.sqrt = function sqrt() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.sqrt(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.sqrt = function sqrt(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.sqrt();
  };

  AbstractMatrix.prototype.tan = function tan() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.tan(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.tan = function tan(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.tan();
  };

  AbstractMatrix.prototype.tanh = function tanh() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.tanh(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.tanh = function tanh(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.tanh();
  };

  AbstractMatrix.prototype.trunc = function trunc() {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, Math.trunc(this.get(i, j)));
      }
    }
    return this;
  };

  AbstractMatrix.trunc = function trunc(matrix) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.trunc();
  };

  AbstractMatrix.pow = function pow(matrix, arg0) {
    const newMatrix = new Matrix(matrix);
    return newMatrix.pow(arg0);
  };

  AbstractMatrix.prototype.pow = function pow(value) {
    if (typeof value === 'number') return this.powS(value);
    return this.powM(value);
  };

  AbstractMatrix.prototype.powS = function powS(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) ** value);
      }
    }
    return this;
  };

  AbstractMatrix.prototype.powM = function powM(matrix) {
    matrix = Matrix.checkMatrix(matrix);
    if (this.rows !== matrix.rows ||
      this.columns !== matrix.columns) {
      throw new RangeError('Matrices dimensions must be equal');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) ** matrix.get(i, j));
      }
    }
    return this;
  };
}

/**
 * @private
 * Check that a row index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */
function checkRowIndex(matrix, index, outer) {
  let max = outer ? matrix.rows : matrix.rows - 1;
  if (index < 0 || index > max) {
    throw new RangeError('Row index out of range');
  }
}

/**
 * @private
 * Check that a column index is not out of bounds
 * @param {Matrix} matrix
 * @param {number} index
 * @param {boolean} [outer]
 */
function checkColumnIndex(matrix, index, outer) {
  let max = outer ? matrix.columns : matrix.columns - 1;
  if (index < 0 || index > max) {
    throw new RangeError('Column index out of range');
  }
}

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @return {Array}
 * @throws {RangeError}
 */
function checkRowVector(matrix, vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== matrix.columns) {
    throw new RangeError(
      'vector size must be the same as the number of columns',
    );
  }
  return vector;
}

/**
 * @private
 * Check that the provided vector is an array with the right length
 * @param {Matrix} matrix
 * @param {Array|Matrix} vector
 * @return {Array}
 * @throws {RangeError}
 */
function checkColumnVector(matrix, vector) {
  if (vector.to1DArray) {
    vector = vector.to1DArray();
  }
  if (vector.length !== matrix.rows) {
    throw new RangeError('vector size must be the same as the number of rows');
  }
  return vector;
}

function checkRowIndices(matrix, rowIndices) {
  if (!isAnyArray.isAnyArray(rowIndices)) {
    throw new TypeError('row indices must be an array');
  }

  for (let i = 0; i < rowIndices.length; i++) {
    if (rowIndices[i] < 0 || rowIndices[i] >= matrix.rows) {
      throw new RangeError('row indices are out of range');
    }
  }
}

function checkColumnIndices(matrix, columnIndices) {
  if (!isAnyArray.isAnyArray(columnIndices)) {
    throw new TypeError('column indices must be an array');
  }

  for (let i = 0; i < columnIndices.length; i++) {
    if (columnIndices[i] < 0 || columnIndices[i] >= matrix.columns) {
      throw new RangeError('column indices are out of range');
    }
  }
}

function checkRange(matrix, startRow, endRow, startColumn, endColumn) {
  if (arguments.length !== 5) {
    throw new RangeError('expected 4 arguments');
  }
  checkNumber('startRow', startRow);
  checkNumber('endRow', endRow);
  checkNumber('startColumn', startColumn);
  checkNumber('endColumn', endColumn);
  if (
    startRow > endRow ||
    startColumn > endColumn ||
    startRow < 0 ||
    startRow >= matrix.rows ||
    endRow < 0 ||
    endRow >= matrix.rows ||
    startColumn < 0 ||
    startColumn >= matrix.columns ||
    endColumn < 0 ||
    endColumn >= matrix.columns
  ) {
    throw new RangeError('Submatrix indices are out of range');
  }
}

function newArray(length, value = 0) {
  let array = [];
  for (let i = 0; i < length; i++) {
    array.push(value);
  }
  return array;
}

function checkNumber(name, value) {
  if (typeof value !== 'number') {
    throw new TypeError(`${name} must be a number`);
  }
}

function checkNonEmpty(matrix) {
  if (matrix.isEmpty()) {
    throw new Error('Empty matrix has no elements to index');
  }
}

function sumByRow(matrix) {
  let sum = newArray(matrix.rows);
  for (let i = 0; i < matrix.rows; ++i) {
    for (let j = 0; j < matrix.columns; ++j) {
      sum[i] += matrix.get(i, j);
    }
  }
  return sum;
}

function sumByColumn(matrix) {
  let sum = newArray(matrix.columns);
  for (let i = 0; i < matrix.rows; ++i) {
    for (let j = 0; j < matrix.columns; ++j) {
      sum[j] += matrix.get(i, j);
    }
  }
  return sum;
}

function sumAll(matrix) {
  let v = 0;
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      v += matrix.get(i, j);
    }
  }
  return v;
}

function productByRow(matrix) {
  let sum = newArray(matrix.rows, 1);
  for (let i = 0; i < matrix.rows; ++i) {
    for (let j = 0; j < matrix.columns; ++j) {
      sum[i] *= matrix.get(i, j);
    }
  }
  return sum;
}

function productByColumn(matrix) {
  let sum = newArray(matrix.columns, 1);
  for (let i = 0; i < matrix.rows; ++i) {
    for (let j = 0; j < matrix.columns; ++j) {
      sum[j] *= matrix.get(i, j);
    }
  }
  return sum;
}

function productAll(matrix) {
  let v = 1;
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      v *= matrix.get(i, j);
    }
  }
  return v;
}

function varianceByRow(matrix, unbiased, mean) {
  const rows = matrix.rows;
  const cols = matrix.columns;
  const variance = [];

  for (let i = 0; i < rows; i++) {
    let sum1 = 0;
    let sum2 = 0;
    let x = 0;
    for (let j = 0; j < cols; j++) {
      x = matrix.get(i, j) - mean[i];
      sum1 += x;
      sum2 += x * x;
    }
    if (unbiased) {
      variance.push((sum2 - (sum1 * sum1) / cols) / (cols - 1));
    } else {
      variance.push((sum2 - (sum1 * sum1) / cols) / cols);
    }
  }
  return variance;
}

function varianceByColumn(matrix, unbiased, mean) {
  const rows = matrix.rows;
  const cols = matrix.columns;
  const variance = [];

  for (let j = 0; j < cols; j++) {
    let sum1 = 0;
    let sum2 = 0;
    let x = 0;
    for (let i = 0; i < rows; i++) {
      x = matrix.get(i, j) - mean[j];
      sum1 += x;
      sum2 += x * x;
    }
    if (unbiased) {
      variance.push((sum2 - (sum1 * sum1) / rows) / (rows - 1));
    } else {
      variance.push((sum2 - (sum1 * sum1) / rows) / rows);
    }
  }
  return variance;
}

function varianceAll(matrix, unbiased, mean) {
  const rows = matrix.rows;
  const cols = matrix.columns;
  const size = rows * cols;

  let sum1 = 0;
  let sum2 = 0;
  let x = 0;
  for (let i = 0; i < rows; i++) {
    for (let j = 0; j < cols; j++) {
      x = matrix.get(i, j) - mean;
      sum1 += x;
      sum2 += x * x;
    }
  }
  if (unbiased) {
    return (sum2 - (sum1 * sum1) / size) / (size - 1);
  } else {
    return (sum2 - (sum1 * sum1) / size) / size;
  }
}

function centerByRow(matrix, mean) {
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      matrix.set(i, j, matrix.get(i, j) - mean[i]);
    }
  }
}

function centerByColumn(matrix, mean) {
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      matrix.set(i, j, matrix.get(i, j) - mean[j]);
    }
  }
}

function centerAll(matrix, mean) {
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      matrix.set(i, j, matrix.get(i, j) - mean);
    }
  }
}

function getScaleByRow(matrix) {
  const scale = [];
  for (let i = 0; i < matrix.rows; i++) {
    let sum = 0;
    for (let j = 0; j < matrix.columns; j++) {
      sum += matrix.get(i, j) ** 2 / (matrix.columns - 1);
    }
    scale.push(Math.sqrt(sum));
  }
  return scale;
}

function scaleByRow(matrix, scale) {
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      matrix.set(i, j, matrix.get(i, j) / scale[i]);
    }
  }
}

function getScaleByColumn(matrix) {
  const scale = [];
  for (let j = 0; j < matrix.columns; j++) {
    let sum = 0;
    for (let i = 0; i < matrix.rows; i++) {
      sum += matrix.get(i, j) ** 2 / (matrix.rows - 1);
    }
    scale.push(Math.sqrt(sum));
  }
  return scale;
}

function scaleByColumn(matrix, scale) {
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      matrix.set(i, j, matrix.get(i, j) / scale[j]);
    }
  }
}

function getScaleAll(matrix) {
  const divider = matrix.size - 1;
  let sum = 0;
  for (let j = 0; j < matrix.columns; j++) {
    for (let i = 0; i < matrix.rows; i++) {
      sum += matrix.get(i, j) ** 2 / divider;
    }
  }
  return Math.sqrt(sum);
}

function scaleAll(matrix, scale) {
  for (let i = 0; i < matrix.rows; i++) {
    for (let j = 0; j < matrix.columns; j++) {
      matrix.set(i, j, matrix.get(i, j) / scale);
    }
  }
}

class AbstractMatrix {
  static from1DArray(newRows, newColumns, newData) {
    let length = newRows * newColumns;
    if (length !== newData.length) {
      throw new RangeError('data length does not match given dimensions');
    }
    let newMatrix = new Matrix(newRows, newColumns);
    for (let row = 0; row < newRows; row++) {
      for (let column = 0; column < newColumns; column++) {
        newMatrix.set(row, column, newData[row * newColumns + column]);
      }
    }
    return newMatrix;
  }

  static rowVector(newData) {
    let vector = new Matrix(1, newData.length);
    for (let i = 0; i < newData.length; i++) {
      vector.set(0, i, newData[i]);
    }
    return vector;
  }

  static columnVector(newData) {
    let vector = new Matrix(newData.length, 1);
    for (let i = 0; i < newData.length; i++) {
      vector.set(i, 0, newData[i]);
    }
    return vector;
  }

  static zeros(rows, columns) {
    return new Matrix(rows, columns);
  }

  static ones(rows, columns) {
    return new Matrix(rows, columns).fill(1);
  }

  static rand(rows, columns, options = {}) {
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { random = Math.random } = options;
    let matrix = new Matrix(rows, columns);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < columns; j++) {
        matrix.set(i, j, random());
      }
    }
    return matrix;
  }

  static randInt(rows, columns, options = {}) {
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { min = 0, max = 1000, random = Math.random } = options;
    if (!Number.isInteger(min)) throw new TypeError('min must be an integer');
    if (!Number.isInteger(max)) throw new TypeError('max must be an integer');
    if (min >= max) throw new RangeError('min must be smaller than max');
    let interval = max - min;
    let matrix = new Matrix(rows, columns);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < columns; j++) {
        let value = min + Math.round(random() * interval);
        matrix.set(i, j, value);
      }
    }
    return matrix;
  }

  static eye(rows, columns, value) {
    if (columns === undefined) columns = rows;
    if (value === undefined) value = 1;
    let min = Math.min(rows, columns);
    let matrix = this.zeros(rows, columns);
    for (let i = 0; i < min; i++) {
      matrix.set(i, i, value);
    }
    return matrix;
  }

  static diag(data, rows, columns) {
    let l = data.length;
    if (rows === undefined) rows = l;
    if (columns === undefined) columns = rows;
    let min = Math.min(l, rows, columns);
    let matrix = this.zeros(rows, columns);
    for (let i = 0; i < min; i++) {
      matrix.set(i, i, data[i]);
    }
    return matrix;
  }

  static min(matrix1, matrix2) {
    matrix1 = this.checkMatrix(matrix1);
    matrix2 = this.checkMatrix(matrix2);
    let rows = matrix1.rows;
    let columns = matrix1.columns;
    let result = new Matrix(rows, columns);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < columns; j++) {
        result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));
      }
    }
    return result;
  }

  static max(matrix1, matrix2) {
    matrix1 = this.checkMatrix(matrix1);
    matrix2 = this.checkMatrix(matrix2);
    let rows = matrix1.rows;
    let columns = matrix1.columns;
    let result = new this(rows, columns);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < columns; j++) {
        result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));
      }
    }
    return result;
  }

  static checkMatrix(value) {
    return AbstractMatrix.isMatrix(value) ? value : new Matrix(value);
  }

  static isMatrix(value) {
    return value != null && value.klass === 'Matrix';
  }

  get size() {
    return this.rows * this.columns;
  }

  apply(callback) {
    if (typeof callback !== 'function') {
      throw new TypeError('callback must be a function');
    }
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        callback.call(this, i, j);
      }
    }
    return this;
  }

  to1DArray() {
    let array = [];
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        array.push(this.get(i, j));
      }
    }
    return array;
  }

  to2DArray() {
    let copy = [];
    for (let i = 0; i < this.rows; i++) {
      copy.push([]);
      for (let j = 0; j < this.columns; j++) {
        copy[i].push(this.get(i, j));
      }
    }
    return copy;
  }

  toJSON() {
    return this.to2DArray();
  }

  isRowVector() {
    return this.rows === 1;
  }

  isColumnVector() {
    return this.columns === 1;
  }

  isVector() {
    return this.rows === 1 || this.columns === 1;
  }

  isSquare() {
    return this.rows === this.columns;
  }

  isEmpty() {
    return this.rows === 0 || this.columns === 0;
  }

  isSymmetric() {
    if (this.isSquare()) {
      for (let i = 0; i < this.rows; i++) {
        for (let j = 0; j <= i; j++) {
          if (this.get(i, j) !== this.get(j, i)) {
            return false;
          }
        }
      }
      return true;
    }
    return false;
  }

  isDistance() {
    if (!this.isSymmetric()) return false;

    for (let i = 0; i < this.rows; i++) {
      if (this.get(i, i) !== 0) return false;
    }

    return true;
  }

  isEchelonForm() {
    let i = 0;
    let j = 0;
    let previousColumn = -1;
    let isEchelonForm = true;
    let checked = false;
    while (i < this.rows && isEchelonForm) {
      j = 0;
      checked = false;
      while (j < this.columns && checked === false) {
        if (this.get(i, j) === 0) {
          j++;
        } else if (this.get(i, j) === 1 && j > previousColumn) {
          checked = true;
          previousColumn = j;
        } else {
          isEchelonForm = false;
          checked = true;
        }
      }
      i++;
    }
    return isEchelonForm;
  }

  isReducedEchelonForm() {
    let i = 0;
    let j = 0;
    let previousColumn = -1;
    let isReducedEchelonForm = true;
    let checked = false;
    while (i < this.rows && isReducedEchelonForm) {
      j = 0;
      checked = false;
      while (j < this.columns && checked === false) {
        if (this.get(i, j) === 0) {
          j++;
        } else if (this.get(i, j) === 1 && j > previousColumn) {
          checked = true;
          previousColumn = j;
        } else {
          isReducedEchelonForm = false;
          checked = true;
        }
      }
      for (let k = j + 1; k < this.rows; k++) {
        if (this.get(i, k) !== 0) {
          isReducedEchelonForm = false;
        }
      }
      i++;
    }
    return isReducedEchelonForm;
  }

  echelonForm() {
    let result = this.clone();
    let h = 0;
    let k = 0;
    while (h < result.rows && k < result.columns) {
      let iMax = h;
      for (let i = h; i < result.rows; i++) {
        if (result.get(i, k) > result.get(iMax, k)) {
          iMax = i;
        }
      }
      if (result.get(iMax, k) === 0) {
        k++;
      } else {
        result.swapRows(h, iMax);
        let tmp = result.get(h, k);
        for (let j = k; j < result.columns; j++) {
          result.set(h, j, result.get(h, j) / tmp);
        }
        for (let i = h + 1; i < result.rows; i++) {
          let factor = result.get(i, k) / result.get(h, k);
          result.set(i, k, 0);
          for (let j = k + 1; j < result.columns; j++) {
            result.set(i, j, result.get(i, j) - result.get(h, j) * factor);
          }
        }
        h++;
        k++;
      }
    }
    return result;
  }

  reducedEchelonForm() {
    let result = this.echelonForm();
    let m = result.columns;
    let n = result.rows;
    let h = n - 1;
    while (h >= 0) {
      if (result.maxRow(h) === 0) {
        h--;
      } else {
        let p = 0;
        let pivot = false;
        while (p < n && pivot === false) {
          if (result.get(h, p) === 1) {
            pivot = true;
          } else {
            p++;
          }
        }
        for (let i = 0; i < h; i++) {
          let factor = result.get(i, p);
          for (let j = p; j < m; j++) {
            let tmp = result.get(i, j) - factor * result.get(h, j);
            result.set(i, j, tmp);
          }
        }
        h--;
      }
    }
    return result;
  }

  set() {
    throw new Error('set method is unimplemented');
  }

  get() {
    throw new Error('get method is unimplemented');
  }

  repeat(options = {}) {
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { rows = 1, columns = 1 } = options;
    if (!Number.isInteger(rows) || rows <= 0) {
      throw new TypeError('rows must be a positive integer');
    }
    if (!Number.isInteger(columns) || columns <= 0) {
      throw new TypeError('columns must be a positive integer');
    }
    let matrix = new Matrix(this.rows * rows, this.columns * columns);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < columns; j++) {
        matrix.setSubMatrix(this, this.rows * i, this.columns * j);
      }
    }
    return matrix;
  }

  fill(value) {
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, value);
      }
    }
    return this;
  }

  neg() {
    return this.mulS(-1);
  }

  getRow(index) {
    checkRowIndex(this, index);
    let row = [];
    for (let i = 0; i < this.columns; i++) {
      row.push(this.get(index, i));
    }
    return row;
  }

  getRowVector(index) {
    return Matrix.rowVector(this.getRow(index));
  }

  setRow(index, array) {
    checkRowIndex(this, index);
    array = checkRowVector(this, array);
    for (let i = 0; i < this.columns; i++) {
      this.set(index, i, array[i]);
    }
    return this;
  }

  swapRows(row1, row2) {
    checkRowIndex(this, row1);
    checkRowIndex(this, row2);
    for (let i = 0; i < this.columns; i++) {
      let temp = this.get(row1, i);
      this.set(row1, i, this.get(row2, i));
      this.set(row2, i, temp);
    }
    return this;
  }

  getColumn(index) {
    checkColumnIndex(this, index);
    let column = [];
    for (let i = 0; i < this.rows; i++) {
      column.push(this.get(i, index));
    }
    return column;
  }

  getColumnVector(index) {
    return Matrix.columnVector(this.getColumn(index));
  }

  setColumn(index, array) {
    checkColumnIndex(this, index);
    array = checkColumnVector(this, array);
    for (let i = 0; i < this.rows; i++) {
      this.set(i, index, array[i]);
    }
    return this;
  }

  swapColumns(column1, column2) {
    checkColumnIndex(this, column1);
    checkColumnIndex(this, column2);
    for (let i = 0; i < this.rows; i++) {
      let temp = this.get(i, column1);
      this.set(i, column1, this.get(i, column2));
      this.set(i, column2, temp);
    }
    return this;
  }

  addRowVector(vector) {
    vector = checkRowVector(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) + vector[j]);
      }
    }
    return this;
  }

  subRowVector(vector) {
    vector = checkRowVector(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) - vector[j]);
      }
    }
    return this;
  }

  mulRowVector(vector) {
    vector = checkRowVector(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) * vector[j]);
      }
    }
    return this;
  }

  divRowVector(vector) {
    vector = checkRowVector(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) / vector[j]);
      }
    }
    return this;
  }

  addColumnVector(vector) {
    vector = checkColumnVector(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) + vector[i]);
      }
    }
    return this;
  }

  subColumnVector(vector) {
    vector = checkColumnVector(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) - vector[i]);
      }
    }
    return this;
  }

  mulColumnVector(vector) {
    vector = checkColumnVector(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) * vector[i]);
      }
    }
    return this;
  }

  divColumnVector(vector) {
    vector = checkColumnVector(this, vector);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        this.set(i, j, this.get(i, j) / vector[i]);
      }
    }
    return this;
  }

  mulRow(index, value) {
    checkRowIndex(this, index);
    for (let i = 0; i < this.columns; i++) {
      this.set(index, i, this.get(index, i) * value);
    }
    return this;
  }

  mulColumn(index, value) {
    checkColumnIndex(this, index);
    for (let i = 0; i < this.rows; i++) {
      this.set(i, index, this.get(i, index) * value);
    }
    return this;
  }

  max(by) {
    if (this.isEmpty()) {
      return NaN;
    }
    switch (by) {
      case 'row': {
        const max = new Array(this.rows).fill(Number.NEGATIVE_INFINITY);
        for (let row = 0; row < this.rows; row++) {
          for (let column = 0; column < this.columns; column++) {
            if (this.get(row, column) > max[row]) {
              max[row] = this.get(row, column);
            }
          }
        }
        return max;
      }
      case 'column': {
        const max = new Array(this.columns).fill(Number.NEGATIVE_INFINITY);
        for (let row = 0; row < this.rows; row++) {
          for (let column = 0; column < this.columns; column++) {
            if (this.get(row, column) > max[column]) {
              max[column] = this.get(row, column);
            }
          }
        }
        return max;
      }
      case undefined: {
        let max = this.get(0, 0);
        for (let row = 0; row < this.rows; row++) {
          for (let column = 0; column < this.columns; column++) {
            if (this.get(row, column) > max) {
              max = this.get(row, column);
            }
          }
        }
        return max;
      }
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  maxIndex() {
    checkNonEmpty(this);
    let v = this.get(0, 0);
    let idx = [0, 0];
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        if (this.get(i, j) > v) {
          v = this.get(i, j);
          idx[0] = i;
          idx[1] = j;
        }
      }
    }
    return idx;
  }

  min(by) {
    if (this.isEmpty()) {
      return NaN;
    }

    switch (by) {
      case 'row': {
        const min = new Array(this.rows).fill(Number.POSITIVE_INFINITY);
        for (let row = 0; row < this.rows; row++) {
          for (let column = 0; column < this.columns; column++) {
            if (this.get(row, column) < min[row]) {
              min[row] = this.get(row, column);
            }
          }
        }
        return min;
      }
      case 'column': {
        const min = new Array(this.columns).fill(Number.POSITIVE_INFINITY);
        for (let row = 0; row < this.rows; row++) {
          for (let column = 0; column < this.columns; column++) {
            if (this.get(row, column) < min[column]) {
              min[column] = this.get(row, column);
            }
          }
        }
        return min;
      }
      case undefined: {
        let min = this.get(0, 0);
        for (let row = 0; row < this.rows; row++) {
          for (let column = 0; column < this.columns; column++) {
            if (this.get(row, column) < min) {
              min = this.get(row, column);
            }
          }
        }
        return min;
      }
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  minIndex() {
    checkNonEmpty(this);
    let v = this.get(0, 0);
    let idx = [0, 0];
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        if (this.get(i, j) < v) {
          v = this.get(i, j);
          idx[0] = i;
          idx[1] = j;
        }
      }
    }
    return idx;
  }

  maxRow(row) {
    checkRowIndex(this, row);
    if (this.isEmpty()) {
      return NaN;
    }
    let v = this.get(row, 0);
    for (let i = 1; i < this.columns; i++) {
      if (this.get(row, i) > v) {
        v = this.get(row, i);
      }
    }
    return v;
  }

  maxRowIndex(row) {
    checkRowIndex(this, row);
    checkNonEmpty(this);
    let v = this.get(row, 0);
    let idx = [row, 0];
    for (let i = 1; i < this.columns; i++) {
      if (this.get(row, i) > v) {
        v = this.get(row, i);
        idx[1] = i;
      }
    }
    return idx;
  }

  minRow(row) {
    checkRowIndex(this, row);
    if (this.isEmpty()) {
      return NaN;
    }
    let v = this.get(row, 0);
    for (let i = 1; i < this.columns; i++) {
      if (this.get(row, i) < v) {
        v = this.get(row, i);
      }
    }
    return v;
  }

  minRowIndex(row) {
    checkRowIndex(this, row);
    checkNonEmpty(this);
    let v = this.get(row, 0);
    let idx = [row, 0];
    for (let i = 1; i < this.columns; i++) {
      if (this.get(row, i) < v) {
        v = this.get(row, i);
        idx[1] = i;
      }
    }
    return idx;
  }

  maxColumn(column) {
    checkColumnIndex(this, column);
    if (this.isEmpty()) {
      return NaN;
    }
    let v = this.get(0, column);
    for (let i = 1; i < this.rows; i++) {
      if (this.get(i, column) > v) {
        v = this.get(i, column);
      }
    }
    return v;
  }

  maxColumnIndex(column) {
    checkColumnIndex(this, column);
    checkNonEmpty(this);
    let v = this.get(0, column);
    let idx = [0, column];
    for (let i = 1; i < this.rows; i++) {
      if (this.get(i, column) > v) {
        v = this.get(i, column);
        idx[0] = i;
      }
    }
    return idx;
  }

  minColumn(column) {
    checkColumnIndex(this, column);
    if (this.isEmpty()) {
      return NaN;
    }
    let v = this.get(0, column);
    for (let i = 1; i < this.rows; i++) {
      if (this.get(i, column) < v) {
        v = this.get(i, column);
      }
    }
    return v;
  }

  minColumnIndex(column) {
    checkColumnIndex(this, column);
    checkNonEmpty(this);
    let v = this.get(0, column);
    let idx = [0, column];
    for (let i = 1; i < this.rows; i++) {
      if (this.get(i, column) < v) {
        v = this.get(i, column);
        idx[0] = i;
      }
    }
    return idx;
  }

  diag() {
    let min = Math.min(this.rows, this.columns);
    let diag = [];
    for (let i = 0; i < min; i++) {
      diag.push(this.get(i, i));
    }
    return diag;
  }

  norm(type = 'frobenius') {
    switch (type) {
      case 'max':
        return this.max();
      case 'frobenius':
        return Math.sqrt(this.dot(this));
      default:
        throw new RangeError(`unknown norm type: ${type}`);
    }
  }

  cumulativeSum() {
    let sum = 0;
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        sum += this.get(i, j);
        this.set(i, j, sum);
      }
    }
    return this;
  }

  dot(vector2) {
    if (AbstractMatrix.isMatrix(vector2)) vector2 = vector2.to1DArray();
    let vector1 = this.to1DArray();
    if (vector1.length !== vector2.length) {
      throw new RangeError('vectors do not have the same size');
    }
    let dot = 0;
    for (let i = 0; i < vector1.length; i++) {
      dot += vector1[i] * vector2[i];
    }
    return dot;
  }

  mmul(other) {
    other = Matrix.checkMatrix(other);

    let m = this.rows;
    let n = this.columns;
    let p = other.columns;

    let result = new Matrix(m, p);

    let Bcolj = new Float64Array(n);
    for (let j = 0; j < p; j++) {
      for (let k = 0; k < n; k++) {
        Bcolj[k] = other.get(k, j);
      }

      for (let i = 0; i < m; i++) {
        let s = 0;
        for (let k = 0; k < n; k++) {
          s += this.get(i, k) * Bcolj[k];
        }

        result.set(i, j, s);
      }
    }
    return result;
  }

  mpow(scalar) {
    if (!this.isSquare()) {
      throw new RangeError('Matrix must be square');
    }
    if (!Number.isInteger(scalar) || scalar < 0) {
      throw new RangeError('Exponent must be a non-negative integer');
    }
    // Russian Peasant exponentiation, i.e. exponentiation by squaring
    let result = Matrix.eye(this.rows);
    let bb = this;
    // Note: Don't bit shift. In JS, that would truncate at 32 bits
    for (let e = scalar; e >= 1; e /= 2) {
      if ((e & 1) !== 0) {
        result = result.mmul(bb);
      }
      bb = bb.mmul(bb);
    }
    return result;
  }

  strassen2x2(other) {
    other = Matrix.checkMatrix(other);
    let result = new Matrix(2, 2);
    const a11 = this.get(0, 0);
    const b11 = other.get(0, 0);
    const a12 = this.get(0, 1);
    const b12 = other.get(0, 1);
    const a21 = this.get(1, 0);
    const b21 = other.get(1, 0);
    const a22 = this.get(1, 1);
    const b22 = other.get(1, 1);

    // Compute intermediate values.
    const m1 = (a11 + a22) * (b11 + b22);
    const m2 = (a21 + a22) * b11;
    const m3 = a11 * (b12 - b22);
    const m4 = a22 * (b21 - b11);
    const m5 = (a11 + a12) * b22;
    const m6 = (a21 - a11) * (b11 + b12);
    const m7 = (a12 - a22) * (b21 + b22);

    // Combine intermediate values into the output.
    const c00 = m1 + m4 - m5 + m7;
    const c01 = m3 + m5;
    const c10 = m2 + m4;
    const c11 = m1 - m2 + m3 + m6;

    result.set(0, 0, c00);
    result.set(0, 1, c01);
    result.set(1, 0, c10);
    result.set(1, 1, c11);
    return result;
  }

  strassen3x3(other) {
    other = Matrix.checkMatrix(other);
    let result = new Matrix(3, 3);

    const a00 = this.get(0, 0);
    const a01 = this.get(0, 1);
    const a02 = this.get(0, 2);
    const a10 = this.get(1, 0);
    const a11 = this.get(1, 1);
    const a12 = this.get(1, 2);
    const a20 = this.get(2, 0);
    const a21 = this.get(2, 1);
    const a22 = this.get(2, 2);

    const b00 = other.get(0, 0);
    const b01 = other.get(0, 1);
    const b02 = other.get(0, 2);
    const b10 = other.get(1, 0);
    const b11 = other.get(1, 1);
    const b12 = other.get(1, 2);
    const b20 = other.get(2, 0);
    const b21 = other.get(2, 1);
    const b22 = other.get(2, 2);

    const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;
    const m2 = (a00 - a10) * (-b01 + b11);
    const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);
    const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);
    const m5 = (a10 + a11) * (-b00 + b01);
    const m6 = a00 * b00;
    const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);
    const m8 = (-a00 + a20) * (b02 - b12);
    const m9 = (a20 + a21) * (-b00 + b02);
    const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;
    const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);
    const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);
    const m13 = (a02 - a22) * (b11 - b21);
    const m14 = a02 * b20;
    const m15 = (a21 + a22) * (-b20 + b21);
    const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);
    const m17 = (a02 - a12) * (b12 - b22);
    const m18 = (a11 + a12) * (-b20 + b22);
    const m19 = a01 * b10;
    const m20 = a12 * b21;
    const m21 = a10 * b02;
    const m22 = a20 * b01;
    const m23 = a22 * b22;

    const c00 = m6 + m14 + m19;
    const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;
    const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;
    const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;
    const c11 = m2 + m4 + m5 + m6 + m20;
    const c12 = m14 + m16 + m17 + m18 + m21;
    const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;
    const c21 = m12 + m13 + m14 + m15 + m22;
    const c22 = m6 + m7 + m8 + m9 + m23;

    result.set(0, 0, c00);
    result.set(0, 1, c01);
    result.set(0, 2, c02);
    result.set(1, 0, c10);
    result.set(1, 1, c11);
    result.set(1, 2, c12);
    result.set(2, 0, c20);
    result.set(2, 1, c21);
    result.set(2, 2, c22);
    return result;
  }

  mmulStrassen(y) {
    y = Matrix.checkMatrix(y);
    let x = this.clone();
    let r1 = x.rows;
    let c1 = x.columns;
    let r2 = y.rows;
    let c2 = y.columns;
    if (c1 !== r2) {
      // eslint-disable-next-line no-console
      console.warn(
        `Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`,
      );
    }

    // Put a matrix into the top left of a matrix of zeros.
    // `rows` and `cols` are the dimensions of the output matrix.
    function embed(mat, rows, cols) {
      let r = mat.rows;
      let c = mat.columns;
      if (r === rows && c === cols) {
        return mat;
      } else {
        let resultat = AbstractMatrix.zeros(rows, cols);
        resultat = resultat.setSubMatrix(mat, 0, 0);
        return resultat;
      }
    }

    // Make sure both matrices are the same size.
    // This is exclusively for simplicity:
    // this algorithm can be implemented with matrices of different sizes.

    let r = Math.max(r1, r2);
    let c = Math.max(c1, c2);
    x = embed(x, r, c);
    y = embed(y, r, c);

    // Our recursive multiplication function.
    function blockMult(a, b, rows, cols) {
      // For small matrices, resort to naive multiplication.
      if (rows <= 512 || cols <= 512) {
        return a.mmul(b); // a is equivalent to this
      }

      // Apply dynamic padding.
      if (rows % 2 === 1 && cols % 2 === 1) {
        a = embed(a, rows + 1, cols + 1);
        b = embed(b, rows + 1, cols + 1);
      } else if (rows % 2 === 1) {
        a = embed(a, rows + 1, cols);
        b = embed(b, rows + 1, cols);
      } else if (cols % 2 === 1) {
        a = embed(a, rows, cols + 1);
        b = embed(b, rows, cols + 1);
      }

      let halfRows = parseInt(a.rows / 2, 10);
      let halfCols = parseInt(a.columns / 2, 10);
      // Subdivide input matrices.
      let a11 = a.subMatrix(0, halfRows - 1, 0, halfCols - 1);
      let b11 = b.subMatrix(0, halfRows - 1, 0, halfCols - 1);

      let a12 = a.subMatrix(0, halfRows - 1, halfCols, a.columns - 1);
      let b12 = b.subMatrix(0, halfRows - 1, halfCols, b.columns - 1);

      let a21 = a.subMatrix(halfRows, a.rows - 1, 0, halfCols - 1);
      let b21 = b.subMatrix(halfRows, b.rows - 1, 0, halfCols - 1);

      let a22 = a.subMatrix(halfRows, a.rows - 1, halfCols, a.columns - 1);
      let b22 = b.subMatrix(halfRows, b.rows - 1, halfCols, b.columns - 1);

      // Compute intermediate values.
      let m1 = blockMult(
        AbstractMatrix.add(a11, a22),
        AbstractMatrix.add(b11, b22),
        halfRows,
        halfCols,
      );
      let m2 = blockMult(AbstractMatrix.add(a21, a22), b11, halfRows, halfCols);
      let m3 = blockMult(a11, AbstractMatrix.sub(b12, b22), halfRows, halfCols);
      let m4 = blockMult(a22, AbstractMatrix.sub(b21, b11), halfRows, halfCols);
      let m5 = blockMult(AbstractMatrix.add(a11, a12), b22, halfRows, halfCols);
      let m6 = blockMult(
        AbstractMatrix.sub(a21, a11),
        AbstractMatrix.add(b11, b12),
        halfRows,
        halfCols,
      );
      let m7 = blockMult(
        AbstractMatrix.sub(a12, a22),
        AbstractMatrix.add(b21, b22),
        halfRows,
        halfCols,
      );

      // Combine intermediate values into the output.
      let c11 = AbstractMatrix.add(m1, m4);
      c11.sub(m5);
      c11.add(m7);
      let c12 = AbstractMatrix.add(m3, m5);
      let c21 = AbstractMatrix.add(m2, m4);
      let c22 = AbstractMatrix.sub(m1, m2);
      c22.add(m3);
      c22.add(m6);

      // Crop output to the desired size (undo dynamic padding).
      let result = AbstractMatrix.zeros(2 * c11.rows, 2 * c11.columns);
      result = result.setSubMatrix(c11, 0, 0);
      result = result.setSubMatrix(c12, c11.rows, 0);
      result = result.setSubMatrix(c21, 0, c11.columns);
      result = result.setSubMatrix(c22, c11.rows, c11.columns);
      return result.subMatrix(0, rows - 1, 0, cols - 1);
    }

    return blockMult(x, y, r, c);
  }

  scaleRows(options = {}) {
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { min = 0, max = 1 } = options;
    if (!Number.isFinite(min)) throw new TypeError('min must be a number');
    if (!Number.isFinite(max)) throw new TypeError('max must be a number');
    if (min >= max) throw new RangeError('min must be smaller than max');
    let newMatrix = new Matrix(this.rows, this.columns);
    for (let i = 0; i < this.rows; i++) {
      const row = this.getRow(i);
      if (row.length > 0) {
        rescale(row, { min, max, output: row });
      }
      newMatrix.setRow(i, row);
    }
    return newMatrix;
  }

  scaleColumns(options = {}) {
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { min = 0, max = 1 } = options;
    if (!Number.isFinite(min)) throw new TypeError('min must be a number');
    if (!Number.isFinite(max)) throw new TypeError('max must be a number');
    if (min >= max) throw new RangeError('min must be smaller than max');
    let newMatrix = new Matrix(this.rows, this.columns);
    for (let i = 0; i < this.columns; i++) {
      const column = this.getColumn(i);
      if (column.length) {
        rescale(column, {
          min,
          max,
          output: column,
        });
      }
      newMatrix.setColumn(i, column);
    }
    return newMatrix;
  }

  flipRows() {
    const middle = Math.ceil(this.columns / 2);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < middle; j++) {
        let first = this.get(i, j);
        let last = this.get(i, this.columns - 1 - j);
        this.set(i, j, last);
        this.set(i, this.columns - 1 - j, first);
      }
    }
    return this;
  }

  flipColumns() {
    const middle = Math.ceil(this.rows / 2);
    for (let j = 0; j < this.columns; j++) {
      for (let i = 0; i < middle; i++) {
        let first = this.get(i, j);
        let last = this.get(this.rows - 1 - i, j);
        this.set(i, j, last);
        this.set(this.rows - 1 - i, j, first);
      }
    }
    return this;
  }

  kroneckerProduct(other) {
    other = Matrix.checkMatrix(other);

    let m = this.rows;
    let n = this.columns;
    let p = other.rows;
    let q = other.columns;

    let result = new Matrix(m * p, n * q);
    for (let i = 0; i < m; i++) {
      for (let j = 0; j < n; j++) {
        for (let k = 0; k < p; k++) {
          for (let l = 0; l < q; l++) {
            result.set(p * i + k, q * j + l, this.get(i, j) * other.get(k, l));
          }
        }
      }
    }
    return result;
  }

  kroneckerSum(other) {
    other = Matrix.checkMatrix(other);
    if (!this.isSquare() || !other.isSquare()) {
      throw new Error('Kronecker Sum needs two Square Matrices');
    }
    let m = this.rows;
    let n = other.rows;
    let AxI = this.kroneckerProduct(Matrix.eye(n, n));
    let IxB = Matrix.eye(m, m).kroneckerProduct(other);
    return AxI.add(IxB);
  }

  transpose() {
    let result = new Matrix(this.columns, this.rows);
    for (let i = 0; i < this.rows; i++) {
      for (let j = 0; j < this.columns; j++) {
        result.set(j, i, this.get(i, j));
      }
    }
    return result;
  }

  sortRows(compareFunction = compareNumbers) {
    for (let i = 0; i < this.rows; i++) {
      this.setRow(i, this.getRow(i).sort(compareFunction));
    }
    return this;
  }

  sortColumns(compareFunction = compareNumbers) {
    for (let i = 0; i < this.columns; i++) {
      this.setColumn(i, this.getColumn(i).sort(compareFunction));
    }
    return this;
  }

  subMatrix(startRow, endRow, startColumn, endColumn) {
    checkRange(this, startRow, endRow, startColumn, endColumn);
    let newMatrix = new Matrix(
      endRow - startRow + 1,
      endColumn - startColumn + 1,
    );
    for (let i = startRow; i <= endRow; i++) {
      for (let j = startColumn; j <= endColumn; j++) {
        newMatrix.set(i - startRow, j - startColumn, this.get(i, j));
      }
    }
    return newMatrix;
  }

  subMatrixRow(indices, startColumn, endColumn) {
    if (startColumn === undefined) startColumn = 0;
    if (endColumn === undefined) endColumn = this.columns - 1;
    if (
      startColumn > endColumn ||
      startColumn < 0 ||
      startColumn >= this.columns ||
      endColumn < 0 ||
      endColumn >= this.columns
    ) {
      throw new RangeError('Argument out of range');
    }

    let newMatrix = new Matrix(indices.length, endColumn - startColumn + 1);
    for (let i = 0; i < indices.length; i++) {
      for (let j = startColumn; j <= endColumn; j++) {
        if (indices[i] < 0 || indices[i] >= this.rows) {
          throw new RangeError(`Row index out of range: ${indices[i]}`);
        }
        newMatrix.set(i, j - startColumn, this.get(indices[i], j));
      }
    }
    return newMatrix;
  }

  subMatrixColumn(indices, startRow, endRow) {
    if (startRow === undefined) startRow = 0;
    if (endRow === undefined) endRow = this.rows - 1;
    if (
      startRow > endRow ||
      startRow < 0 ||
      startRow >= this.rows ||
      endRow < 0 ||
      endRow >= this.rows
    ) {
      throw new RangeError('Argument out of range');
    }

    let newMatrix = new Matrix(endRow - startRow + 1, indices.length);
    for (let i = 0; i < indices.length; i++) {
      for (let j = startRow; j <= endRow; j++) {
        if (indices[i] < 0 || indices[i] >= this.columns) {
          throw new RangeError(`Column index out of range: ${indices[i]}`);
        }
        newMatrix.set(j - startRow, i, this.get(j, indices[i]));
      }
    }
    return newMatrix;
  }

  setSubMatrix(matrix, startRow, startColumn) {
    matrix = Matrix.checkMatrix(matrix);
    if (matrix.isEmpty()) {
      return this;
    }
    let endRow = startRow + matrix.rows - 1;
    let endColumn = startColumn + matrix.columns - 1;
    checkRange(this, startRow, endRow, startColumn, endColumn);
    for (let i = 0; i < matrix.rows; i++) {
      for (let j = 0; j < matrix.columns; j++) {
        this.set(startRow + i, startColumn + j, matrix.get(i, j));
      }
    }
    return this;
  }

  selection(rowIndices, columnIndices) {
    checkRowIndices(this, rowIndices);
    checkColumnIndices(this, columnIndices);
    let newMatrix = new Matrix(rowIndices.length, columnIndices.length);
    for (let i = 0; i < rowIndices.length; i++) {
      let rowIndex = rowIndices[i];
      for (let j = 0; j < columnIndices.length; j++) {
        let columnIndex = columnIndices[j];
        newMatrix.set(i, j, this.get(rowIndex, columnIndex));
      }
    }
    return newMatrix;
  }

  trace() {
    let min = Math.min(this.rows, this.columns);
    let trace = 0;
    for (let i = 0; i < min; i++) {
      trace += this.get(i, i);
    }
    return trace;
  }

  clone() {
    return this.constructor.copy(this, new Matrix(this.rows, this.columns));
  }

  /**
   * @template {AbstractMatrix} M
   * @param {AbstractMatrix} from
   * @param {M} to
   * @return {M}
   */
  static copy(from, to) {
    for (const [row, column, value] of from.entries()) {
      to.set(row, column, value);
    }

    return to;
  }

  sum(by) {
    switch (by) {
      case 'row':
        return sumByRow(this);
      case 'column':
        return sumByColumn(this);
      case undefined:
        return sumAll(this);
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  product(by) {
    switch (by) {
      case 'row':
        return productByRow(this);
      case 'column':
        return productByColumn(this);
      case undefined:
        return productAll(this);
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  mean(by) {
    const sum = this.sum(by);
    switch (by) {
      case 'row': {
        for (let i = 0; i < this.rows; i++) {
          sum[i] /= this.columns;
        }
        return sum;
      }
      case 'column': {
        for (let i = 0; i < this.columns; i++) {
          sum[i] /= this.rows;
        }
        return sum;
      }
      case undefined:
        return sum / this.size;
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  variance(by, options = {}) {
    if (typeof by === 'object') {
      options = by;
      by = undefined;
    }
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { unbiased = true, mean = this.mean(by) } = options;
    if (typeof unbiased !== 'boolean') {
      throw new TypeError('unbiased must be a boolean');
    }
    switch (by) {
      case 'row': {
        if (!isAnyArray.isAnyArray(mean)) {
          throw new TypeError('mean must be an array');
        }
        return varianceByRow(this, unbiased, mean);
      }
      case 'column': {
        if (!isAnyArray.isAnyArray(mean)) {
          throw new TypeError('mean must be an array');
        }
        return varianceByColumn(this, unbiased, mean);
      }
      case undefined: {
        if (typeof mean !== 'number') {
          throw new TypeError('mean must be a number');
        }
        return varianceAll(this, unbiased, mean);
      }
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  standardDeviation(by, options) {
    if (typeof by === 'object') {
      options = by;
      by = undefined;
    }
    const variance = this.variance(by, options);
    if (by === undefined) {
      return Math.sqrt(variance);
    } else {
      for (let i = 0; i < variance.length; i++) {
        variance[i] = Math.sqrt(variance[i]);
      }
      return variance;
    }
  }

  center(by, options = {}) {
    if (typeof by === 'object') {
      options = by;
      by = undefined;
    }
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    const { center = this.mean(by) } = options;
    switch (by) {
      case 'row': {
        if (!isAnyArray.isAnyArray(center)) {
          throw new TypeError('center must be an array');
        }
        centerByRow(this, center);
        return this;
      }
      case 'column': {
        if (!isAnyArray.isAnyArray(center)) {
          throw new TypeError('center must be an array');
        }
        centerByColumn(this, center);
        return this;
      }
      case undefined: {
        if (typeof center !== 'number') {
          throw new TypeError('center must be a number');
        }
        centerAll(this, center);
        return this;
      }
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  scale(by, options = {}) {
    if (typeof by === 'object') {
      options = by;
      by = undefined;
    }
    if (typeof options !== 'object') {
      throw new TypeError('options must be an object');
    }
    let scale = options.scale;
    switch (by) {
      case 'row': {
        if (scale === undefined) {
          scale = getScaleByRow(this);
        } else if (!isAnyArray.isAnyArray(scale)) {
          throw new TypeError('scale must be an array');
        }
        scaleByRow(this, scale);
        return this;
      }
      case 'column': {
        if (scale === undefined) {
          scale = getScaleByColumn(this);
        } else if (!isAnyArray.isAnyArray(scale)) {
          throw new TypeError('scale must be an array');
        }
        scaleByColumn(this, scale);
        return this;
      }
      case undefined: {
        if (scale === undefined) {
          scale = getScaleAll(this);
        } else if (typeof scale !== 'number') {
          throw new TypeError('scale must be a number');
        }
        scaleAll(this, scale);
        return this;
      }
      default:
        throw new Error(`invalid option: ${by}`);
    }
  }

  toString(options) {
    return inspectMatrixWithOptions(this, options);
  }

  [Symbol.iterator]() {
    return this.entries();
  }

  /**
   * iterator from left to right, from top to bottom
   * yield [row, column, value]
   * @returns {Generator<[number, number, number], void, void>}
   */
  *entries() {
    for (let row = 0; row < this.rows; row++) {
      for (let col = 0; col < this.columns; col++) {
        yield [row, col, this.get(row, col)];
      }
    }
  }

  /**
   * iterator from left to right, from top to bottom
   * yield value
   * @returns {Generator<number, void, void>}
   */
  *values() {
    for (let row = 0; row < this.rows; row++) {
      for (let col = 0; col < this.columns; col++) {
        yield this.get(row, col);
      }
    }
  }
}

AbstractMatrix.prototype.klass = 'Matrix';
if (typeof Symbol !== 'undefined') {
  AbstractMatrix.prototype[Symbol.for('nodejs.util.inspect.custom')] =
    inspectMatrix;
}

function compareNumbers(a, b) {
  return a - b;
}

function isArrayOfNumbers(array) {
  return array.every((element) => {
    return typeof element === 'number';
  });
}

// Synonyms
AbstractMatrix.random = AbstractMatrix.rand;
AbstractMatrix.randomInt = AbstractMatrix.randInt;
AbstractMatrix.diagonal = AbstractMatrix.diag;
AbstractMatrix.prototype.diagonal = AbstractMatrix.prototype.diag;
AbstractMatrix.identity = AbstractMatrix.eye;
AbstractMatrix.prototype.negate = AbstractMatrix.prototype.neg;
AbstractMatrix.prototype.tensorProduct =
  AbstractMatrix.prototype.kroneckerProduct;

class Matrix extends AbstractMatrix {
  /**
   * @type {Float64Array[]}
   */
  data;

  /**
   * Init an empty matrix
   * @param {number} nRows
   * @param {number} nColumns
   */
  #initData(nRows, nColumns) {
    this.data = [];

    if (Number.isInteger(nColumns) && nColumns >= 0) {
      for (let i = 0; i < nRows; i++) {
        this.data.push(new Float64Array(nColumns));
      }
    } else {
      throw new TypeError('nColumns must be a positive integer');
    }

    this.rows = nRows;
    this.columns = nColumns;
  }

  constructor(nRows, nColumns) {
    super();
    if (Matrix.isMatrix(nRows)) {
      this.#initData(nRows.rows, nRows.columns);
      Matrix.copy(nRows, this);
    } else if (Number.isInteger(nRows) && nRows >= 0) {
      this.#initData(nRows, nColumns);
    } else if (isAnyArray.isAnyArray(nRows)) {
      // Copy the values from the 2D array
      const arrayData = nRows;
      nRows = arrayData.length;
      nColumns = nRows ? arrayData[0].length : 0;
      if (typeof nColumns !== 'number') {
        throw new TypeError(
          'Data must be a 2D array with at least one element',
        );
      }
      this.data = [];

      for (let i = 0; i < nRows; i++) {
        if (arrayData[i].length !== nColumns) {
          throw new RangeError('Inconsistent array dimensions');
        }
        if (!isArrayOfNumbers(arrayData[i])) {
          throw new TypeError('Input data contains non-numeric values');
        }
        this.data.push(Float64Array.from(arrayData[i]));
      }

      this.rows = nRows;
      this.columns = nColumns;
    } else {
      throw new TypeError(
        'First argument must be a positive number or an array',
      );
    }
  }

  set(rowIndex, columnIndex, value) {
    this.data[rowIndex][columnIndex] = value;
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.data[rowIndex][columnIndex];
  }

  removeRow(index) {
    checkRowIndex(this, index);
    this.data.splice(index, 1);
    this.rows -= 1;
    return this;
  }

  addRow(index, array) {
    if (array === undefined) {
      array = index;
      index = this.rows;
    }
    checkRowIndex(this, index, true);
    array = Float64Array.from(checkRowVector(this, array));
    this.data.splice(index, 0, array);
    this.rows += 1;
    return this;
  }

  removeColumn(index) {
    checkColumnIndex(this, index);
    for (let i = 0; i < this.rows; i++) {
      const newRow = new Float64Array(this.columns - 1);
      for (let j = 0; j < index; j++) {
        newRow[j] = this.data[i][j];
      }
      for (let j = index + 1; j < this.columns; j++) {
        newRow[j - 1] = this.data[i][j];
      }
      this.data[i] = newRow;
    }
    this.columns -= 1;
    return this;
  }

  addColumn(index, array) {
    if (typeof array === 'undefined') {
      array = index;
      index = this.columns;
    }
    checkColumnIndex(this, index, true);
    array = checkColumnVector(this, array);
    for (let i = 0; i < this.rows; i++) {
      const newRow = new Float64Array(this.columns + 1);
      let j = 0;
      for (; j < index; j++) {
        newRow[j] = this.data[i][j];
      }
      newRow[j++] = array[i];
      for (; j < this.columns + 1; j++) {
        newRow[j] = this.data[i][j - 1];
      }
      this.data[i] = newRow;
    }
    this.columns += 1;
    return this;
  }
}

installMathOperations(AbstractMatrix, Matrix);

/**
 * @typedef {0 | 1 | number | boolean} Mask
 */

class SymmetricMatrix extends AbstractMatrix {
  /** @type {Matrix} */
  #matrix;

  get size() {
    return this.#matrix.size;
  }

  get rows() {
    return this.#matrix.rows;
  }

  get columns() {
    return this.#matrix.columns;
  }

  get diagonalSize() {
    return this.rows;
  }

  /**
   * not the same as matrix.isSymmetric()
   * Here is to check if it's instanceof SymmetricMatrix without bundling issues
   *
   * @param value
   * @returns {boolean}
   */
  static isSymmetricMatrix(value) {
    return Matrix.isMatrix(value) && value.klassType === 'SymmetricMatrix';
  }

  /**
   * @param diagonalSize
   * @return {SymmetricMatrix}
   */
  static zeros(diagonalSize) {
    return new this(diagonalSize);
  }

  /**
   * @param diagonalSize
   * @return {SymmetricMatrix}
   */
  static ones(diagonalSize) {
    return new this(diagonalSize).fill(1);
  }

  /**
   * @param {number | AbstractMatrix | ArrayLike<ArrayLike<number>>} diagonalSize
   * @return {this}
   */
  constructor(diagonalSize) {
    super();

    if (Matrix.isMatrix(diagonalSize)) {
      if (!diagonalSize.isSymmetric()) {
        throw new TypeError('not symmetric data');
      }

      this.#matrix = Matrix.copy(
        diagonalSize,
        new Matrix(diagonalSize.rows, diagonalSize.rows),
      );
    } else if (Number.isInteger(diagonalSize) && diagonalSize >= 0) {
      this.#matrix = new Matrix(diagonalSize, diagonalSize);
    } else {
      this.#matrix = new Matrix(diagonalSize);

      if (!this.isSymmetric()) {
        throw new TypeError('not symmetric data');
      }
    }
  }

  clone() {
    const matrix = new SymmetricMatrix(this.diagonalSize);

    for (const [row, col, value] of this.upperRightEntries()) {
      matrix.set(row, col, value);
    }

    return matrix;
  }

  toMatrix() {
    return new Matrix(this);
  }

  get(rowIndex, columnIndex) {
    return this.#matrix.get(rowIndex, columnIndex);
  }
  set(rowIndex, columnIndex, value) {
    // symmetric set
    this.#matrix.set(rowIndex, columnIndex, value);
    this.#matrix.set(columnIndex, rowIndex, value);

    return this;
  }

  removeCross(index) {
    // symmetric remove side
    this.#matrix.removeRow(index);
    this.#matrix.removeColumn(index);

    return this;
  }

  addCross(index, array) {
    if (array === undefined) {
      array = index;
      index = this.diagonalSize;
    }

    const row = array.slice();
    row.splice(index, 1);

    this.#matrix.addRow(index, row);
    this.#matrix.addColumn(index, array);

    return this;
  }

  /**
   * @param {Mask[]} mask
   */
  applyMask(mask) {
    if (mask.length !== this.diagonalSize) {
      throw new RangeError('Mask size do not match with matrix size');
    }

    // prepare sides to remove from matrix from mask
    /** @type {number[]} */
    const sidesToRemove = [];
    for (const [index, passthroughs] of mask.entries()) {
      if (passthroughs) continue;
      sidesToRemove.push(index);
    }
    // to remove from highest to lowest for no mutation shifting
    sidesToRemove.reverse();

    // remove sides
    for (const sideIndex of sidesToRemove) {
      this.removeCross(sideIndex);
    }

    return this;
  }

  /**
   * Compact format upper-right corner of matrix
   * iterate from left to right, from top to bottom.
   *
   * ```
   *   A B C D
   * A 1 2 3 4
   * B 2 5 6 7
   * C 3 6 8 9
   * D 4 7 9 10
   * ```
   *
   * will return compact 1D array `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`
   *
   * length is S(i=0, n=sideSize) => 10 for a 4 sideSized matrix
   *
   * @returns {number[]}
   */
  toCompact() {
    const { diagonalSize } = this;

    /** @type {number[]} */
    const compact = new Array((diagonalSize * (diagonalSize + 1)) / 2);
    for (let col = 0, row = 0, index = 0; index < compact.length; index++) {
      compact[index] = this.get(row, col);

      if (++col >= diagonalSize) col = ++row;
    }

    return compact;
  }

  /**
   * @param {number[]} compact
   * @return {SymmetricMatrix}
   */
  static fromCompact(compact) {
    const compactSize = compact.length;
    // compactSize = (sideSize * (sideSize + 1)) / 2
    // https://mathsolver.microsoft.com/fr/solve-problem/y%20%3D%20%20x%20%60cdot%20%20%20%60frac%7B%20%20%60left(%20x%2B1%20%20%60right)%20%20%20%20%7D%7B%202%20%20%7D
    // sideSize = (Sqrt(8 × compactSize + 1) - 1) / 2
    const diagonalSize = (Math.sqrt(8 * compactSize + 1) - 1) / 2;

    if (!Number.isInteger(diagonalSize)) {
      throw new TypeError(
        `This array is not a compact representation of a Symmetric Matrix, ${JSON.stringify(
          compact,
        )}`,
      );
    }

    const matrix = new SymmetricMatrix(diagonalSize);
    for (let col = 0, row = 0, index = 0; index < compactSize; index++) {
      matrix.set(col, row, compact[index]);
      if (++col >= diagonalSize) col = ++row;
    }

    return matrix;
  }

  /**
   * half iterator upper-right-corner from left to right, from top to bottom
   * yield [row, column, value]
   *
   * @returns {Generator<[number, number, number], void, void>}
   */
  *upperRightEntries() {
    for (let row = 0, col = 0; row < this.diagonalSize; void 0) {
      const value = this.get(row, col);

      yield [row, col, value];

      // at the end of row, move cursor to next row at diagonal position
      if (++col >= this.diagonalSize) col = ++row;
    }
  }

  /**
   * half iterator upper-right-corner from left to right, from top to bottom
   * yield value
   *
   * @returns {Generator<[number, number, number], void, void>}
   */
  *upperRightValues() {
    for (let row = 0, col = 0; row < this.diagonalSize; void 0) {
      const value = this.get(row, col);

      yield value;

      // at the end of row, move cursor to next row at diagonal position
      if (++col >= this.diagonalSize) col = ++row;
    }
  }
}
SymmetricMatrix.prototype.klassType = 'SymmetricMatrix';

class DistanceMatrix extends SymmetricMatrix {
  /**
   * not the same as matrix.isSymmetric()
   * Here is to check if it's instanceof SymmetricMatrix without bundling issues
   *
   * @param value
   * @returns {boolean}
   */
  static isDistanceMatrix(value) {
    return (
      SymmetricMatrix.isSymmetricMatrix(value) &&
      value.klassSubType === 'DistanceMatrix'
    );
  }

  constructor(sideSize) {
    super(sideSize);

    if (!this.isDistance()) {
      throw new TypeError('Provided arguments do no produce a distance matrix');
    }
  }

  set(rowIndex, columnIndex, value) {
    // distance matrix diagonal is 0
    if (rowIndex === columnIndex) value = 0;

    return super.set(rowIndex, columnIndex, value);
  }

  addCross(index, array) {
    if (array === undefined) {
      array = index;
      index = this.diagonalSize;
    }

    // ensure distance
    array = array.slice();
    array[index] = 0;

    return super.addCross(index, array);
  }

  toSymmetricMatrix() {
    return new SymmetricMatrix(this);
  }

  clone() {
    const matrix = new DistanceMatrix(this.diagonalSize);

    for (const [row, col, value] of this.upperRightEntries()) {
      if (row === col) continue;
      matrix.set(row, col, value);
    }

    return matrix;
  }

  /**
   * Compact format upper-right corner of matrix
   * no diagonal (only zeros)
   * iterable from left to right, from top to bottom.
   *
   * ```
   *   A B C D
   * A 0 1 2 3
   * B 1 0 4 5
   * C 2 4 0 6
   * D 3 5 6 0
   * ```
   *
   * will return compact 1D array `[1, 2, 3, 4, 5, 6]`
   *
   * length is S(i=0, n=sideSize-1) => 6 for a 4 side sized matrix
   *
   * @returns {number[]}
   */
  toCompact() {
    const { diagonalSize } = this;
    const compactLength = ((diagonalSize - 1) * diagonalSize) / 2;

    /** @type {number[]} */
    const compact = new Array(compactLength);
    for (let col = 1, row = 0, index = 0; index < compact.length; index++) {
      compact[index] = this.get(row, col);

      if (++col >= diagonalSize) col = ++row + 1;
    }

    return compact;
  }

  /**
   * @param {number[]} compact
   */
  static fromCompact(compact) {
    const compactSize = compact.length;

    if (compactSize === 0) {
      return new this(0);
    }

    // compactSize in Natural integer range ]0;∞]
    // compactSize = (sideSize * (sideSize - 1)) / 2
    // sideSize = (Sqrt(8 × compactSize + 1) + 1) / 2
    const diagonalSize = (Math.sqrt(8 * compactSize + 1) + 1) / 2;

    if (!Number.isInteger(diagonalSize)) {
      throw new TypeError(
        `This array is not a compact representation of a DistanceMatrix, ${JSON.stringify(
          compact,
        )}`,
      );
    }

    const matrix = new this(diagonalSize);
    for (let col = 1, row = 0, index = 0; index < compactSize; index++) {
      matrix.set(col, row, compact[index]);
      if (++col >= diagonalSize) col = ++row + 1;
    }

    return matrix;
  }
}
DistanceMatrix.prototype.klassSubType = 'DistanceMatrix';

class BaseView extends AbstractMatrix {
  constructor(matrix, rows, columns) {
    super();
    this.matrix = matrix;
    this.rows = rows;
    this.columns = columns;
  }
}

class MatrixColumnView extends BaseView {
  constructor(matrix, column) {
    checkColumnIndex(matrix, column);
    super(matrix, matrix.rows, 1);
    this.column = column;
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(rowIndex, this.column, value);
    return this;
  }

  get(rowIndex) {
    return this.matrix.get(rowIndex, this.column);
  }
}

class MatrixColumnSelectionView extends BaseView {
  constructor(matrix, columnIndices) {
    checkColumnIndices(matrix, columnIndices);
    super(matrix, matrix.rows, columnIndices.length);
    this.columnIndices = columnIndices;
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(rowIndex, this.columnIndices[columnIndex], value);
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.matrix.get(rowIndex, this.columnIndices[columnIndex]);
  }
}

class MatrixFlipColumnView extends BaseView {
  constructor(matrix) {
    super(matrix, matrix.rows, matrix.columns);
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(rowIndex, this.columns - columnIndex - 1, value);
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.matrix.get(rowIndex, this.columns - columnIndex - 1);
  }
}

class MatrixFlipRowView extends BaseView {
  constructor(matrix) {
    super(matrix, matrix.rows, matrix.columns);
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(this.rows - rowIndex - 1, columnIndex, value);
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.matrix.get(this.rows - rowIndex - 1, columnIndex);
  }
}

class MatrixRowView extends BaseView {
  constructor(matrix, row) {
    checkRowIndex(matrix, row);
    super(matrix, 1, matrix.columns);
    this.row = row;
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(this.row, columnIndex, value);
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.matrix.get(this.row, columnIndex);
  }
}

class MatrixRowSelectionView extends BaseView {
  constructor(matrix, rowIndices) {
    checkRowIndices(matrix, rowIndices);
    super(matrix, rowIndices.length, matrix.columns);
    this.rowIndices = rowIndices;
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(this.rowIndices[rowIndex], columnIndex, value);
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.matrix.get(this.rowIndices[rowIndex], columnIndex);
  }
}

class MatrixSelectionView extends BaseView {
  constructor(matrix, rowIndices, columnIndices) {
    checkRowIndices(matrix, rowIndices);
    checkColumnIndices(matrix, columnIndices);
    super(matrix, rowIndices.length, columnIndices.length);
    this.rowIndices = rowIndices;
    this.columnIndices = columnIndices;
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(
      this.rowIndices[rowIndex],
      this.columnIndices[columnIndex],
      value,
    );
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.matrix.get(
      this.rowIndices[rowIndex],
      this.columnIndices[columnIndex],
    );
  }
}

class MatrixSubView extends BaseView {
  constructor(matrix, startRow, endRow, startColumn, endColumn) {
    checkRange(matrix, startRow, endRow, startColumn, endColumn);
    super(matrix, endRow - startRow + 1, endColumn - startColumn + 1);
    this.startRow = startRow;
    this.startColumn = startColumn;
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(
      this.startRow + rowIndex,
      this.startColumn + columnIndex,
      value,
    );
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.matrix.get(
      this.startRow + rowIndex,
      this.startColumn + columnIndex,
    );
  }
}

class MatrixTransposeView extends BaseView {
  constructor(matrix) {
    super(matrix, matrix.columns, matrix.rows);
  }

  set(rowIndex, columnIndex, value) {
    this.matrix.set(columnIndex, rowIndex, value);
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.matrix.get(columnIndex, rowIndex);
  }
}

class WrapperMatrix1D extends AbstractMatrix {
  constructor(data, options = {}) {
    const { rows = 1 } = options;

    if (data.length % rows !== 0) {
      throw new Error('the data length is not divisible by the number of rows');
    }
    super();
    this.rows = rows;
    this.columns = data.length / rows;
    this.data = data;
  }

  set(rowIndex, columnIndex, value) {
    let index = this._calculateIndex(rowIndex, columnIndex);
    this.data[index] = value;
    return this;
  }

  get(rowIndex, columnIndex) {
    let index = this._calculateIndex(rowIndex, columnIndex);
    return this.data[index];
  }

  _calculateIndex(row, column) {
    return row * this.columns + column;
  }
}

class WrapperMatrix2D extends AbstractMatrix {
  constructor(data) {
    super();
    this.data = data;
    this.rows = data.length;
    this.columns = data[0].length;
  }

  set(rowIndex, columnIndex, value) {
    this.data[rowIndex][columnIndex] = value;
    return this;
  }

  get(rowIndex, columnIndex) {
    return this.data[rowIndex][columnIndex];
  }
}

function wrap(array, options) {
  if (isAnyArray.isAnyArray(array)) {
    if (array[0] && isAnyArray.isAnyArray(array[0])) {
      return new WrapperMatrix2D(array);
    } else {
      return new WrapperMatrix1D(array, options);
    }
  } else {
    throw new Error('the argument is not an array');
  }
}

class LuDecomposition {
  constructor(matrix) {
    matrix = WrapperMatrix2D.checkMatrix(matrix);

    let lu = matrix.clone();
    let rows = lu.rows;
    let columns = lu.columns;
    let pivotVector = new Float64Array(rows);
    let pivotSign = 1;
    let i, j, k, p, s, t, v;
    let LUcolj, kmax;

    for (i = 0; i < rows; i++) {
      pivotVector[i] = i;
    }

    LUcolj = new Float64Array(rows);

    for (j = 0; j < columns; j++) {
      for (i = 0; i < rows; i++) {
        LUcolj[i] = lu.get(i, j);
      }

      for (i = 0; i < rows; i++) {
        kmax = Math.min(i, j);
        s = 0;
        for (k = 0; k < kmax; k++) {
          s += lu.get(i, k) * LUcolj[k];
        }
        LUcolj[i] -= s;
        lu.set(i, j, LUcolj[i]);
      }

      p = j;
      for (i = j + 1; i < rows; i++) {
        if (Math.abs(LUcolj[i]) > Math.abs(LUcolj[p])) {
          p = i;
        }
      }

      if (p !== j) {
        for (k = 0; k < columns; k++) {
          t = lu.get(p, k);
          lu.set(p, k, lu.get(j, k));
          lu.set(j, k, t);
        }

        v = pivotVector[p];
        pivotVector[p] = pivotVector[j];
        pivotVector[j] = v;

        pivotSign = -pivotSign;
      }

      if (j < rows && lu.get(j, j) !== 0) {
        for (i = j + 1; i < rows; i++) {
          lu.set(i, j, lu.get(i, j) / lu.get(j, j));
        }
      }
    }

    this.LU = lu;
    this.pivotVector = pivotVector;
    this.pivotSign = pivotSign;
  }

  isSingular() {
    let data = this.LU;
    let col = data.columns;
    for (let j = 0; j < col; j++) {
      if (data.get(j, j) === 0) {
        return true;
      }
    }
    return false;
  }

  solve(value) {
    value = Matrix.checkMatrix(value);

    let lu = this.LU;
    let rows = lu.rows;

    if (rows !== value.rows) {
      throw new Error('Invalid matrix dimensions');
    }
    if (this.isSingular()) {
      throw new Error('LU matrix is singular');
    }

    let count = value.columns;
    let X = value.subMatrixRow(this.pivotVector, 0, count - 1);
    let columns = lu.columns;
    let i, j, k;

    for (k = 0; k < columns; k++) {
      for (i = k + 1; i < columns; i++) {
        for (j = 0; j < count; j++) {
          X.set(i, j, X.get(i, j) - X.get(k, j) * lu.get(i, k));
        }
      }
    }
    for (k = columns - 1; k >= 0; k--) {
      for (j = 0; j < count; j++) {
        X.set(k, j, X.get(k, j) / lu.get(k, k));
      }
      for (i = 0; i < k; i++) {
        for (j = 0; j < count; j++) {
          X.set(i, j, X.get(i, j) - X.get(k, j) * lu.get(i, k));
        }
      }
    }
    return X;
  }

  get determinant() {
    let data = this.LU;
    if (!data.isSquare()) {
      throw new Error('Matrix must be square');
    }
    let determinant = this.pivotSign;
    let col = data.columns;
    for (let j = 0; j < col; j++) {
      determinant *= data.get(j, j);
    }
    return determinant;
  }

  get lowerTriangularMatrix() {
    let data = this.LU;
    let rows = data.rows;
    let columns = data.columns;
    let X = new Matrix(rows, columns);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < columns; j++) {
        if (i > j) {
          X.set(i, j, data.get(i, j));
        } else if (i === j) {
          X.set(i, j, 1);
        } else {
          X.set(i, j, 0);
        }
      }
    }
    return X;
  }

  get upperTriangularMatrix() {
    let data = this.LU;
    let rows = data.rows;
    let columns = data.columns;
    let X = new Matrix(rows, columns);
    for (let i = 0; i < rows; i++) {
      for (let j = 0; j < columns; j++) {
        if (i <= j) {
          X.set(i, j, data.get(i, j));
        } else {
          X.set(i, j, 0);
        }
      }
    }
    return X;
  }

  get pivotPermutationVector() {
    return Array.from(this.pivotVector);
  }
}

function hypotenuse(a, b) {
  let r = 0;
  if (Math.abs(a) > Math.abs(b)) {
    r = b / a;
    return Math.abs(a) * Math.sqrt(1 + r * r);
  }
  if (b !== 0) {
    r = a / b;
    return Math.abs(b) * Math.sqrt(1 + r * r);
  }
  return 0;
}

class QrDecomposition {
  constructor(value) {
    value = WrapperMatrix2D.checkMatrix(value);

    let qr = value.clone();
    let m = value.rows;
    let n = value.columns;
    let rdiag = new Float64Array(n);
    let i, j, k, s;

    for (k = 0; k < n; k++) {
      let nrm = 0;
      for (i = k; i < m; i++) {
        nrm = hypotenuse(nrm, qr.get(i, k));
      }
      if (nrm !== 0) {
        if (qr.get(k, k) < 0) {
          nrm = -nrm;
        }
        for (i = k; i < m; i++) {
          qr.set(i, k, qr.get(i, k) / nrm);
        }
        qr.set(k, k, qr.get(k, k) + 1);
        for (j = k + 1; j < n; j++) {
          s = 0;
          for (i = k; i < m; i++) {
            s += qr.get(i, k) * qr.get(i, j);
          }
          s = -s / qr.get(k, k);
          for (i = k; i < m; i++) {
            qr.set(i, j, qr.get(i, j) + s * qr.get(i, k));
          }
        }
      }
      rdiag[k] = -nrm;
    }

    this.QR = qr;
    this.Rdiag = rdiag;
  }

  solve(value) {
    value = Matrix.checkMatrix(value);

    let qr = this.QR;
    let m = qr.rows;

    if (value.rows !== m) {
      throw new Error('Matrix row dimensions must agree');
    }
    if (!this.isFullRank()) {
      throw new Error('Matrix is rank deficient');
    }

    let count = value.columns;
    let X = value.clone();
    let n = qr.columns;
    let i, j, k, s;

    for (k = 0; k < n; k++) {
      for (j = 0; j < count; j++) {
        s = 0;
        for (i = k; i < m; i++) {
          s += qr.get(i, k) * X.get(i, j);
        }
        s = -s / qr.get(k, k);
        for (i = k; i < m; i++) {
          X.set(i, j, X.get(i, j) + s * qr.get(i, k));
        }
      }
    }
    for (k = n - 1; k >= 0; k--) {
      for (j = 0; j < count; j++) {
        X.set(k, j, X.get(k, j) / this.Rdiag[k]);
      }
      for (i = 0; i < k; i++) {
        for (j = 0; j < count; j++) {
          X.set(i, j, X.get(i, j) - X.get(k, j) * qr.get(i, k));
        }
      }
    }

    return X.subMatrix(0, n - 1, 0, count - 1);
  }

  isFullRank() {
    let columns = this.QR.columns;
    for (let i = 0; i < columns; i++) {
      if (this.Rdiag[i] === 0) {
        return false;
      }
    }
    return true;
  }

  get upperTriangularMatrix() {
    let qr = this.QR;
    let n = qr.columns;
    let X = new Matrix(n, n);
    let i, j;
    for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
        if (i < j) {
          X.set(i, j, qr.get(i, j));
        } else if (i === j) {
          X.set(i, j, this.Rdiag[i]);
        } else {
          X.set(i, j, 0);
        }
      }
    }
    return X;
  }

  get orthogonalMatrix() {
    let qr = this.QR;
    let rows = qr.rows;
    let columns = qr.columns;
    let X = new Matrix(rows, columns);
    let i, j, k, s;

    for (k = columns - 1; k >= 0; k--) {
      for (i = 0; i < rows; i++) {
        X.set(i, k, 0);
      }
      X.set(k, k, 1);
      for (j = k; j < columns; j++) {
        if (qr.get(k, k) !== 0) {
          s = 0;
          for (i = k; i < rows; i++) {
            s += qr.get(i, k) * X.get(i, j);
          }

          s = -s / qr.get(k, k);

          for (i = k; i < rows; i++) {
            X.set(i, j, X.get(i, j) + s * qr.get(i, k));
          }
        }
      }
    }
    return X;
  }
}

class SingularValueDecomposition {
  constructor(value, options = {}) {
    value = WrapperMatrix2D.checkMatrix(value);

    if (value.isEmpty()) {
      throw new Error('Matrix must be non-empty');
    }

    let m = value.rows;
    let n = value.columns;

    const {
      computeLeftSingularVectors = true,
      computeRightSingularVectors = true,
      autoTranspose = false,
    } = options;

    let wantu = Boolean(computeLeftSingularVectors);
    let wantv = Boolean(computeRightSingularVectors);

    let swapped = false;
    let a;
    if (m < n) {
      if (!autoTranspose) {
        a = value.clone();
        // eslint-disable-next-line no-console
        console.warn(
          'Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose',
        );
      } else {
        a = value.transpose();
        m = a.rows;
        n = a.columns;
        swapped = true;
        let aux = wantu;
        wantu = wantv;
        wantv = aux;
      }
    } else {
      a = value.clone();
    }

    let nu = Math.min(m, n);
    let ni = Math.min(m + 1, n);
    let s = new Float64Array(ni);
    let U = new Matrix(m, nu);
    let V = new Matrix(n, n);

    let e = new Float64Array(n);
    let work = new Float64Array(m);

    let si = new Float64Array(ni);
    for (let i = 0; i < ni; i++) si[i] = i;

    let nct = Math.min(m - 1, n);
    let nrt = Math.max(0, Math.min(n - 2, m));
    let mrc = Math.max(nct, nrt);

    for (let k = 0; k < mrc; k++) {
      if (k < nct) {
        s[k] = 0;
        for (let i = k; i < m; i++) {
          s[k] = hypotenuse(s[k], a.get(i, k));
        }
        if (s[k] !== 0) {
          if (a.get(k, k) < 0) {
            s[k] = -s[k];
          }
          for (let i = k; i < m; i++) {
            a.set(i, k, a.get(i, k) / s[k]);
          }
          a.set(k, k, a.get(k, k) + 1);
        }
        s[k] = -s[k];
      }

      for (let j = k + 1; j < n; j++) {
        if (k < nct && s[k] !== 0) {
          let t = 0;
          for (let i = k; i < m; i++) {
            t += a.get(i, k) * a.get(i, j);
          }
          t = -t / a.get(k, k);
          for (let i = k; i < m; i++) {
            a.set(i, j, a.get(i, j) + t * a.get(i, k));
          }
        }
        e[j] = a.get(k, j);
      }

      if (wantu && k < nct) {
        for (let i = k; i < m; i++) {
          U.set(i, k, a.get(i, k));
        }
      }

      if (k < nrt) {
        e[k] = 0;
        for (let i = k + 1; i < n; i++) {
          e[k] = hypotenuse(e[k], e[i]);
        }
        if (e[k] !== 0) {
          if (e[k + 1] < 0) {
            e[k] = 0 - e[k];
          }
          for (let i = k + 1; i < n; i++) {
            e[i] /= e[k];
          }
          e[k + 1] += 1;
        }
        e[k] = -e[k];
        if (k + 1 < m && e[k] !== 0) {
          for (let i = k + 1; i < m; i++) {
            work[i] = 0;
          }
          for (let i = k + 1; i < m; i++) {
            for (let j = k + 1; j < n; j++) {
              work[i] += e[j] * a.get(i, j);
            }
          }
          for (let j = k + 1; j < n; j++) {
            let t = -e[j] / e[k + 1];
            for (let i = k + 1; i < m; i++) {
              a.set(i, j, a.get(i, j) + t * work[i]);
            }
          }
        }
        if (wantv) {
          for (let i = k + 1; i < n; i++) {
            V.set(i, k, e[i]);
          }
        }
      }
    }

    let p = Math.min(n, m + 1);
    if (nct < n) {
      s[nct] = a.get(nct, nct);
    }
    if (m < p) {
      s[p - 1] = 0;
    }
    if (nrt + 1 < p) {
      e[nrt] = a.get(nrt, p - 1);
    }
    e[p - 1] = 0;

    if (wantu) {
      for (let j = nct; j < nu; j++) {
        for (let i = 0; i < m; i++) {
          U.set(i, j, 0);
        }
        U.set(j, j, 1);
      }
      for (let k = nct - 1; k >= 0; k--) {
        if (s[k] !== 0) {
          for (let j = k + 1; j < nu; j++) {
            let t = 0;
            for (let i = k; i < m; i++) {
              t += U.get(i, k) * U.get(i, j);
            }
            t = -t / U.get(k, k);
            for (let i = k; i < m; i++) {
              U.set(i, j, U.get(i, j) + t * U.get(i, k));
            }
          }
          for (let i = k; i < m; i++) {
            U.set(i, k, -U.get(i, k));
          }
          U.set(k, k, 1 + U.get(k, k));
          for (let i = 0; i < k - 1; i++) {
            U.set(i, k, 0);
          }
        } else {
          for (let i = 0; i < m; i++) {
            U.set(i, k, 0);
          }
          U.set(k, k, 1);
        }
      }
    }

    if (wantv) {
      for (let k = n - 1; k >= 0; k--) {
        if (k < nrt && e[k] !== 0) {
          for (let j = k + 1; j < n; j++) {
            let t = 0;
            for (let i = k + 1; i < n; i++) {
              t += V.get(i, k) * V.get(i, j);
            }
            t = -t / V.get(k + 1, k);
            for (let i = k + 1; i < n; i++) {
              V.set(i, j, V.get(i, j) + t * V.get(i, k));
            }
          }
        }
        for (let i = 0; i < n; i++) {
          V.set(i, k, 0);
        }
        V.set(k, k, 1);
      }
    }

    let pp = p - 1;
    let eps = Number.EPSILON;
    while (p > 0) {
      let k, kase;
      for (k = p - 2; k >= -1; k--) {
        if (k === -1) {
          break;
        }
        const alpha =
          Number.MIN_VALUE + eps * Math.abs(s[k] + Math.abs(s[k + 1]));
        if (Math.abs(e[k]) <= alpha || Number.isNaN(e[k])) {
          e[k] = 0;
          break;
        }
      }
      if (k === p - 2) {
        kase = 4;
      } else {
        let ks;
        for (ks = p - 1; ks >= k; ks--) {
          if (ks === k) {
            break;
          }
          let t =
            (ks !== p ? Math.abs(e[ks]) : 0) +
            (ks !== k + 1 ? Math.abs(e[ks - 1]) : 0);
          if (Math.abs(s[ks]) <= eps * t) {
            s[ks] = 0;
            break;
          }
        }
        if (ks === k) {
          kase = 3;
        } else if (ks === p - 1) {
          kase = 1;
        } else {
          kase = 2;
          k = ks;
        }
      }

      k++;

      switch (kase) {
        case 1: {
          let f = e[p - 2];
          e[p - 2] = 0;
          for (let j = p - 2; j >= k; j--) {
            let t = hypotenuse(s[j], f);
            let cs = s[j] / t;
            let sn = f / t;
            s[j] = t;
            if (j !== k) {
              f = -sn * e[j - 1];
              e[j - 1] = cs * e[j - 1];
            }
            if (wantv) {
              for (let i = 0; i < n; i++) {
                t = cs * V.get(i, j) + sn * V.get(i, p - 1);
                V.set(i, p - 1, -sn * V.get(i, j) + cs * V.get(i, p - 1));
                V.set(i, j, t);
              }
            }
          }
          break;
        }
        case 2: {
          let f = e[k - 1];
          e[k - 1] = 0;
          for (let j = k; j < p; j++) {
            let t = hypotenuse(s[j], f);
            let cs = s[j] / t;
            let sn = f / t;
            s[j] = t;
            f = -sn * e[j];
            e[j] = cs * e[j];
            if (wantu) {
              for (let i = 0; i < m; i++) {
                t = cs * U.get(i, j) + sn * U.get(i, k - 1);
                U.set(i, k - 1, -sn * U.get(i, j) + cs * U.get(i, k - 1));
                U.set(i, j, t);
              }
            }
          }
          break;
        }
        case 3: {
          const scale = Math.max(
            Math.abs(s[p - 1]),
            Math.abs(s[p - 2]),
            Math.abs(e[p - 2]),
            Math.abs(s[k]),
            Math.abs(e[k]),
          );
          const sp = s[p - 1] / scale;
          const spm1 = s[p - 2] / scale;
          const epm1 = e[p - 2] / scale;
          const sk = s[k] / scale;
          const ek = e[k] / scale;
          const b = ((spm1 + sp) * (spm1 - sp) + epm1 * epm1) / 2;
          const c = sp * epm1 * (sp * epm1);
          let shift = 0;
          if (b !== 0 || c !== 0) {
            if (b < 0) {
              shift = 0 - Math.sqrt(b * b + c);
            } else {
              shift = Math.sqrt(b * b + c);
            }
            shift = c / (b + shift);
          }
          let f = (sk + sp) * (sk - sp) + shift;
          let g = sk * ek;
          for (let j = k; j < p - 1; j++) {
            let t = hypotenuse(f, g);
            if (t === 0) t = Number.MIN_VALUE;
            let cs = f / t;
            let sn = g / t;
            if (j !== k) {
              e[j - 1] = t;
            }
            f = cs * s[j] + sn * e[j];
            e[j] = cs * e[j] - sn * s[j];
            g = sn * s[j + 1];
            s[j + 1] = cs * s[j + 1];
            if (wantv) {
              for (let i = 0; i < n; i++) {
                t = cs * V.get(i, j) + sn * V.get(i, j + 1);
                V.set(i, j + 1, -sn * V.get(i, j) + cs * V.get(i, j + 1));
                V.set(i, j, t);
              }
            }
            t = hypotenuse(f, g);
            if (t === 0) t = Number.MIN_VALUE;
            cs = f / t;
            sn = g / t;
            s[j] = t;
            f = cs * e[j] + sn * s[j + 1];
            s[j + 1] = -sn * e[j] + cs * s[j + 1];
            g = sn * e[j + 1];
            e[j + 1] = cs * e[j + 1];
            if (wantu && j < m - 1) {
              for (let i = 0; i < m; i++) {
                t = cs * U.get(i, j) + sn * U.get(i, j + 1);
                U.set(i, j + 1, -sn * U.get(i, j) + cs * U.get(i, j + 1));
                U.set(i, j, t);
              }
            }
          }
          e[p - 2] = f;
          break;
        }
        case 4: {
          if (s[k] <= 0) {
            s[k] = s[k] < 0 ? -s[k] : 0;
            if (wantv) {
              for (let i = 0; i <= pp; i++) {
                V.set(i, k, -V.get(i, k));
              }
            }
          }
          while (k < pp) {
            if (s[k] >= s[k + 1]) {
              break;
            }
            let t = s[k];
            s[k] = s[k + 1];
            s[k + 1] = t;
            if (wantv && k < n - 1) {
              for (let i = 0; i < n; i++) {
                t = V.get(i, k + 1);
                V.set(i, k + 1, V.get(i, k));
                V.set(i, k, t);
              }
            }
            if (wantu && k < m - 1) {
              for (let i = 0; i < m; i++) {
                t = U.get(i, k + 1);
                U.set(i, k + 1, U.get(i, k));
                U.set(i, k, t);
              }
            }
            k++;
          }
          p--;
          break;
        }
        // no default
      }
    }

    if (swapped) {
      let tmp = V;
      V = U;
      U = tmp;
    }

    this.m = m;
    this.n = n;
    this.s = s;
    this.U = U;
    this.V = V;
  }

  solve(value) {
    let Y = value;
    let e = this.threshold;
    let scols = this.s.length;
    let Ls = Matrix.zeros(scols, scols);

    for (let i = 0; i < scols; i++) {
      if (Math.abs(this.s[i]) <= e) {
        Ls.set(i, i, 0);
      } else {
        Ls.set(i, i, 1 / this.s[i]);
      }
    }

    let U = this.U;
    let V = this.rightSingularVectors;

    let VL = V.mmul(Ls);
    let vrows = V.rows;
    let urows = U.rows;
    let VLU = Matrix.zeros(vrows, urows);

    for (let i = 0; i < vrows; i++) {
      for (let j = 0; j < urows; j++) {
        let sum = 0;
        for (let k = 0; k < scols; k++) {
          sum += VL.get(i, k) * U.get(j, k);
        }
        VLU.set(i, j, sum);
      }
    }

    return VLU.mmul(Y);
  }

  solveForDiagonal(value) {
    return this.solve(Matrix.diag(value));
  }

  inverse() {
    let V = this.V;
    let e = this.threshold;
    let vrows = V.rows;
    let vcols = V.columns;
    let X = new Matrix(vrows, this.s.length);

    for (let i = 0; i < vrows; i++) {
      for (let j = 0; j < vcols; j++) {
        if (Math.abs(this.s[j]) > e) {
          X.set(i, j, V.get(i, j) / this.s[j]);
        }
      }
    }

    let U = this.U;

    let urows = U.rows;
    let ucols = U.columns;
    let Y = new Matrix(vrows, urows);

    for (let i = 0; i < vrows; i++) {
      for (let j = 0; j < urows; j++) {
        let sum = 0;
        for (let k = 0; k < ucols; k++) {
          sum += X.get(i, k) * U.get(j, k);
        }
        Y.set(i, j, sum);
      }
    }

    return Y;
  }

  get condition() {
    return this.s[0] / this.s[Math.min(this.m, this.n) - 1];
  }

  get norm2() {
    return this.s[0];
  }

  get rank() {
    let tol = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON;
    let r = 0;
    let s = this.s;
    for (let i = 0, ii = s.length; i < ii; i++) {
      if (s[i] > tol) {
        r++;
      }
    }
    return r;
  }

  get diagonal() {
    return Array.from(this.s);
  }

  get threshold() {
    return (Number.EPSILON / 2) * Math.max(this.m, this.n) * this.s[0];
  }

  get leftSingularVectors() {
    return this.U;
  }

  get rightSingularVectors() {
    return this.V;
  }

  get diagonalMatrix() {
    return Matrix.diag(this.s);
  }
}

function inverse(matrix, useSVD = false) {
  matrix = WrapperMatrix2D.checkMatrix(matrix);
  if (useSVD) {
    return new SingularValueDecomposition(matrix).inverse();
  } else {
    return solve(matrix, Matrix.eye(matrix.rows));
  }
}

function solve(leftHandSide, rightHandSide, useSVD = false) {
  leftHandSide = WrapperMatrix2D.checkMatrix(leftHandSide);
  rightHandSide = WrapperMatrix2D.checkMatrix(rightHandSide);
  if (useSVD) {
    return new SingularValueDecomposition(leftHandSide).solve(rightHandSide);
  } else {
    return leftHandSide.isSquare()
      ? new LuDecomposition(leftHandSide).solve(rightHandSide)
      : new QrDecomposition(leftHandSide).solve(rightHandSide);
  }
}

function determinant(matrix) {
  matrix = Matrix.checkMatrix(matrix);
  if (matrix.isSquare()) {
    if (matrix.columns === 0) {
      return 1;
    }

    let a, b, c, d;
    if (matrix.columns === 2) {
      // 2 x 2 matrix
      a = matrix.get(0, 0);
      b = matrix.get(0, 1);
      c = matrix.get(1, 0);
      d = matrix.get(1, 1);

      return a * d - b * c;
    } else if (matrix.columns === 3) {
      // 3 x 3 matrix
      let subMatrix0, subMatrix1, subMatrix2;
      subMatrix0 = new MatrixSelectionView(matrix, [1, 2], [1, 2]);
      subMatrix1 = new MatrixSelectionView(matrix, [1, 2], [0, 2]);
      subMatrix2 = new MatrixSelectionView(matrix, [1, 2], [0, 1]);
      a = matrix.get(0, 0);
      b = matrix.get(0, 1);
      c = matrix.get(0, 2);

      return (
        a * determinant(subMatrix0) -
        b * determinant(subMatrix1) +
        c * determinant(subMatrix2)
      );
    } else {
      // general purpose determinant using the LU decomposition
      return new LuDecomposition(matrix).determinant;
    }
  } else {
    throw Error('determinant can only be calculated for a square matrix');
  }
}

function xrange(n, exception) {
  let range = [];
  for (let i = 0; i < n; i++) {
    if (i !== exception) {
      range.push(i);
    }
  }
  return range;
}

function dependenciesOneRow(
  error,
  matrix,
  index,
  thresholdValue = 10e-10,
  thresholdError = 10e-10,
) {
  if (error > thresholdError) {
    return new Array(matrix.rows + 1).fill(0);
  } else {
    let returnArray = matrix.addRow(index, [0]);
    for (let i = 0; i < returnArray.rows; i++) {
      if (Math.abs(returnArray.get(i, 0)) < thresholdValue) {
        returnArray.set(i, 0, 0);
      }
    }
    return returnArray.to1DArray();
  }
}

function linearDependencies(matrix, options = {}) {
  const { thresholdValue = 10e-10, thresholdError = 10e-10 } = options;
  matrix = Matrix.checkMatrix(matrix);

  let n = matrix.rows;
  let results = new Matrix(n, n);

  for (let i = 0; i < n; i++) {
    let b = Matrix.columnVector(matrix.getRow(i));
    let Abis = matrix.subMatrixRow(xrange(n, i)).transpose();
    let svd = new SingularValueDecomposition(Abis);
    let x = svd.solve(b);
    let error = Matrix.sub(b, Abis.mmul(x)).abs().max();
    results.setRow(
      i,
      dependenciesOneRow(error, x, i, thresholdValue, thresholdError),
    );
  }
  return results;
}

function pseudoInverse(matrix, threshold = Number.EPSILON) {
  matrix = Matrix.checkMatrix(matrix);
  if (matrix.isEmpty()) {
    // with a zero dimension, the pseudo-inverse is the transpose, since all 0xn and nx0 matrices are singular
    // (0xn)*(nx0)*(0xn) = 0xn
    // (nx0)*(0xn)*(nx0) = nx0
    return matrix.transpose();
  }
  let svdSolution = new SingularValueDecomposition(matrix, { autoTranspose: true });

  let U = svdSolution.leftSingularVectors;
  let V = svdSolution.rightSingularVectors;
  let s = svdSolution.diagonal;

  for (let i = 0; i < s.length; i++) {
    if (Math.abs(s[i]) > threshold) {
      s[i] = 1.0 / s[i];
    } else {
      s[i] = 0.0;
    }
  }

  return V.mmul(Matrix.diag(s).mmul(U.transpose()));
}

function covariance(xMatrix, yMatrix = xMatrix, options = {}) {
  xMatrix = new Matrix(xMatrix);
  let yIsSame = false;
  if (
    typeof yMatrix === 'object' &&
    !Matrix.isMatrix(yMatrix) &&
    !isAnyArray.isAnyArray(yMatrix)
  ) {
    options = yMatrix;
    yMatrix = xMatrix;
    yIsSame = true;
  } else {
    yMatrix = new Matrix(yMatrix);
  }
  if (xMatrix.rows !== yMatrix.rows) {
    throw new TypeError('Both matrices must have the same number of rows');
  }
  const { center = true } = options;
  if (center) {
    xMatrix = xMatrix.center('column');
    if (!yIsSame) {
      yMatrix = yMatrix.center('column');
    }
  }
  const cov = xMatrix.transpose().mmul(yMatrix);
  for (let i = 0; i < cov.rows; i++) {
    for (let j = 0; j < cov.columns; j++) {
      cov.set(i, j, cov.get(i, j) * (1 / (xMatrix.rows - 1)));
    }
  }
  return cov;
}

function correlation(xMatrix, yMatrix = xMatrix, options = {}) {
  xMatrix = new Matrix(xMatrix);
  let yIsSame = false;
  if (
    typeof yMatrix === 'object' &&
    !Matrix.isMatrix(yMatrix) &&
    !isAnyArray.isAnyArray(yMatrix)
  ) {
    options = yMatrix;
    yMatrix = xMatrix;
    yIsSame = true;
  } else {
    yMatrix = new Matrix(yMatrix);
  }
  if (xMatrix.rows !== yMatrix.rows) {
    throw new TypeError('Both matrices must have the same number of rows');
  }

  const { center = true, scale = true } = options;
  if (center) {
    xMatrix.center('column');
    if (!yIsSame) {
      yMatrix.center('column');
    }
  }
  if (scale) {
    xMatrix.scale('column');
    if (!yIsSame) {
      yMatrix.scale('column');
    }
  }

  const sdx = xMatrix.standardDeviation('column', { unbiased: true });
  const sdy = yIsSame
    ? sdx
    : yMatrix.standardDeviation('column', { unbiased: true });

  const corr = xMatrix.transpose().mmul(yMatrix);
  for (let i = 0; i < corr.rows; i++) {
    for (let j = 0; j < corr.columns; j++) {
      corr.set(
        i,
        j,
        corr.get(i, j) * (1 / (sdx[i] * sdy[j])) * (1 / (xMatrix.rows - 1)),
      );
    }
  }
  return corr;
}

class EigenvalueDecomposition {
  constructor(matrix, options = {}) {
    const { assumeSymmetric = false } = options;

    matrix = WrapperMatrix2D.checkMatrix(matrix);
    if (!matrix.isSquare()) {
      throw new Error('Matrix is not a square matrix');
    }

    if (matrix.isEmpty()) {
      throw new Error('Matrix must be non-empty');
    }

    let n = matrix.columns;
    let V = new Matrix(n, n);
    let d = new Float64Array(n);
    let e = new Float64Array(n);
    let value = matrix;
    let i, j;

    let isSymmetric = false;
    if (assumeSymmetric) {
      isSymmetric = true;
    } else {
      isSymmetric = matrix.isSymmetric();
    }

    if (isSymmetric) {
      for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
          V.set(i, j, value.get(i, j));
        }
      }
      tred2(n, e, d, V);
      tql2(n, e, d, V);
    } else {
      let H = new Matrix(n, n);
      let ort = new Float64Array(n);
      for (j = 0; j < n; j++) {
        for (i = 0; i < n; i++) {
          H.set(i, j, value.get(i, j));
        }
      }
      orthes(n, H, ort, V);
      hqr2(n, e, d, V, H);
    }

    this.n = n;
    this.e = e;
    this.d = d;
    this.V = V;
  }

  get realEigenvalues() {
    return Array.from(this.d);
  }

  get imaginaryEigenvalues() {
    return Array.from(this.e);
  }

  get eigenvectorMatrix() {
    return this.V;
  }

  get diagonalMatrix() {
    let n = this.n;
    let e = this.e;
    let d = this.d;
    let X = new Matrix(n, n);
    let i, j;
    for (i = 0; i < n; i++) {
      for (j = 0; j < n; j++) {
        X.set(i, j, 0);
      }
      X.set(i, i, d[i]);
      if (e[i] > 0) {
        X.set(i, i + 1, e[i]);
      } else if (e[i] < 0) {
        X.set(i, i - 1, e[i]);
      }
    }
    return X;
  }
}

function tred2(n, e, d, V) {
  let f, g, h, i, j, k, hh, scale;

  for (j = 0; j < n; j++) {
    d[j] = V.get(n - 1, j);
  }

  for (i = n - 1; i > 0; i--) {
    scale = 0;
    h = 0;
    for (k = 0; k < i; k++) {
      scale = scale + Math.abs(d[k]);
    }

    if (scale === 0) {
      e[i] = d[i - 1];
      for (j = 0; j < i; j++) {
        d[j] = V.get(i - 1, j);
        V.set(i, j, 0);
        V.set(j, i, 0);
      }
    } else {
      for (k = 0; k < i; k++) {
        d[k] /= scale;
        h += d[k] * d[k];
      }

      f = d[i - 1];
      g = Math.sqrt(h);
      if (f > 0) {
        g = -g;
      }

      e[i] = scale * g;
      h = h - f * g;
      d[i - 1] = f - g;
      for (j = 0; j < i; j++) {
        e[j] = 0;
      }

      for (j = 0; j < i; j++) {
        f = d[j];
        V.set(j, i, f);
        g = e[j] + V.get(j, j) * f;
        for (k = j + 1; k <= i - 1; k++) {
          g += V.get(k, j) * d[k];
          e[k] += V.get(k, j) * f;
        }
        e[j] = g;
      }

      f = 0;
      for (j = 0; j < i; j++) {
        e[j] /= h;
        f += e[j] * d[j];
      }

      hh = f / (h + h);
      for (j = 0; j < i; j++) {
        e[j] -= hh * d[j];
      }

      for (j = 0; j < i; j++) {
        f = d[j];
        g = e[j];
        for (k = j; k <= i - 1; k++) {
          V.set(k, j, V.get(k, j) - (f * e[k] + g * d[k]));
        }
        d[j] = V.get(i - 1, j);
        V.set(i, j, 0);
      }
    }
    d[i] = h;
  }

  for (i = 0; i < n - 1; i++) {
    V.set(n - 1, i, V.get(i, i));
    V.set(i, i, 1);
    h = d[i + 1];
    if (h !== 0) {
      for (k = 0; k <= i; k++) {
        d[k] = V.get(k, i + 1) / h;
      }

      for (j = 0; j <= i; j++) {
        g = 0;
        for (k = 0; k <= i; k++) {
          g += V.get(k, i + 1) * V.get(k, j);
        }
        for (k = 0; k <= i; k++) {
          V.set(k, j, V.get(k, j) - g * d[k]);
        }
      }
    }

    for (k = 0; k <= i; k++) {
      V.set(k, i + 1, 0);
    }
  }

  for (j = 0; j < n; j++) {
    d[j] = V.get(n - 1, j);
    V.set(n - 1, j, 0);
  }

  V.set(n - 1, n - 1, 1);
  e[0] = 0;
}

function tql2(n, e, d, V) {
  let g, h, i, j, k, l, m, p, r, dl1, c, c2, c3, el1, s, s2;

  for (i = 1; i < n; i++) {
    e[i - 1] = e[i];
  }

  e[n - 1] = 0;

  let f = 0;
  let tst1 = 0;
  let eps = Number.EPSILON;

  for (l = 0; l < n; l++) {
    tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));
    m = l;
    while (m < n) {
      if (Math.abs(e[m]) <= eps * tst1) {
        break;
      }
      m++;
    }

    if (m > l) {
      do {

        g = d[l];
        p = (d[l + 1] - g) / (2 * e[l]);
        r = hypotenuse(p, 1);
        if (p < 0) {
          r = -r;
        }

        d[l] = e[l] / (p + r);
        d[l + 1] = e[l] * (p + r);
        dl1 = d[l + 1];
        h = g - d[l];
        for (i = l + 2; i < n; i++) {
          d[i] -= h;
        }

        f = f + h;

        p = d[m];
        c = 1;
        c2 = c;
        c3 = c;
        el1 = e[l + 1];
        s = 0;
        s2 = 0;
        for (i = m - 1; i >= l; i--) {
          c3 = c2;
          c2 = c;
          s2 = s;
          g = c * e[i];
          h = c * p;
          r = hypotenuse(p, e[i]);
          e[i + 1] = s * r;
          s = e[i] / r;
          c = p / r;
          p = c * d[i] - s * g;
          d[i + 1] = h + s * (c * g + s * d[i]);

          for (k = 0; k < n; k++) {
            h = V.get(k, i + 1);
            V.set(k, i + 1, s * V.get(k, i) + c * h);
            V.set(k, i, c * V.get(k, i) - s * h);
          }
        }

        p = (-s * s2 * c3 * el1 * e[l]) / dl1;
        e[l] = s * p;
        d[l] = c * p;
      } while (Math.abs(e[l]) > eps * tst1);
    }
    d[l] = d[l] + f;
    e[l] = 0;
  }

  for (i = 0; i < n - 1; i++) {
    k = i;
    p = d[i];
    for (j = i + 1; j < n; j++) {
      if (d[j] < p) {
        k = j;
        p = d[j];
      }
    }

    if (k !== i) {
      d[k] = d[i];
      d[i] = p;
      for (j = 0; j < n; j++) {
        p = V.get(j, i);
        V.set(j, i, V.get(j, k));
        V.set(j, k, p);
      }
    }
  }
}

function orthes(n, H, ort, V) {
  let low = 0;
  let high = n - 1;
  let f, g, h, i, j, m;
  let scale;

  for (m = low + 1; m <= high - 1; m++) {
    scale = 0;
    for (i = m; i <= high; i++) {
      scale = scale + Math.abs(H.get(i, m - 1));
    }

    if (scale !== 0) {
      h = 0;
      for (i = high; i >= m; i--) {
        ort[i] = H.get(i, m - 1) / scale;
        h += ort[i] * ort[i];
      }

      g = Math.sqrt(h);
      if (ort[m] > 0) {
        g = -g;
      }

      h = h - ort[m] * g;
      ort[m] = ort[m] - g;

      for (j = m; j < n; j++) {
        f = 0;
        for (i = high; i >= m; i--) {
          f += ort[i] * H.get(i, j);
        }

        f = f / h;
        for (i = m; i <= high; i++) {
          H.set(i, j, H.get(i, j) - f * ort[i]);
        }
      }

      for (i = 0; i <= high; i++) {
        f = 0;
        for (j = high; j >= m; j--) {
          f += ort[j] * H.get(i, j);
        }

        f = f / h;
        for (j = m; j <= high; j++) {
          H.set(i, j, H.get(i, j) - f * ort[j]);
        }
      }

      ort[m] = scale * ort[m];
      H.set(m, m - 1, scale * g);
    }
  }

  for (i = 0; i < n; i++) {
    for (j = 0; j < n; j++) {
      V.set(i, j, i === j ? 1 : 0);
    }
  }

  for (m = high - 1; m >= low + 1; m--) {
    if (H.get(m, m - 1) !== 0) {
      for (i = m + 1; i <= high; i++) {
        ort[i] = H.get(i, m - 1);
      }

      for (j = m; j <= high; j++) {
        g = 0;
        for (i = m; i <= high; i++) {
          g += ort[i] * V.get(i, j);
        }

        g = g / ort[m] / H.get(m, m - 1);
        for (i = m; i <= high; i++) {
          V.set(i, j, V.get(i, j) + g * ort[i]);
        }
      }
    }
  }
}

function hqr2(nn, e, d, V, H) {
  let n = nn - 1;
  let low = 0;
  let high = nn - 1;
  let eps = Number.EPSILON;
  let exshift = 0;
  let norm = 0;
  let p = 0;
  let q = 0;
  let r = 0;
  let s = 0;
  let z = 0;
  let iter = 0;
  let i, j, k, l, m, t, w, x, y;
  let ra, sa, vr, vi;
  let notlast, cdivres;

  for (i = 0; i < nn; i++) {
    if (i < low || i > high) {
      d[i] = H.get(i, i);
      e[i] = 0;
    }

    for (j = Math.max(i - 1, 0); j < nn; j++) {
      norm = norm + Math.abs(H.get(i, j));
    }
  }

  while (n >= low) {
    l = n;
    while (l > low) {
      s = Math.abs(H.get(l - 1, l - 1)) + Math.abs(H.get(l, l));
      if (s === 0) {
        s = norm;
      }
      if (Math.abs(H.get(l, l - 1)) < eps * s) {
        break;
      }
      l--;
    }

    if (l === n) {
      H.set(n, n, H.get(n, n) + exshift);
      d[n] = H.get(n, n);
      e[n] = 0;
      n--;
      iter = 0;
    } else if (l === n - 1) {
      w = H.get(n, n - 1) * H.get(n - 1, n);
      p = (H.get(n - 1, n - 1) - H.get(n, n)) / 2;
      q = p * p + w;
      z = Math.sqrt(Math.abs(q));
      H.set(n, n, H.get(n, n) + exshift);
      H.set(n - 1, n - 1, H.get(n - 1, n - 1) + exshift);
      x = H.get(n, n);

      if (q >= 0) {
        z = p >= 0 ? p + z : p - z;
        d[n - 1] = x + z;
        d[n] = d[n - 1];
        if (z !== 0) {
          d[n] = x - w / z;
        }
        e[n - 1] = 0;
        e[n] = 0;
        x = H.get(n, n - 1);
        s = Math.abs(x) + Math.abs(z);
        p = x / s;
        q = z / s;
        r = Math.sqrt(p * p + q * q);
        p = p / r;
        q = q / r;

        for (j = n - 1; j < nn; j++) {
          z = H.get(n - 1, j);
          H.set(n - 1, j, q * z + p * H.get(n, j));
          H.set(n, j, q * H.get(n, j) - p * z);
        }

        for (i = 0; i <= n; i++) {
          z = H.get(i, n - 1);
          H.set(i, n - 1, q * z + p * H.get(i, n));
          H.set(i, n, q * H.get(i, n) - p * z);
        }

        for (i = low; i <= high; i++) {
          z = V.get(i, n - 1);
          V.set(i, n - 1, q * z + p * V.get(i, n));
          V.set(i, n, q * V.get(i, n) - p * z);
        }
      } else {
        d[n - 1] = x + p;
        d[n] = x + p;
        e[n - 1] = z;
        e[n] = -z;
      }

      n = n - 2;
      iter = 0;
    } else {
      x = H.get(n, n);
      y = 0;
      w = 0;
      if (l < n) {
        y = H.get(n - 1, n - 1);
        w = H.get(n, n - 1) * H.get(n - 1, n);
      }

      if (iter === 10) {
        exshift += x;
        for (i = low; i <= n; i++) {
          H.set(i, i, H.get(i, i) - x);
        }
        s = Math.abs(H.get(n, n - 1)) + Math.abs(H.get(n - 1, n - 2));
        // eslint-disable-next-line no-multi-assign
        x = y = 0.75 * s;
        w = -0.4375 * s * s;
      }

      if (iter === 30) {
        s = (y - x) / 2;
        s = s * s + w;
        if (s > 0) {
          s = Math.sqrt(s);
          if (y < x) {
            s = -s;
          }
          s = x - w / ((y - x) / 2 + s);
          for (i = low; i <= n; i++) {
            H.set(i, i, H.get(i, i) - s);
          }
          exshift += s;
          // eslint-disable-next-line no-multi-assign
          x = y = w = 0.964;
        }
      }

      iter = iter + 1;

      m = n - 2;
      while (m >= l) {
        z = H.get(m, m);
        r = x - z;
        s = y - z;
        p = (r * s - w) / H.get(m + 1, m) + H.get(m, m + 1);
        q = H.get(m + 1, m + 1) - z - r - s;
        r = H.get(m + 2, m + 1);
        s = Math.abs(p) + Math.abs(q) + Math.abs(r);
        p = p / s;
        q = q / s;
        r = r / s;
        if (m === l) {
          break;
        }
        if (
          Math.abs(H.get(m, m - 1)) * (Math.abs(q) + Math.abs(r)) <
          eps *
            (Math.abs(p) *
              (Math.abs(H.get(m - 1, m - 1)) +
                Math.abs(z) +
                Math.abs(H.get(m + 1, m + 1))))
        ) {
          break;
        }
        m--;
      }

      for (i = m + 2; i <= n; i++) {
        H.set(i, i - 2, 0);
        if (i > m + 2) {
          H.set(i, i - 3, 0);
        }
      }

      for (k = m; k <= n - 1; k++) {
        notlast = k !== n - 1;
        if (k !== m) {
          p = H.get(k, k - 1);
          q = H.get(k + 1, k - 1);
          r = notlast ? H.get(k + 2, k - 1) : 0;
          x = Math.abs(p) + Math.abs(q) + Math.abs(r);
          if (x !== 0) {
            p = p / x;
            q = q / x;
            r = r / x;
          }
        }

        if (x === 0) {
          break;
        }

        s = Math.sqrt(p * p + q * q + r * r);
        if (p < 0) {
          s = -s;
        }

        if (s !== 0) {
          if (k !== m) {
            H.set(k, k - 1, -s * x);
          } else if (l !== m) {
            H.set(k, k - 1, -H.get(k, k - 1));
          }

          p = p + s;
          x = p / s;
          y = q / s;
          z = r / s;
          q = q / p;
          r = r / p;

          for (j = k; j < nn; j++) {
            p = H.get(k, j) + q * H.get(k + 1, j);
            if (notlast) {
              p = p + r * H.get(k + 2, j);
              H.set(k + 2, j, H.get(k + 2, j) - p * z);
            }

            H.set(k, j, H.get(k, j) - p * x);
            H.set(k + 1, j, H.get(k + 1, j) - p * y);
          }

          for (i = 0; i <= Math.min(n, k + 3); i++) {
            p = x * H.get(i, k) + y * H.get(i, k + 1);
            if (notlast) {
              p = p + z * H.get(i, k + 2);
              H.set(i, k + 2, H.get(i, k + 2) - p * r);
            }

            H.set(i, k, H.get(i, k) - p);
            H.set(i, k + 1, H.get(i, k + 1) - p * q);
          }

          for (i = low; i <= high; i++) {
            p = x * V.get(i, k) + y * V.get(i, k + 1);
            if (notlast) {
              p = p + z * V.get(i, k + 2);
              V.set(i, k + 2, V.get(i, k + 2) - p * r);
            }

            V.set(i, k, V.get(i, k) - p);
            V.set(i, k + 1, V.get(i, k + 1) - p * q);
          }
        }
      }
    }
  }

  if (norm === 0) {
    return;
  }

  for (n = nn - 1; n >= 0; n--) {
    p = d[n];
    q = e[n];

    if (q === 0) {
      l = n;
      H.set(n, n, 1);
      for (i = n - 1; i >= 0; i--) {
        w = H.get(i, i) - p;
        r = 0;
        for (j = l; j <= n; j++) {
          r = r + H.get(i, j) * H.get(j, n);
        }

        if (e[i] < 0) {
          z = w;
          s = r;
        } else {
          l = i;
          if (e[i] === 0) {
            H.set(i, n, w !== 0 ? -r / w : -r / (eps * norm));
          } else {
            x = H.get(i, i + 1);
            y = H.get(i + 1, i);
            q = (d[i] - p) * (d[i] - p) + e[i] * e[i];
            t = (x * s - z * r) / q;
            H.set(i, n, t);
            H.set(
              i + 1,
              n,
              Math.abs(x) > Math.abs(z) ? (-r - w * t) / x : (-s - y * t) / z,
            );
          }

          t = Math.abs(H.get(i, n));
          if (eps * t * t > 1) {
            for (j = i; j <= n; j++) {
              H.set(j, n, H.get(j, n) / t);
            }
          }
        }
      }
    } else if (q < 0) {
      l = n - 1;

      if (Math.abs(H.get(n, n - 1)) > Math.abs(H.get(n - 1, n))) {
        H.set(n - 1, n - 1, q / H.get(n, n - 1));
        H.set(n - 1, n, -(H.get(n, n) - p) / H.get(n, n - 1));
      } else {
        cdivres = cdiv(0, -H.get(n - 1, n), H.get(n - 1, n - 1) - p, q);
        H.set(n - 1, n - 1, cdivres[0]);
        H.set(n - 1, n, cdivres[1]);
      }

      H.set(n, n - 1, 0);
      H.set(n, n, 1);
      for (i = n - 2; i >= 0; i--) {
        ra = 0;
        sa = 0;
        for (j = l; j <= n; j++) {
          ra = ra + H.get(i, j) * H.get(j, n - 1);
          sa = sa + H.get(i, j) * H.get(j, n);
        }

        w = H.get(i, i) - p;

        if (e[i] < 0) {
          z = w;
          r = ra;
          s = sa;
        } else {
          l = i;
          if (e[i] === 0) {
            cdivres = cdiv(-ra, -sa, w, q);
            H.set(i, n - 1, cdivres[0]);
            H.set(i, n, cdivres[1]);
          } else {
            x = H.get(i, i + 1);
            y = H.get(i + 1, i);
            vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;
            vi = (d[i] - p) * 2 * q;
            if (vr === 0 && vi === 0) {
              vr =
                eps *
                norm *
                (Math.abs(w) +
                  Math.abs(q) +
                  Math.abs(x) +
                  Math.abs(y) +
                  Math.abs(z));
            }
            cdivres = cdiv(
              x * r - z * ra + q * sa,
              x * s - z * sa - q * ra,
              vr,
              vi,
            );
            H.set(i, n - 1, cdivres[0]);
            H.set(i, n, cdivres[1]);
            if (Math.abs(x) > Math.abs(z) + Math.abs(q)) {
              H.set(
                i + 1,
                n - 1,
                (-ra - w * H.get(i, n - 1) + q * H.get(i, n)) / x,
              );
              H.set(
                i + 1,
                n,
                (-sa - w * H.get(i, n) - q * H.get(i, n - 1)) / x,
              );
            } else {
              cdivres = cdiv(
                -r - y * H.get(i, n - 1),
                -s - y * H.get(i, n),
                z,
                q,
              );
              H.set(i + 1, n - 1, cdivres[0]);
              H.set(i + 1, n, cdivres[1]);
            }
          }

          t = Math.max(Math.abs(H.get(i, n - 1)), Math.abs(H.get(i, n)));
          if (eps * t * t > 1) {
            for (j = i; j <= n; j++) {
              H.set(j, n - 1, H.get(j, n - 1) / t);
              H.set(j, n, H.get(j, n) / t);
            }
          }
        }
      }
    }
  }

  for (i = 0; i < nn; i++) {
    if (i < low || i > high) {
      for (j = i; j < nn; j++) {
        V.set(i, j, H.get(i, j));
      }
    }
  }

  for (j = nn - 1; j >= low; j--) {
    for (i = low; i <= high; i++) {
      z = 0;
      for (k = low; k <= Math.min(j, high); k++) {
        z = z + V.get(i, k) * H.get(k, j);
      }
      V.set(i, j, z);
    }
  }
}

function cdiv(xr, xi, yr, yi) {
  let r, d;
  if (Math.abs(yr) > Math.abs(yi)) {
    r = yi / yr;
    d = yr + r * yi;
    return [(xr + r * xi) / d, (xi - r * xr) / d];
  } else {
    r = yr / yi;
    d = yi + r * yr;
    return [(r * xr + xi) / d, (r * xi - xr) / d];
  }
}

class CholeskyDecomposition {
  constructor(value) {
    value = WrapperMatrix2D.checkMatrix(value);
    if (!value.isSymmetric()) {
      throw new Error('Matrix is not symmetric');
    }

    let a = value;
    let dimension = a.rows;
    let l = new Matrix(dimension, dimension);
    let positiveDefinite = true;
    let i, j, k;

    for (j = 0; j < dimension; j++) {
      let d = 0;
      for (k = 0; k < j; k++) {
        let s = 0;
        for (i = 0; i < k; i++) {
          s += l.get(k, i) * l.get(j, i);
        }
        s = (a.get(j, k) - s) / l.get(k, k);
        l.set(j, k, s);
        d = d + s * s;
      }

      d = a.get(j, j) - d;

      positiveDefinite &&= d > 0;
      l.set(j, j, Math.sqrt(Math.max(d, 0)));
      for (k = j + 1; k < dimension; k++) {
        l.set(j, k, 0);
      }
    }

    this.L = l;
    this.positiveDefinite = positiveDefinite;
  }

  isPositiveDefinite() {
    return this.positiveDefinite;
  }

  solve(value) {
    value = WrapperMatrix2D.checkMatrix(value);

    let l = this.L;
    let dimension = l.rows;

    if (value.rows !== dimension) {
      throw new Error('Matrix dimensions do not match');
    }
    if (this.isPositiveDefinite() === false) {
      throw new Error('Matrix is not positive definite');
    }

    let count = value.columns;
    let B = value.clone();
    let i, j, k;

    for (k = 0; k < dimension; k++) {
      for (j = 0; j < count; j++) {
        for (i = 0; i < k; i++) {
          B.set(k, j, B.get(k, j) - B.get(i, j) * l.get(k, i));
        }
        B.set(k, j, B.get(k, j) / l.get(k, k));
      }
    }

    for (k = dimension - 1; k >= 0; k--) {
      for (j = 0; j < count; j++) {
        for (i = k + 1; i < dimension; i++) {
          B.set(k, j, B.get(k, j) - B.get(i, j) * l.get(i, k));
        }
        B.set(k, j, B.get(k, j) / l.get(k, k));
      }
    }

    return B;
  }

  get lowerTriangularMatrix() {
    return this.L;
  }
}

class nipals {
  constructor(X, options = {}) {
    X = WrapperMatrix2D.checkMatrix(X);
    let { Y } = options;
    const {
      scaleScores = false,
      maxIterations = 1000,
      terminationCriteria = 1e-10,
    } = options;

    let u;
    if (Y) {
      if (isAnyArray.isAnyArray(Y) && typeof Y[0] === 'number') {
        Y = Matrix.columnVector(Y);
      } else {
        Y = WrapperMatrix2D.checkMatrix(Y);
      }
      if (Y.rows !== X.rows) {
        throw new Error('Y should have the same number of rows as X');
      }
      u = Y.getColumnVector(0);
    } else {
      u = X.getColumnVector(0);
    }

    let diff = 1;
    let t, q, w, tOld;

    for (
      let counter = 0;
      counter < maxIterations && diff > terminationCriteria;
      counter++
    ) {
      w = X.transpose().mmul(u).div(u.transpose().mmul(u).get(0, 0));
      w = w.div(w.norm());

      t = X.mmul(w).div(w.transpose().mmul(w).get(0, 0));

      if (counter > 0) {
        diff = t.clone().sub(tOld).pow(2).sum();
      }
      tOld = t.clone();

      if (Y) {
        q = Y.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));
        q = q.div(q.norm());

        u = Y.mmul(q).div(q.transpose().mmul(q).get(0, 0));
      } else {
        u = t;
      }
    }

    if (Y) {
      let p = X.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));
      p = p.div(p.norm());
      let xResidual = X.clone().sub(t.clone().mmul(p.transpose()));
      let residual = u.transpose().mmul(t).div(t.transpose().mmul(t).get(0, 0));
      let yResidual = Y.clone().sub(
        t.clone().mulS(residual.get(0, 0)).mmul(q.transpose()),
      );

      this.t = t;
      this.p = p.transpose();
      this.w = w.transpose();
      this.q = q;
      this.u = u;
      this.s = t.transpose().mmul(t);
      this.xResidual = xResidual;
      this.yResidual = yResidual;
      this.betas = residual;
    } else {
      this.w = w.transpose();
      this.s = t.transpose().mmul(t).sqrt();
      if (scaleScores) {
        this.t = t.clone().div(this.s.get(0, 0));
      } else {
        this.t = t;
      }
      this.xResidual = X.sub(t.mmul(w.transpose()));
    }
  }
}

exports.AbstractMatrix = AbstractMatrix;
exports.CHO = CholeskyDecomposition;
exports.CholeskyDecomposition = CholeskyDecomposition;
exports.DistanceMatrix = DistanceMatrix;
exports.EVD = EigenvalueDecomposition;
exports.EigenvalueDecomposition = EigenvalueDecomposition;
exports.LU = LuDecomposition;
exports.LuDecomposition = LuDecomposition;
exports.Matrix = Matrix;
exports.MatrixColumnSelectionView = MatrixColumnSelectionView;
exports.MatrixColumnView = MatrixColumnView;
exports.MatrixFlipColumnView = MatrixFlipColumnView;
exports.MatrixFlipRowView = MatrixFlipRowView;
exports.MatrixRowSelectionView = MatrixRowSelectionView;
exports.MatrixRowView = MatrixRowView;
exports.MatrixSelectionView = MatrixSelectionView;
exports.MatrixSubView = MatrixSubView;
exports.MatrixTransposeView = MatrixTransposeView;
exports.NIPALS = nipals;
exports.Nipals = nipals;
exports.QR = QrDecomposition;
exports.QrDecomposition = QrDecomposition;
exports.SVD = SingularValueDecomposition;
exports.SingularValueDecomposition = SingularValueDecomposition;
exports.SymmetricMatrix = SymmetricMatrix;
exports.WrapperMatrix1D = WrapperMatrix1D;
exports.WrapperMatrix2D = WrapperMatrix2D;
exports.correlation = correlation;
exports.covariance = covariance;
exports["default"] = Matrix;
exports.determinant = determinant;
exports.inverse = inverse;
exports.linearDependencies = linearDependencies;
exports.pseudoInverse = pseudoInverse;
exports.solve = solve;
exports.wrap = wrap;


/***/ }),

/***/ "./node_modules/ml-matrix/matrix.mjs":
/*!*******************************************!*\
  !*** ./node_modules/ml-matrix/matrix.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractMatrix: () => (/* binding */ AbstractMatrix),
/* harmony export */   CHO: () => (/* binding */ CHO),
/* harmony export */   CholeskyDecomposition: () => (/* binding */ CholeskyDecomposition),
/* harmony export */   DistanceMatrix: () => (/* binding */ DistanceMatrix),
/* harmony export */   EVD: () => (/* binding */ EVD),
/* harmony export */   EigenvalueDecomposition: () => (/* binding */ EigenvalueDecomposition),
/* harmony export */   LU: () => (/* binding */ LU),
/* harmony export */   LuDecomposition: () => (/* binding */ LuDecomposition),
/* harmony export */   Matrix: () => (/* binding */ Matrix),
/* harmony export */   MatrixColumnSelectionView: () => (/* binding */ MatrixColumnSelectionView),
/* harmony export */   MatrixColumnView: () => (/* binding */ MatrixColumnView),
/* harmony export */   MatrixFlipColumnView: () => (/* binding */ MatrixFlipColumnView),
/* harmony export */   MatrixFlipRowView: () => (/* binding */ MatrixFlipRowView),
/* harmony export */   MatrixRowSelectionView: () => (/* binding */ MatrixRowSelectionView),
/* harmony export */   MatrixRowView: () => (/* binding */ MatrixRowView),
/* harmony export */   MatrixSelectionView: () => (/* binding */ MatrixSelectionView),
/* harmony export */   MatrixSubView: () => (/* binding */ MatrixSubView),
/* harmony export */   MatrixTransposeView: () => (/* binding */ MatrixTransposeView),
/* harmony export */   NIPALS: () => (/* binding */ NIPALS),
/* harmony export */   Nipals: () => (/* binding */ Nipals),
/* harmony export */   QR: () => (/* binding */ QR),
/* harmony export */   QrDecomposition: () => (/* binding */ QrDecomposition),
/* harmony export */   SVD: () => (/* binding */ SVD),
/* harmony export */   SingularValueDecomposition: () => (/* binding */ SingularValueDecomposition),
/* harmony export */   SymmetricMatrix: () => (/* binding */ SymmetricMatrix),
/* harmony export */   WrapperMatrix1D: () => (/* binding */ WrapperMatrix1D),
/* harmony export */   WrapperMatrix2D: () => (/* binding */ WrapperMatrix2D),
/* harmony export */   correlation: () => (/* binding */ correlation),
/* harmony export */   covariance: () => (/* binding */ covariance),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   determinant: () => (/* binding */ determinant),
/* harmony export */   inverse: () => (/* binding */ inverse),
/* harmony export */   linearDependencies: () => (/* binding */ linearDependencies),
/* harmony export */   pseudoInverse: () => (/* binding */ pseudoInverse),
/* harmony export */   solve: () => (/* binding */ solve),
/* harmony export */   wrap: () => (/* binding */ wrap)
/* harmony export */ });
/* harmony import */ var _matrix_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./matrix.js */ "./node_modules/ml-matrix/matrix.js");


const AbstractMatrix = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.AbstractMatrix;
const CHO = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.CHO;
const CholeskyDecomposition = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.CholeskyDecomposition;
const DistanceMatrix = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.DistanceMatrix;
const EVD = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.EVD;
const EigenvalueDecomposition = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.EigenvalueDecomposition;
const LU = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.LU;
const LuDecomposition = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.LuDecomposition;
const Matrix = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix;
const MatrixColumnSelectionView = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.MatrixColumnSelectionView;
const MatrixColumnView = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.MatrixColumnView;
const MatrixFlipColumnView = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.MatrixFlipColumnView;
const MatrixFlipRowView = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.MatrixFlipRowView;
const MatrixRowSelectionView = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.MatrixRowSelectionView;
const MatrixRowView = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.MatrixRowView;
const MatrixSelectionView = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.MatrixSelectionView;
const MatrixSubView = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.MatrixSubView;
const MatrixTransposeView = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.MatrixTransposeView;
const NIPALS = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.NIPALS;
const Nipals = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.Nipals;
const QR = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.QR;
const QrDecomposition = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.QrDecomposition;
const SVD = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.SVD;
const SingularValueDecomposition = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.SingularValueDecomposition;
const SymmetricMatrix = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.SymmetricMatrix;
const WrapperMatrix1D = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.WrapperMatrix1D;
const WrapperMatrix2D = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.WrapperMatrix2D;
const correlation = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.correlation;
const covariance = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.covariance;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix ? _matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix : _matrix_js__WEBPACK_IMPORTED_MODULE_0__.Matrix);
const determinant = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.determinant;
const inverse = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.inverse;
const linearDependencies = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.linearDependencies;
const pseudoInverse = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.pseudoInverse;
const solve = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.solve;
const wrap = _matrix_js__WEBPACK_IMPORTED_MODULE_0__.wrap;


/***/ }),

/***/ "./node_modules/tslib/tslib.es6.mjs":
/*!******************************************!*\
  !*** ./node_modules/tslib/tslib.es6.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __addDisposableResource: () => (/* binding */ __addDisposableResource),
/* harmony export */   __assign: () => (/* binding */ __assign),
/* harmony export */   __asyncDelegator: () => (/* binding */ __asyncDelegator),
/* harmony export */   __asyncGenerator: () => (/* binding */ __asyncGenerator),
/* harmony export */   __asyncValues: () => (/* binding */ __asyncValues),
/* harmony export */   __await: () => (/* binding */ __await),
/* harmony export */   __awaiter: () => (/* binding */ __awaiter),
/* harmony export */   __classPrivateFieldGet: () => (/* binding */ __classPrivateFieldGet),
/* harmony export */   __classPrivateFieldIn: () => (/* binding */ __classPrivateFieldIn),
/* harmony export */   __classPrivateFieldSet: () => (/* binding */ __classPrivateFieldSet),
/* harmony export */   __createBinding: () => (/* binding */ __createBinding),
/* harmony export */   __decorate: () => (/* binding */ __decorate),
/* harmony export */   __disposeResources: () => (/* binding */ __disposeResources),
/* harmony export */   __esDecorate: () => (/* binding */ __esDecorate),
/* harmony export */   __exportStar: () => (/* binding */ __exportStar),
/* harmony export */   __extends: () => (/* binding */ __extends),
/* harmony export */   __generator: () => (/* binding */ __generator),
/* harmony export */   __importDefault: () => (/* binding */ __importDefault),
/* harmony export */   __importStar: () => (/* binding */ __importStar),
/* harmony export */   __makeTemplateObject: () => (/* binding */ __makeTemplateObject),
/* harmony export */   __metadata: () => (/* binding */ __metadata),
/* harmony export */   __param: () => (/* binding */ __param),
/* harmony export */   __propKey: () => (/* binding */ __propKey),
/* harmony export */   __read: () => (/* binding */ __read),
/* harmony export */   __rest: () => (/* binding */ __rest),
/* harmony export */   __rewriteRelativeImportExtension: () => (/* binding */ __rewriteRelativeImportExtension),
/* harmony export */   __runInitializers: () => (/* binding */ __runInitializers),
/* harmony export */   __setFunctionName: () => (/* binding */ __setFunctionName),
/* harmony export */   __spread: () => (/* binding */ __spread),
/* harmony export */   __spreadArray: () => (/* binding */ __spreadArray),
/* harmony export */   __spreadArrays: () => (/* binding */ __spreadArrays),
/* harmony export */   __values: () => (/* binding */ __values),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */

var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
  return extendStatics(d, b);
};

function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() { this.constructor = d; }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
  __assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }
      return t;
  }
  return __assign.apply(this, arguments);
}

function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
              t[p[i]] = s[p[i]];
      }
  return t;
}

function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
  return function (target, key) { decorator(target, key, paramIndex); }
}

function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
      var context = {};
      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
      for (var p in contextIn.access) context.access[p] = contextIn.access[p];
      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };
      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
      if (kind === "accessor") {
          if (result === void 0) continue;
          if (result === null || typeof result !== "object") throw new TypeError("Object expected");
          if (_ = accept(result.get)) descriptor.get = _;
          if (_ = accept(result.set)) descriptor.set = _;
          if (_ = accept(result.init)) initializers.unshift(_);
      }
      else if (_ = accept(result)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
      }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
};

function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
};

function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
};

function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
};

function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
  return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}

function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
  function verb(n) { return function (v) { return step([n, v]); }; }
  function step(op) {
      if (f) throw new TypeError("Generator is already executing.");
      while (g && (g = 0, op[0] && (_ = 0)), _) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];
          switch (op[0]) {
              case 0: case 1: t = op; break;
              case 4: _.label++; return { value: op[1], done: false };
              case 5: _.label++; y = op[1]; op = [0]; continue;
              case 7: op = _.ops.pop(); _.trys.pop(); continue;
              default:
                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                  if (t[2]) _.ops.pop();
                  _.trys.pop(); continue;
          }
          op = body.call(thisArg, _);
      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
  }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
  }
  Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
      next: function () {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
      }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  }
  catch (error) { e = { error: error }; }
  finally {
      try {
          if (r && !r.done && (m = i["return"])) m.call(i);
      }
      finally { if (e) throw e.error; }
  }
  return ar;
}

/** @deprecated */
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
      ar = ar.concat(__read(arguments[i]));
  return ar;
}

/** @deprecated */
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
          r[k] = a[j];
  return r;
}

function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
      }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}

function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
  function fulfill(value) { resume("next", value); }
  function reject(value) { resume("throw", value); }
  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
  return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
  o["default"] = v;
};

var ownKeys = function(o) {
  ownKeys = Object.getOwnPropertyNames || function (o) {
    var ar = [];
    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
    return ar;
  };
  return ownKeys(o);
};

function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
  __setModuleDefault(result, mod);
  return result;
}

function __importDefault(mod) {
  return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}

function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}

function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };
    env.stack.push({ value: value, dispose: dispose, async: async });
  }
  else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}

var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });
        }
        else s |= 1;
      }
      catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}

function __rewriteRelativeImportExtension(path, preserveJsx) {
  if (typeof path === "string" && /^\.\.?\//.test(path)) {
      return path.replace(/\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {
          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : (d + ext + "." + cm.toLowerCase() + "js");
      });
  }
  return path;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __esDecorate,
  __runInitializers,
  __propKey,
  __setFunctionName,
  __metadata,
  __awaiter,
  __generator,
  __createBinding,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar,
  __importDefault,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources,
  __rewriteRelativeImportExtension,
});


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
/*!*************************************************!*\
  !*** ./node_modules/@antv/layout/lib/worker.js ***!
  \*************************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");
/* harmony import */ var _antv_graphlib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @antv/graphlib */ "./node_modules/@antv/graphlib/esm/graph.js");
/* harmony import */ var comlink__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! comlink */ "./node_modules/comlink/dist/esm/comlink.mjs");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./registry */ "./node_modules/@antv/layout/lib/registry.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./types */ "./node_modules/@antv/layout/lib/types.js");





let currentLayout;
const obj = {
    stopLayout() {
        if (currentLayout === null || currentLayout === void 0 ? void 0 : currentLayout.stop) {
            currentLayout.stop();
        }
    },
    calculateLayout(payload, transferables) {
        return (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__awaiter)(this, void 0, void 0, function* () {
            const { layout: { id, options, iterations }, nodes, edges, } = payload;
            // Sync graph on the worker side.
            // TODO: Use transferable objects like ArrayBuffer for nodes & edges,
            // in which case we don't need the whole graph.
            // @see https://github.com/graphology/graphology/blob/master/src/layout-noverlap/webworker.tpl.js#L32
            const graph = new _antv_graphlib__WEBPACK_IMPORTED_MODULE_1__.Graph({
                nodes,
                edges,
            });
            /**
             * Create layout instance on the worker side.
             */
            const layoutCtor = _registry__WEBPACK_IMPORTED_MODULE_2__.registry[id];
            if (layoutCtor) {
                currentLayout = new layoutCtor(options);
            }
            else {
                throw new Error(`Unknown layout id: ${id}`);
            }
            let positions = yield currentLayout.execute(graph);
            if ((0,_types__WEBPACK_IMPORTED_MODULE_3__.isLayoutWithIterations)(currentLayout)) {
                currentLayout.stop();
                positions = currentLayout.tick(iterations);
            }
            return [positions, transferables];
        });
    },
};
comlink__WEBPACK_IMPORTED_MODULE_4__.expose(obj);
//# sourceMappingURL=worker.js.map
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfYW50dl9sYXlvdXRfbGliX3dvcmtlcl9qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxpRUFBZSxZQUFZLEVBQUM7QUFDNUI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pHK0M7QUFDUDtBQUNRO0FBQ3pDLG9CQUFvQiwyREFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMseUJBQXlCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsbUJBQW1CO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGFBQWEsOENBQThDO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUZBQWlGO0FBQzVGLFdBQVcsOEJBQThCLGlCQUFpQixVQUFVO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsc0RBQXNEO0FBQ2hHLDBDQUEwQyxzREFBc0Q7QUFDaEcsK0NBQStDLHNEQUFzRDtBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULDRCQUE0QixnQ0FBZ0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0NBQWtDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixnQ0FBZ0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixhQUFhO0FBQ3BDLHVCQUF1QixhQUFhO0FBQ3BDLHVCQUF1QiwrQ0FBK0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0NBQWtDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsbUJBQW1CLGlEQUFTO0FBQzVCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDMzlCZ0Q7QUFDaEQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVEsc0RBQUs7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUSxzREFBSztBQUNiO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7OztBQ3hSTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FB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QjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGNBQWM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsU0FBUztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0wsYUFBYTtBQUNiO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUCwyQkFBMkIsaURBQUs7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUZBQXFGLGdCQUFnQix5REFBeUQ7QUFDOUo7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLDRDQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUCxZQUFZLDhDQUE4QztBQUMxRCxxQkFBcUIsdURBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMVkrRDtBQUNnRztBQUMvSjtBQUNBLFlBQVksY0FBYztBQUMxQixxQkFBcUIsdURBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsWUFBWSw4Q0FBOEM7QUFDMUQscUJBQXFCLHVEQUFnQjtBQUNyQyxvQ0FBb0MsdURBQWtCLGVBQWUsdURBQWtCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNEQUFpQjtBQUMzQyx1QkFBdUIseURBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCwwQkFBMEIsK0RBQTBCO0FBQ3BELHFCQUFxQixxREFBZ0I7QUFDckMsV0FBVyw0Q0FBTztBQUNsQjtBQUNPO0FBQ1A7QUFDQSxlQUFlLHlEQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDbER1QztBQUNQO0FBQ0Q7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpREFBSztBQUN2QjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDRDQUFLLGFBQWEsNENBQUs7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsNENBQUs7QUFDdkM7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlEQUFLLEdBQUcsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLDRDQUFLLGFBQWEsNENBQUs7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQsNENBQUs7QUFDaEU7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0Q0FBSztBQUNoQjtBQUNBLG1CQUFtQiw0Q0FBSztBQUN4QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQytDO0FBQy9DOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNuS3dFO0FBQ3JCO0FBQ1E7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhDQUFXO0FBQ3JDO0FBQ0EsSUFBSSwyREFBb0I7QUFDeEIsSUFBSSxxRUFBWTtBQUNoQjtBQUNBO0FBQ0EsSUFBSSxnRUFBYztBQUNsQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvQytDO0FBQ0E7QUFDUztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLGNBQWMsK0NBQVE7QUFDdEIsSUFBSSxrREFBUTtBQUNaLGNBQWMsNERBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxhQUFhLDBDQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1AsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsV0FBVyw0Q0FBSztBQUNoQixlQUFlLDRDQUFLO0FBQ3BCLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsYUFBYSwwQ0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ29EO0FBQ3BEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDekl1QztBQUNEO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGVBQWUsS0FBSyxFQUFFLGNBQWM7QUFDcEMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsMkJBQTJCLGlEQUFLO0FBQ2hDO0FBQ0EsMkNBQTJDO0FBQzNDLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHVEQUF1RCxtQkFBbUI7QUFDMUU7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxZQUFZO0FBQ3ZEO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtB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OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQyxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQyxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQyxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQyxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQyxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQyxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQyxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQyxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMs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RUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQyxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQyxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixlQUFlO0FBQ25DLHNCQUFzQixrQkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQyxzQkFBc0Isa0JBQWtCO0FBQ3hDO0FBQ0E7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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDLFlBQVksV0FBVzs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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Q1I7QUFDQSx5QkFBeUIsU0FBUztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFTO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0E7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bm9kZV9tb2R1bGVzL0BhbnR2L2V2ZW50LWVtaXR0ZXIvZXNtL2luZGV4LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9AYW50di9ncmFwaGxpYi9lc20vZ3JhcGguanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L2dyYXBobGliL2VzbS9ncmFwaFZpZXcuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L2dyYXBobGliL2VzbS91dGlscy90cmF2ZXJzZS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvQGFudHYvbGF5b3V0L2xpYi9hbnR2LWRhZ3JlLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9AYW50di9sYXlvdXQvbGliL2FudHYtZGFncmUvYWN5Y2xpYy5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvQGFudHYvbGF5b3V0L2xpYi9hbnR2LWRhZ3JlL2FkZC1ib3JkZXItc2VnbWVudHMuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L2xheW91dC9saWIvYW50di1kYWdyZS9jb29yZGluYXRlLXN5c3RlbS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvQGFudHYvbGF5b3V0L2xpYi9hbnR2LWRhZ3JlL2RhdGEvbGlzdC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvQGFudHYvbGF5b3V0L2xpYi9hbnR2LWRhZ3JlL2dyZWVkeS1mYXMuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L2xheW91dC9saWIvYW50di1kYWdyZS9sYXlvdXQuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L2xheW91dC9saWIvYW50di1kYWdyZS9uZXN0aW5nLWdyYXBoLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9AYW50di9sYXlvdXQvbGliL2FudHYtZGFncmUvbm9ybWFsaXplLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9AYW50di9sYXlvdXQvbGliL2FudHYtZGFncmUvb3JkZXIvYWRkLXN1YmdyYXBoLWNvbnN0cmFpbnRzLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9AYW50di9sYXlvdXQvbGliL2FudHYtZGFncmUvb3JkZXIvYmFyeWNlbnRlci5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvQGFudHYvbGF5b3V0L2xpYi9hbnR2LWRhZ3JlL29yZGVyL2J1aWxkLWxheWVyLWdyYXBoLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9AYW50di9sYXlvdXQvbGliL2FudHYtZGFncmUvb3JkZXIvY3Jvc3MtY291bnQuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L2xheW91dC9saWIvYW50di1kYWdyZS9vcmRlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvQGFudHYvbGF5b3V0L2xpYi9hbnR2LWRhZ3JlL29yZGVyL2luaXQtZGF0YS1vcmRlci5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvQGFudHYvbGF5b3V0L2xpYi9hbnR2LWRhZ3JlL29yZGVyL2luaXQtb3JkZXIuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L2xheW91dC9saWIvYW50di1kYWdyZS9vcmRlci9yZXNvbHZlLWNvbmZsaWN0cy5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvQGFudHYvbGF5b3V0L2xpYi9hbnR2LWRhZ3JlL29yZGVyL3NvcnQtc3ViZ3JhcGguanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L2xheW91dC9saWIvYW50di1kYWdyZS9vcmRlci9zb3J0LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9AYW50di9sYXlvdXQvbGliL2FudHYtZGFncmUvcGFyZW50LWR1bW15LWNoYWlucy5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvQGFudHYvbGF5b3V0L2xpYi9hbnR2LWRhZ3JlL3Bvc2l0aW9uL2JrLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9AYW50di9sYXlvdXQvbGliL2FudHYtZGFncmUvcG9zaXRpb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L2xheW91dC9saWIvYW50di1kYWdyZS9yYW5rL2ZlYXNpYmxlLXRyZWUuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L2xheW91dC9saWIvYW50di1kYWdyZS9yYW5rL2luZGV4LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9AYW50di9sYXlvdXQvbGliL2FudHYtZGFncmUvcmFuay9uZXR3b3JrLXNpbXBsZXguanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L2xheW91dC9saWIvYW50di1kYWdyZS9yYW5rL3V0aWwuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L2xheW91dC9saWIvYW50di1kYWdyZS91dGlsLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9AYW50di9sYXlvdXQvbGliL2NpcmN1bGFyLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9AYW50di9sYXlvdXQvbGliL2NvbWJvLWNvbWJpbmVkLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9AYW50di9sYXlvdXQvbGliL2NvbmNlbnRyaWMuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L2xheW91dC9saWIvZDMtZm9yY2UtM2QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L2xheW91dC9saWIvZDMtZm9yY2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L2xheW91dC9saWIvZGFncmUuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L2xheW91dC9saWIvZm9yY2UtYXRsYXMyL2JvZHkuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L2xheW91dC9saWIvZm9yY2UtYXRsYXMyL2luZGV4LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9AYW50di9sYXlvdXQvbGliL2ZvcmNlLWF0bGFzMi9xdWFkLXRyZWUuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L2xheW91dC9saWIvZm9yY2UtYXRsYXMyL3F1YWQuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L2xheW91dC9saWIvZm9yY2UvZm9yY2Utbi1ib2R5LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9AYW50di9sYXlvdXQvbGliL2ZvcmNlL2luZGV4LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9AYW50di9sYXlvdXQvbGliL2ZydWNodGVybWFuLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9AYW50di9sYXlvdXQvbGliL2dyaWQuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L2xheW91dC9saWIvbWRzLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9AYW50di9sYXlvdXQvbGliL3JhZGlhbC9pbmRleC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvQGFudHYvbGF5b3V0L2xpYi9yYWRpYWwvbWRzLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9AYW50di9sYXlvdXQvbGliL3JhZGlhbC9yYWRpYWwtbm9ub3ZlcmxhcC1mb3JjZS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvQGFudHYvbGF5b3V0L2xpYi9yYW5kb20uanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L2xheW91dC9saWIvcmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L2xheW91dC9saWIvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L2xheW91dC9saWIvdXRpbC9hcnJheS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvQGFudHYvbGF5b3V0L2xpYi91dGlsL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvQGFudHYvbGF5b3V0L2xpYi91dGlsL2Z1bmN0aW9uLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9AYW50di9sYXlvdXQvbGliL3V0aWwvbWF0aC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvQGFudHYvbGF5b3V0L2xpYi91dGlsL29iamVjdC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvQGFudHYvbGF5b3V0L2xpYi91dGlsL3NpemUuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L3V0aWwvZXNtL2xvZGFzaC9jbG9uZS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvQGFudHYvdXRpbC9lc20vbG9kYXNoL2RlZXAtbWl4LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9AYW50di91dGlsL2VzbS9sb2Rhc2gvZWFjaC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvQGFudHYvdXRpbC9lc20vbG9kYXNoL2lzLWFycmF5LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9AYW50di91dGlsL2VzbS9sb2Rhc2gvaXMtZnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L3V0aWwvZXNtL2xvZGFzaC9pcy1uaWwuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L3V0aWwvZXNtL2xvZGFzaC9pcy1udW1iZXIuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L3V0aWwvZXNtL2xvZGFzaC9pcy1vYmplY3QtbGlrZS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvQGFudHYvdXRpbC9lc20vbG9kYXNoL2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvQGFudHYvdXRpbC9lc20vbG9kYXNoL2lzLXBsYWluLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvQGFudHYvdXRpbC9lc20vbG9kYXNoL2lzLXN0cmluZy5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvQGFudHYvdXRpbC9lc20vbG9kYXNoL2lzLXR5cGUuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL0BhbnR2L3V0aWwvZXNtL2xvZGFzaC9waWNrLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9jb21saW5rL2Rpc3QvZXNtL2NvbWxpbmsubWpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kMy1iaW5hcnl0cmVlL3NyYy9hZGQuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLWJpbmFyeXRyZWUvc3JjL2JpbmFyeXRyZWUuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLWJpbmFyeXRyZWUvc3JjL2NvdmVyLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kMy1iaW5hcnl0cmVlL3NyYy9kYXRhLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kMy1iaW5hcnl0cmVlL3NyYy9leHRlbnQuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLWJpbmFyeXRyZWUvc3JjL2ZpbmQuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLWJpbmFyeXRyZWUvc3JjL2hhbGYuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLWJpbmFyeXRyZWUvc3JjL3JlbW92ZS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZDMtYmluYXJ5dHJlZS9zcmMvcm9vdC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZDMtYmluYXJ5dHJlZS9zcmMvc2l6ZS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZDMtYmluYXJ5dHJlZS9zcmMvdmlzaXQuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLWJpbmFyeXRyZWUvc3JjL3Zpc2l0QWZ0ZXIuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLWJpbmFyeXRyZWUvc3JjL3guanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLWRpc3BhdGNoL3NyYy9kaXNwYXRjaC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZDMtZm9yY2UtM2Qvc3JjL2NlbnRlci5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZDMtZm9yY2UtM2Qvc3JjL2NvbGxpZGUuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlLTNkL3NyYy9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZDMtZm9yY2UtM2Qvc3JjL2ppZ2dsZS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZDMtZm9yY2UtM2Qvc3JjL2xjZy5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZDMtZm9yY2UtM2Qvc3JjL2xpbmsuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlLTNkL3NyYy9tYW55Qm9keS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZDMtZm9yY2UtM2Qvc3JjL3JhZGlhbC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZDMtZm9yY2UtM2Qvc3JjL3NpbXVsYXRpb24uanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlLTNkL3NyYy94LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kMy1mb3JjZS0zZC9zcmMveS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZDMtZm9yY2UtM2Qvc3JjL3ouanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9jZW50ZXIuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9jb2xsaWRlLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kMy1mb3JjZS9zcmMvY29uc3RhbnQuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9qaWdnbGUuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9sY2cuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9saW5rLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kMy1mb3JjZS9zcmMvbWFueUJvZHkuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9yYWRpYWwuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLWZvcmNlL3NyYy9zaW11bGF0aW9uLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kMy1mb3JjZS9zcmMveC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZDMtZm9yY2Uvc3JjL3kuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLW9jdHJlZS9zcmMvYWRkLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kMy1vY3RyZWUvc3JjL2NvdmVyLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kMy1vY3RyZWUvc3JjL2RhdGEuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLW9jdHJlZS9zcmMvZXh0ZW50LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kMy1vY3RyZWUvc3JjL2ZpbmQuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLW9jdHJlZS9zcmMvZmluZEFsbC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZDMtb2N0cmVlL3NyYy9vY3RhbnQuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLW9jdHJlZS9zcmMvb2N0cmVlLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kMy1vY3RyZWUvc3JjL3JlbW92ZS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZDMtb2N0cmVlL3NyYy9yb290LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kMy1vY3RyZWUvc3JjL3NpemUuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLW9jdHJlZS9zcmMvdmlzaXQuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLW9jdHJlZS9zcmMvdmlzaXRBZnRlci5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZDMtb2N0cmVlL3NyYy94LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kMy1vY3RyZWUvc3JjL3kuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLW9jdHJlZS9zcmMvei5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL2FkZC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL2NvdmVyLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvZGF0YS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL2V4dGVudC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL2ZpbmQuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy9xdWFkLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvcXVhZHRyZWUuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy9yZW1vdmUuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy9yb290LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvc2l6ZS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3Zpc2l0LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kMy1xdWFkdHJlZS9zcmMvdmlzaXRBZnRlci5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZDMtcXVhZHRyZWUvc3JjL3guanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2QzLXF1YWR0cmVlL3NyYy95LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kMy10aW1lci9zcmMvdGltZXIuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2luZGV4LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvYWN5Y2xpYy5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL2FkZC1ib3JkZXItc2VnbWVudHMuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9jb29yZGluYXRlLXN5c3RlbS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL2RhdGEvbGlzdC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL2RlYnVnLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvZ3JhcGhsaWIuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9ncmVlZHktZmFzLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvbGF5b3V0LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvbG9kYXNoLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvbmVzdGluZy1ncmFwaC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL25vcm1hbGl6ZS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL29yZGVyL2FkZC1zdWJncmFwaC1jb25zdHJhaW50cy5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL29yZGVyL2JhcnljZW50ZXIuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9vcmRlci9idWlsZC1sYXllci1ncmFwaC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL29yZGVyL2Nyb3NzLWNvdW50LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvb3JkZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9vcmRlci9pbml0LW9yZGVyLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvb3JkZXIvcmVzb2x2ZS1jb25mbGljdHMuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9vcmRlci9zb3J0LXN1YmdyYXBoLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvb3JkZXIvc29ydC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL3BhcmVudC1kdW1teS1jaGFpbnMuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2RhZ3JlL2xpYi9wb3NpdGlvbi9iay5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL3Bvc2l0aW9uL2luZGV4LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvcmFuay9mZWFzaWJsZS10cmVlLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvcmFuay9pbmRleC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL3JhbmsvbmV0d29yay1zaW1wbGV4LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvcmFuay91dGlsLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9kYWdyZS9saWIvdXRpbC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZGFncmUvbGliL3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2luZGV4LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL2NvbXBvbmVudHMuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9hbGcvZGZzLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL2RpamtzdHJhLWFsbC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9kaWprc3RyYS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9maW5kLWN5Y2xlcy5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9mbG95ZC13YXJzaGFsbC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9pbmRleC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9pcy1hY3ljbGljLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL3Bvc3RvcmRlci5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9wcmVvcmRlci5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy9wcmltLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvYWxnL3Rhcmphbi5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2FsZy90b3Bzb3J0LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvZGF0YS9wcmlvcml0eS1xdWV1ZS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvZ3JhcGhsaWIvbGliL2dyYXBoLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2dyYXBobGliL2xpYi9qc29uLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvbG9kYXNoLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9ncmFwaGxpYi9saWIvdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvaXMtYW55LWFycmF5L2xpYi1lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fRGF0YVZpZXcuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fSGFzaC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19MaXN0Q2FjaGUuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fTWFwLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX01hcENhY2hlLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1Byb21pc2UuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fU2V0LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1NldENhY2hlLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N0YWNrLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1N5bWJvbC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19VaW50OEFycmF5LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX1dlYWtNYXAuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXBwbHkuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlFYWNoLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5RmlsdGVyLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FycmF5SW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlJbmNsdWRlc1dpdGguanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlMaWtlS2V5cy5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheU1hcC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hcnJheVB1c2guanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlSZWR1Y2UuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYXJyYXlTb21lLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2FzY2lpU2l6ZS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19hc3NpZ25NZXJnZVZhbHVlLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc2lnblZhbHVlLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Fzc29jSW5kZXhPZi5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VBc3NpZ25Jbi5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlQXNzaWduVmFsdWUuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUNsb25lLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUVhY2guanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUV4dHJlbXVtLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGaWx0ZXIuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUZpbmRJbmRleC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRmxhdHRlbi5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlRm9yLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VGb3JPd24uanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUdldC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0QWxsS2V5cy5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlR2V0VGFnLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VHdC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSGFzLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VIYXNJbi5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSW5kZXhPZi5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWwuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzRXF1YWxEZWVwLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc01hcC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNNYXRjaC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNOYU4uanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZUlzTmF0aXZlLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJc1NldC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlSXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VJdGVyYXRlZS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5cy5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlS2V5c0luLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VMdC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlTWFwLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXRjaGVzLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNYXRjaGVzUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU1lcmdlLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VNZXJnZURlZXAuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZU9yZGVyQnkuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVBpY2suanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVBpY2tCeS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVByb3BlcnR5RGVlcC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUmFuZ2UuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVJlZHVjZS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlUmVzdC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU2V0LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VTZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlU29ydEJ5LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VUaW1lcy5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19iYXNlVG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVRyaW0uanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVVuYXJ5LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VVbmlxLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Jhc2VWYWx1ZXMuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVppcE9iamVjdC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jYWNoZUhhcy5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jYXN0RnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2FzdFBhdGguanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY2xvbmVBcnJheUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZUJ1ZmZlci5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jbG9uZURhdGFWaWV3LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lUmVnRXhwLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lU3ltYm9sLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2Nsb25lVHlwZWRBcnJheS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb21wYXJlQXNjZW5kaW5nLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvbXBhcmVNdWx0aXBsZS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5QXJyYXkuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY29weU9iamVjdC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5U3ltYm9scy5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jb3B5U3ltYm9sc0luLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NvcmVKc0RhdGEuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQXNzaWduZXIuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUVhY2guanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fY3JlYXRlQmFzZUZvci5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19jcmVhdGVGaW5kLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZVJhbmdlLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2NyZWF0ZVNldC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19kZWZpbmVQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbEFycmF5cy5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19lcXVhbEJ5VGFnLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2VxdWFsT2JqZWN0cy5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19mbGF0UmVzdC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19mcmVlR2xvYmFsLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldEFsbEtleXMuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0QWxsS2V5c0luLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE1hcERhdGEuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0TWF0Y2hEYXRhLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldE5hdGl2ZS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0UmF3VGFnLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFN5bWJvbHMuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fZ2V0U3ltYm9sc0luLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2dldFRhZy5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19nZXRWYWx1ZS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNQYXRoLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc1VuaWNvZGUuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaENsZWFyLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hEZWxldGUuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faGFzaEdldC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19oYXNoSGFzLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2hhc2hTZXQuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lQXJyYXkuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lQnlUYWcuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faW5pdENsb25lT2JqZWN0LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2lzRmxhdHRlbmFibGUuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNJbmRleC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0l0ZXJhdGVlQ2FsbC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19pc0tleWFibGUuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNNYXNrZWQuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNQcm90b3R5cGUuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9faXNTdHJpY3RDb21wYXJhYmxlLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZUNsZWFyLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZURlbGV0ZS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19saXN0Q2FjaGVHZXQuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbGlzdENhY2hlSGFzLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX2xpc3RDYWNoZVNldC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19tYXBDYWNoZUNsZWFyLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlRGVsZXRlLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlR2V0LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlSGFzLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcENhY2hlU2V0LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX21hcFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbWVtb2l6ZUNhcHBlZC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVDcmVhdGUuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbmF0aXZlS2V5cy5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19uYXRpdmVLZXlzSW4uanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fbm9kZVV0aWwuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb2JqZWN0VG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fb3ZlckFyZy5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19vdmVyUmVzdC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19yb290LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3NhZmVHZXQuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVBZGQuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0Q2FjaGVIYXMuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc2V0VG9BcnJheS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zZXRUb1N0cmluZy5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zaG9ydE91dC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdGFja0NsZWFyLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrRGVsZXRlLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrR2V0LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrSGFzLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0YWNrU2V0LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3N0cmljdEluZGV4T2YuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fc3RyaW5nU2l6ZS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL19zdHJpbmdUb1BhdGguanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9LZXkuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdG9Tb3VyY2UuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fdHJpbW1lZEVuZEluZGV4LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvX3VuaWNvZGVTaXplLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvY2xvbmUuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9jbG9uZURlZXAuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9jb25zdGFudC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2RlZmF1bHRzLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZWFjaC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2VxLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZmlsdGVyLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZmluZC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZpbmRJbmRleC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2ZsYXR0ZW4uanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9mb3JFYWNoLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvZm9ySW4uanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9nZXQuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9oYXMuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9oYXNJbi5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lkZW50aXR5LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcmd1bWVudHMuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNBcnJheUxpa2UuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0FycmF5TGlrZU9iamVjdC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzQnVmZmVyLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNFbXB0eS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzRnVuY3Rpb24uanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc0xlbmd0aC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzTWFwLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNPYmplY3QuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc09iamVjdExpa2UuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNTZXQuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9pc1N0cmluZy5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2lzU3ltYm9sLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNUeXBlZEFycmF5LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvaXNVbmRlZmluZWQuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9rZXlzLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gva2V5c0luLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbGFzdC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL21hcC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL21hcFZhbHVlcy5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL21heC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL21lbW9pemUuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9tZXJnZS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL21pbi5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL21pbkJ5LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvbm9vcC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL25vdy5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3BpY2suanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3JhbmdlLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvcmVkdWNlLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvc2l6ZS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3NvcnRCeS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJBcnJheS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3N0dWJGYWxzZS5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3RvRmluaXRlLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9JbnRlZ2VyLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9OdW1iZXIuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90b1BsYWluT2JqZWN0LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdG9TdHJpbmcuanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC91bmlvbi5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3VuaXF1ZUlkLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvdmFsdWVzLmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9sb2Rhc2gvemlwT2JqZWN0LmpzIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9tbC1hcnJheS1tYXgvbGliLWVzNi9pbmRleC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbWwtYXJyYXktbWluL2xpYi1lczYvaW5kZXguanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL21sLWFycmF5LXJlc2NhbGUvbGliLWVzNi9pbmRleC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbWwtbWF0cml4L21hdHJpeC5qcyIsIndlYnBhY2s6Ly9nNnIvLi9ub2RlX21vZHVsZXMvbWwtbWF0cml4L21hdHJpeC5tanMiLCJ3ZWJwYWNrOi8vZzZyLy4vbm9kZV9tb2R1bGVzL3RzbGliL3RzbGliLmVzNi5tanMiLCJ3ZWJwYWNrOi8vZzZyL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL2c2ci93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly9nNnIvd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovL2c2ci93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL2c2ci93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL2c2ci93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovL2c2ci93ZWJwYWNrL3J1bnRpbWUvbm9kZSBtb2R1bGUgZGVjb3JhdG9yIiwid2VicGFjazovL2c2ci8uL25vZGVfbW9kdWxlcy9AYW50di9sYXlvdXQvbGliL3dvcmtlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgV0lMRENBUkQgPSAnKic7XG4vKiBldmVudC1lbWl0dGVyICovXG52YXIgRXZlbnRFbWl0dGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIOebkeWQrOS4gOS4quS6i+S7tlxuICAgICAqIEBwYXJhbSBldnRcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgKiBAcGFyYW0gb25jZVxuICAgICAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXZ0LCBjYWxsYmFjaywgb25jZSkge1xuICAgICAgICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHNbZXZ0XSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2V2ZW50c1tldnRdLnB1c2goe1xuICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgICAgb25jZTogISFvbmNlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiDnm5HlkKzkuIDkuKrkuovku7bkuIDmrKFcbiAgICAgKiBAcGFyYW0gZXZ0XG4gICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKGV2dCwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub24oZXZ0LCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiDop6blj5HkuIDkuKrkuovku7ZcbiAgICAgKiBAcGFyYW0gZXZ0XG4gICAgICogQHBhcmFtIGFyZ3NcbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHNbZXZ0XSB8fCBbXTtcbiAgICAgICAgdmFyIHdpbGRjYXJkRXZlbnRzID0gdGhpcy5fZXZlbnRzW1dJTERDQVJEXSB8fCBbXTtcbiAgICAgICAgLy8g5a6e6ZmF55qE5aSE55CGIGVtaXQg5pa55rOVXG4gICAgICAgIHZhciBkb0VtaXQgPSBmdW5jdGlvbiAoZXMpIHtcbiAgICAgICAgICAgIHZhciBsZW5ndGggPSBlcy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlc1tpXSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gZXNbaV0sIGNhbGxiYWNrID0gX2EuY2FsbGJhY2ssIG9uY2UgPSBfYS5vbmNlO1xuICAgICAgICAgICAgICAgIGlmIChvbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF90aGlzLl9ldmVudHNbZXZ0XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZW5ndGgtLTtcbiAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShfdGhpcywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGRvRW1pdChldmVudHMpO1xuICAgICAgICBkb0VtaXQod2lsZGNhcmRFdmVudHMpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICog5Y+W5raI55uR5ZCs5LiA5Liq5LqL5Lu277yM5oiW6ICF5LiA5LiqY2hhbm5lbFxuICAgICAqIEBwYXJhbSBldnRcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uIChldnQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghZXZ0KSB7XG4gICAgICAgICAgICAvLyBldnQg5Li656m65YWo6YOo5riF6ZmkXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAvLyBldnQg5a2Y5Zyo77yMY2FsbGJhY2sg5Li656m677yM5riF6Zmk5LqL5Lu25omA5pyJ5pa55rOVXG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1tldnRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZXZ0IOWtmOWcqO+8jGNhbGxiYWNrIOWtmOWcqO+8jOa4hemZpOWMuemFjeeahFxuICAgICAgICAgICAgICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHNbZXZ0XSB8fCBbXTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoXzEgPSBldmVudHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoXzE7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRzW2ldLmNhbGxiYWNrID09PSBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aF8xLS07XG4gICAgICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1tldnRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8qIOW9k+WJjeaJgOacieeahOS6i+S7tiAqL1xuICAgIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0RXZlbnRzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzO1xuICAgIH07XG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcbn0oKSk7XG5leHBvcnQgZGVmYXVsdCBFdmVudEVtaXR0ZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ0BhbnR2L2V2ZW50LWVtaXR0ZXInO1xuaW1wb3J0IHsgR3JhcGhWaWV3IH0gZnJvbSAnLi9ncmFwaFZpZXcnO1xuaW1wb3J0IHsgZG9CRlMsIGRvREZTIH0gZnJvbSAnLi91dGlscy90cmF2ZXJzZSc7XG5leHBvcnQgY2xhc3MgR3JhcGggZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIG5vZGVNYXAgPSBuZXcgTWFwKCk7XG4gICAgZWRnZU1hcCA9IG5ldyBNYXAoKTtcbiAgICBpbkVkZ2VzTWFwID0gbmV3IE1hcCgpO1xuICAgIG91dEVkZ2VzTWFwID0gbmV3IE1hcCgpO1xuICAgIGJvdGhFZGdlc01hcCA9IG5ldyBNYXAoKTtcbiAgICB0cmVlSW5kaWNlcyA9IG5ldyBNYXAoKTtcbiAgICBjaGFuZ2VzID0gW107XG4gICAgYmF0Y2hDb3VudCA9IDA7XG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhIHtAbGluayBHcmFwaENoYW5nZWRFdmVudH0gZWFjaCB0aW1lIGEgZ3JhcGggY2hhbmdlIGhhcHBlbmVkLlxuICAgICAqXG4gICAgICogYGV2ZW50LmNoYW5nZXNgIGNvbnRhaW5zIGFsbCB0aGUgZ3JhcGggY2hhbmdlcyBpbiBvcmRlciBzaW5jZSBsYXN0IGBvbkNoYW5nZWRgLlxuICAgICAqL1xuICAgIG9uQ2hhbmdlZCA9ICgpID0+IHtcbiAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBHcmFwaCBpbnN0YW5jZS5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIHRvIGluaXRpYWxpemUgYSBncmFwaC4gU2VlIHtAbGluayBHcmFwaE9wdGlvbnN9LlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBncmFwaCA9IG5ldyBHcmFwaCh7XG4gICAgICogICAvLyBPcHRpb25hbCwgaW5pdGlhbCBub2Rlcy5cbiAgICAgKiAgIG5vZGVzOiBbXG4gICAgICogICAgIC8vIEVhY2ggbm9kZSBoYXMgYSB1bmlxdWUgSUQuXG4gICAgICogICAgIHsgaWQ6ICdBJywgZm9vOiAxIH0sXG4gICAgICogICAgIHsgaWQ6ICdCJywgZm9vOiAxIH0sXG4gICAgICogICBdLFxuICAgICAqICAgLy8gT3B0aW9uYWwsIGluaXRpYWwgZWRnZXMuXG4gICAgICogICBlZGdlczogW1xuICAgICAqICAgICB7IGlkOiAnQycsIHNvdXJjZTogJ0InLCB0YXJnZXQ6ICdCJywgd2VpZ2h0OiAxIH0sXG4gICAgICogICBdLFxuICAgICAqICAgLy8gT3B0aW9uYWwsIGNhbGxlZCB3aXRoIGEgR3JhcGhDaGFuZ2VkRXZlbnQuXG4gICAgICogICBvbkNoYW5nZWQ6IChldmVudCkgPT4ge1xuICAgICAqICAgICBjb25zb2xlLmxvZyhldmVudCk7XG4gICAgICogICB9XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoIW9wdGlvbnMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChvcHRpb25zLm5vZGVzKVxuICAgICAgICAgICAgdGhpcy5hZGROb2RlcyhvcHRpb25zLm5vZGVzKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZWRnZXMpXG4gICAgICAgICAgICB0aGlzLmFkZEVkZ2VzKG9wdGlvbnMuZWRnZXMpO1xuICAgICAgICBpZiAob3B0aW9ucy50cmVlKVxuICAgICAgICAgICAgdGhpcy5hZGRUcmVlKG9wdGlvbnMudHJlZSk7XG4gICAgICAgIGlmIChvcHRpb25zLm9uQ2hhbmdlZClcbiAgICAgICAgICAgIHRoaXMub25DaGFuZ2VkID0gb3B0aW9ucy5vbkNoYW5nZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJhdGNoIHNldmVyYWwgZ3JhcGggY2hhbmdlcyBpbnRvIG9uZS5cbiAgICAgKlxuICAgICAqIE1ha2Ugc2V2ZXJhbCBjaGFuZ2VzLCBidXQgZGlzcGF0Y2ggb25seSBvbmUgQ2hhbmdlZEV2ZW50IGF0IHRoZSBlbmQgb2YgYmF0Y2g6XG4gICAgICogYGBgdHNcbiAgICAgKiBncmFwaC5iYXRjaCgoKSA9PiB7XG4gICAgICogICBncmFwaC5hZGROb2RlcyhbXSk7XG4gICAgICogICBncmFwaC5hZGRFZGdlcyhbXSk7XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBCYXRjaGVzIGNhbiBiZSBuZXN0ZWQuIE9ubHkgdGhlIG91dGVybW9zdCBiYXRjaCB3aWxsIGRpc3BhdGNoIGEgQ2hhbmdlZEV2ZW50OlxuICAgICAqIGBgYHRzXG4gICAgICogZ3JhcGguYmF0Y2goKCkgPT4ge1xuICAgICAqICAgZ3JhcGguYWRkTm9kZXMoW10pO1xuICAgICAqICAgZ3JhcGguYmF0Y2goKCkgPT4ge1xuICAgICAqICAgICBncmFwaC5hZGRFZGdlcyhbXSk7XG4gICAgICogICB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBiYXRjaCA9IChmbikgPT4ge1xuICAgICAgICB0aGlzLmJhdGNoQ291bnQgKz0gMTtcbiAgICAgICAgZm4oKTtcbiAgICAgICAgdGhpcy5iYXRjaENvdW50IC09IDE7XG4gICAgICAgIGlmICghdGhpcy5iYXRjaENvdW50KSB7XG4gICAgICAgICAgICB0aGlzLmNvbW1pdCgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNldCBjaGFuZ2VzIGFuZCBkaXNwYXRjaCBhIENoYW5nZWRFdmVudC5cbiAgICAgKi9cbiAgICBjb21taXQoKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSB0aGlzLmNoYW5nZXM7XG4gICAgICAgIHRoaXMuY2hhbmdlcyA9IFtdO1xuICAgICAgICBjb25zdCBldmVudCA9IHtcbiAgICAgICAgICAgIGdyYXBoOiB0aGlzLFxuICAgICAgICAgICAgY2hhbmdlcyxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbWl0KCdjaGFuZ2VkJywgZXZlbnQpO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlZChldmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZHVjZSB0aGUgbnVtYmVyIG9mIG9yZGVyZWQgZ3JhcGggY2hhbmdlcyBieSBkcm9wcGluZyBvciBtZXJnaW5nIHVubmVjZXNzYXJ5IGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSwgaWYgd2UgdXBkYXRlIGEgbm9kZSBhbmQgcmVtb3ZlIGl0IGluIGEgYmF0Y2g6XG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGdyYXBoLmJhdGNoKCgpID0+IHtcbiAgICAgKiAgIGdyYXBoLnVwZGF0ZU5vZGVEYXRhKCdBJywgJ2ZvbycsIDIpO1xuICAgICAqICAgZ3JhcGgucmVtb3ZlTm9kZSgnQScpO1xuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogV2UgZ2V0IDIgYXRvbWljIGdyYXBoIGNoYW5nZXMgbGlrZVxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBbXG4gICAgICogICB7IHR5cGU6ICdOb2RlRGF0YVVwZGF0ZWQnLCBpZDogJ0EnLCBwcm9wZXJ0eU5hbWU6ICdmb28nLCBvbGRWYWx1ZTogMSwgbmV3VmFsdWU6IDIgfSxcbiAgICAgKiAgIHsgdHlwZTogJ05vZGVSZW1vdmVkJywgdmFsdWU6IHsgaWQ6ICdBJywgZGF0YTogeyBmb286IDIgfSB9LFxuICAgICAqIF1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFNpbmNlIG5vZGUgJ0EnIGhhcyBiZWVuIHJlbW92ZWQsIHdlIGFjdHVhbGx5IGhhdmUgbm8gbmVlZCB0byBoYW5kbGUgd2l0aCBOb2RlRGF0YVVwZGF0ZWQgY2hhbmdlLlxuICAgICAqXG4gICAgICogYHJlZHVjZUNoYW5nZXMoKWAgaGVyZSBoZWxwcyB1cyByZW1vdmUgc3VjaCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIHJlZHVjZUNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBsZXQgbWVyZ2VkQ2hhbmdlcyA9IFtdO1xuICAgICAgICBjaGFuZ2VzLmZvckVhY2goKGNoYW5nZSkgPT4ge1xuICAgICAgICAgICAgc3dpdGNoIChjaGFuZ2UudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ05vZGVSZW1vdmVkJzoge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb2RlQWRkZWQ6IEEgYWRkZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vZGVEYXRhVXBkYXRlZDogQSBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgICAgICAvLyBUcmVlU3RydWN0dXJlQ2hhbmdlZDogQSdzIHBhcmVudCBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgICAgICAvLyBOb2RlUmVtb3ZlZDogQSByZW1vdmVkLiDwn5GI8J+PuyBTaW5jZSBBIHdhcyByZW1vdmVkLCBhYm92ZSB0aHJlZSBjaGFuZ2VzIG1heSBiZSBpZ25vcmVkLlxuICAgICAgICAgICAgICAgICAgICBsZXQgaXNOZXdseUFkZGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIG1lcmdlZENoYW5nZXMgPSBtZXJnZWRDaGFuZ2VzLmZpbHRlcigocGFzdENoYW5nZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhc3RDaGFuZ2UudHlwZSA9PT0gJ05vZGVBZGRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzYW1lSWQgPSBwYXN0Q2hhbmdlLnZhbHVlLmlkID09PSBjaGFuZ2UudmFsdWUuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNhbWVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc05ld2x5QWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXNhbWVJZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHBhc3RDaGFuZ2UudHlwZSA9PT0gJ05vZGVEYXRhVXBkYXRlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFzdENoYW5nZS5pZCAhPT0gY2hhbmdlLnZhbHVlLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocGFzdENoYW5nZS50eXBlID09PSAnVHJlZVN0cnVjdHVyZUNoYW5nZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhc3RDaGFuZ2Uubm9kZUlkICE9PSBjaGFuZ2UudmFsdWUuaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOZXdseUFkZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZWRDaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAnRWRnZVJlbW92ZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVkZ2VBZGRlZDogQSBhZGRlZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gRWRnZURhdGFVcGRhdGVkOiBBIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIEVkZ2VEYXRhVXBkYXRlZDogQSdzIHNvdXJjZS90YXJnZXQgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gRWRnZVJlbW92ZWQ6IEEgcmVtb3ZlZC4g8J+RiPCfj7sgU2luY2UgQSB3YXMgcmVtb3ZlZCwgYWJvdmUgdGhyZWUgY2hhbmdlcyBtYXkgYmUgaWdub3JlZC5cbiAgICAgICAgICAgICAgICAgICAgbGV0IGlzTmV3bHlBZGRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBtZXJnZWRDaGFuZ2VzID0gbWVyZ2VkQ2hhbmdlcy5maWx0ZXIoKHBhc3RDaGFuZ2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXN0Q2hhbmdlLnR5cGUgPT09ICdFZGdlQWRkZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2FtZUlkID0gcGFzdENoYW5nZS52YWx1ZS5pZCA9PT0gY2hhbmdlLnZhbHVlLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzYW1lSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNOZXdseUFkZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICFzYW1lSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXN0Q2hhbmdlLnR5cGUgPT09ICdFZGdlRGF0YVVwZGF0ZWQnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzdENoYW5nZS50eXBlID09PSAnRWRnZVVwZGF0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhc3RDaGFuZ2UuaWQgIT09IGNoYW5nZS52YWx1ZS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05ld2x5QWRkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlZENoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdOb2RlRGF0YVVwZGF0ZWQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ0VkZ2VEYXRhVXBkYXRlZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnRWRnZVVwZGF0ZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vZGVEYXRhVXBkYXRlZDogeyBpZDogQSwgcHJvcGVydHlOYW1lOiAnZm9vJywgb2xkVmFsdWU6IDEsIG5ld1ZhbHVlOiAyIH0uXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vZGVEYXRhVXBkYXRlZDogeyBpZDogQSwgcHJvcGVydHlOYW1lOiAnZm9vJywgb2xkVmFsdWU6IDIsIG5ld1ZhbHVlOiAzIH0uXG4gICAgICAgICAgICAgICAgICAgIC8vIPCfkYYgQ291bGQgYmUgbWVyZ2VkIGFzIHsgaWQ6IEEsIHByb3BlcnR5TmFtZTogJ2ZvbycsIG9sZFZhbHVlOiAxLCBuZXdWYWx1ZTogMyB9LlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IG1lcmdlZENoYW5nZXMuZmluZEluZGV4KChwYXN0Q2hhbmdlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKHBhc3RDaGFuZ2UudHlwZSA9PT0gY2hhbmdlLnR5cGUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXN0Q2hhbmdlLmlkID09PSBjaGFuZ2UuaWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2hhbmdlLnByb3BlcnR5TmFtZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3RDaGFuZ2UucHJvcGVydHlOYW1lID09PSBjaGFuZ2UucHJvcGVydHlOYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ0NoYW5nZSA9IG1lcmdlZENoYW5nZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2UucHJvcGVydHlOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgaW5jb21pbmcgY2hhbmdlIGlzIG9mIHRoZSBzYW1lIHByb3BlcnR5IG9mIGV4aXN0aW5nIGNoYW5nZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0NoYW5nZS5uZXdWYWx1ZSA9IGNoYW5nZS5uZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBpbmNvbWluZyBjaGFuZ2UgaXMgYSB3aG9sZSBkYXRhIG92ZXJyaWRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlZENoYW5nZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXJnZWRDaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlZENoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdUcmVlU3RydWN0dXJlRGV0YWNoZWQnOiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyZWVTdHJ1Y3R1cmVBdHRhY2hlZFxuICAgICAgICAgICAgICAgICAgICAvLyBUcmVlU3RydWN0dXJlQ2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICAvLyBUcmVlU3RydWN0dXJlRGV0YWNoZWQg8J+RiPCfj7sgU2luY2UgdGhlIHRyZWUgc3RydWN0IHdhcyBkZXRhY2hlZCwgYWJvdmUgMiBjaGFuZ2VzIG1heSBiZSBpZ25vcmVkLlxuICAgICAgICAgICAgICAgICAgICBtZXJnZWRDaGFuZ2VzID0gbWVyZ2VkQ2hhbmdlcy5maWx0ZXIoKHBhc3RDaGFuZ2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXN0Q2hhbmdlLnR5cGUgPT09ICdUcmVlU3RydWN0dXJlQXR0YWNoZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhc3RDaGFuZ2UudHJlZUtleSAhPT0gY2hhbmdlLnRyZWVLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXN0Q2hhbmdlLnR5cGUgPT09ICdUcmVlU3RydWN0dXJlQ2hhbmdlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFzdENoYW5nZS50cmVlS2V5ICE9PSBjaGFuZ2UudHJlZUtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VkQ2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlICdUcmVlU3RydWN0dXJlQ2hhbmdlZCc6IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdDaGFuZ2UgPSBtZXJnZWRDaGFuZ2VzLmZpbmQoKHBhc3RDaGFuZ2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAocGFzdENoYW5nZS50eXBlID09PSAnVHJlZVN0cnVjdHVyZUNoYW5nZWQnICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzdENoYW5nZS50cmVlS2V5ID09PSBjaGFuZ2UudHJlZUtleSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3RDaGFuZ2Uubm9kZUlkID09PSBjaGFuZ2Uubm9kZUlkKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0NoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdDaGFuZ2UubmV3UGFyZW50SWQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZS5uZXdQYXJlbnRJZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lcmdlZENoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBtZXJnZWRDaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWVyZ2VkQ2hhbmdlcztcbiAgICB9XG4gICAgLy8gPT09PT09PT09PT09PT09PT0gTm9kZSA9PT09PT09PT09PT09PT09PVxuICAgIGNoZWNrTm9kZUV4aXN0ZW5jZShpZCkge1xuICAgICAgICB0aGlzLmdldE5vZGUoaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhIG5vZGUgZXhpc3RzIGluIHRoZSBncmFwaC5cbiAgICAgKiBAZ3JvdXAgTm9kZU1ldGhvZHNcbiAgICAgKi9cbiAgICBoYXNOb2RlKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVNYXAuaGFzKGlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGVsbCBpZiB0d28gbm9kZXMgYXJlIG5laWdoYm9ycy5cbiAgICAgKiBAZ3JvdXAgTm9kZU1ldGhvZHNcbiAgICAgKi9cbiAgICBhcmVOZWlnaGJvcnMoZmlyc3ROb2RlSWQsIHNlY29uZE5vZGVJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXROZWlnaGJvcnMoc2Vjb25kTm9kZUlkKS5zb21lKChuZWlnaGJvcikgPT4gbmVpZ2hib3IuaWQgPT09IGZpcnN0Tm9kZUlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBub2RlIGRhdGEgd2l0aCBnaXZlbiBJRC5cbiAgICAgKiBAZ3JvdXAgTm9kZU1ldGhvZHNcbiAgICAgKi9cbiAgICBnZXROb2RlKGlkKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGVNYXAuZ2V0KGlkKTtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vZGUgbm90IGZvdW5kIGZvciBpZDogJyArIGlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBub2RlIElELCBmaW5kIGFsbCBlZGdlcyBvZiB0aGUgbm9kZS5cbiAgICAgKiBAcGFyYW0gaWQgLSBJRCBvZiB0aGUgbm9kZVxuICAgICAqIEBwYXJhbSBkaXJlY3Rpb24gLSBFZGdlIGRpcmVjdGlvbiwgZGVmYXVsdHMgdG8gJ2JvdGgnLlxuICAgICAqIEBncm91cCBOb2RlTWV0aG9kc1xuICAgICAqL1xuICAgIGdldFJlbGF0ZWRFZGdlcyhpZCwgZGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuY2hlY2tOb2RlRXhpc3RlbmNlKGlkKTtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gJ2luJykge1xuICAgICAgICAgICAgY29uc3QgaW5FZGdlcyA9IHRoaXMuaW5FZGdlc01hcC5nZXQoaWQpO1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oaW5FZGdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGlyZWN0aW9uID09PSAnb3V0Jykge1xuICAgICAgICAgICAgY29uc3Qgb3V0RWRnZXMgPSB0aGlzLm91dEVkZ2VzTWFwLmdldChpZCk7XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShvdXRFZGdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBib3RoRWRnZXMgPSB0aGlzLmJvdGhFZGdlc01hcC5nZXQoaWQpO1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oYm90aEVkZ2VzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRlZ3JlZSBvZiB0aGUgZ2l2ZW4gbm9kZS5cbiAgICAgKiBAZ3JvdXAgTm9kZU1ldGhvZHNcbiAgICAgKi9cbiAgICBnZXREZWdyZWUoaWQsIGRpcmVjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRSZWxhdGVkRWRnZXMoaWQsIGRpcmVjdGlvbikubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIHN1Y2Nlc3NvcnMgb2YgdGhlIGdpdmVuIG5vZGUuXG4gICAgICovXG4gICAgZ2V0U3VjY2Vzc29ycyhpZCkge1xuICAgICAgICBjb25zdCBvdXRFZGdlcyA9IHRoaXMuZ2V0UmVsYXRlZEVkZ2VzKGlkLCAnb3V0Jyk7XG4gICAgICAgIGNvbnN0IHRhcmdldHMgPSBvdXRFZGdlcy5tYXAoKGVkZ2UpID0+IHRoaXMuZ2V0Tm9kZShlZGdlLnRhcmdldCkpO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KHRhcmdldHMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBwcmVkZWNlc3NvcnMgb2YgdGhlIGdpdmVuIG5vZGUuXG4gICAgICovXG4gICAgZ2V0UHJlZGVjZXNzb3JzKGlkKSB7XG4gICAgICAgIGNvbnN0IGluRWRnZXMgPSB0aGlzLmdldFJlbGF0ZWRFZGdlcyhpZCwgJ2luJyk7XG4gICAgICAgIGNvbnN0IHNvdXJjZXMgPSBpbkVkZ2VzLm1hcCgoZWRnZSkgPT4gdGhpcy5nZXROb2RlKGVkZ2Uuc291cmNlKSk7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQoc291cmNlcykpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhIG5vZGUgSUQsIGZpbmQgaXRzIG5laWdoYm9ycy5cbiAgICAgKiBAcGFyYW0gaWQgLSBJRCBvZiB0aGUgbm9kZVxuICAgICAqIEBncm91cCBOb2RlTWV0aG9kc1xuICAgICAqL1xuICAgIGdldE5laWdoYm9ycyhpZCkge1xuICAgICAgICBjb25zdCBwcmVkZWNlc3NvcnMgPSB0aGlzLmdldFByZWRlY2Vzc29ycyhpZCk7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3NvcnMgPSB0aGlzLmdldFN1Y2Nlc3NvcnMoaWQpO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KFsuLi5wcmVkZWNlc3NvcnMsIC4uLnN1Y2Nlc3NvcnNdKSk7XG4gICAgfVxuICAgIGRvQWRkTm9kZShub2RlKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc05vZGUobm9kZS5pZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm9kZSBhbHJlYWR5IGV4aXN0czogJyArIG5vZGUuaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZU1hcC5zZXQobm9kZS5pZCwgbm9kZSk7XG4gICAgICAgIHRoaXMuaW5FZGdlc01hcC5zZXQobm9kZS5pZCwgbmV3IFNldCgpKTtcbiAgICAgICAgdGhpcy5vdXRFZGdlc01hcC5zZXQobm9kZS5pZCwgbmV3IFNldCgpKTtcbiAgICAgICAgdGhpcy5ib3RoRWRnZXNNYXAuc2V0KG5vZGUuaWQsIG5ldyBTZXQoKSk7XG4gICAgICAgIHRoaXMudHJlZUluZGljZXMuZm9yRWFjaCgodHJlZSkgPT4ge1xuICAgICAgICAgICAgdHJlZS5jaGlsZHJlbk1hcC5zZXQobm9kZS5pZCwgbmV3IFNldCgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5wdXNoKHsgdHlwZTogJ05vZGVBZGRlZCcsIHZhbHVlOiBub2RlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYWxsIG5vZGVzIG9mIHRoZSBnaXZlbiBhcnJheSwgb3IgaXRlcmFibGUsIGludG8gdGhlIGdyYXBoLlxuICAgICAqIEBncm91cCBOb2RlTWV0aG9kc1xuICAgICAqL1xuICAgIGFkZE5vZGVzKG5vZGVzKSB7XG4gICAgICAgIHRoaXMuYmF0Y2goKCkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kb0FkZE5vZGUobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBzaW5nbGUgbm9kZSBpbnRvIHRoZSBncmFwaC5cbiAgICAgKiBAZ3JvdXAgTm9kZU1ldGhvZHNcbiAgICAgKi9cbiAgICBhZGROb2RlKG5vZGUpIHtcbiAgICAgICAgdGhpcy5hZGROb2Rlcyhbbm9kZV0pO1xuICAgIH1cbiAgICBkb1JlbW92ZU5vZGUoaWQpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0Tm9kZShpZCk7XG4gICAgICAgIGNvbnN0IGJvdGhFZGdlcyA9IHRoaXMuYm90aEVkZ2VzTWFwLmdldChpZCk7XG4gICAgICAgIGJvdGhFZGdlcz8uZm9yRWFjaCgoZWRnZSkgPT4gdGhpcy5kb1JlbW92ZUVkZ2UoZWRnZS5pZCkpO1xuICAgICAgICB0aGlzLm5vZGVNYXAuZGVsZXRlKGlkKTtcbiAgICAgICAgdGhpcy50cmVlSW5kaWNlcy5mb3JFYWNoKCh0cmVlKSA9PiB7XG4gICAgICAgICAgICB0cmVlLmNoaWxkcmVuTWFwLmdldChpZCk/LmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJlZS5wYXJlbnRNYXAuZGVsZXRlKGNoaWxkLmlkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gdHJlZS5wYXJlbnRNYXAuZ2V0KGlkKTtcbiAgICAgICAgICAgIGlmIChwYXJlbnQpXG4gICAgICAgICAgICAgICAgdHJlZS5jaGlsZHJlbk1hcC5nZXQocGFyZW50LmlkKT8uZGVsZXRlKG5vZGUpO1xuICAgICAgICAgICAgdHJlZS5wYXJlbnRNYXAuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIHRyZWUuY2hpbGRyZW5NYXAuZGVsZXRlKGlkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuYm90aEVkZ2VzTWFwLmRlbGV0ZShpZCk7XG4gICAgICAgIHRoaXMuaW5FZGdlc01hcC5kZWxldGUoaWQpO1xuICAgICAgICB0aGlzLm91dEVkZ2VzTWFwLmRlbGV0ZShpZCk7XG4gICAgICAgIHRoaXMuY2hhbmdlcy5wdXNoKHsgdHlwZTogJ05vZGVSZW1vdmVkJywgdmFsdWU6IG5vZGUgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBub2RlcyBhbmQgdGhlaXIgYXR0YWNoZWQgZWRnZXMgZnJvbSB0aGUgZ3JhcGguXG4gICAgICogQGdyb3VwIE5vZGVNZXRob2RzXG4gICAgICovXG4gICAgcmVtb3ZlTm9kZXMoaWRMaXN0KSB7XG4gICAgICAgIHRoaXMuYmF0Y2goKCkgPT4ge1xuICAgICAgICAgICAgaWRMaXN0LmZvckVhY2goKGlkKSA9PiB0aGlzLmRvUmVtb3ZlTm9kZShpZCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgc2luZ2xlIG5vZGUgYW5kIGl0cyBhdHRhY2hlZCBlZGdlcyBmcm9tIHRoZSBncmFwaC5cbiAgICAgKiBAZ3JvdXAgTm9kZU1ldGhvZHNcbiAgICAgKi9cbiAgICByZW1vdmVOb2RlKGlkKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTm9kZXMoW2lkXSk7XG4gICAgfVxuICAgIHVwZGF0ZU5vZGVEYXRhUHJvcGVydHkoaWQsIHByb3BlcnR5TmFtZSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0Tm9kZShpZCk7XG4gICAgICAgIHRoaXMuYmF0Y2goKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBub2RlLmRhdGFbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICBub2RlLmRhdGFbcHJvcGVydHlOYW1lXSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdOb2RlRGF0YVVwZGF0ZWQnLFxuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZSxcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSxcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlrZSBPYmplY3QuYXNzaWduLCBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiBgcGF0aGAgdG8gdGhlIG5vZGUgZGF0YS5cbiAgICAgKiBAcGFyYW0gaWQgTm9kZSBJRC5cbiAgICAgKiBAcGFyYW0gcGF0Y2ggQSBkYXRhIG9iamVjdCB0byBtZXJnZS5cbiAgICAgKi9cbiAgICBtZXJnZU5vZGVEYXRhKGlkLCBwYXRjaCkge1xuICAgICAgICB0aGlzLmJhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHBhdGNoKS5mb3JFYWNoKChbcHJvcGVydHlOYW1lLCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZU5vZGVEYXRhUHJvcGVydHkoaWQsIHByb3BlcnR5TmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGVOb2RlRGF0YSguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGlkID0gYXJnc1swXTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ2V0Tm9kZShpZCk7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIC8vIGlkLCBwcm9wZXJ0eU5hbWUsIHZhbHVlXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU5vZGVEYXRhUHJvcGVydHkoaWQsIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkYXRhO1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGlkLCB1cGRhdGVcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZSA9IGFyZ3NbMV07XG4gICAgICAgICAgICBkYXRhID0gdXBkYXRlKG5vZGUuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFyZ3NbMV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvLyBpZCwgZGF0YVxuICAgICAgICAgICAgZGF0YSA9IGFyZ3NbMV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvbGRWYWx1ZSA9IG5vZGUuZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gZGF0YTtcbiAgICAgICAgICAgIG5vZGUuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ05vZGVEYXRhVXBkYXRlZCcsXG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgb2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vID09PT09PT09PT09PT09PT09IEVkZ2UgPT09PT09PT09PT09PT09PT1cbiAgICBjaGVja0VkZ2VFeGlzdGVuY2UoaWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0VkZ2UoaWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VkZ2Ugbm90IGZvdW5kIGZvciBpZDogJyArIGlkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBhbiBlZGdlIGV4aXN0cyBpbiB0aGUgZ3JhcGguXG4gICAgICogQGdyb3VwIE5vZGVNZXRob2RzXG4gICAgICovXG4gICAgaGFzRWRnZShpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGdlTWFwLmhhcyhpZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZWRnZSBkYXRhIHdpdGggZ2l2ZW4gSUQuXG4gICAgICogQGdyb3VwIEVkZ2VNZXRob2RzXG4gICAgICovXG4gICAgZ2V0RWRnZShpZCkge1xuICAgICAgICB0aGlzLmNoZWNrRWRnZUV4aXN0ZW5jZShpZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmVkZ2VNYXAuZ2V0KGlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBlZGdlLCB0aGUgc291cmNlIG5vZGUsIGFuZCB0aGUgdGFyZ2V0IG5vZGUgYnkgYW4gZWRnZSBJRC5cbiAgICAgKiBAZ3JvdXAgRWRnZU1ldGhvZHNcbiAgICAgKi9cbiAgICBnZXRFZGdlRGV0YWlsKGlkKSB7XG4gICAgICAgIGNvbnN0IGVkZ2UgPSB0aGlzLmdldEVkZ2UoaWQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZWRnZSxcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcy5nZXROb2RlKGVkZ2Uuc291cmNlKSxcbiAgICAgICAgICAgIHRhcmdldDogdGhpcy5nZXROb2RlKGVkZ2UudGFyZ2V0KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZG9BZGRFZGdlKGVkZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzRWRnZShlZGdlLmlkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFZGdlIGFscmVhZHkgZXhpc3RzOiAnICsgZWRnZS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja05vZGVFeGlzdGVuY2UoZWRnZS5zb3VyY2UpO1xuICAgICAgICB0aGlzLmNoZWNrTm9kZUV4aXN0ZW5jZShlZGdlLnRhcmdldCk7XG4gICAgICAgIHRoaXMuZWRnZU1hcC5zZXQoZWRnZS5pZCwgZWRnZSk7XG4gICAgICAgIGNvbnN0IGluRWRnZXMgPSB0aGlzLmluRWRnZXNNYXAuZ2V0KGVkZ2UudGFyZ2V0KTtcbiAgICAgICAgY29uc3Qgb3V0RWRnZXMgPSB0aGlzLm91dEVkZ2VzTWFwLmdldChlZGdlLnNvdXJjZSk7XG4gICAgICAgIGNvbnN0IGJvdGhFZGdlc09mU291cmNlID0gdGhpcy5ib3RoRWRnZXNNYXAuZ2V0KGVkZ2Uuc291cmNlKTtcbiAgICAgICAgY29uc3QgYm90aEVkZ2VzT2ZUYXJnZXQgPSB0aGlzLmJvdGhFZGdlc01hcC5nZXQoZWRnZS50YXJnZXQpO1xuICAgICAgICBpbkVkZ2VzLmFkZChlZGdlKTtcbiAgICAgICAgb3V0RWRnZXMuYWRkKGVkZ2UpO1xuICAgICAgICBib3RoRWRnZXNPZlNvdXJjZS5hZGQoZWRnZSk7XG4gICAgICAgIGJvdGhFZGdlc09mVGFyZ2V0LmFkZChlZGdlKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VzLnB1c2goeyB0eXBlOiAnRWRnZUFkZGVkJywgdmFsdWU6IGVkZ2UgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhbGwgZWRnZXMgb2YgdGhlIGdpdmVuIGl0ZXJhYmxlKGFuIGFycmF5LCBhIHNldCwgZXRjLikgaW50byB0aGUgZ3JhcGguXG4gICAgICogQGdyb3VwIEVkZ2VNZXRob2RzXG4gICAgICovXG4gICAgYWRkRWRnZXMoZWRnZXMpIHtcbiAgICAgICAgdGhpcy5iYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgZWRnZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQWRkRWRnZShlZGdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIHNpbmdsZSBlZGdlIHBvaW50aW5nIGZyb20gYHNvdXJjZWAgdG8gYHRhcmdldGAgaW50byB0aGUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBgYGB0c1xuICAgICAqIGdyYXBoLmFkZE5vZGUoeyBpZDogJ05vZGVBJyB9KTtcbiAgICAgKiBncmFwaC5hZGROb2RlKHsgaWQ6ICdOb2RlQicgfSk7XG4gICAgICogZ3JhcGguYWRkRWRnZSh7IGlkOiAnRWRnZUEnLCBzb3VyY2U6ICdOb2RlQScsIHRhcmdldDogJ05vZGVCJyB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIElmIGBzb3VyY2VgIG9yIGB0YXJnZXRgIHdlcmUgbm90IGZvdW5kIGluIHRoZSBjdXJyZW50IGdyYXBoLCBpdCB0aHJvd3MgYW4gRXJyb3IuXG4gICAgICogQGdyb3VwIEVkZ2VNZXRob2RzXG4gICAgICovXG4gICAgYWRkRWRnZShlZGdlKSB7XG4gICAgICAgIHRoaXMuYWRkRWRnZXMoW2VkZ2VdKTtcbiAgICB9XG4gICAgZG9SZW1vdmVFZGdlKGlkKSB7XG4gICAgICAgIGNvbnN0IGVkZ2UgPSB0aGlzLmdldEVkZ2UoaWQpO1xuICAgICAgICBjb25zdCBvdXRFZGdlcyA9IHRoaXMub3V0RWRnZXNNYXAuZ2V0KGVkZ2Uuc291cmNlKTtcbiAgICAgICAgY29uc3QgaW5FZGdlcyA9IHRoaXMuaW5FZGdlc01hcC5nZXQoZWRnZS50YXJnZXQpO1xuICAgICAgICBjb25zdCBib3RoRWRnZXNPZlNvdXJjZSA9IHRoaXMuYm90aEVkZ2VzTWFwLmdldChlZGdlLnNvdXJjZSk7XG4gICAgICAgIGNvbnN0IGJvdGhFZGdlc09mVGFyZ2V0ID0gdGhpcy5ib3RoRWRnZXNNYXAuZ2V0KGVkZ2UudGFyZ2V0KTtcbiAgICAgICAgb3V0RWRnZXMuZGVsZXRlKGVkZ2UpO1xuICAgICAgICBpbkVkZ2VzLmRlbGV0ZShlZGdlKTtcbiAgICAgICAgYm90aEVkZ2VzT2ZTb3VyY2UuZGVsZXRlKGVkZ2UpO1xuICAgICAgICBib3RoRWRnZXNPZlRhcmdldC5kZWxldGUoZWRnZSk7XG4gICAgICAgIHRoaXMuZWRnZU1hcC5kZWxldGUoaWQpO1xuICAgICAgICB0aGlzLmNoYW5nZXMucHVzaCh7IHR5cGU6ICdFZGdlUmVtb3ZlZCcsIHZhbHVlOiBlZGdlIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZWRnZXMgd2hvc2UgaWQgd2FzIGluY2x1ZGVkIGluIHRoZSBnaXZlbiBpZCBsaXN0LlxuICAgICAqIEBncm91cCBFZGdlTWV0aG9kc1xuICAgICAqL1xuICAgIHJlbW92ZUVkZ2VzKGlkTGlzdCkge1xuICAgICAgICB0aGlzLmJhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIGlkTGlzdC5mb3JFYWNoKChpZCkgPT4gdGhpcy5kb1JlbW92ZUVkZ2UoaWQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIHNpbmdsZSBlZGdlIG9mIHRoZSBnaXZlbiBpZC5cbiAgICAgKiBAZ3JvdXAgRWRnZU1ldGhvZHNcbiAgICAgKi9cbiAgICByZW1vdmVFZGdlKGlkKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRWRnZXMoW2lkXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0aGUgc291cmNlIG9mIGFuIGVkZ2UuIFRoZSBzb3VyY2UgbXVzdCBiZSBmb3VuZCBpbiBjdXJyZW50IGdyYXBoLlxuICAgICAqIEBncm91cCBFZGdlTWV0aG9kc1xuICAgICAqL1xuICAgIHVwZGF0ZUVkZ2VTb3VyY2UoaWQsIHNvdXJjZSkge1xuICAgICAgICBjb25zdCBlZGdlID0gdGhpcy5nZXRFZGdlKGlkKTtcbiAgICAgICAgdGhpcy5jaGVja05vZGVFeGlzdGVuY2Uoc291cmNlKTtcbiAgICAgICAgY29uc3Qgb2xkU291cmNlID0gZWRnZS5zb3VyY2U7XG4gICAgICAgIGNvbnN0IG5ld1NvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5vdXRFZGdlc01hcC5nZXQob2xkU291cmNlKS5kZWxldGUoZWRnZSk7XG4gICAgICAgIHRoaXMuYm90aEVkZ2VzTWFwLmdldChvbGRTb3VyY2UpLmRlbGV0ZShlZGdlKTtcbiAgICAgICAgdGhpcy5vdXRFZGdlc01hcC5nZXQobmV3U291cmNlKS5hZGQoZWRnZSk7XG4gICAgICAgIHRoaXMuYm90aEVkZ2VzTWFwLmdldChuZXdTb3VyY2UpLmFkZChlZGdlKTtcbiAgICAgICAgZWRnZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuYmF0Y2goKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdFZGdlVXBkYXRlZCcsXG4gICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lOiAnc291cmNlJyxcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZTogb2xkU291cmNlLFxuICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiBuZXdTb3VyY2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoYW5nZSB0aGUgdGFyZ2V0IG9mIGFuIGVkZ2UuIFRoZSB0YXJnZXQgbXVzdCBiZSBmb3VuZCBpbiBjdXJyZW50IGdyYXBoLlxuICAgICAqIEBncm91cCBFZGdlTWV0aG9kc1xuICAgICAqL1xuICAgIHVwZGF0ZUVkZ2VUYXJnZXQoaWQsIHRhcmdldCkge1xuICAgICAgICBjb25zdCBlZGdlID0gdGhpcy5nZXRFZGdlKGlkKTtcbiAgICAgICAgdGhpcy5jaGVja05vZGVFeGlzdGVuY2UodGFyZ2V0KTtcbiAgICAgICAgY29uc3Qgb2xkVGFyZ2V0ID0gZWRnZS50YXJnZXQ7XG4gICAgICAgIGNvbnN0IG5ld1RhcmdldCA9IHRhcmdldDtcbiAgICAgICAgdGhpcy5pbkVkZ2VzTWFwLmdldChvbGRUYXJnZXQpLmRlbGV0ZShlZGdlKTtcbiAgICAgICAgdGhpcy5ib3RoRWRnZXNNYXAuZ2V0KG9sZFRhcmdldCkuZGVsZXRlKGVkZ2UpO1xuICAgICAgICB0aGlzLmluRWRnZXNNYXAuZ2V0KG5ld1RhcmdldCkuYWRkKGVkZ2UpO1xuICAgICAgICB0aGlzLmJvdGhFZGdlc01hcC5nZXQobmV3VGFyZ2V0KS5hZGQoZWRnZSk7XG4gICAgICAgIGVkZ2UudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLmJhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnRWRnZVVwZGF0ZWQnLFxuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHByb3BlcnR5TmFtZTogJ3RhcmdldCcsXG4gICAgICAgICAgICAgICAgb2xkVmFsdWU6IG9sZFRhcmdldCxcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZTogbmV3VGFyZ2V0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGVFZGdlRGF0YVByb3BlcnR5KGlkLCBwcm9wZXJ0eU5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGVkZ2UgPSB0aGlzLmdldEVkZ2UoaWQpO1xuICAgICAgICB0aGlzLmJhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gZWRnZS5kYXRhW3Byb3BlcnR5TmFtZV07XG4gICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgZWRnZS5kYXRhW3Byb3BlcnR5TmFtZV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnRWRnZURhdGFVcGRhdGVkJyxcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eU5hbWUsXG4gICAgICAgICAgICAgICAgb2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZUVkZ2VEYXRhKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgaWQgPSBhcmdzWzBdO1xuICAgICAgICBjb25zdCBlZGdlID0gdGhpcy5nZXRFZGdlKGlkKTtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzFdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gaWQsIHByb3BlcnR5TmFtZSwgdmFsdWVcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRWRnZURhdGFQcm9wZXJ0eShpZCwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGE7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gaWQsIHVwZGF0ZVxuICAgICAgICAgICAgY29uc3QgdXBkYXRlID0gYXJnc1sxXTtcbiAgICAgICAgICAgIGRhdGEgPSB1cGRhdGUoZWRnZS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnc1sxXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIC8vIGlkLCBkYXRhXG4gICAgICAgICAgICBkYXRhID0gYXJnc1sxXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9sZFZhbHVlID0gZWRnZS5kYXRhO1xuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBkYXRhO1xuICAgICAgICAgICAgZWRnZS5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnRWRnZURhdGFVcGRhdGVkJyxcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSxcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGdyb3VwIEVkZ2VNZXRob2RzXG4gICAgICovXG4gICAgbWVyZ2VFZGdlRGF0YShpZCwgcGF0Y2gpIHtcbiAgICAgICAgdGhpcy5iYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICBPYmplY3QuZW50cmllcyhwYXRjaCkuZm9yRWFjaCgoW3Byb3BlcnR5TmFtZSwgdmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVFZGdlRGF0YVByb3BlcnR5KGlkLCBwcm9wZXJ0eU5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gPT09PT09PT09PT09PT09PT0gVHJlZSA9PT09PT09PT09PT09PT09PVxuICAgIGNoZWNrVHJlZUV4aXN0ZW5jZSh0cmVlS2V5KSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNUcmVlU3RydWN0dXJlKHRyZWVLZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyZWUgc3RydWN0dXJlIG5vdCBmb3VuZCBmb3IgdHJlZUtleTogJyArIHRyZWVLZXkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc1RyZWVTdHJ1Y3R1cmUodHJlZUtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlSW5kaWNlcy5oYXModHJlZUtleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaCBhIG5ldyB0cmVlIHN0cnVjdHVyZSByZXByZXNlbnRpbmcgdGhlIGhpZXJhcmNoeSBvZiBhbGwgbm9kZXMgaW4gdGhlIGdyYXBoLlxuICAgICAqIEBwYXJhbSB0cmVlS2V5IEEgdW5pcXVlIGtleSBvZiB0aGUgdHJlZSBzdHJ1Y3R1cmUuIFlvdSBjYW4gYXR0YWNoIG11bHRpcGxlIHRyZWUgc3RydWN0dXJlcyB3aXRoIGRpZmZlcmVudCBrZXlzLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBjb25zdCBncmFwaCA9IG5ldyBHcmFwaCh7XG4gICAgICogICBub2RlczogW3sgaWQ6IDEgfSwgeyBpZDogMiB9LCB7IGlkOiAzIH1dLFxuICAgICAqIH0pO1xuICAgICAqIGdyYXBoLmF0dGFjaFRyZWVTdHJ1Y3R1cmUoJ0luaGVyaXRhbmNlJyk7XG4gICAgICogZ3JhcGguc2V0UGFyZW50KDIsIDEsICdJbmhlcml0YW5jZScpO1xuICAgICAqIGdyYXBoLnNldFBhcmVudCgzLCAxLCAnSW5oZXJpdGFuY2UnKTtcbiAgICAgKiBncmFwaC5nZXRSb290cygnSW5oZXJpdGFuY2UnKTsgLy8gWzFdXG4gICAgICogZ3JhcGguZ2V0Q2hpbGRyZW4oMSwgJ0luaGVyaXRhbmNlJyk7IC8vIFsyLDNdXG4gICAgICogYGBgXG4gICAgICogQGdyb3VwIFRyZWVNZXRob2RzXG4gICAgICovXG4gICAgYXR0YWNoVHJlZVN0cnVjdHVyZSh0cmVlS2V5KSB7XG4gICAgICAgIGlmICh0aGlzLnRyZWVJbmRpY2VzLmhhcyh0cmVlS2V5KSkge1xuICAgICAgICAgICAgLy8gQWxyZWFkeSBhdHRhY2hlZC5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyZWVJbmRpY2VzLnNldCh0cmVlS2V5LCB7XG4gICAgICAgICAgICBwYXJlbnRNYXA6IG5ldyBNYXAoKSxcbiAgICAgICAgICAgIGNoaWxkcmVuTWFwOiBuZXcgTWFwKCksXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmJhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnVHJlZVN0cnVjdHVyZUF0dGFjaGVkJyxcbiAgICAgICAgICAgICAgICB0cmVlS2V5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRhY2ggdGhlIHRyZWUgc3RydWN0dXJlIG9mIHRoZSBnaXZlbiB0cmVlIGtleSBmcm9tIHRoZSBncmFwaC5cbiAgICAgKlxuICAgICAqIGBgYHRzXG4gICAgICogZ3JhcGguZGV0YWNoVHJlZVN0cnVjdHVyZSgnSW5oZXJpdGFuY2UnKTtcbiAgICAgKiBncmFwaC5nZXRSb290cygnSW5oZXJpdGFuY2UnKTsgLy8gRXJyb3IhXG4gICAgICogYGBgXG4gICAgICogQGdyb3VwIFRyZWVNZXRob2RzXG4gICAgICovXG4gICAgZGV0YWNoVHJlZVN0cnVjdHVyZSh0cmVlS2V5KSB7XG4gICAgICAgIHRoaXMuY2hlY2tUcmVlRXhpc3RlbmNlKHRyZWVLZXkpO1xuICAgICAgICB0aGlzLnRyZWVJbmRpY2VzLmRlbGV0ZSh0cmVlS2V5KTtcbiAgICAgICAgdGhpcy5iYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1RyZWVTdHJ1Y3R1cmVEZXRhY2hlZCcsXG4gICAgICAgICAgICAgICAgdHJlZUtleSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhdmVyc2UgdGhlIGdpdmVuIHRyZWUgZGF0YSwgYWRkIGVhY2ggbm9kZSBpbnRvIHRoZSBncmFwaCwgdGhlbiBhdHRhY2ggdGhlIHRyZWUgc3RydWN0dXJlLlxuICAgICAqXG4gICAgICogYGBgdHNcbiAgICAgKiBncmFwaC5hZGRUcmVlKHtcbiAgICAgKiAgIGlkOiAxLFxuICAgICAqICAgY2hpbGRyZW46IFtcbiAgICAgKiAgICAgeyBpZDogMiB9LFxuICAgICAqICAgICB7IGlkOiAzIH0sXG4gICAgICogICBdLFxuICAgICAqIH0sICdJbmhlcml0YW5jZScpO1xuICAgICAqIGdyYXBoLmdldFJvb3RzKCdJbmhlcml0YW5jZScpOyAvLyBbMV1cbiAgICAgKiBncmFwaC5nZXRDaGlsZHJlbigxLCAnSW5oZXJpdGFuY2UnKTsgLy8gWzIsIDNdXG4gICAgICogZ3JhcGguZ2V0QWxsTm9kZXMoKTsgLy8gWzEsIDIsIDNdXG4gICAgICogZ3JhcGguZ2V0QWxsRWRnZXMoKTsgLy8gW11cbiAgICAgKiBgYGBcbiAgICAgKiBAZ3JvdXAgVHJlZU1ldGhvZHNcbiAgICAgKi9cbiAgICBhZGRUcmVlKHRyZWUsIHRyZWVLZXkpIHtcbiAgICAgICAgdGhpcy5iYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFRyZWVTdHJ1Y3R1cmUodHJlZUtleSk7XG4gICAgICAgICAgICAvLyBBZGQgTm9kZXNcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IEFycmF5LmlzQXJyYXkodHJlZSkgPyB0cmVlIDogW3RyZWVdO1xuICAgICAgICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBzdGFjay5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCguLi5ub2RlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFkZE5vZGVzKG5vZGVzKTtcbiAgICAgICAgICAgIC8vIFNldCBwYXJlbnQgZm9yIGVhY2ggY2hpbGQgbm9kZS5cbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2goKHBhcmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHBhcmVudC5jaGlsZHJlbj8uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRQYXJlbnQoY2hpbGQuaWQsIHBhcmVudC5pZCwgdHJlZUtleSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcm9vdCBub2RlcyBvZiBhbiBhdHRhY2hlZCB0cmVlIHN0cnVjdHVyZS5cbiAgICAgKlxuICAgICAqIENvbnNpZGVyIGEgZ3JhcGggd2l0aCB0aGUgZm9sbG93aW5nIHRyZWUgc3RydWN0dXJlIGF0dGFjaGVkOlxuICAgICAqIGBgYFxuICAgICAqIFRyZWUgc3RydWN0dXJlOlxuICAgICAqICAgIE8gICAgIDNcbiAgICAgKiAgIC8gXFwgICAgfFxuICAgICAqICAxICAgMiAgIDRcbiAgICAgKiBgYGBcbiAgICAgKiBgZ3JhcGguZ2V0Um9vdHMoKWAgdGFrZXMgYWxsIG5vZGVzIHdpdGhvdXQgYSBwYXJlbnQsIHRoZXJlZm9yZSBbMCwgM10gd2FzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogTmV3bHkgYWRkZWQgbm9kZXMgYXJlIGFsc28gdW5wYXJlbnRlZC4gU28gdGhleSBhcmUgY291bnRlZCBhcyByb290cy5cbiAgICAgKiBgYGB0c1xuICAgICAqIGdyYXBoLmFkZE5vZGUoeyBpZDogNSB9KTtcbiAgICAgKiBncmFwaC5nZXRSb290cygpOyAvLyBbMCwgMywgNV1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEhlcmUgaXMgaG93IHRoZSB0cmVlIHN0cnVjdHVyZSBsb29rcyBsaWtlOlxuICAgICAqIGBgYFxuICAgICAqIFRyZWUgc3RydWN0dXJlOlxuICAgICAqICAgIE8gICAgIDMgIDVcbiAgICAgKiAgIC8gXFwgICAgfFxuICAgICAqICAxICAgMiAgIDRcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEJ5IHNldHRpbmcgYSBwYXJlbnQsIGEgcm9vdCBub2RlIG5vIG1vcmUgYmUgYSByb290LlxuICAgICAqIGBgYHRzXG4gICAgICogZ3JhcGguc2V0UGFyZW50KDUsIDIpO1xuICAgICAqIGdyYXBoLmdldFJvb3RzKCk7IC8vIFswLCAzXVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVGhlIHRyZWUgc3RydWN0dXJlIG5vdyBiZWNvbWVzOlxuICAgICAqIGBgYFxuICAgICAqIFRyZWUgc3RydWN0dXJlOlxuICAgICAqICAgIE8gICAgIDNcbiAgICAgKiAgIC8gXFwgICAgfFxuICAgICAqICAxICAgMiAgIDRcbiAgICAgKiAgICAgIHxcbiAgICAgKiAgICAgIDVcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFJlbW92aW5nIGEgbm9kZSBmb3JjZXMgaXRzIGNoaWxkcmVuIHRvIGJlIHVucGFyZW50ZWQsIG9yIHJvb3RzLlxuICAgICAqIGBgYHRzXG4gICAgICogZ3JhcGgucmVtb3ZlTm9kZSgwKTtcbiAgICAgKiBncmFwaC5nZXRSb290cygpOyAvLyBbMSwgMiwgM11cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFlvdSBtaWdodCBkcmF3IHRoZSB0aGUgc3RydWN0dXJlIGFzIGZvbGxvdzpcbiAgICAgKiBgYGBcbiAgICAgKiBUcmVlIHN0cnVjdHVyZTpcbiAgICAgKiAgMSAgIDIgIDNcbiAgICAgKiAgICAgIHwgIHxcbiAgICAgKiAgICAgIDUgIDRcbiAgICAgKiBgYGBcbiAgICAgKiBAZ3JvdXAgVHJlZU1ldGhvZHNcbiAgICAgKi9cbiAgICBnZXRSb290cyh0cmVlS2V5KSB7XG4gICAgICAgIHRoaXMuY2hlY2tUcmVlRXhpc3RlbmNlKHRyZWVLZXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGxOb2RlcygpLmZpbHRlcigobm9kZSkgPT4gIXRoaXMuZ2V0UGFyZW50KG5vZGUuaWQsIHRyZWVLZXkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBub2RlIElEIGFuZCBhbiBvcHRpb25hbCB0cmVlIGtleSwgZ2V0IHRoZSBjaGlsZHJlbiBvZiB0aGUgbm9kZSBpbiB0aGUgc3BlY2lmaWVkIHRyZWUgc3RydWN0dXJlLlxuICAgICAqIEBncm91cCBUcmVlTWV0aG9kc1xuICAgICAqL1xuICAgIGdldENoaWxkcmVuKGlkLCB0cmVlS2V5KSB7XG4gICAgICAgIHRoaXMuY2hlY2tOb2RlRXhpc3RlbmNlKGlkKTtcbiAgICAgICAgdGhpcy5jaGVja1RyZWVFeGlzdGVuY2UodHJlZUtleSk7XG4gICAgICAgIGNvbnN0IHRyZWUgPSB0aGlzLnRyZWVJbmRpY2VzLmdldCh0cmVlS2V5KTtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0cmVlLmNoaWxkcmVuTWFwLmdldChpZCk7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKGNoaWxkcmVuIHx8IFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYSBub2RlIElEIGFuZCBhbiBvcHRpb25hbCB0cmVlIGtleSwgZ2V0IHRoZSBwYXJlbnQgb2YgdGhlIG5vZGUgaW4gdGhlIHNwZWNpZmllZCB0cmVlIHN0cnVjdHVyZS5cbiAgICAgKiBJZiB0aGUgZ2l2ZW4gbm9kZSBpcyBvbmUgb2YgdGhlIHRyZWUgcm9vdHMsIHRoaXMgcmV0dXJucyBudWxsLlxuICAgICAqIEBncm91cCBUcmVlTWV0aG9kc1xuICAgICAqL1xuICAgIGdldFBhcmVudChpZCwgdHJlZUtleSkge1xuICAgICAgICB0aGlzLmNoZWNrTm9kZUV4aXN0ZW5jZShpZCk7XG4gICAgICAgIHRoaXMuY2hlY2tUcmVlRXhpc3RlbmNlKHRyZWVLZXkpO1xuICAgICAgICBjb25zdCB0cmVlID0gdGhpcy50cmVlSW5kaWNlcy5nZXQodHJlZUtleSk7XG4gICAgICAgIHJldHVybiB0cmVlLnBhcmVudE1hcC5nZXQoaWQpIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHRoZSBhbmNlc3RvciBub2Rlcywgc3RhcmluZyBmcm9tIHRoZSBwYXJlbnQgdG8gdGhlIHJvb3QuXG4gICAgICovXG4gICAgZ2V0QW5jZXN0b3JzKGlkLCB0cmVlS2V5KSB7XG4gICAgICAgIGNvbnN0IGFuY2VzdG9ycyA9IFtdO1xuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuZ2V0Tm9kZShpZCk7XG4gICAgICAgIGxldCBwYXJlbnQ7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxuICAgICAgICB3aGlsZSAoKHBhcmVudCA9IHRoaXMuZ2V0UGFyZW50KGN1cnJlbnQuaWQsIHRyZWVLZXkpKSkge1xuICAgICAgICAgICAgYW5jZXN0b3JzLnB1c2gocGFyZW50KTtcbiAgICAgICAgICAgIGN1cnJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IG5vZGUgcGFyZW50LiBJZiB0aGlzIG9wZXJhdGlvbiBjYXVzZXMgYSBjaXJjbGUsIGl0IGZhaWxzIHdpdGggYW4gZXJyb3IuXG4gICAgICogQHBhcmFtIGlkIC0gSUQgb2YgdGhlIGNoaWxkIG5vZGUuXG4gICAgICogQHBhcmFtIHBhcmVudCAtIElEIG9mIHRoZSBwYXJlbnQgbm9kZS4gSWYgaXQgaXMgdW5kZWZpbmVkIG9yIG51bGwsIG1lYW5zIHVuc2V0IHBhcmVudCBmb3Igbm9kZSB3aXRoIGlkLlxuICAgICAqIEBwYXJhbSB0cmVlS2V5IC0gV2hpY2ggdHJlZSBzdHJ1Y3R1cmUgdGhlIHJlbGF0aW9uIGlzIGFwcGxpZWQgdG8uXG4gICAgICogQGdyb3VwIFRyZWVNZXRob2RzXG4gICAgICovXG4gICAgc2V0UGFyZW50KGlkLCBwYXJlbnQsIHRyZWVLZXkpIHtcbiAgICAgICAgdGhpcy5jaGVja1RyZWVFeGlzdGVuY2UodHJlZUtleSk7XG4gICAgICAgIGNvbnN0IHRyZWUgPSB0aGlzLnRyZWVJbmRpY2VzLmdldCh0cmVlS2V5KTtcbiAgICAgICAgaWYgKCF0cmVlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5nZXROb2RlKGlkKTtcbiAgICAgICAgY29uc3Qgb2xkUGFyZW50ID0gdHJlZS5wYXJlbnRNYXAuZ2V0KGlkKTtcbiAgICAgICAgLy8gU2FtZSBwYXJlbnQgaWQgYXMgb2xkIG9uZSwgc2tpcFxuICAgICAgICBpZiAob2xkUGFyZW50Py5pZCA9PT0gcGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBOZXcgcGFyZW50IGlzIHVuZGVmaW5lZCBvciBudWxsLCB1bnNldCBwYXJlbnQgZm9yIHRoZSBub2RlXG4gICAgICAgIGlmIChwYXJlbnQgPT09IHVuZGVmaW5lZCB8fCBwYXJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChvbGRQYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB0cmVlLmNoaWxkcmVuTWFwLmdldChvbGRQYXJlbnQuaWQpPy5kZWxldGUobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmVlLnBhcmVudE1hcC5kZWxldGUoaWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld1BhcmVudCA9IHRoaXMuZ2V0Tm9kZShwYXJlbnQpO1xuICAgICAgICAvLyBTZXQgcGFyZW50XG4gICAgICAgIHRyZWUucGFyZW50TWFwLnNldChpZCwgbmV3UGFyZW50KTtcbiAgICAgICAgLy8gU2V0IGNoaWxkcmVuXG4gICAgICAgIGlmIChvbGRQYXJlbnQpIHtcbiAgICAgICAgICAgIHRyZWUuY2hpbGRyZW5NYXAuZ2V0KG9sZFBhcmVudC5pZCk/LmRlbGV0ZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hpbGRyZW4gPSB0cmVlLmNoaWxkcmVuTWFwLmdldChuZXdQYXJlbnQuaWQpO1xuICAgICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjaGlsZHJlbiA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIHRyZWUuY2hpbGRyZW5NYXAuc2V0KG5ld1BhcmVudC5pZCwgY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLmFkZChub2RlKTtcbiAgICAgICAgdGhpcy5iYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ1RyZWVTdHJ1Y3R1cmVDaGFuZ2VkJyxcbiAgICAgICAgICAgICAgICB0cmVlS2V5LFxuICAgICAgICAgICAgICAgIG5vZGVJZDogaWQsXG4gICAgICAgICAgICAgICAgb2xkUGFyZW50SWQ6IG9sZFBhcmVudD8uaWQsXG4gICAgICAgICAgICAgICAgbmV3UGFyZW50SWQ6IG5ld1BhcmVudC5pZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGZzVHJlZShpZCwgZm4sIHRyZWVLZXkpIHtcbiAgICAgICAgY29uc3QgbmF2aWdhdG9yID0gKG5vZGVJZCkgPT4gdGhpcy5nZXRDaGlsZHJlbihub2RlSWQsIHRyZWVLZXkpO1xuICAgICAgICByZXR1cm4gZG9ERlModGhpcy5nZXROb2RlKGlkKSwgbmV3IFNldCgpLCBmbiwgbmF2aWdhdG9yKTtcbiAgICB9XG4gICAgYmZzVHJlZShpZCwgZm4sIHRyZWVLZXkpIHtcbiAgICAgICAgY29uc3QgbmF2aWdhdG9yID0gKG5vZGVJZCkgPT4gdGhpcy5nZXRDaGlsZHJlbihub2RlSWQsIHRyZWVLZXkpO1xuICAgICAgICByZXR1cm4gZG9CRlMoW3RoaXMuZ2V0Tm9kZShpZCldLCBuZXcgU2V0KCksIGZuLCBuYXZpZ2F0b3IpO1xuICAgIH1cbiAgICAvLyA9PT09PT09PT09PT09PT09PSBHcmFwaCA9PT09PT09PT09PT09PT09PVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgbm9kZXMgaW4gdGhlIGdyYXBoIGFzIGFuIGFycmF5LlxuICAgICAqL1xuICAgIGdldEFsbE5vZGVzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLm5vZGVNYXAudmFsdWVzKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWxsIGVkZ2VzIGluIHRoZSBncmFwaCBhcyBhbiBhcnJheS5cbiAgICAgKi9cbiAgICBnZXRBbGxFZGdlcygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5lZGdlTWFwLnZhbHVlcygpKTtcbiAgICB9XG4gICAgYmZzKGlkLCBmbiwgZGlyZWN0aW9uID0gJ291dCcpIHtcbiAgICAgICAgY29uc3QgbmF2aWdhdG9yID0ge1xuICAgICAgICAgICAgaW46IHRoaXMuZ2V0UHJlZGVjZXNzb3JzLmJpbmQodGhpcyksXG4gICAgICAgICAgICBvdXQ6IHRoaXMuZ2V0U3VjY2Vzc29ycy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgYm90aDogdGhpcy5nZXROZWlnaGJvcnMuYmluZCh0aGlzKSxcbiAgICAgICAgfVtkaXJlY3Rpb25dO1xuICAgICAgICByZXR1cm4gZG9CRlMoW3RoaXMuZ2V0Tm9kZShpZCldLCBuZXcgU2V0KCksIGZuLCBuYXZpZ2F0b3IpO1xuICAgIH1cbiAgICBkZnMoaWQsIGZuLCBkaXJlY3Rpb24gPSAnb3V0Jykge1xuICAgICAgICBjb25zdCBuYXZpZ2F0b3IgPSB7XG4gICAgICAgICAgICBpbjogdGhpcy5nZXRQcmVkZWNlc3NvcnMuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIG91dDogdGhpcy5nZXRTdWNjZXNzb3JzLmJpbmQodGhpcyksXG4gICAgICAgICAgICBib3RoOiB0aGlzLmdldE5laWdoYm9ycy5iaW5kKHRoaXMpLFxuICAgICAgICB9W2RpcmVjdGlvbl07XG4gICAgICAgIHJldHVybiBkb0RGUyh0aGlzLmdldE5vZGUoaWQpLCBuZXcgU2V0KCksIGZuLCBuYXZpZ2F0b3IpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgLy8gTWFrZSBhIHNoYWxsb3cgY29weSBvZiBub2RlcyBhbmQgZWRnZXMuXG4gICAgICAgIGNvbnN0IG5ld05vZGVzID0gdGhpcy5nZXRBbGxOb2RlcygpLm1hcCgob2xkTm9kZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHsgLi4ub2xkTm9kZSwgZGF0YTogeyAuLi5vbGROb2RlLmRhdGEgfSB9O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbmV3RWRnZXMgPSB0aGlzLmdldEFsbEVkZ2VzKCkubWFwKChvbGRFZGdlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyAuLi5vbGRFZGdlLCBkYXRhOiB7IC4uLm9sZEVkZ2UuZGF0YSB9IH07XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgZ3JhcGggd2l0aCBzaGFsbG93IGNvcGllZCBub2RlcyBhbmQgZWRnZXMuXG4gICAgICAgIGNvbnN0IG5ld0dyYXBoID0gbmV3IEdyYXBoKHtcbiAgICAgICAgICAgIG5vZGVzOiBuZXdOb2RlcyxcbiAgICAgICAgICAgIGVkZ2VzOiBuZXdFZGdlcyxcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFkZCB0cmVlIGluZGljZXMuXG4gICAgICAgIHRoaXMudHJlZUluZGljZXMuZm9yRWFjaCgoeyBwYXJlbnRNYXA6IG9sZFBhcmVudE1hcCwgY2hpbGRyZW5NYXA6IG9sZENoaWxkcmVuTWFwIH0sIHRyZWVLZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIG9sZFBhcmVudE1hcC5mb3JFYWNoKChwYXJlbnQsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHBhcmVudE1hcC5zZXQoa2V5LCBuZXdHcmFwaC5nZXROb2RlKHBhcmVudC5pZCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbk1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIG9sZENoaWxkcmVuTWFwLmZvckVhY2goKGNoaWxkcmVuLCBrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBjaGlsZHJlbk1hcC5zZXQoa2V5LCBuZXcgU2V0KEFycmF5LmZyb20oY2hpbGRyZW4pLm1hcCgobikgPT4gbmV3R3JhcGguZ2V0Tm9kZShuLmlkKSkpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbmV3R3JhcGgudHJlZUluZGljZXMuc2V0KHRyZWVLZXksIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRNYXA6IHBhcmVudE1hcCxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbk1hcDogY2hpbGRyZW5NYXAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXdHcmFwaDtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgbm9kZXM6IHRoaXMuZ2V0QWxsTm9kZXMoKSxcbiAgICAgICAgICAgIGVkZ2VzOiB0aGlzLmdldEFsbEVkZ2VzKCksXG4gICAgICAgICAgICAvLyBGSVhNRTogQW5kIHRyZWUgc3RydWN0dXJlcz9cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZVZpZXcob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gbmV3IEdyYXBoVmlldyh7XG4gICAgICAgICAgICBncmFwaDogdGhpcyxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyYXBoLmpzLm1hcCIsImltcG9ydCB7IGRvQkZTLCBkb0RGUyB9IGZyb20gJy4vdXRpbHMvdHJhdmVyc2UnO1xuY29uc3QgZGVmYXVsdEZpbHRlciA9ICgpID0+IHRydWU7XG5leHBvcnQgY2xhc3MgR3JhcGhWaWV3IHtcbiAgICBncmFwaDtcbiAgICBub2RlRmlsdGVyO1xuICAgIGVkZ2VGaWx0ZXI7XG4gICAgLy8gY2FjaGVzXG4gICAgY2FjaGVFbmFibGVkO1xuICAgIGluRWRnZXNNYXAgPSBuZXcgTWFwKCk7XG4gICAgb3V0RWRnZXNNYXAgPSBuZXcgTWFwKCk7XG4gICAgYm90aEVkZ2VzTWFwID0gbmV3IE1hcCgpO1xuICAgIGFsbE5vZGVzTWFwID0gbmV3IE1hcCgpO1xuICAgIGFsbEVkZ2VzTWFwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5ncmFwaCA9IG9wdGlvbnMuZ3JhcGg7XG4gICAgICAgIGNvbnN0IG5vZGVGaWx0ZXIgPSBvcHRpb25zLm5vZGVGaWx0ZXIgfHwgZGVmYXVsdEZpbHRlcjtcbiAgICAgICAgY29uc3QgZWRnZUZpbHRlciA9IG9wdGlvbnMuZWRnZUZpbHRlciB8fCBkZWZhdWx0RmlsdGVyO1xuICAgICAgICB0aGlzLm5vZGVGaWx0ZXIgPSBub2RlRmlsdGVyO1xuICAgICAgICB0aGlzLmVkZ2VGaWx0ZXIgPSAoZWRnZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBzb3VyY2UsIHRhcmdldCB9ID0gdGhpcy5ncmFwaC5nZXRFZGdlRGV0YWlsKGVkZ2UuaWQpO1xuICAgICAgICAgICAgaWYgKCFub2RlRmlsdGVyKHNvdXJjZSkgfHwgIW5vZGVGaWx0ZXIodGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlZGdlRmlsdGVyKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMuY2FjaGUgPT09ICdhdXRvJykge1xuICAgICAgICAgICAgdGhpcy5jYWNoZUVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5zdGFydEF1dG9DYWNoZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9wdGlvbnMuY2FjaGUgPT09ICdtYW51YWwnKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlRW5hYmxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBjYWNoZSBkYXRhLiBUaGVyZWZvcmUgYGdldEFsbE5vZGVzKClgIHdpbGwgcmV0dXJuIGBbXWAuXG4gICAgICogSWYgeW91IHdhbnQgdG8gZGlzYWJsZSBjYWNoaW5nLCB1c2UgYGdyYXBoVmlldy5jYWNoZUVuYWJsZWQgPSBmYWxzZWAgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBjbGVhckNhY2hlID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmluRWRnZXNNYXAuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5vdXRFZGdlc01hcC5jbGVhcigpO1xuICAgICAgICB0aGlzLmJvdGhFZGdlc01hcC5jbGVhcigpO1xuICAgICAgICB0aGlzLmFsbE5vZGVzTWFwLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuYWxsRWRnZXNNYXAuY2xlYXIoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEZ1bGx5IHJlZnJlc2ggYWxsIGNhY2hlIGRhdGEgdG8gdGhlIGN1cnJlbnQgZ3JhcGggc3RhdGUuXG4gICAgICovXG4gICAgcmVmcmVzaENhY2hlID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgdGhpcy51cGRhdGVDYWNoZSh0aGlzLmdyYXBoLmdldEFsbE5vZGVzKCkubWFwKChub2RlKSA9PiBub2RlLmlkKSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBJbnN0ZWFkIG9mIGEgZnVsbHkgcmVmcmVzaG1lbnQsIHRoaXMgbWV0aG9kIHBhcnRpYWxseSB1cGRhdGUgdGhlIGNhY2hlIGRhdGEgYnkgc3BlY2lmeWluZ1xuICAgICAqIGludm9sdmVkKGFkZGVkLCByZW1vdmVkLCB1cGRhdGVkKSBub2Rlcy4gSXQncyBtb3JlIGVmZmljaWVudCB3aGVuIGhhbmRsaW5nIHNtYWxsIGNoYW5nZXNcbiAgICAgKiBvbiBhIGxhcmdlIGdyYXBoLlxuICAgICAqL1xuICAgIHVwZGF0ZUNhY2hlID0gKGludm9sdmVkTm9kZUlkcykgPT4ge1xuICAgICAgICBjb25zdCBpbnZvbHZlZEVkZ2VJZHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGludm9sdmVkTm9kZUlkcy5mb3JFYWNoKChpZCkgPT4ge1xuICAgICAgICAgICAgLy8gQ29sbGVjdCBhbGwgaW52b2x2ZWQgb2xkIGVkZ2VzLlxuICAgICAgICAgICAgY29uc3Qgb2xkRWRnZXNTZXQgPSB0aGlzLmJvdGhFZGdlc01hcC5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKG9sZEVkZ2VzU2V0KSB7XG4gICAgICAgICAgICAgICAgb2xkRWRnZXNTZXQuZm9yRWFjaCgoZWRnZSkgPT4gaW52b2x2ZWRFZGdlSWRzLmFkZChlZGdlLmlkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzTm9kZShpZCkpIHtcbiAgICAgICAgICAgICAgICAvLyBXaGVuIGFuIGludm9sdmVkIG5vZGUgYmVjb21lcyB1bnZpc2l0YWJsZTpcbiAgICAgICAgICAgICAgICAvLyAxLiBEZWxldGUgaXRzIHJlbGF0ZWQgZWRnZXMgY2FjaGUuXG4gICAgICAgICAgICAgICAgdGhpcy5pbkVkZ2VzTWFwLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vdXRFZGdlc01hcC5kZWxldGUoaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuYm90aEVkZ2VzTWFwLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICAgICAgLy8gMi4gRGVsZXRlIGl0IGZyb20gdGhlIGFsbE5vZGVzTWFwLlxuICAgICAgICAgICAgICAgIHRoaXMuYWxsTm9kZXNNYXAuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gYW4gaW52b2x2ZWQgbm9kZSBiZWNvbWVzIG9yIHN0YXlzIHZpc2l0YWJsZTpcbiAgICAgICAgICAgICAgICAvLyAxLiBDb2xsZWN0IGl0cyBuZXcgZWRnZXMuXG4gICAgICAgICAgICAgICAgY29uc3QgaW5FZGdlcyA9IHRoaXMuZ3JhcGhcbiAgICAgICAgICAgICAgICAgICAgLmdldFJlbGF0ZWRFZGdlcyhpZCwgJ2luJylcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcih0aGlzLmVkZ2VGaWx0ZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dEVkZ2VzID0gdGhpcy5ncmFwaFxuICAgICAgICAgICAgICAgICAgICAuZ2V0UmVsYXRlZEVkZ2VzKGlkLCAnb3V0JylcbiAgICAgICAgICAgICAgICAgICAgLmZpbHRlcih0aGlzLmVkZ2VGaWx0ZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvdGhFZGdlcyA9IEFycmF5LmZyb20obmV3IFNldChbLi4uaW5FZGdlcywgLi4ub3V0RWRnZXNdKSk7XG4gICAgICAgICAgICAgICAgYm90aEVkZ2VzLmZvckVhY2goKGVkZ2UpID0+IGludm9sdmVkRWRnZUlkcy5hZGQoZWRnZS5pZCkpO1xuICAgICAgICAgICAgICAgIC8vIDIuIFVwZGF0ZSBpdHMgcmVsYXRlZCBlZGdlcyBjYWNoZS5cbiAgICAgICAgICAgICAgICB0aGlzLmluRWRnZXNNYXAuc2V0KGlkLCBpbkVkZ2VzKTtcbiAgICAgICAgICAgICAgICB0aGlzLm91dEVkZ2VzTWFwLnNldChpZCwgb3V0RWRnZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuYm90aEVkZ2VzTWFwLnNldChpZCwgYm90aEVkZ2VzKTtcbiAgICAgICAgICAgICAgICAvLyAzLiBBZGQgdG8gYWxsTm9kZXNNYXAuXG4gICAgICAgICAgICAgICAgdGhpcy5hbGxOb2Rlc01hcC5zZXQoaWQsIHRoaXMuZ3JhcGguZ2V0Tm9kZShpZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVXBkYXRlIGFsbEVkZ2VzTWFwLlxuICAgICAgICBpbnZvbHZlZEVkZ2VJZHMuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0VkZ2UoaWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxFZGdlc01hcC5zZXQoaWQsIHRoaXMuZ3JhcGguZ2V0RWRnZShpZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGxFZGdlc01hcC5kZWxldGUoaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHN0YXJ0QXV0b0NhY2hlKCkge1xuICAgICAgICB0aGlzLnJlZnJlc2hDYWNoZSgpO1xuICAgICAgICB0aGlzLmdyYXBoLm9uKCdjaGFuZ2VkJywgdGhpcy5oYW5kbGVHcmFwaENoYW5nZWQpO1xuICAgIH1cbiAgICBzdG9wQXV0b0NhY2hlKCkge1xuICAgICAgICB0aGlzLmdyYXBoLm9mZignY2hhbmdlZCcsIHRoaXMuaGFuZGxlR3JhcGhDaGFuZ2VkKTtcbiAgICB9XG4gICAgaGFuZGxlR3JhcGhDaGFuZ2VkID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIC8vIENvbGxlY3QgYWxsIGludm9sdmVkIG5vZGVzLlxuICAgICAgICBjb25zdCBpbnZvbHZlZE5vZGVJZHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGV2ZW50LmNoYW5nZXMuZm9yRWFjaCgoY2hhbmdlKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoYW5nZS50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnTm9kZUFkZGVkJzpcbiAgICAgICAgICAgICAgICAgICAgaW52b2x2ZWROb2RlSWRzLmFkZChjaGFuZ2UudmFsdWUuaWQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdOb2RlRGF0YVVwZGF0ZWQnOlxuICAgICAgICAgICAgICAgICAgICBpbnZvbHZlZE5vZGVJZHMuYWRkKGNoYW5nZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0VkZ2VBZGRlZCc6XG4gICAgICAgICAgICAgICAgICAgIGludm9sdmVkTm9kZUlkcy5hZGQoY2hhbmdlLnZhbHVlLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIGludm9sdmVkTm9kZUlkcy5hZGQoY2hhbmdlLnZhbHVlLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0VkZ2VVcGRhdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5nZS5wcm9wZXJ0eU5hbWUgPT09ICdzb3VyY2UnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2UucHJvcGVydHlOYW1lID09PSAndGFyZ2V0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52b2x2ZWROb2RlSWRzLmFkZChjaGFuZ2Uub2xkVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW52b2x2ZWROb2RlSWRzLmFkZChjaGFuZ2UubmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0VkZ2VEYXRhVXBkYXRlZCc6XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5ncmFwaC5oYXNFZGdlKGNoYW5nZS5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVkZ2UgPSBldmVudC5ncmFwaC5nZXRFZGdlKGNoYW5nZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZvbHZlZE5vZGVJZHMuYWRkKGVkZ2Uuc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGludm9sdmVkTm9kZUlkcy5hZGQoZWRnZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0VkZ2VSZW1vdmVkJzpcbiAgICAgICAgICAgICAgICAgICAgaW52b2x2ZWROb2RlSWRzLmFkZChjaGFuZ2UudmFsdWUuc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgaW52b2x2ZWROb2RlSWRzLmFkZChjaGFuZ2UudmFsdWUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnTm9kZVJlbW92ZWQnOlxuICAgICAgICAgICAgICAgICAgICBpbnZvbHZlZE5vZGVJZHMuYWRkKGNoYW5nZS52YWx1ZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZWlyIGNhY2hlcy5cbiAgICAgICAgdGhpcy51cGRhdGVDYWNoZShpbnZvbHZlZE5vZGVJZHMpO1xuICAgIH07XG4gICAgLy8gPT09PT09PT09PT09PT09PT0gTm9kZSA9PT09PT09PT09PT09PT09PVxuICAgIGNoZWNrTm9kZUV4aXN0ZW5jZShpZCkge1xuICAgICAgICB0aGlzLmdldE5vZGUoaWQpO1xuICAgIH1cbiAgICBoYXNOb2RlKGlkKSB7XG4gICAgICAgIGlmICghdGhpcy5ncmFwaC5oYXNOb2RlKGlkKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ3JhcGguZ2V0Tm9kZShpZCk7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVGaWx0ZXIobm9kZSk7XG4gICAgfVxuICAgIGFyZU5laWdoYm9ycyhmaXJzdE5vZGVJZCwgc2Vjb25kTm9kZUlkKSB7XG4gICAgICAgIHRoaXMuY2hlY2tOb2RlRXhpc3RlbmNlKGZpcnN0Tm9kZUlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TmVpZ2hib3JzKHNlY29uZE5vZGVJZCkuc29tZSgobmVpZ2hib3IpID0+IG5laWdoYm9yLmlkID09PSBmaXJzdE5vZGVJZCk7XG4gICAgfVxuICAgIGdldE5vZGUoaWQpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuZ3JhcGguZ2V0Tm9kZShpZCk7XG4gICAgICAgIGlmICghdGhpcy5ub2RlRmlsdGVyKG5vZGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vZGUgbm90IGZvdW5kIGZvciBpZDogJyArIGlkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgZ2V0UmVsYXRlZEVkZ2VzKGlkLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5jaGVja05vZGVFeGlzdGVuY2UoaWQpO1xuICAgICAgICBpZiAodGhpcy5jYWNoZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09ICdpbicpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbkVkZ2VzTWFwLmdldChpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaXJlY3Rpb24gPT09ICdvdXQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3V0RWRnZXNNYXAuZ2V0KGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJvdGhFZGdlc01hcC5nZXQoaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVkZ2VzID0gdGhpcy5ncmFwaC5nZXRSZWxhdGVkRWRnZXMoaWQsIGRpcmVjdGlvbik7XG4gICAgICAgIHJldHVybiBlZGdlcy5maWx0ZXIodGhpcy5lZGdlRmlsdGVyKTtcbiAgICB9XG4gICAgZ2V0RGVncmVlKGlkLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVsYXRlZEVkZ2VzKGlkLCBkaXJlY3Rpb24pLmxlbmd0aDtcbiAgICB9XG4gICAgZ2V0U3VjY2Vzc29ycyhpZCkge1xuICAgICAgICBjb25zdCBvdXRFZGdlcyA9IHRoaXMuZ2V0UmVsYXRlZEVkZ2VzKGlkLCAnb3V0Jyk7XG4gICAgICAgIGNvbnN0IHRhcmdldHMgPSBvdXRFZGdlcy5tYXAoKGVkZ2UpID0+IHRoaXMuZ2V0Tm9kZShlZGdlLnRhcmdldCkpO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShuZXcgU2V0KHRhcmdldHMpKTtcbiAgICB9XG4gICAgZ2V0UHJlZGVjZXNzb3JzKGlkKSB7XG4gICAgICAgIGNvbnN0IGluRWRnZXMgPSB0aGlzLmdldFJlbGF0ZWRFZGdlcyhpZCwgJ2luJyk7XG4gICAgICAgIGNvbnN0IHNvdXJjZXMgPSBpbkVkZ2VzLm1hcCgoZWRnZSkgPT4gdGhpcy5nZXROb2RlKGVkZ2Uuc291cmNlKSk7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQoc291cmNlcykpO1xuICAgIH1cbiAgICBnZXROZWlnaGJvcnMoaWQpIHtcbiAgICAgICAgY29uc3QgcHJlZGVjZXNzb3JzID0gdGhpcy5nZXRQcmVkZWNlc3NvcnMoaWQpO1xuICAgICAgICBjb25zdCBzdWNjZXNzb3JzID0gdGhpcy5nZXRTdWNjZXNzb3JzKGlkKTtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChbLi4ucHJlZGVjZXNzb3JzLCAuLi5zdWNjZXNzb3JzXSkpO1xuICAgIH1cbiAgICAvLyA9PT09PT09PT09PT09PT09PSBFZGdlID09PT09PT09PT09PT09PT09XG4gICAgaGFzRWRnZShpZCkge1xuICAgICAgICBpZiAoIXRoaXMuZ3JhcGguaGFzRWRnZShpZCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGVkZ2UgPSB0aGlzLmdyYXBoLmdldEVkZ2UoaWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5lZGdlRmlsdGVyKGVkZ2UpO1xuICAgIH1cbiAgICBnZXRFZGdlKGlkKSB7XG4gICAgICAgIGNvbnN0IGVkZ2UgPSB0aGlzLmdyYXBoLmdldEVkZ2UoaWQpO1xuICAgICAgICBpZiAoIXRoaXMuZWRnZUZpbHRlcihlZGdlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFZGdlIG5vdCBmb3VuZCBmb3IgaWQ6ICcgKyBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVkZ2U7XG4gICAgfVxuICAgIGdldEVkZ2VEZXRhaWwoaWQpIHtcbiAgICAgICAgY29uc3QgZWRnZSA9IHRoaXMuZ2V0RWRnZShpZCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlZGdlLFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLmdldE5vZGUoZWRnZS5zb3VyY2UpLFxuICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLmdldE5vZGUoZWRnZS50YXJnZXQpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyA9PT09PT09PT09PT09PT09PSBUcmVlID09PT09PT09PT09PT09PT09XG4gICAgaGFzVHJlZVN0cnVjdHVyZSh0cmVlS2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyYXBoLmhhc1RyZWVTdHJ1Y3R1cmUodHJlZUtleSk7XG4gICAgfVxuICAgIGdldFJvb3RzKHRyZWVLZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JhcGguZ2V0Um9vdHModHJlZUtleSkuZmlsdGVyKHRoaXMubm9kZUZpbHRlcik7XG4gICAgfVxuICAgIGdldENoaWxkcmVuKGlkLCB0cmVlS2V5KSB7XG4gICAgICAgIHRoaXMuY2hlY2tOb2RlRXhpc3RlbmNlKGlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JhcGguZ2V0Q2hpbGRyZW4oaWQsIHRyZWVLZXkpLmZpbHRlcih0aGlzLm5vZGVGaWx0ZXIpO1xuICAgIH1cbiAgICBnZXRQYXJlbnQoaWQsIHRyZWVLZXkpIHtcbiAgICAgICAgdGhpcy5jaGVja05vZGVFeGlzdGVuY2UoaWQpO1xuICAgICAgICBjb25zdCBwYXJlbnQgPSB0aGlzLmdyYXBoLmdldFBhcmVudChpZCwgdHJlZUtleSk7XG4gICAgICAgIGlmICghcGFyZW50IHx8ICF0aGlzLm5vZGVGaWx0ZXIocGFyZW50KSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbiAgICAvLyA9PT09PT09PT09PT09PT09PSBHcmFwaCA9PT09PT09PT09PT09PT09PVxuICAgIGdldEFsbE5vZGVzKCkge1xuICAgICAgICBpZiAodGhpcy5jYWNoZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuYWxsTm9kZXNNYXAudmFsdWVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdyYXBoLmdldEFsbE5vZGVzKCkuZmlsdGVyKHRoaXMubm9kZUZpbHRlcik7XG4gICAgfVxuICAgIGdldEFsbEVkZ2VzKCkge1xuICAgICAgICBpZiAodGhpcy5jYWNoZUVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuYWxsRWRnZXNNYXAudmFsdWVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdyYXBoLmdldEFsbEVkZ2VzKCkuZmlsdGVyKHRoaXMuZWRnZUZpbHRlcik7XG4gICAgfVxuICAgIGJmcyhpZCwgZm4sIGRpcmVjdGlvbiA9ICdvdXQnKSB7XG4gICAgICAgIGNvbnN0IG5hdmlnYXRvciA9IHtcbiAgICAgICAgICAgIGluOiB0aGlzLmdldFByZWRlY2Vzc29ycy5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgb3V0OiB0aGlzLmdldFN1Y2Nlc3NvcnMuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIGJvdGg6IHRoaXMuZ2V0TmVpZ2hib3JzLmJpbmQodGhpcyksXG4gICAgICAgIH1bZGlyZWN0aW9uXTtcbiAgICAgICAgZG9CRlMoW3RoaXMuZ2V0Tm9kZShpZCldLCBuZXcgU2V0KCksIGZuLCBuYXZpZ2F0b3IpO1xuICAgIH1cbiAgICBkZnMoaWQsIGZuLCBkaXJlY3Rpb24gPSAnb3V0Jykge1xuICAgICAgICBjb25zdCBuYXZpZ2F0b3IgPSB7XG4gICAgICAgICAgICBpbjogdGhpcy5nZXRQcmVkZWNlc3NvcnMuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIG91dDogdGhpcy5nZXRTdWNjZXNzb3JzLmJpbmQodGhpcyksXG4gICAgICAgICAgICBib3RoOiB0aGlzLmdldE5laWdoYm9ycy5iaW5kKHRoaXMpLFxuICAgICAgICB9W2RpcmVjdGlvbl07XG4gICAgICAgIGRvREZTKHRoaXMuZ2V0Tm9kZShpZCksIG5ldyBTZXQoKSwgZm4sIG5hdmlnYXRvcik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JhcGhWaWV3LmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBkb0JGUyhxdWV1ZSwgdmlzaXRlZCwgZm4sIG5hdmlnYXRvcikge1xuICAgIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgIGNvbnN0IGFib3J0ID0gZm4obm9kZSk7XG4gICAgICAgIGlmIChhYm9ydCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRlZC5hZGQobm9kZS5pZCk7XG4gICAgICAgIG5hdmlnYXRvcihub2RlLmlkKS5mb3JFYWNoKChuKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKG4uaWQpKSB7XG4gICAgICAgICAgICAgICAgdmlzaXRlZC5hZGQobi5pZCk7XG4gICAgICAgICAgICAgICAgcXVldWUucHVzaChuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkb0RGUyhub2RlLCB2aXNpdGVkLCBmbiwgbmF2aWdhdG9yKSB7XG4gICAgY29uc3QgYWJvcnQgPSBmbihub2RlKTtcbiAgICBpZiAoYWJvcnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZpc2l0ZWQuYWRkKG5vZGUuaWQpO1xuICAgIGZvciAoY29uc3QgbiBvZiBuYXZpZ2F0b3Iobm9kZS5pZCkpIHtcbiAgICAgICAgaWYgKCF2aXNpdGVkLmhhcyhuLmlkKSkge1xuICAgICAgICAgICAgaWYgKGRvREZTKG4sIHZpc2l0ZWQsIGZuLCBuYXZpZ2F0b3IpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhdmVyc2UuanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBHcmFwaCB9IGZyb20gJ0BhbnR2L2dyYXBobGliJztcbmltcG9ydCB7IGlzTnVtYmVyIH0gZnJvbSAnQGFudHYvdXRpbCc7XG5pbXBvcnQgeyBsYXlvdXQgfSBmcm9tICcuL2FudHYtZGFncmUvbGF5b3V0JztcbmltcG9ydCB7IGNsb25lRm9ybWF0RGF0YSwgZm9ybWF0TnVtYmVyRm4sIGZvcm1hdFNpemVGbiB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBwYXJzZVNpemUgfSBmcm9tICcuL3V0aWwvc2l6ZSc7XG5jb25zdCBERUZBVUxUU19MQVlPVVRfT1BUSU9OUyA9IHtcbiAgICByYW5rZGlyOiAnVEInLFxuICAgIG5vZGVzZXA6IDUwLFxuICAgIHJhbmtzZXA6IDUwLFxuICAgIGVkZ2VMYWJlbFNwYWNlOiB0cnVlLFxuICAgIHJhbmtlcjogJ3RpZ2h0LXRyZWUnLFxuICAgIGNvbnRyb2xQb2ludHM6IGZhbHNlLFxuICAgIHJhZGlhbDogZmFsc2UsXG4gICAgZm9jdXNOb2RlOiBudWxsLCAvLyByYWRpYWwg5Li6IHRydWUg5pe255Sf5pWI77yM5YWz5rOo55qE6IqC54K5XG59O1xuLyoqXG4gKiA8emgvPiBBbnRWIOWunueOsOeahCBEYWdyZSDluIPlsYBcbiAqXG4gKiA8ZW4vPiBBbnRWIGltcGxlbWVudGF0aW9uIG9mIERhZ3JlIGxheW91dFxuICovXG5leHBvcnQgY2xhc3MgQW50VkRhZ3JlTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5pZCA9ICdhbnR2LWRhZ3JlJztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUU19MQVlPVVRfT1BUSU9OUyksIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHBvc2l0aW9ucyBvZiBub2RlcyBhbmQgZWRnZXMoaWYgbmVlZGVkKS5cbiAgICAgKi9cbiAgICBleGVjdXRlKGdyYXBoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmljRGFncmVMYXlvdXQoZmFsc2UsIGdyYXBoLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvIGRpcmVjdGx5IGFzc2lnbiB0aGUgcG9zaXRpb25zIHRvIHRoZSBub2Rlcy5cbiAgICAgKi9cbiAgICBhc3NpZ24oZ3JhcGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2VuZXJpY0RhZ3JlTGF5b3V0KHRydWUsIGdyYXBoLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdlbmVyaWNEYWdyZUxheW91dChhc3NpZ24sIGdyYXBoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWRPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZVNpemUsIGFsaWduLCByYW5rZGlyID0gJ1RCJywgcmFua3NlcCwgbm9kZXNlcCwgcmFua3NlcEZ1bmMsIG5vZGVzZXBGdW5jLCBlZGdlTGFiZWxTcGFjZSwgcmFua2VyLCBub2RlT3JkZXIsIGJlZ2luLCBjb250cm9sUG9pbnRzLCByYWRpYWwsIHNvcnRCeUNvbWJvLCBcbiAgICAgICAgICAgIC8vIGZvY3VzTm9kZSxcbiAgICAgICAgICAgIHByZXNldCwgfSA9IG1lcmdlZE9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBnID0gbmV3IEdyYXBoKHtcbiAgICAgICAgICAgICAgICB0cmVlOiBbXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmFua3NlcGZ1bmMgPSBmb3JtYXROdW1iZXJGbihyYW5rc2VwIHx8IDUwLCByYW5rc2VwRnVuYyk7XG4gICAgICAgICAgICBjb25zdCBub2Rlc2VwZnVuYyA9IGZvcm1hdE51bWJlckZuKG5vZGVzZXAgfHwgNTAsIG5vZGVzZXBGdW5jKTtcbiAgICAgICAgICAgIGxldCBob3Jpc2VwID0gbm9kZXNlcGZ1bmM7XG4gICAgICAgICAgICBsZXQgdmVydGlzZXAgPSByYW5rc2VwZnVuYztcbiAgICAgICAgICAgIGlmIChyYW5rZGlyID09PSAnTFInIHx8IHJhbmtkaXIgPT09ICdSTCcpIHtcbiAgICAgICAgICAgICAgICBob3Jpc2VwID0gcmFua3NlcGZ1bmM7XG4gICAgICAgICAgICAgICAgdmVydGlzZXAgPSBub2Rlc2VwZnVuYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5vZGVTaXplRnVuYyA9IGZvcm1hdFNpemVGbigxMCwgbm9kZVNpemUsIGZhbHNlKTtcbiAgICAgICAgICAgIC8vIGNvcHkgZ3JhcGggdG8gZ1xuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBncmFwaC5nZXRBbGxOb2RlcygpO1xuICAgICAgICAgICAgY29uc3QgZWRnZXMgPSBncmFwaC5nZXRBbGxFZGdlcygpO1xuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemUgPSBwYXJzZVNpemUobm9kZVNpemVGdW5jKG5vZGUpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2ZXJ0aSA9IHZlcnRpc2VwKG5vZGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhvcmkgPSBob3Jpc2VwKG5vZGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gc2l6ZVswXSArIDIgKiBob3JpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IHNpemVbMV0gKyAyICogdmVydGk7XG4gICAgICAgICAgICAgICAgY29uc3QgbGF5ZXIgPSBub2RlLmRhdGEubGF5ZXI7XG4gICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGxheWVyKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpzmnIlsYXllcuWxnuaAp++8jOWKoOWFpeWIsG5vZGXnmoRsYWJlbOS4rVxuICAgICAgICAgICAgICAgICAgICBnLmFkZE5vZGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHdpZHRoLCBoZWlnaHQsIGxheWVyIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZy5hZGROb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBub2RlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogeyB3aWR0aCwgaGVpZ2h0IH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHNvcnRCeUNvbWJvKSB7XG4gICAgICAgICAgICAgICAgZy5hdHRhY2hUcmVlU3RydWN0dXJlKCdjb21ibycpO1xuICAgICAgICAgICAgICAgIG5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwYXJlbnRJZCB9ID0gbm9kZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50SWQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGcuaGFzTm9kZShwYXJlbnRJZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGcuc2V0UGFyZW50KG5vZGUuaWQsIHBhcmVudElkLCAnY29tYm8nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWRnZXMuZm9yRWFjaCgoZWRnZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGRhZ3JlanMgV2lraSBodHRwczovL2dpdGh1Yi5jb20vZGFncmVqcy9kYWdyZS93aWtpI2NvbmZpZ3VyaW5nLXRoZS1sYXlvdXRcbiAgICAgICAgICAgICAgICBnLmFkZEVkZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBpZDogZWRnZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBlZGdlLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBlZGdlLnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0OiBlZGdlLmRhdGEud2VpZ2h0IHx8IDEsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBwcmV2R3JhcGggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAocHJlc2V0ID09PSBudWxsIHx8IHByZXNldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJlc2V0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHByZXZHcmFwaCA9IG5ldyBHcmFwaCh7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzOiBwcmVzZXQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXlvdXQoZywge1xuICAgICAgICAgICAgICAgIHByZXZHcmFwaCxcbiAgICAgICAgICAgICAgICBlZGdlTGFiZWxTcGFjZSxcbiAgICAgICAgICAgICAgICBrZWVwTm9kZU9yZGVyOiAhIW5vZGVPcmRlcixcbiAgICAgICAgICAgICAgICBub2RlT3JkZXI6IG5vZGVPcmRlciB8fCBbXSxcbiAgICAgICAgICAgICAgICBhY3ljbGljZXI6ICdncmVlZHknLFxuICAgICAgICAgICAgICAgIHJhbmtlcixcbiAgICAgICAgICAgICAgICByYW5rZGlyLFxuICAgICAgICAgICAgICAgIG5vZGVzZXAsXG4gICAgICAgICAgICAgICAgYWxpZ24sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGxheW91dFRvcExlZnQgPSBbMCwgMF07XG4gICAgICAgICAgICBpZiAoYmVnaW4pIHtcbiAgICAgICAgICAgICAgICBsZXQgbWluWCA9IEluZmluaXR5O1xuICAgICAgICAgICAgICAgIGxldCBtaW5ZID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgZy5nZXRBbGxOb2RlcygpLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pblggPiBub2RlLmRhdGEueClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pblggPSBub2RlLmRhdGEueDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1pblkgPiBub2RlLmRhdGEueSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pblkgPSBub2RlLmRhdGEueTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBnLmdldEFsbEVkZ2VzKCkuZm9yRWFjaCgoZWRnZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IGVkZ2UuZGF0YS5wb2ludHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChwb2ludCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pblggPiBwb2ludC54KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pblggPSBwb2ludC54O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1pblkgPiBwb2ludC55KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pblkgPSBwb2ludC55O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsYXlvdXRUb3BMZWZ0WzBdID0gYmVnaW5bMF0gLSBtaW5YO1xuICAgICAgICAgICAgICAgIGxheW91dFRvcExlZnRbMV0gPSBiZWdpblsxXSAtIG1pblk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpc0hvcml6b250YWwgPSByYW5rZGlyID09PSAnTFInIHx8IHJhbmtkaXIgPT09ICdSTCc7XG4gICAgICAgICAgICBpZiAocmFkaWFsKSB7XG4gICAgICAgICAgICAgICAgLy8gY29uc3QgZm9jdXNJZCA9IChpc1N0cmluZyhmb2N1c05vZGUpID8gZm9jdXNOb2RlIDogZm9jdXNOb2RlPy5pZCkgYXMgSUQ7XG4gICAgICAgICAgICAgICAgLy8gY29uc3QgZm9jdXNMYXllciA9IGZvY3VzSWQgPyBnLmdldE5vZGUoZm9jdXNJZCk/LmRhdGEuX3JhbmsgYXMgbnVtYmVyIDogMDtcbiAgICAgICAgICAgICAgICAvLyBjb25zdCBsYXllcnM6IGFueVtdID0gW107XG4gICAgICAgICAgICAgICAgLy8gY29uc3QgZGltID0gaXNIb3Jpem9udGFsID8gXCJ5XCIgOiBcInhcIjtcbiAgICAgICAgICAgICAgICAvLyBjb25zdCBzaXplRGltID0gaXNIb3Jpem9udGFsID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIjtcbiAgICAgICAgICAgICAgICAvLyAvLyDmib7liLDmlbTkuKrlm77kvZzkuLrnjq/nmoTlnZDmoIfnu7TluqbvvIhkaW3vvInnmoTmnIDlpKfjgIHmnIDlsI/lgLzvvIzogIPomZHoioLngrnlrr3luqZcbiAgICAgICAgICAgICAgICAvLyBsZXQgbWluID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgLy8gbGV0IG1heCA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgICAgICAvLyBnLmdldEFsbE5vZGVzKCkuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vICAgY29uc3QgY3VycmVudE5vZGVzZXAgPSBub2Rlc2VwZnVuYyhub2RlKTtcbiAgICAgICAgICAgICAgICAvLyAgIGlmIChmb2N1c0xheWVyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIGlmICghbGF5ZXJzW25vZGUuZGF0YS5fcmFuayFdKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgbGF5ZXJzW25vZGUuZGF0YS5fcmFuayFdID0ge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgbm9kZXM6IFtdLFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgdG90YWxXaWR0aDogMCxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIG1heFNpemU6IC1JbmZpbml0eSxcbiAgICAgICAgICAgICAgICAvLyAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAgICAgLy8gICAgIGxheWVyc1tub2RlLmRhdGEuX3JhbmshXS5ub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIC8vICAgICBsYXllcnNbbm9kZS5kYXRhLl9yYW5rIV0udG90YWxXaWR0aCArPSBjdXJyZW50Tm9kZXNlcCAqIDIgKyBub2RlLmRhdGFbc2l6ZURpbV0hO1xuICAgICAgICAgICAgICAgIC8vICAgICBpZiAoXG4gICAgICAgICAgICAgICAgLy8gICAgICAgbGF5ZXJzW25vZGUuZGF0YS5fcmFuayFdLm1heFNpemUgPCBNYXRoLm1heChub2RlLmRhdGEud2lkdGghLCBub2RlLmRhdGEuaGVpZ2h0ISlcbiAgICAgICAgICAgICAgICAvLyAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgbGF5ZXJzW25vZGUuZGF0YS5fcmFuayFdLm1heFNpemUgPSBNYXRoLm1heChub2RlLmRhdGEud2lkdGghLCBub2RlLmRhdGEuaGVpZ2h0ISk7XG4gICAgICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgICAgICAvLyAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIGNvbnN0IGRpZmZMYXllciA9IG5vZGUuZGF0YS5fcmFuayEgLSBmb2N1c0xheWVyITtcbiAgICAgICAgICAgICAgICAvLyAgICAgaWYgKGRpZmZMYXllciA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vICAgICAgIGlmICghbGF5ZXJzW2RpZmZMYXllcl0pIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxheWVyc1tkaWZmTGF5ZXJdID0ge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICBub2RlczogW10sXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgIHRvdGFsV2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgIG1heFNpemU6IC1JbmZpbml0eSxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICAgICAgIGxheWVyc1tkaWZmTGF5ZXJdLm5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgbGF5ZXJzW2RpZmZMYXllcl0udG90YWxXaWR0aCArPSBjdXJyZW50Tm9kZXNlcCAqIDIgKyBub2RlLmRhdGFbc2l6ZURpbV0hO1xuICAgICAgICAgICAgICAgIC8vICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxheWVyc1tkaWZmTGF5ZXJdLm1heFNpemUgPCBNYXRoLm1heChub2RlLmRhdGEud2lkdGghLCBub2RlLmRhdGEuaGVpZ2h0ISlcbiAgICAgICAgICAgICAgICAvLyAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxheWVyc1tkaWZmTGF5ZXJdLm1heFNpemUgPSBNYXRoLm1heChub2RlLmRhdGEud2lkdGghLCBub2RlLmRhdGEuaGVpZ2h0ISk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vICAgICAgIGNvbnN0IGRpZmZMYXllckFicyA9IE1hdGguYWJzKGRpZmZMYXllcik7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgaWYgKCFsYXllcnNbZGlmZkxheWVyQWJzXSkge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGF5ZXJzW2RpZmZMYXllckFic10gPSB7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgIGxlZnQ6IFtdLFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICByaWdodDogW10sXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgIHRvdGFsV2lkdGg6IDAsXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICAgIG1heFNpemU6IC1JbmZpbml0eSxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gICAgICAgfVxuICAgICAgICAgICAgICAgIC8vICAgICAgIGxheWVyc1tkaWZmTGF5ZXJBYnNdLnRvdGFsV2lkdGggKz1cbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGN1cnJlbnROb2Rlc2VwICogMiArIG5vZGUuZGF0YVtzaXplRGltXSE7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGF5ZXJzW2RpZmZMYXllckFic10ubWF4U2l6ZSA8IE1hdGgubWF4KG5vZGUuZGF0YS53aWR0aCEsIG5vZGUuZGF0YS5oZWlnaHQhKVxuICAgICAgICAgICAgICAgIC8vICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGF5ZXJzW2RpZmZMYXllckFic10ubWF4U2l6ZSA9IE1hdGgubWF4KFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICBub2RlLmRhdGEud2lkdGghLFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICBub2RlLmRhdGEuaGVpZ2h0IVxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gICAgICAgaWYgKGRpZmZMYXllciA8IDApIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGxheWVyc1tkaWZmTGF5ZXJBYnNdLmxlZnQucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgbGF5ZXJzW2RpZmZMYXllckFic10ucmlnaHQucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAgICAgICAvLyAgIGNvbnN0IGxlZnRQb3MgPSBub2RlLmRhdGFbZGltXSEgLSBub2RlLmRhdGFbc2l6ZURpbV0hIC8gMiAtIGN1cnJlbnROb2Rlc2VwO1xuICAgICAgICAgICAgICAgIC8vICAgY29uc3QgcmlnaHRQb3MgPSBub2RlLmRhdGFbZGltXSEgKyBub2RlLmRhdGFbc2l6ZURpbV0hIC8gMiArIGN1cnJlbnROb2Rlc2VwO1xuICAgICAgICAgICAgICAgIC8vICAgaWYgKGxlZnRQb3MgPCBtaW4pIG1pbiA9IGxlZnRQb3M7XG4gICAgICAgICAgICAgICAgLy8gICBpZiAocmlnaHRQb3MgPiBtYXgpIG1heCA9IHJpZ2h0UG9zO1xuICAgICAgICAgICAgICAgIC8vIH0pO1xuICAgICAgICAgICAgICAgIC8vIC8vIGNvbnN0IHBhZGRpbmcgPSAobWF4IC0gbWluKSAqIDAuMTsgLy8gVE9ET1xuICAgICAgICAgICAgICAgIC8vIC8vIOWIneWni+WMluS4uuesrOS4gOWciOeahOWNiuW+hO+8jOWQjumdouagueaNruavj+WxgiByYW5rc2VwIOWPoOWKoFxuICAgICAgICAgICAgICAgIC8vIGxldCByYWRpdXMgPSByYW5rc2VwIHx8IDUwOyAvLyBUT0RPO1xuICAgICAgICAgICAgICAgIC8vIGNvbnN0IHJhZGl1c01hcDogYW55ID0ge307XG4gICAgICAgICAgICAgICAgLy8gLy8g5omp5aSn5pyA5aSn5pyA5bCP5YC86IyD5Zu077yM5Lul5L6/5Li6546v5LiK55WZ5Ye65o6l57yd5aSE55qE56m66ZqZXG4gICAgICAgICAgICAgICAgLy8gY29uc3QgcmFuZ2VMZW5ndGggPSAobWF4IC0gbWluKSAvIDAuOTtcbiAgICAgICAgICAgICAgICAvLyBjb25zdCByYW5nZSA9IFtcbiAgICAgICAgICAgICAgICAvLyAgIChtaW4gKyBtYXggLSByYW5nZUxlbmd0aCkgKiAwLjUsXG4gICAgICAgICAgICAgICAgLy8gICAobWluICsgbWF4ICsgcmFuZ2VMZW5ndGgpICogMC41LFxuICAgICAgICAgICAgICAgIC8vIF07XG4gICAgICAgICAgICAgICAgLy8gLy8g5qC55o2u5Y2K5b6E44CB5YiG5biD5q+U5L6L77yM6K6h566X6IqC54K55Zyo546v5LiK55qE5L2N572u77yM5bm26L+U5Zue6K+l57uE6IqC54K55Lit5pyA5aSn55qEIHJhbmtzZXAg5YC8XG4gICAgICAgICAgICAgICAgLy8gY29uc3QgcHJvY2Vzc05vZGVzID0gKFxuICAgICAgICAgICAgICAgIC8vICAgbGF5ZXJOb2RlczogYW55LFxuICAgICAgICAgICAgICAgIC8vICAgcmFkaXVzOiBudW1iZXIsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wc01heFJhbmtzZXAgPSAtSW5maW5pdHksXG4gICAgICAgICAgICAgICAgLy8gICBhcmNSYW5nZSA9IFswLCAxXVxuICAgICAgICAgICAgICAgIC8vICkgPT4ge1xuICAgICAgICAgICAgICAgIC8vICAgbGV0IG1heFJhbmtzZXAgPSBwcm9wc01heFJhbmtzZXA7XG4gICAgICAgICAgICAgICAgLy8gICBsYXllck5vZGVzLmZvckVhY2goKG5vZGU6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vICAgICBjb25zdCBjb29yZCA9IGcubm9kZShub2RlKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgcmFkaXVzTWFwW25vZGVdID0gcmFkaXVzO1xuICAgICAgICAgICAgICAgIC8vICAgICAvLyDojrflj5blj5jlvaLkuLogcmFkaWFsIOWQjueahOebtOinkuWdkOagh+ezu+WdkOagh1xuICAgICAgICAgICAgICAgIC8vICAgICBjb25zdCB7IHg6IG5ld1gsIHk6IG5ld1kgfSA9IGdldFJhZGlhbFBvcyhcbiAgICAgICAgICAgICAgICAvLyAgICAgICBjb29yZCFbZGltXSEsXG4gICAgICAgICAgICAgICAgLy8gICAgICAgcmFuZ2UsXG4gICAgICAgICAgICAgICAgLy8gICAgICAgcmFuZ2VMZW5ndGgsXG4gICAgICAgICAgICAgICAgLy8gICAgICAgcmFkaXVzLFxuICAgICAgICAgICAgICAgIC8vICAgICAgIGFyY1JhbmdlXG4gICAgICAgICAgICAgICAgLy8gICAgICk7XG4gICAgICAgICAgICAgICAgLy8gICAgIC8vIOWwhuaWsOWdkOagh+WGmeWFpea6kOaVsOaNrlxuICAgICAgICAgICAgICAgIC8vICAgICBjb25zdCBpID0gbm9kZXMuZmluZEluZGV4KChpdCkgPT4gaXQuaWQgPT09IG5vZGUpO1xuICAgICAgICAgICAgICAgIC8vICAgICBpZiAoIW5vZGVzW2ldKSByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gICAgIG5vZGVzW2ldLnggPSBuZXdYICsgZEJlZ2luWzBdO1xuICAgICAgICAgICAgICAgIC8vICAgICBub2Rlc1tpXS55ID0gbmV3WSArIGRCZWdpblsxXTtcbiAgICAgICAgICAgICAgICAvLyAgICAgLy8gQHRzLWlnbm9yZTogcGFzcyBsYXllciBvcmRlciB0byBkYXRhIGZvciBpbmNyZW1lbnQgbGF5b3V0IHVzZVxuICAgICAgICAgICAgICAgIC8vICAgICBub2Rlc1tpXS5fb3JkZXIgPSBjb29yZC5fb3JkZXI7XG4gICAgICAgICAgICAgICAgLy8gICAgIC8vIOaJvuWIsOacrOWxguacgOWkp+eahOS4gOS4qiByYW5rc2Vw77yM5L2c5Li65LiL5LiA5bGC5LiO5pys5bGC55qE6Ze06ZqZ77yM5Y+g5Yqg5Yiw5LiL5LiA5bGC55qE5Y2K5b6E5LiKXG4gICAgICAgICAgICAgICAgLy8gICAgIGNvbnN0IGN1cnJlbnROb2RlUmFua3NlcCA9IHJhbmtzZXBmdW5jKG5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgaWYgKG1heFJhbmtzZXAgPCBjdXJyZW50Tm9kZVJhbmtzZXApIG1heFJhbmtzZXAgPSBjdXJyZW50Tm9kZVJhbmtzZXA7XG4gICAgICAgICAgICAgICAgLy8gICB9KTtcbiAgICAgICAgICAgICAgICAvLyAgIHJldHVybiBtYXhSYW5rc2VwO1xuICAgICAgICAgICAgICAgIC8vIH07XG4gICAgICAgICAgICAgICAgLy8gbGV0IGlzRmlyc3RMZXZlbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gY29uc3QgbGFzdExheWVyTWF4Tm9kZVNpemUgPSAwO1xuICAgICAgICAgICAgICAgIC8vIGxheWVycy5mb3JFYWNoKChsYXllck5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gICBpZiAoXG4gICAgICAgICAgICAgICAgLy8gICAgICFsYXllck5vZGVzPy5ub2Rlcz8ubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgLy8gICAgICFsYXllck5vZGVzPy5sZWZ0Py5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICAvLyAgICAgIWxheWVyTm9kZXM/LnJpZ2h0Py5sZW5ndGhcbiAgICAgICAgICAgICAgICAvLyAgICkge1xuICAgICAgICAgICAgICAgIC8vICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gICB9XG4gICAgICAgICAgICAgICAgLy8gICAvLyDnrKzkuIDlsYLlj6rmnInkuIDkuKroioLngrnvvIznm7TmjqXmlL7lnKjlnIblv4PvvIzliJ3lp4vljYrlvoTorr7lrprkuLogMFxuICAgICAgICAgICAgICAgIC8vICAgaWYgKGlzRmlyc3RMZXZlbCAmJiBsYXllck5vZGVzLm5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vICAgICAvLyDlsIbmlrDlnZDmoIflhpnlhaXmupDmlbDmja5cbiAgICAgICAgICAgICAgICAvLyAgICAgY29uc3QgaSA9IG5vZGVzLmZpbmRJbmRleCgoaXQpID0+IGl0LmlkID09PSBsYXllck5vZGVzLm5vZGVzWzBdKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgaWYgKGkgPD0gLTEpIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyAgICAgbm9kZXNbaV0ueCA9IGRCZWdpblswXTtcbiAgICAgICAgICAgICAgICAvLyAgICAgbm9kZXNbaV0ueSA9IGRCZWdpblsxXTtcbiAgICAgICAgICAgICAgICAvLyAgICAgcmFkaXVzTWFwW2xheWVyTm9kZXMubm9kZXNbMF1dID0gMDtcbiAgICAgICAgICAgICAgICAvLyAgICAgcmFkaXVzID0gcmFua3NlcGZ1bmMobm9kZXNbaV0pO1xuICAgICAgICAgICAgICAgIC8vICAgICBpc0ZpcnN0TGV2ZWwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vICAgfVxuICAgICAgICAgICAgICAgIC8vICAgLy8g5Li65o6l57yd55WZ5Ye656m66ZqZ77yM5Y2K5b6E5Lmf6ZyA6KaB5omp5aSnXG4gICAgICAgICAgICAgICAgLy8gICByYWRpdXMgPSBNYXRoLm1heChyYWRpdXMsIGxheWVyTm9kZXMudG90YWxXaWR0aCAvICgyICogTWF0aC5QSSkpOyAvLyAvIDAuOTtcbiAgICAgICAgICAgICAgICAvLyAgIGxldCBtYXhSYW5rc2VwID0gLUluZmluaXR5O1xuICAgICAgICAgICAgICAgIC8vICAgaWYgKGZvY3VzTGF5ZXIgPT09IDAgfHwgbGF5ZXJOb2Rlcy5ub2Rlcz8ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gICAgIG1heFJhbmtzZXAgPSBwcm9jZXNzTm9kZXMoXG4gICAgICAgICAgICAgICAgLy8gICAgICAgbGF5ZXJOb2Rlcy5ub2RlcyxcbiAgICAgICAgICAgICAgICAvLyAgICAgICByYWRpdXMsXG4gICAgICAgICAgICAgICAgLy8gICAgICAgbWF4UmFua3NlcCxcbiAgICAgICAgICAgICAgICAvLyAgICAgICBbMCwgMV1cbiAgICAgICAgICAgICAgICAvLyAgICAgKTsgLy8gMC44XG4gICAgICAgICAgICAgICAgLy8gICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vICAgICBjb25zdCBsZWZ0UmF0aW8gPVxuICAgICAgICAgICAgICAgIC8vICAgICAgIGxheWVyTm9kZXMubGVmdD8ubGVuZ3RoIC9cbiAgICAgICAgICAgICAgICAvLyAgICAgICAobGF5ZXJOb2Rlcy5sZWZ0Py5sZW5ndGggKyBsYXllck5vZGVzLnJpZ2h0Py5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vICAgICBtYXhSYW5rc2VwID0gcHJvY2Vzc05vZGVzKGxheWVyTm9kZXMubGVmdCwgcmFkaXVzLCBtYXhSYW5rc2VwLCBbXG4gICAgICAgICAgICAgICAgLy8gICAgICAgMCxcbiAgICAgICAgICAgICAgICAvLyAgICAgICBsZWZ0UmF0aW8sXG4gICAgICAgICAgICAgICAgLy8gICAgIF0pOyAvLyDmjqXnvJ3nlZnlh7ogMC4wNSDnmoTnvJ3pmplcbiAgICAgICAgICAgICAgICAvLyAgICAgbWF4UmFua3NlcCA9IHByb2Nlc3NOb2RlcyhsYXllck5vZGVzLnJpZ2h0LCByYWRpdXMsIG1heFJhbmtzZXAsIFtcbiAgICAgICAgICAgICAgICAvLyAgICAgICBsZWZ0UmF0aW8gKyAwLjA1LFxuICAgICAgICAgICAgICAgIC8vICAgICAgIDEsXG4gICAgICAgICAgICAgICAgLy8gICAgIF0pOyAvLyDmjqXnvJ3nlZnlh7ogMC4wNSDnmoTnvJ3pmplcbiAgICAgICAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAgICAgICAvLyAgIHJhZGl1cyArPSBtYXhSYW5rc2VwO1xuICAgICAgICAgICAgICAgIC8vICAgaXNGaXJzdExldmVsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gICBsYXN0TGF5ZXJNYXhOb2RlU2l6ZSAtIGxheWVyTm9kZXMubWF4U2l6ZTtcbiAgICAgICAgICAgICAgICAvLyB9KTtcbiAgICAgICAgICAgICAgICAvLyBnLmVkZ2VzKCkuZm9yRWFjaCgoZWRnZTogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gICBjb25zdCBjb29yZCA9IGcuZWRnZShlZGdlKTtcbiAgICAgICAgICAgICAgICAvLyAgIGNvbnN0IGkgPSBlZGdlcy5maW5kSW5kZXgoKGl0KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gICAgIGNvbnN0IHNvdXJjZSA9IGdldEVkZ2VUZXJtaW5hbChpdCwgXCJzb3VyY2VcIik7XG4gICAgICAgICAgICAgICAgLy8gICAgIGNvbnN0IHRhcmdldCA9IGdldEVkZ2VUZXJtaW5hbChpdCwgXCJ0YXJnZXRcIik7XG4gICAgICAgICAgICAgICAgLy8gICAgIHJldHVybiBzb3VyY2UgPT09IGVkZ2UudiAmJiB0YXJnZXQgPT09IGVkZ2UudztcbiAgICAgICAgICAgICAgICAvLyAgIH0pO1xuICAgICAgICAgICAgICAgIC8vICAgaWYgKGkgPD0gLTEpIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyAgIGlmIChcbiAgICAgICAgICAgICAgICAvLyAgICAgc2VsZi5lZGdlTGFiZWxTcGFjZSAmJlxuICAgICAgICAgICAgICAgIC8vICAgICBzZWxmLmNvbnRyb2xQb2ludHMgJiZcbiAgICAgICAgICAgICAgICAvLyAgICAgZWRnZXNbaV0udHlwZSAhPT0gXCJsb29wXCJcbiAgICAgICAgICAgICAgICAvLyAgICkge1xuICAgICAgICAgICAgICAgIC8vICAgICBjb25zdCBvdGhlckRpbSA9IGRpbSA9PT0gXCJ4XCIgPyBcInlcIiA6IFwieFwiO1xuICAgICAgICAgICAgICAgIC8vICAgICBjb25zdCBjb250cm9sUG9pbnRzID0gY29vcmQ/LnBvaW50cz8uc2xpY2UoXG4gICAgICAgICAgICAgICAgLy8gICAgICAgMSxcbiAgICAgICAgICAgICAgICAvLyAgICAgICBjb29yZC5wb2ludHMubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgIC8vICAgICApO1xuICAgICAgICAgICAgICAgIC8vICAgICBjb25zdCBuZXdDb250cm9sUG9pbnRzOiBQb2ludFtdID0gW107XG4gICAgICAgICAgICAgICAgLy8gICAgIGNvbnN0IHNvdXJjZU90aGVyRGltVmFsdWUgPSBnLm5vZGUoZWRnZS52KT8uW290aGVyRGltXSE7XG4gICAgICAgICAgICAgICAgLy8gICAgIGNvbnN0IG90aGVyRGltRGlzdCA9XG4gICAgICAgICAgICAgICAgLy8gICAgICAgc291cmNlT3RoZXJEaW1WYWx1ZSAtIGcubm9kZShlZGdlLncpPy5bb3RoZXJEaW1dITtcbiAgICAgICAgICAgICAgICAvLyAgICAgY29uc3Qgc291cmNlUmFkaXVzID0gcmFkaXVzTWFwW2VkZ2Uudl07XG4gICAgICAgICAgICAgICAgLy8gICAgIGNvbnN0IHJhZGl1c0Rpc3QgPSBzb3VyY2VSYWRpdXMgLSByYWRpdXNNYXBbZWRnZS53XTtcbiAgICAgICAgICAgICAgICAvLyAgICAgY29udHJvbFBvaW50cz8uZm9yRWFjaCgocG9pbnQ6IGFueSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vICAgICAgIC8vIOagueaNruivpei+ueeahOi1t+eCueOAgee7iOeCueWNiuW+hO+8jOWPiui1t+eCueOAgee7iOeCueOAgeaOp+WItueCueS9jee9ruWFs+ezu++8jOehruWumuivpeaOp+WItueCueeahOWNiuW+hFxuICAgICAgICAgICAgICAgIC8vICAgICAgIGNvbnN0IGNSYWRpdXMgPVxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgKChwb2ludFtvdGhlckRpbV0gLSBzb3VyY2VPdGhlckRpbVZhbHVlKSAvIG90aGVyRGltRGlzdCkgKlxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgICByYWRpdXNEaXN0ICtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHNvdXJjZVJhZGl1cztcbiAgICAgICAgICAgICAgICAvLyAgICAgICAvLyDojrflj5blj5jlvaLkuLogcmFkaWFsIOWQjueahOebtOinkuWdkOagh+ezu+WdkOagh1xuICAgICAgICAgICAgICAgIC8vICAgICAgIGNvbnN0IG5ld1BvcyA9IGdldFJhZGlhbFBvcyhcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHBvaW50W2RpbV0sXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICByYW5nZSxcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHJhbmdlTGVuZ3RoLFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgY1JhZGl1c1xuICAgICAgICAgICAgICAgIC8vICAgICAgICk7XG4gICAgICAgICAgICAgICAgLy8gICAgICAgbmV3Q29udHJvbFBvaW50cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIHg6IG5ld1Bvcy54ICsgZEJlZ2luWzBdLFxuICAgICAgICAgICAgICAgIC8vICAgICAgICAgeTogbmV3UG9zLnkgKyBkQmVnaW5bMV0sXG4gICAgICAgICAgICAgICAgLy8gICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vICAgICBlZGdlc1tpXS5jb250cm9sUG9pbnRzID0gbmV3Q29udHJvbFBvaW50cztcbiAgICAgICAgICAgICAgICAvLyAgIH1cbiAgICAgICAgICAgICAgICAvLyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxheWVyQ29vcmRzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzSW52ZXJ0ID0gcmFua2RpciA9PT0gJ0JUJyB8fCByYW5rZGlyID09PSAnUkwnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxheWVyQ29vcmRTb3J0ID0gaXNJbnZlcnRcbiAgICAgICAgICAgICAgICAgICAgPyAoYSwgYikgPT4gYiAtIGFcbiAgICAgICAgICAgICAgICAgICAgOiAoYSwgYikgPT4gYSAtIGI7XG4gICAgICAgICAgICAgICAgZy5nZXRBbGxOb2RlcygpLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGV0IG5kYXRhOiBhbnkgPSB0aGlzLm5vZGVNYXBbbm9kZV07XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmICghbmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICBuZGF0YSA9IGNvbWJvcz8uZmluZCgoaXQpID0+IGl0LmlkID09PSBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICAvLyBpZiAoIW5kYXRhKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIC8vIG5kYXRhLnggPSBub2RlLmRhdGEueCEgKyBkQmVnaW5bMF07XG4gICAgICAgICAgICAgICAgICAgIC8vIG5kYXRhLnkgPSBub2RlLmRhdGEueSEgKyBkQmVnaW5bMV07XG4gICAgICAgICAgICAgICAgICAgIC8vIC8vICBwYXNzIGxheWVyIG9yZGVyIHRvIGRhdGEgZm9yIGluY3JlbWVudCBsYXlvdXQgdXNlXG4gICAgICAgICAgICAgICAgICAgIC8vIG5kYXRhLl9vcmRlciA9IG5vZGUuZGF0YS5fb3JkZXI7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxheWVyQ29vcmRzLmFkZChpc0hvcml6b250YWwgPyBuZGF0YS54IDogbmRhdGEueSk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuZGF0YS54ID0gbm9kZS5kYXRhLnggKyBsYXlvdXRUb3BMZWZ0WzBdO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmRhdGEueSA9IG5vZGUuZGF0YS55ICsgbGF5b3V0VG9wTGVmdFsxXTtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJDb29yZHMuYWRkKGlzSG9yaXpvbnRhbCA/IG5vZGUuZGF0YS54IDogbm9kZS5kYXRhLnkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxheWVyQ29vcmRzQXJyID0gQXJyYXkuZnJvbShsYXllckNvb3Jkcykuc29ydChsYXllckNvb3JkU29ydCk7XG4gICAgICAgICAgICAgICAgLy8gcHJlLWRlZmluZSB0aGUgaXNIb3Jpem9udGFsIHJlbGF0ZWQgZnVuY3Rpb25zIHRvIGF2b2lkIHJlZHVuZGFudCBjYWxjIGluIGludGVyYXRpb25zXG4gICAgICAgICAgICAgICAgY29uc3QgaXNEaWZmZXJlbnRMYXllciA9IGlzSG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgICA/IChwb2ludDEsIHBvaW50MikgPT4gcG9pbnQxLnggIT09IHBvaW50Mi54XG4gICAgICAgICAgICAgICAgICAgIDogKHBvaW50MSwgcG9pbnQyKSA9PiBwb2ludDEueSAhPT0gcG9pbnQyLnk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyQ29udHJvbFBvaW50c091dE9mQm91bmRhcnkgPSBpc0hvcml6b250YWxcbiAgICAgICAgICAgICAgICAgICAgPyAocHMsIHBvaW50MSwgcG9pbnQyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXggPSBNYXRoLm1heChwb2ludDEueSwgcG9pbnQyLnkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWluID0gTWF0aC5taW4ocG9pbnQxLnksIHBvaW50Mi55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcy5maWx0ZXIoKHBvaW50KSA9PiBwb2ludC55IDw9IG1heCAmJiBwb2ludC55ID49IG1pbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiAocHMsIHBvaW50MSwgcG9pbnQyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXggPSBNYXRoLm1heChwb2ludDEueCwgcG9pbnQyLngpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWluID0gTWF0aC5taW4ocG9pbnQxLngsIHBvaW50Mi54KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcy5maWx0ZXIoKHBvaW50KSA9PiBwb2ludC54IDw9IG1heCAmJiBwb2ludC54ID49IG1pbik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZy5nZXRBbGxFZGdlcygpLmZvckVhY2goKGVkZ2UsIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCBpID0gZWRnZXMuZmluZEluZGV4KChpdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyAgIHJldHVybiBpdC5zb3VyY2UgPT09IGVkZ2Uuc291cmNlICYmIGl0LnRhcmdldCA9PT0gZWRnZS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIC8vIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiAoaSA8PSAtMSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWRnZUxhYmVsU3BhY2UgJiYgY29udHJvbFBvaW50cyAmJiBlZGdlLmRhdGEudHlwZSAhPT0gJ2xvb3AnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlLmRhdGEuY29udHJvbFBvaW50cyA9IGdldENvbnRyb2xQb2ludHMoKF9hID0gZWRnZS5kYXRhLnBvaW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hcCgoeyB4LCB5IH0pID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogeCArIGxheW91dFRvcExlZnRbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogeSArIGxheW91dFRvcExlZnRbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSksIGcuZ2V0Tm9kZShlZGdlLnNvdXJjZSksIGcuZ2V0Tm9kZShlZGdlLnRhcmdldCksIGxheWVyQ29vcmRzQXJyLCBpc0hvcml6b250YWwsIGlzRGlmZmVyZW50TGF5ZXIsIGZpbHRlckNvbnRyb2xQb2ludHNPdXRPZkJvdW5kYXJ5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gY2FsY3VsYXRlZCBub2RlcyBhcyB0ZW1wb3JhcnkgcmVzdWx0XG4gICAgICAgICAgICBsZXQgbGF5b3V0Tm9kZXMgPSBbXTtcbiAgICAgICAgICAgIC8vIGxheW91dCBhY2NvcmRpbmcgdG8gdGhlIG9yaWdpbmFsIG9yZGVyIGluIHRoZSBkYXRhLm5vZGVzXG4gICAgICAgICAgICBsYXlvdXROb2RlcyA9IGdcbiAgICAgICAgICAgICAgICAuZ2V0QWxsTm9kZXMoKVxuICAgICAgICAgICAgICAgIC5tYXAoKG5vZGUpID0+IGNsb25lRm9ybWF0RGF0YShub2RlKSk7XG4gICAgICAgICAgICBjb25zdCBsYXlvdXRFZGdlcyA9IGcuZ2V0QWxsRWRnZXMoKTtcbiAgICAgICAgICAgIGlmIChhc3NpZ24pIHtcbiAgICAgICAgICAgICAgICBsYXlvdXROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoLm1lcmdlTm9kZURhdGEobm9kZS5pZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogbm9kZS5kYXRhLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBub2RlLmRhdGEueSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGF5b3V0RWRnZXMuZm9yRWFjaCgoZWRnZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBncmFwaC5tZXJnZUVkZ2VEYXRhKGVkZ2UuaWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xQb2ludHM6IGVkZ2UuZGF0YS5jb250cm9sUG9pbnRzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBub2RlczogbGF5b3V0Tm9kZXMsXG4gICAgICAgICAgICAgICAgZWRnZXM6IGxheW91dEVkZ2VzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogRm9ybWF0IGNvbnRyb2xQb2ludHMgdG8gYXZvaWQgcG9seWxpbmVzIGNyb3NzaW5nIG5vZGVzXG4gKiBAcGFyYW0gcG9pbnRzXG4gKiBAcGFyYW0gc291cmNlTm9kZVxuICogQHBhcmFtIHRhcmdldE5vZGVcbiAqIEBwYXJhbSBsYXllckNvb3Jkc0FyclxuICogQHBhcmFtIGlzSG9yaXpvbnRhbFxuICogQHJldHVybnNcbiAqL1xuY29uc3QgZ2V0Q29udHJvbFBvaW50cyA9IChwb2ludHMsIHNvdXJjZU5vZGUsIHRhcmdldE5vZGUsIGxheWVyQ29vcmRzQXJyLCBpc0hvcml6b250YWwsIGlzRGlmZmVyZW50TGF5ZXIsIGZpbHRlckNvbnRyb2xQb2ludHNPdXRPZkJvdW5kYXJ5KSA9PiB7XG4gICAgbGV0IGNvbnRyb2xQb2ludHMgPSAocG9pbnRzID09PSBudWxsIHx8IHBvaW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogcG9pbnRzLnNsaWNlKDEsIHBvaW50cy5sZW5ndGggLSAxKSkgfHwgW107IC8vIOWOu+aOieWktOWwvlxuICAgIC8vIOmFjOaDheWinuWKoOaOp+WItueCue+8jOS9v+aKmOe6v+S4jeepv+i/h+i3qOWxgueahOiKgueCuVxuICAgIGlmIChzb3VyY2VOb2RlICYmIHRhcmdldE5vZGUpIHtcbiAgICAgICAgbGV0IHsgeDogc291cmNlWCwgeTogc291cmNlWSB9ID0gc291cmNlTm9kZS5kYXRhO1xuICAgICAgICBsZXQgeyB4OiB0YXJnZXRYLCB5OiB0YXJnZXRZIH0gPSB0YXJnZXROb2RlLmRhdGE7XG4gICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIHNvdXJjZVggPSBzb3VyY2VOb2RlLmRhdGEueTtcbiAgICAgICAgICAgIHNvdXJjZVkgPSBzb3VyY2VOb2RlLmRhdGEueDtcbiAgICAgICAgICAgIHRhcmdldFggPSB0YXJnZXROb2RlLmRhdGEueTtcbiAgICAgICAgICAgIHRhcmdldFkgPSB0YXJnZXROb2RlLmRhdGEueDtcbiAgICAgICAgfVxuICAgICAgICAvLyDkuLrot6jlsYLnuqfnmoTovrnlop7liqDnrKzkuIDkuKrmjqfliLbngrnjgILlv73nlaXlnoLnm7TnmoQv5qiq5ZCR55qE6L6544CCXG4gICAgICAgIC8vIOaWsOaOp+WItueCuSA9IHtcbiAgICAgICAgLy8gICB4OiDnu4jngrl4LFxuICAgICAgICAvLyAgIHk6ICjotbfngrl5ICsg5LiL5LiA5bGCeSkgLyAyLCAgICPkuIvkuIDlsYJ55Y+v6IO95LiN562J5LqO57uI54K5eVxuICAgICAgICAvLyB9XG4gICAgICAgIGlmICh0YXJnZXRZICE9PSBzb3VyY2VZICYmIHNvdXJjZVggIT09IHRhcmdldFgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUxheWVyID0gbGF5ZXJDb29yZHNBcnIuaW5kZXhPZihzb3VyY2VZKTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZU5leHRMYXllckNvb3JkID0gbGF5ZXJDb29yZHNBcnJbc291cmNlTGF5ZXIgKyAxXTtcbiAgICAgICAgICAgIGlmIChzb3VyY2VOZXh0TGF5ZXJDb29yZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0Q29udHJvbFBvaW50ID0gY29udHJvbFBvaW50c1swXTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbnNlcnRTdGFydENvbnRyb2xQb2ludCA9IChpc0hvcml6b250YWxcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAoc291cmNlWSArIHNvdXJjZU5leHRMYXllckNvb3JkKSAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiAoZmlyc3RDb250cm9sUG9pbnQgPT09IG51bGwgfHwgZmlyc3RDb250cm9sUG9pbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpcnN0Q29udHJvbFBvaW50LnkpIHx8IHRhcmdldFgsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAoZmlyc3RDb250cm9sUG9pbnQgPT09IG51bGwgfHwgZmlyc3RDb250cm9sUG9pbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpcnN0Q29udHJvbFBvaW50LngpIHx8IHRhcmdldFgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiAoc291cmNlWSArIHNvdXJjZU5leHRMYXllckNvb3JkKSAvIDIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIOW9k+aWsOWinueahOaOp+WItueCueS4jeWtmOWcqO+8iCE95b2T5YmN56ys5LiA5Liq5o6n5Yi254K577yJ5pe25re75YqgXG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdENvbnRyb2xQb2ludCB8fFxuICAgICAgICAgICAgICAgICAgICBpc0RpZmZlcmVudExheWVyKGZpcnN0Q29udHJvbFBvaW50LCBpbnNlcnRTdGFydENvbnRyb2xQb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbFBvaW50cy51bnNoaWZ0KGluc2VydFN0YXJ0Q29udHJvbFBvaW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRMYXllciA9IGxheWVyQ29vcmRzQXJyLmluZGV4T2YodGFyZ2V0WSk7XG4gICAgICAgICAgICBjb25zdCBsYXllckRpZmYgPSBNYXRoLmFicyh0YXJnZXRMYXllciAtIHNvdXJjZUxheWVyKTtcbiAgICAgICAgICAgIGlmIChsYXllckRpZmYgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sUG9pbnRzID0gZmlsdGVyQ29udHJvbFBvaW50c091dE9mQm91bmRhcnkoY29udHJvbFBvaW50cywgc291cmNlTm9kZS5kYXRhLCB0YXJnZXROb2RlLmRhdGEpO1xuICAgICAgICAgICAgICAgIC8vIG9uZSBjb250cm9sUG9pbnQgYXQgbGVhc3RcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRyb2xQb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xQb2ludHMucHVzaCgoaXNIb3Jpem9udGFsXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiAoc291cmNlWSArIHRhcmdldFkpIC8gMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBzb3VyY2VYLFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogc291cmNlWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiAoc291cmNlWSArIHRhcmdldFkpIC8gMixcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsYXllckRpZmYgPiAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0TGFzdExheWVyQ29vcmQgPSBsYXllckNvb3Jkc0Fyclt0YXJnZXRMYXllciAtIDFdO1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRMYXN0TGF5ZXJDb29yZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0Q29udHJvbFBvaW50cyA9IGNvbnRyb2xQb2ludHNbY29udHJvbFBvaW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5zZXJ0RW5kQ29udHJvbFBvaW50ID0gKGlzSG9yaXpvbnRhbFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogKHRhcmdldFkgKyB0YXJnZXRMYXN0TGF5ZXJDb29yZCkgLyAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IChsYXN0Q29udHJvbFBvaW50cyA9PT0gbnVsbCB8fCBsYXN0Q29udHJvbFBvaW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdENvbnRyb2xQb2ludHMueSkgfHwgdGFyZ2V0WCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IChsYXN0Q29udHJvbFBvaW50cyA9PT0gbnVsbCB8fCBsYXN0Q29udHJvbFBvaW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdENvbnRyb2xQb2ludHMueCkgfHwgc291cmNlWCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiAodGFyZ2V0WSArIHRhcmdldExhc3RMYXllckNvb3JkKSAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8g5b2T5paw5aKe55qE5o6n5Yi254K55LiN5a2Y5Zyo77yIIT3lvZPliY3mnIDlkI7kuIDkuKrmjqfliLbngrnvvInml7bmt7vliqBcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsYXN0Q29udHJvbFBvaW50cyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNEaWZmZXJlbnRMYXllcihsYXN0Q29udHJvbFBvaW50cywgaW5zZXJ0RW5kQ29udHJvbFBvaW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbFBvaW50cy5wdXNoKGluc2VydEVuZENvbnRyb2xQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbnRyb2xQb2ludHM7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YW50di1kYWdyZS5qcy5tYXAiLCJpbXBvcnQgeyBncmVlZHlGQVMgfSBmcm9tICcuL2dyZWVkeS1mYXMnO1xuY29uc3QgcnVuID0gKGcsIGFjeWNsaWNlcikgPT4ge1xuICAgIGNvbnN0IHdlaWdodEZuID0gKGcpID0+IHtcbiAgICAgICAgcmV0dXJuIChlKSA9PiBlLmRhdGEud2VpZ2h0IHx8IDE7XG4gICAgfTtcbiAgICBjb25zdCBmYXMgPSBhY3ljbGljZXIgPT09ICdncmVlZHknID8gZ3JlZWR5RkFTKGcsIHdlaWdodEZuKGcpKSA6IGRmc0ZBUyhnKTtcbiAgICBmYXMgPT09IG51bGwgfHwgZmFzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmYXMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICBjb25zdCBsYWJlbCA9IGUuZGF0YTtcbiAgICAgICAgZy5yZW1vdmVFZGdlKGUuaWQpO1xuICAgICAgICBsYWJlbC5mb3J3YXJkTmFtZSA9IGUuZGF0YS5uYW1lO1xuICAgICAgICBsYWJlbC5yZXZlcnNlZCA9IHRydWU7XG4gICAgICAgIGcuYWRkRWRnZSh7XG4gICAgICAgICAgICBpZDogZS5pZCxcbiAgICAgICAgICAgIHNvdXJjZTogZS50YXJnZXQsXG4gICAgICAgICAgICB0YXJnZXQ6IGUuc291cmNlLFxuICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgbGFiZWwpLFxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5jb25zdCBkZnNGQVMgPSAoZykgPT4ge1xuICAgIGNvbnN0IGZhcyA9IFtdO1xuICAgIGNvbnN0IHN0YWNrID0ge307XG4gICAgY29uc3QgdmlzaXRlZCA9IHt9O1xuICAgIGNvbnN0IGRmcyA9ICh2KSA9PiB7XG4gICAgICAgIGlmICh2aXNpdGVkW3ZdKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRlZFt2XSA9IHRydWU7XG4gICAgICAgIHN0YWNrW3ZdID0gdHJ1ZTtcbiAgICAgICAgZy5nZXRSZWxhdGVkRWRnZXModiwgJ291dCcpLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgICAgIGlmIChzdGFja1tlLnRhcmdldF0pIHtcbiAgICAgICAgICAgICAgICBmYXMucHVzaChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRmcyhlLnRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgc3RhY2tbdl07XG4gICAgfTtcbiAgICBnLmdldEFsbE5vZGVzKCkuZm9yRWFjaCgobikgPT4gZGZzKG4uaWQpKTtcbiAgICByZXR1cm4gZmFzO1xufTtcbmNvbnN0IHVuZG8gPSAoZykgPT4ge1xuICAgIGcuZ2V0QWxsRWRnZXMoKS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gZS5kYXRhO1xuICAgICAgICBpZiAobGFiZWwucmV2ZXJzZWQpIHtcbiAgICAgICAgICAgIGcucmVtb3ZlRWRnZShlLmlkKTtcbiAgICAgICAgICAgIGNvbnN0IGZvcndhcmROYW1lID0gbGFiZWwuZm9yd2FyZE5hbWU7XG4gICAgICAgICAgICBkZWxldGUgbGFiZWwucmV2ZXJzZWQ7XG4gICAgICAgICAgICBkZWxldGUgbGFiZWwuZm9yd2FyZE5hbWU7XG4gICAgICAgICAgICBnLmFkZEVkZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiBlLmlkLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogZS50YXJnZXQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBlLnNvdXJjZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxhYmVsKSwgeyBmb3J3YXJkTmFtZSB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuZXhwb3J0IHsgcnVuLCB1bmRvIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hY3ljbGljLmpzLm1hcCIsImltcG9ydCB7IGFkZER1bW15Tm9kZSB9IGZyb20gJy4vdXRpbCc7XG5leHBvcnQgY29uc3QgYWRkQm9yZGVyU2VnbWVudHMgPSAoZykgPT4ge1xuICAgIGNvbnN0IGRmcyA9ICh2KSA9PiB7XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gZy5nZXRDaGlsZHJlbih2KTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGcuZ2V0Tm9kZSh2KTtcbiAgICAgICAgaWYgKGNoaWxkcmVuID09PSBudWxsIHx8IGNoaWxkcmVuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNoaWxkcmVuLmZvckVhY2goKGNoaWxkKSA9PiBkZnMoY2hpbGQuaWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5kYXRhLmhhc093blByb3BlcnR5KCdtaW5SYW5rJykpIHtcbiAgICAgICAgICAgIG5vZGUuZGF0YS5ib3JkZXJMZWZ0ID0gW107XG4gICAgICAgICAgICBub2RlLmRhdGEuYm9yZGVyUmlnaHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IHJhbmsgPSBub2RlLmRhdGEubWluUmFuaywgbWF4UmFuayA9IG5vZGUuZGF0YS5tYXhSYW5rICsgMTsgcmFuayA8IG1heFJhbms7IHJhbmsgKz0gMSkge1xuICAgICAgICAgICAgICAgIGFkZEJvcmRlck5vZGUoZywgJ2JvcmRlckxlZnQnLCAnX2JsJywgdiwgbm9kZSwgcmFuayk7XG4gICAgICAgICAgICAgICAgYWRkQm9yZGVyTm9kZShnLCAnYm9yZGVyUmlnaHQnLCAnX2JyJywgdiwgbm9kZSwgcmFuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGcuZ2V0Um9vdHMoKS5mb3JFYWNoKChjaGlsZCkgPT4gZGZzKGNoaWxkLmlkKSk7XG59O1xuY29uc3QgYWRkQm9yZGVyTm9kZSA9IChnLCBwcm9wLCBwcmVmaXgsIHNnLCBzZ05vZGUsIHJhbmspID0+IHtcbiAgICBjb25zdCBsYWJlbCA9IHsgcmFuaywgYm9yZGVyVHlwZTogcHJvcCwgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBwcmV2ID0gc2dOb2RlLmRhdGFbcHJvcF1bcmFuayAtIDFdO1xuICAgIGNvbnN0IGN1cnIgPSBhZGREdW1teU5vZGUoZywgJ2JvcmRlcicsIGxhYmVsLCBwcmVmaXgpO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBzZ05vZGUuZGF0YVtwcm9wXVtyYW5rXSA9IGN1cnI7XG4gICAgZy5zZXRQYXJlbnQoY3Vyciwgc2cpO1xuICAgIGlmIChwcmV2KSB7XG4gICAgICAgIGcuYWRkRWRnZSh7XG4gICAgICAgICAgICBpZDogYGUke01hdGgucmFuZG9tKCl9YCxcbiAgICAgICAgICAgIHNvdXJjZTogcHJldixcbiAgICAgICAgICAgIHRhcmdldDogY3VycixcbiAgICAgICAgICAgIGRhdGE6IHsgd2VpZ2h0OiAxIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGQtYm9yZGVyLXNlZ21lbnRzLmpzLm1hcCIsImNvbnN0IGFkanVzdCA9IChnLCByYW5rZGlyKSA9PiB7XG4gICAgY29uc3QgcmQgPSByYW5rZGlyLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHJkID09PSAnbHInIHx8IHJkID09PSAncmwnKSB7XG4gICAgICAgIHN3YXBXaWR0aEhlaWdodChnKTtcbiAgICB9XG59O1xuY29uc3QgdW5kbyA9IChnLCByYW5rZGlyKSA9PiB7XG4gICAgY29uc3QgcmQgPSByYW5rZGlyLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHJkID09PSAnYnQnIHx8IHJkID09PSAncmwnKSB7XG4gICAgICAgIHJldmVyc2VZKGcpO1xuICAgIH1cbiAgICBpZiAocmQgPT09ICdscicgfHwgcmQgPT09ICdybCcpIHtcbiAgICAgICAgc3dhcFhZKGcpO1xuICAgICAgICBzd2FwV2lkdGhIZWlnaHQoZyk7XG4gICAgfVxufTtcbmNvbnN0IHN3YXBXaWR0aEhlaWdodCA9IChnKSA9PiB7XG4gICAgZy5nZXRBbGxOb2RlcygpLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgc3dhcFdpZHRoSGVpZ2h0T25lKHYpO1xuICAgIH0pO1xuICAgIGcuZ2V0QWxsRWRnZXMoKS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgIHN3YXBXaWR0aEhlaWdodE9uZShlKTtcbiAgICB9KTtcbn07XG5jb25zdCBzd2FwV2lkdGhIZWlnaHRPbmUgPSAobm9kZSkgPT4ge1xuICAgIGNvbnN0IHcgPSBub2RlLmRhdGEud2lkdGg7XG4gICAgbm9kZS5kYXRhLndpZHRoID0gbm9kZS5kYXRhLmhlaWdodDtcbiAgICBub2RlLmRhdGEuaGVpZ2h0ID0gdztcbn07XG5jb25zdCByZXZlcnNlWSA9IChnKSA9PiB7XG4gICAgZy5nZXRBbGxOb2RlcygpLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgcmV2ZXJzZVlPbmUodi5kYXRhKTtcbiAgICB9KTtcbiAgICBnLmdldEFsbEVkZ2VzKCkuZm9yRWFjaCgoZWRnZSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IGVkZ2UuZGF0YS5wb2ludHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChwb2ludCkgPT4gcmV2ZXJzZVlPbmUocG9pbnQpKTtcbiAgICAgICAgaWYgKGVkZ2UuZGF0YS5oYXNPd25Qcm9wZXJ0eSgneScpKSB7XG4gICAgICAgICAgICByZXZlcnNlWU9uZShlZGdlLmRhdGEpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuY29uc3QgcmV2ZXJzZVlPbmUgPSAobm9kZSkgPT4ge1xuICAgIGlmIChub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUueSkge1xuICAgICAgICBub2RlLnkgPSAtbm9kZS55O1xuICAgIH1cbn07XG5jb25zdCBzd2FwWFkgPSAoZykgPT4ge1xuICAgIGcuZ2V0QWxsTm9kZXMoKS5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAgIHN3YXBYWU9uZSh2LmRhdGEpO1xuICAgIH0pO1xuICAgIGcuZ2V0QWxsRWRnZXMoKS5mb3JFYWNoKChlZGdlKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gZWRnZS5kYXRhLnBvaW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKHBvaW50KSA9PiBzd2FwWFlPbmUocG9pbnQpKTtcbiAgICAgICAgaWYgKGVkZ2UuZGF0YS5oYXNPd25Qcm9wZXJ0eSgneCcpKSB7XG4gICAgICAgICAgICBzd2FwWFlPbmUoZWRnZS5kYXRhKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmNvbnN0IHN3YXBYWU9uZSA9IChub2RlKSA9PiB7XG4gICAgY29uc3QgeCA9IG5vZGUueDtcbiAgICBub2RlLnggPSBub2RlLnk7XG4gICAgbm9kZS55ID0geDtcbn07XG5leHBvcnQgeyBhZGp1c3QsIHVuZG8gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvb3JkaW5hdGUtc3lzdGVtLmpzLm1hcCIsImNvbnN0IGZpbHRlck91dExpbmtzID0gKGssIHYpID0+IHtcbiAgICBpZiAoayAhPT0gJ25leHQnICYmIGsgIT09ICdwcmV2Jykge1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG59O1xuY29uc3QgdW5saW5rID0gKGVudHJ5KSA9PiB7XG4gICAgZW50cnkucHJldi5uZXh0ID0gZW50cnkubmV4dDtcbiAgICBlbnRyeS5uZXh0LnByZXYgPSBlbnRyeS5wcmV2O1xuICAgIGRlbGV0ZSBlbnRyeS5uZXh0O1xuICAgIGRlbGV0ZSBlbnRyeS5wcmV2O1xufTtcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpc3Qge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBjb25zdCBzaG9ydGN1dCA9IHt9O1xuICAgICAgICBzaG9ydGN1dC5wcmV2ID0gc2hvcnRjdXQ7XG4gICAgICAgIHNob3J0Y3V0Lm5leHQgPSBzaG9ydGN1dC5wcmV2O1xuICAgICAgICB0aGlzLnNob3J0Y3V0ID0gc2hvcnRjdXQ7XG4gICAgfVxuICAgIGRlcXVldWUoKSB7XG4gICAgICAgIGNvbnN0IHNob3J0Y3V0ID0gdGhpcy5zaG9ydGN1dDtcbiAgICAgICAgY29uc3QgZW50cnkgPSBzaG9ydGN1dC5wcmV2O1xuICAgICAgICBpZiAoZW50cnkgJiYgZW50cnkgIT09IHNob3J0Y3V0KSB7XG4gICAgICAgICAgICB1bmxpbmsoZW50cnkpO1xuICAgICAgICAgICAgcmV0dXJuIGVudHJ5O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVucXVldWUoZW50cnkpIHtcbiAgICAgICAgY29uc3Qgc2hvcnRjdXQgPSB0aGlzLnNob3J0Y3V0O1xuICAgICAgICBpZiAoZW50cnkucHJldiAmJiBlbnRyeS5uZXh0KSB7XG4gICAgICAgICAgICB1bmxpbmsoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVudHJ5Lm5leHQgPSBzaG9ydGN1dC5uZXh0O1xuICAgICAgICBzaG9ydGN1dC5uZXh0LnByZXYgPSBlbnRyeTtcbiAgICAgICAgc2hvcnRjdXQubmV4dCA9IGVudHJ5O1xuICAgICAgICBlbnRyeS5wcmV2ID0gc2hvcnRjdXQ7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBzdHJzID0gW107XG4gICAgICAgIGNvbnN0IHNlbnRpbmVsID0gdGhpcy5zaG9ydGN1dDtcbiAgICAgICAgbGV0IGN1cnIgPSBzZW50aW5lbC5wcmV2O1xuICAgICAgICB3aGlsZSAoY3VyciAhPT0gc2VudGluZWwpIHtcbiAgICAgICAgICAgIHN0cnMucHVzaChKU09OLnN0cmluZ2lmeShjdXJyLCBmaWx0ZXJPdXRMaW5rcykpO1xuICAgICAgICAgICAgY3VyciA9IGN1cnIgPT09IG51bGwgfHwgY3VyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3Vyci5wcmV2O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgWyR7c3Rycy5qb2luKCcsICcpfV1gO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpc3QuanMubWFwIiwiLypcbiAqIEEgZ3JlZWR5IGhldXJpc3RpYyBmb3IgZmluZGluZyBhIGZlZWRiYWNrIGFyYyBzZXQgZm9yIGEgZ3JhcGguIEEgZmVlZGJhY2tcbiAqIGFyYyBzZXQgaXMgYSBzZXQgb2YgZWRnZXMgdGhhdCBjYW4gYmUgcmVtb3ZlZCB0byBtYWtlIGEgZ3JhcGggYWN5Y2xpYy5cbiAqIFRoZSBhbGdvcml0aG0gY29tZXMgZnJvbTogUC4gRWFkZXMsIFguIExpbiwgYW5kIFcuIEYuIFNteXRoLCBcIkEgZmFzdCBhbmRcbiAqIGVmZmVjdGl2ZSBoZXVyaXN0aWMgZm9yIHRoZSBmZWVkYmFjayBhcmMgc2V0IHByb2JsZW0uXCIgVGhpcyBpbXBsZW1lbnRhdGlvblxuICogYWRqdXN0cyB0aGF0IGZyb20gdGhlIHBhcGVyIHRvIGFsbG93IGZvciB3ZWlnaHRlZCBlZGdlcy5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kYWdyZWpzL2RhZ3JlL2Jsb2IvbWFzdGVyL2xpYi9ncmVlZHktZmFzLmpzXG4gKi9cbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnQGFudHYvZ3JhcGhsaWInO1xuaW1wb3J0IFJhd0xpc3QgZnJvbSAnLi9kYXRhL2xpc3QnO1xuY2xhc3MgTGlzdCBleHRlbmRzIFJhd0xpc3Qge1xufVxuY29uc3QgREVGQVVMVF9XRUlHSFRfRk4gPSAoKSA9PiAxO1xuZXhwb3J0IGNvbnN0IGdyZWVkeUZBUyA9IChnLCB3ZWlnaHRGbikgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoZy5nZXRBbGxOb2RlcygpLmxlbmd0aCA8PSAxKVxuICAgICAgICByZXR1cm4gW107XG4gICAgY29uc3Qgc3RhdGUgPSBidWlsZFN0YXRlKGcsIHdlaWdodEZuIHx8IERFRkFVTFRfV0VJR0hUX0ZOKTtcbiAgICBjb25zdCByZXN1bHRzID0gZG9HcmVlZHlGQVMoc3RhdGUuZ3JhcGgsIHN0YXRlLmJ1Y2tldHMsIHN0YXRlLnplcm9JZHgpO1xuICAgIHJldHVybiAoX2EgPSByZXN1bHRzXG4gICAgICAgIC5tYXAoKGUpID0+IGcuZ2V0UmVsYXRlZEVkZ2VzKGUudiwgJ291dCcpLmZpbHRlcigoeyB0YXJnZXQgfSkgPT4gdGFyZ2V0ID09PSBlLncpKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZsYXQoKTtcbn07XG5jb25zdCBkb0dyZWVkeUZBUyA9IChnLCBidWNrZXRzLCB6ZXJvSWR4KSA9PiB7XG4gICAgbGV0IHJlc3VsdHMgPSBbXTtcbiAgICBjb25zdCBzb3VyY2VzID0gYnVja2V0c1tidWNrZXRzLmxlbmd0aCAtIDFdO1xuICAgIGNvbnN0IHNpbmtzID0gYnVja2V0c1swXTtcbiAgICBsZXQgZW50cnk7XG4gICAgd2hpbGUgKGcuZ2V0QWxsTm9kZXMoKS5sZW5ndGgpIHtcbiAgICAgICAgd2hpbGUgKChlbnRyeSA9IHNpbmtzLmRlcXVldWUoKSkpIHtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUoZywgYnVja2V0cywgemVyb0lkeCwgZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICgoZW50cnkgPSBzb3VyY2VzLmRlcXVldWUoKSkpIHtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUoZywgYnVja2V0cywgemVyb0lkeCwgZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnLmdldEFsbE5vZGVzKCkubGVuZ3RoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gYnVja2V0cy5sZW5ndGggLSAyOyBpID4gMDsgLS1pKSB7XG4gICAgICAgICAgICAgICAgZW50cnkgPSBidWNrZXRzW2ldLmRlcXVldWUoKTtcbiAgICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMuY29uY2F0KHJlbW92ZU5vZGUoZywgYnVja2V0cywgemVyb0lkeCwgZW50cnksIHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xufTtcbmNvbnN0IHJlbW92ZU5vZGUgPSAoZywgYnVja2V0cywgemVyb0lkeCwgZW50cnksIGNvbGxlY3RQcmVkZWNlc3NvcnMpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBpZiAoZy5oYXNOb2RlKGVudHJ5LnYpKSB7XG4gICAgICAgIChfYSA9IGcuZ2V0UmVsYXRlZEVkZ2VzKGVudHJ5LnYsICdpbicpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCgoZWRnZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgd2VpZ2h0ID0gZWRnZS5kYXRhLndlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHVFbnRyeSA9IGcuZ2V0Tm9kZShlZGdlLnNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoY29sbGVjdFByZWRlY2Vzc29ycykge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgcmVzdWx0IG5vdCByZWFsbHkgY2FyZSBhYm91dCBpbiBvciBvdXRcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goeyB2OiBlZGdlLnNvdXJjZSwgdzogZWRnZS50YXJnZXQsIGluOiAwLCBvdXQ6IDAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodUVudHJ5LmRhdGEub3V0ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgdUVudHJ5LmRhdGEub3V0ID0gMDtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHVFbnRyeS5kYXRhLm91dCAtPSB3ZWlnaHQ7XG4gICAgICAgICAgICBhc3NpZ25CdWNrZXQoYnVja2V0cywgemVyb0lkeCwgT2JqZWN0LmFzc2lnbih7IHY6IHVFbnRyeS5pZCB9LCB1RW50cnkuZGF0YSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgKF9iID0gZy5nZXRSZWxhdGVkRWRnZXMoZW50cnkudiwgJ291dCcpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZm9yRWFjaCgoZWRnZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgd2VpZ2h0ID0gZWRnZS5kYXRhLndlaWdodDtcbiAgICAgICAgICAgIGNvbnN0IHcgPSBlZGdlLnRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IHdFbnRyeSA9IGcuZ2V0Tm9kZSh3KTtcbiAgICAgICAgICAgIGlmICh3RW50cnkuZGF0YS5pbiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHdFbnRyeS5kYXRhLmluID0gMDtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHdFbnRyeS5kYXRhLmluIC09IHdlaWdodDtcbiAgICAgICAgICAgIGFzc2lnbkJ1Y2tldChidWNrZXRzLCB6ZXJvSWR4LCBPYmplY3QuYXNzaWduKHsgdjogd0VudHJ5LmlkIH0sIHdFbnRyeS5kYXRhKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBnLnJlbW92ZU5vZGUoZW50cnkudik7XG4gICAgfVxuICAgIHJldHVybiBjb2xsZWN0UHJlZGVjZXNzb3JzID8gcmVzdWx0cyA6IHVuZGVmaW5lZDtcbn07XG5jb25zdCBidWlsZFN0YXRlID0gKGcsIHdlaWdodEZuKSA9PiB7XG4gICAgY29uc3QgZmFzR3JhcGggPSBuZXcgR3JhcGgoKTtcbiAgICBsZXQgbWF4SW4gPSAwO1xuICAgIGxldCBtYXhPdXQgPSAwO1xuICAgIGcuZ2V0QWxsTm9kZXMoKS5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAgIGZhc0dyYXBoLmFkZE5vZGUoe1xuICAgICAgICAgICAgaWQ6IHYuaWQsXG4gICAgICAgICAgICBkYXRhOiB7IHY6IHYuaWQsIGluOiAwLCBvdXQ6IDAgfSxcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgLy8gQWdncmVnYXRlIHdlaWdodHMgb24gbm9kZXMsIGJ1dCBhbHNvIHN1bSB0aGUgd2VpZ2h0cyBhY3Jvc3MgbXVsdGktZWRnZXNcbiAgICAvLyBpbnRvIGEgc2luZ2xlIGVkZ2UgZm9yIHRoZSBmYXNHcmFwaC5cbiAgICBnLmdldEFsbEVkZ2VzKCkuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICBjb25zdCBlZGdlID0gZmFzR3JhcGhcbiAgICAgICAgICAgIC5nZXRSZWxhdGVkRWRnZXMoZS5zb3VyY2UsICdvdXQnKVxuICAgICAgICAgICAgLmZpbmQoKGVkZ2UpID0+IGVkZ2UudGFyZ2V0ID09PSBlLnRhcmdldCk7XG4gICAgICAgIGNvbnN0IHdlaWdodCA9ICh3ZWlnaHRGbiA9PT0gbnVsbCB8fCB3ZWlnaHRGbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2VpZ2h0Rm4oZSkpIHx8IDE7XG4gICAgICAgIGlmICghZWRnZSkge1xuICAgICAgICAgICAgZmFzR3JhcGguYWRkRWRnZSh7XG4gICAgICAgICAgICAgICAgaWQ6IGUuaWQsXG4gICAgICAgICAgICAgICAgc291cmNlOiBlLnNvdXJjZSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGUudGFyZ2V0LFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgd2VpZ2h0LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZhc0dyYXBoLnVwZGF0ZUVkZ2VEYXRhKGVkZ2UgPT09IG51bGwgfHwgZWRnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWRnZS5pZCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlZGdlLmRhdGEpLCB7IHdlaWdodDogZWRnZS5kYXRhLndlaWdodCArIHdlaWdodCB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBtYXhPdXQgPSBNYXRoLm1heChtYXhPdXQsIChmYXNHcmFwaC5nZXROb2RlKGUuc291cmNlKS5kYXRhLm91dCArPSB3ZWlnaHQpKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBtYXhJbiA9IE1hdGgubWF4KG1heEluLCAoZmFzR3JhcGguZ2V0Tm9kZShlLnRhcmdldCkuZGF0YS5pbiArPSB3ZWlnaHQpKTtcbiAgICB9KTtcbiAgICBjb25zdCBidWNrZXRzID0gW107XG4gICAgY29uc3QgcmFuZ2VNYXggPSBtYXhPdXQgKyBtYXhJbiArIDM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZU1heDsgaSsrKSB7XG4gICAgICAgIGJ1Y2tldHMucHVzaChuZXcgTGlzdCgpKTtcbiAgICB9XG4gICAgY29uc3QgemVyb0lkeCA9IG1heEluICsgMTtcbiAgICBmYXNHcmFwaC5nZXRBbGxOb2RlcygpLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgYXNzaWduQnVja2V0KGJ1Y2tldHMsIHplcm9JZHgsIE9iamVjdC5hc3NpZ24oeyB2OiB2LmlkIH0sIGZhc0dyYXBoLmdldE5vZGUodi5pZCkuZGF0YSkpO1xuICAgIH0pO1xuICAgIHJldHVybiB7IGJ1Y2tldHMsIHplcm9JZHgsIGdyYXBoOiBmYXNHcmFwaCB9O1xufTtcbmNvbnN0IGFzc2lnbkJ1Y2tldCA9IChidWNrZXRzLCB6ZXJvSWR4LCBlbnRyeSkgPT4ge1xuICAgIGlmICghZW50cnkub3V0KSB7XG4gICAgICAgIGJ1Y2tldHNbMF0uZW5xdWV1ZShlbnRyeSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFlbnRyeVsnaW4nXSkge1xuICAgICAgICBidWNrZXRzW2J1Y2tldHMubGVuZ3RoIC0gMV0uZW5xdWV1ZShlbnRyeSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBidWNrZXRzW2VudHJ5Lm91dCAtIGVudHJ5WydpbiddICsgemVyb0lkeF0uZW5xdWV1ZShlbnRyeSk7XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyZWVkeS1mYXMuanMubWFwIiwiaW1wb3J0IHsgR3JhcGggfSBmcm9tICdAYW50di9ncmFwaGxpYic7XG5pbXBvcnQgeyBpc05pbCB9IGZyb20gJ0BhbnR2L3V0aWwnO1xuaW1wb3J0IHsgcnVuIGFzIHJ1bkFjeWNsaWMsIHVuZG8gYXMgdW5kb0FjeWNsaWMgfSBmcm9tICcuL2FjeWNsaWMnO1xuaW1wb3J0IHsgYWRkQm9yZGVyU2VnbWVudHMgfSBmcm9tICcuL2FkZC1ib3JkZXItc2VnbWVudHMnO1xuaW1wb3J0IHsgYWRqdXN0IGFzIGFkanVzdENvb3JkaW5hdGVTeXN0ZW0sIHVuZG8gYXMgdW5kb0Nvb3JkaW5hdGVTeXN0ZW0sIH0gZnJvbSAnLi9jb29yZGluYXRlLXN5c3RlbSc7XG5pbXBvcnQgeyBjbGVhbnVwIGFzIGNsZWFudXBOZXN0aW5nR3JhcGgsIHJ1biBhcyBydW5OZXN0aW5nR3JhcGgsIH0gZnJvbSAnLi9uZXN0aW5nLWdyYXBoJztcbmltcG9ydCB7IHJ1biBhcyBydW5Ob3JtYWxpemUsIHVuZG8gYXMgdW5kb05vcm1hbGl6ZSB9IGZyb20gJy4vbm9ybWFsaXplJztcbmltcG9ydCB7IG9yZGVyIH0gZnJvbSAnLi9vcmRlcic7XG5pbXBvcnQgeyBpbml0RGF0YU9yZGVyIH0gZnJvbSAnLi9vcmRlci9pbml0LWRhdGEtb3JkZXInO1xuaW1wb3J0IHsgcGFyZW50RHVtbXlDaGFpbnMgfSBmcm9tICcuL3BhcmVudC1kdW1teS1jaGFpbnMnO1xuaW1wb3J0IHsgcG9zaXRpb24gfSBmcm9tICcuL3Bvc2l0aW9uJztcbmltcG9ydCB7IHJhbmsgfSBmcm9tICcuL3JhbmsnO1xuaW1wb3J0IHsgYWRkRHVtbXlOb2RlLCBhc05vbkNvbXBvdW5kR3JhcGgsIGJ1aWxkTGF5ZXJNYXRyaXgsIGludGVyc2VjdFJlY3QsIG5vcm1hbGl6ZVJhbmtzLCByZW1vdmVFbXB0eVJhbmtzLCB9IGZyb20gJy4vdXRpbCc7XG4vLyBjb25zdCBncmFwaE51bUF0dHJzID0gW1wibm9kZXNlcFwiLCBcImVkZ2VzZXBcIiwgXCJyYW5rc2VwXCIsIFwibWFyZ2lueFwiLCBcIm1hcmdpbnlcIl07XG4vLyBjb25zdCBncmFwaERlZmF1bHRzID0geyByYW5rc2VwOiA1MCwgZWRnZXNlcDogMjAsIG5vZGVzZXA6IDUwLCByYW5rZGlyOiBcInRiXCIgfTtcbi8vIGNvbnN0IGdyYXBoQXR0cnMgPSBbXCJhY3ljbGljZXJcIiwgXCJyYW5rZXJcIiwgXCJyYW5rZGlyXCIsIFwiYWxpZ25cIl07XG5leHBvcnQgY29uc3QgbGF5b3V0ID0gKGcsIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB7IGVkZ2VMYWJlbFNwYWNlLCBrZWVwTm9kZU9yZGVyLCBwcmV2R3JhcGgsIHJhbmtkaXIsIHJhbmtzZXAgfSA9IG9wdGlvbnM7XG4gICAgLy8g5aaC5p6c5Zyo5Y6f5Zu+5Z+656GA5LiK5L+u5pS577yM57un5om/5Y6f5Zu+55qEb3JkZXLnu5PmnpxcbiAgICBpZiAoIWtlZXBOb2RlT3JkZXIgJiYgcHJldkdyYXBoKSB7XG4gICAgICAgIGluaGVyaXRPcmRlcihnLCBwcmV2R3JhcGgpO1xuICAgIH1cbiAgICBjb25zdCBsYXlvdXRHcmFwaCA9IGJ1aWxkTGF5b3V0R3JhcGgoZyk7XG4gICAgLy8g5o6n5Yi25piv5ZCm5Li66L6555qEbGFiZWznlZnkvY3nva7vvIjov5nkvJrlvbHlk43mmK/lkKblnKjovrnkuK3pl7Tmt7vliqBkdW1teSBub2Rl77yJXG4gICAgaWYgKCEhZWRnZUxhYmVsU3BhY2UpIHtcbiAgICAgICAgb3B0aW9ucy5yYW5rc2VwID0gbWFrZVNwYWNlRm9yRWRnZUxhYmVscyhsYXlvdXRHcmFwaCwge1xuICAgICAgICAgICAgcmFua2RpcixcbiAgICAgICAgICAgIHJhbmtzZXAsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgZGltZW5zaW9uO1xuICAgIC8vIFRPRE86IOaaguaXtuWkhOeQhuWxgue6p+iuvue9ruS4jeato+ehruaXtueahOW8guW4uOaKpemUme+8jOaPkOekuuiuvue9ruato+ehrueahOWxgue6p1xuICAgIHRyeSB7XG4gICAgICAgIGRpbWVuc2lvbiA9IHJ1bkxheW91dChsYXlvdXRHcmFwaCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlLm1lc3NhZ2UgPT09ICdOb3QgcG9zc2libGUgdG8gZmluZCBpbnRlcnNlY3Rpb24gaW5zaWRlIG9mIHRoZSByZWN0YW5nbGUnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiVGhlIGZvbGxvd2luZyBlcnJvciBtYXkgYmUgY2F1c2VkIGJ5IGltcHJvcGVyIGxheWVyIHNldHRpbmcsIHBsZWFzZSBtYWtlIHN1cmUgeW91ciBtYW51YWwgbGF5ZXIgc2V0dGluZyBkb2VzIG5vdCB2aW9sYXRlIHRoZSBncmFwaCdzIHN0cnVjdHVyZTpcXG5cIiwgZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgdXBkYXRlSW5wdXRHcmFwaChnLCBsYXlvdXRHcmFwaCk7XG4gICAgcmV0dXJuIGRpbWVuc2lvbjtcbn07XG5jb25zdCBydW5MYXlvdXQgPSAoZywgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IHsgYWN5Y2xpY2VyLCByYW5rZXIsIHJhbmtkaXIgPSAndGInLCBub2RlT3JkZXIsIGtlZXBOb2RlT3JkZXIsIGFsaWduLCBub2Rlc2VwID0gNTAsIGVkZ2VzZXAgPSAyMCwgcmFua3NlcCA9IDUwLCB9ID0gb3B0aW9ucztcbiAgICByZW1vdmVTZWxmRWRnZXMoZyk7XG4gICAgcnVuQWN5Y2xpYyhnLCBhY3ljbGljZXIpO1xuICAgIGNvbnN0IHsgbmVzdGluZ1Jvb3QsIG5vZGVSYW5rRmFjdG9yIH0gPSBydW5OZXN0aW5nR3JhcGgoZyk7XG4gICAgcmFuayhhc05vbkNvbXBvdW5kR3JhcGgoZyksIHJhbmtlcik7XG4gICAgaW5qZWN0RWRnZUxhYmVsUHJveGllcyhnKTtcbiAgICByZW1vdmVFbXB0eVJhbmtzKGcsIG5vZGVSYW5rRmFjdG9yKTtcbiAgICBjbGVhbnVwTmVzdGluZ0dyYXBoKGcsIG5lc3RpbmdSb290KTtcbiAgICBub3JtYWxpemVSYW5rcyhnKTtcbiAgICBhc3NpZ25SYW5rTWluTWF4KGcpO1xuICAgIHJlbW92ZUVkZ2VMYWJlbFByb3hpZXMoZyk7XG4gICAgY29uc3QgZHVtbXlDaGFpbnMgPSBbXTtcbiAgICBydW5Ob3JtYWxpemUoZywgZHVtbXlDaGFpbnMpO1xuICAgIHBhcmVudER1bW15Q2hhaW5zKGcsIGR1bW15Q2hhaW5zKTtcbiAgICBhZGRCb3JkZXJTZWdtZW50cyhnKTtcbiAgICBpZiAoa2VlcE5vZGVPcmRlcikge1xuICAgICAgICBpbml0RGF0YU9yZGVyKGcsIG5vZGVPcmRlcik7XG4gICAgfVxuICAgIG9yZGVyKGcsIGtlZXBOb2RlT3JkZXIpO1xuICAgIGluc2VydFNlbGZFZGdlcyhnKTtcbiAgICBhZGp1c3RDb29yZGluYXRlU3lzdGVtKGcsIHJhbmtkaXIpO1xuICAgIHBvc2l0aW9uKGcsIHtcbiAgICAgICAgYWxpZ24sXG4gICAgICAgIG5vZGVzZXAsXG4gICAgICAgIGVkZ2VzZXAsXG4gICAgICAgIHJhbmtzZXAsXG4gICAgfSk7XG4gICAgcG9zaXRpb25TZWxmRWRnZXMoZyk7XG4gICAgcmVtb3ZlQm9yZGVyTm9kZXMoZyk7XG4gICAgdW5kb05vcm1hbGl6ZShnLCBkdW1teUNoYWlucyk7XG4gICAgZml4dXBFZGdlTGFiZWxDb29yZHMoZyk7XG4gICAgdW5kb0Nvb3JkaW5hdGVTeXN0ZW0oZywgcmFua2Rpcik7XG4gICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0cmFuc2xhdGVHcmFwaChnKTtcbiAgICBhc3NpZ25Ob2RlSW50ZXJzZWN0cyhnKTtcbiAgICByZXZlcnNlUG9pbnRzRm9yUmV2ZXJzZWRFZGdlcyhnKTtcbiAgICB1bmRvQWN5Y2xpYyhnKTtcbiAgICByZXR1cm4geyB3aWR0aCwgaGVpZ2h0IH07XG59O1xuLyoqXG4gKiDnu6fmib/kuIrkuIDkuKrluIPlsYDkuK3nmoRvcmRlcu+8jOmYsuatoue/u+i9rFxuICogVE9ETzog5pqC5pe25rKh5pyJ6ICD6JmR5raJ5Y+K5bGC57qn5Y+Y5Yqo55qE5biD5bGA77yM5Y+q5L+d6K+B5Y6f5p2l5biD5bGA5bGC57qn5ZKM55u45a+56aG65bqP5LiN5Y+YXG4gKi9cbmNvbnN0IGluaGVyaXRPcmRlciA9IChjdXJyRywgcHJldkcpID0+IHtcbiAgICBjdXJyRy5nZXRBbGxOb2RlcygpLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGN1cnJHLmdldE5vZGUobi5pZCk7XG4gICAgICAgIGlmIChwcmV2Ry5oYXNOb2RlKG4uaWQpKSB7XG4gICAgICAgICAgICBjb25zdCBwcmV2Tm9kZSA9IHByZXZHLmdldE5vZGUobi5pZCk7XG4gICAgICAgICAgICBub2RlLmRhdGEuZml4b3JkZXIgPSBwcmV2Tm9kZS5kYXRhLl9vcmRlcjtcbiAgICAgICAgICAgIGRlbGV0ZSBwcmV2Tm9kZS5kYXRhLl9vcmRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBub2RlLmRhdGEuZml4b3JkZXI7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG4vKlxuICogQ29waWVzIGZpbmFsIGxheW91dCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBsYXlvdXQgZ3JhcGggYmFjayB0byB0aGUgaW5wdXRcbiAqIGdyYXBoLiBUaGlzIHByb2Nlc3Mgb25seSBjb3BpZXMgd2hpdGVsaXN0ZWQgYXR0cmlidXRlcyBmcm9tIHRoZSBsYXlvdXQgZ3JhcGhcbiAqIHRvIHRoZSBpbnB1dCBncmFwaCwgc28gaXQgc2VydmVzIGFzIGEgZ29vZCBwbGFjZSB0byBkZXRlcm1pbmUgd2hhdFxuICogYXR0cmlidXRlcyBjYW4gaW5mbHVlbmNlIGxheW91dC5cbiAqL1xuY29uc3QgdXBkYXRlSW5wdXRHcmFwaCA9IChpbnB1dEdyYXBoLCBsYXlvdXRHcmFwaCkgPT4ge1xuICAgIGlucHV0R3JhcGguZ2V0QWxsTm9kZXMoKS5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgaW5wdXRMYWJlbCA9IGlucHV0R3JhcGguZ2V0Tm9kZSh2LmlkKTtcbiAgICAgICAgaWYgKGlucHV0TGFiZWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGxheW91dExhYmVsID0gbGF5b3V0R3JhcGguZ2V0Tm9kZSh2LmlkKTtcbiAgICAgICAgICAgIGlucHV0TGFiZWwuZGF0YS54ID0gbGF5b3V0TGFiZWwuZGF0YS54O1xuICAgICAgICAgICAgaW5wdXRMYWJlbC5kYXRhLnkgPSBsYXlvdXRMYWJlbC5kYXRhLnk7XG4gICAgICAgICAgICBpbnB1dExhYmVsLmRhdGEuX29yZGVyID0gbGF5b3V0TGFiZWwuZGF0YS5vcmRlcjtcbiAgICAgICAgICAgIGlucHV0TGFiZWwuZGF0YS5fcmFuayA9IGxheW91dExhYmVsLmRhdGEucmFuaztcbiAgICAgICAgICAgIGlmICgoX2EgPSBsYXlvdXRHcmFwaC5nZXRDaGlsZHJlbih2LmlkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlucHV0TGFiZWwuZGF0YS53aWR0aCA9IGxheW91dExhYmVsLmRhdGEud2lkdGg7XG4gICAgICAgICAgICAgICAgaW5wdXRMYWJlbC5kYXRhLmhlaWdodCA9IGxheW91dExhYmVsLmRhdGEuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgaW5wdXRHcmFwaC5nZXRBbGxFZGdlcygpLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXRMYWJlbCA9IGlucHV0R3JhcGguZ2V0RWRnZShlLmlkKTtcbiAgICAgICAgY29uc3QgbGF5b3V0TGFiZWwgPSBsYXlvdXRHcmFwaC5nZXRFZGdlKGUuaWQpO1xuICAgICAgICBpbnB1dExhYmVsLmRhdGEucG9pbnRzID0gbGF5b3V0TGFiZWwgPyBsYXlvdXRMYWJlbC5kYXRhLnBvaW50cyA6IFtdO1xuICAgICAgICBpZiAobGF5b3V0TGFiZWwgJiYgbGF5b3V0TGFiZWwuZGF0YS5oYXNPd25Qcm9wZXJ0eSgneCcpKSB7XG4gICAgICAgICAgICBpbnB1dExhYmVsLmRhdGEueCA9IGxheW91dExhYmVsLmRhdGEueDtcbiAgICAgICAgICAgIGlucHV0TGFiZWwuZGF0YS55ID0gbGF5b3V0TGFiZWwuZGF0YS55O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gaW5wdXRHcmFwaC5ncmFwaCgpLndpZHRoID0gbGF5b3V0R3JhcGguZ3JhcGgoKS53aWR0aDtcbiAgICAvLyBpbnB1dEdyYXBoLmdyYXBoKCkuaGVpZ2h0ID0gbGF5b3V0R3JhcGguZ3JhcGgoKS5oZWlnaHQ7XG59O1xuY29uc3Qgbm9kZU51bUF0dHJzID0gWyd3aWR0aCcsICdoZWlnaHQnLCAnbGF5ZXInLCAnZml4b3JkZXInXTsgLy8g6ZyA6KaB5Lyg5YWlbGF5ZXIsIGZpeE9yZGVy5L2c5Li65Y+C5pWw5Y+C6ICDXG5jb25zdCBub2RlRGVmYXVsdHMgPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcbmNvbnN0IGVkZ2VOdW1BdHRycyA9IFsnbWlubGVuJywgJ3dlaWdodCcsICd3aWR0aCcsICdoZWlnaHQnLCAnbGFiZWxvZmZzZXQnXTtcbmNvbnN0IGVkZ2VEZWZhdWx0cyA9IHtcbiAgICBtaW5sZW46IDEsXG4gICAgd2VpZ2h0OiAxLFxuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMCxcbiAgICBsYWJlbG9mZnNldDogMTAsXG4gICAgbGFiZWxwb3M6ICdyJyxcbn07XG5jb25zdCBlZGdlQXR0cnMgPSBbJ2xhYmVscG9zJ107XG4vKlxuICogQ29uc3RydWN0cyBhIG5ldyBncmFwaCBmcm9tIHRoZSBpbnB1dCBncmFwaCwgd2hpY2ggY2FuIGJlIHVzZWQgZm9yIGxheW91dC5cbiAqIFRoaXMgcHJvY2VzcyBjb3BpZXMgb25seSB3aGl0ZWxpc3RlZCBhdHRyaWJ1dGVzIGZyb20gdGhlIGlucHV0IGdyYXBoIHRvIHRoZVxuICogbGF5b3V0IGdyYXBoLiBUaHVzIHRoaXMgZnVuY3Rpb24gc2VydmVzIGFzIGEgZ29vZCBwbGFjZSB0byBkZXRlcm1pbmUgd2hhdFxuICogYXR0cmlidXRlcyBjYW4gaW5mbHVlbmNlIGxheW91dC5cbiAqL1xuY29uc3QgYnVpbGRMYXlvdXRHcmFwaCA9IChpbnB1dEdyYXBoKSA9PiB7XG4gICAgY29uc3QgZyA9IG5ldyBHcmFwaCh7IHRyZWU6IFtdIH0pO1xuICAgIGlucHV0R3JhcGguZ2V0QWxsTm9kZXMoKS5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBjYW5vbmljYWxpemUoaW5wdXRHcmFwaC5nZXROb2RlKHYuaWQpLmRhdGEpO1xuICAgICAgICBjb25zdCBkZWZhdWx0Tm9kZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbm9kZURlZmF1bHRzKSwgbm9kZSk7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRBdHRycyA9IHNlbGVjdE51bWJlckF0dHJzKGRlZmF1bHROb2RlLCBub2RlTnVtQXR0cnMpO1xuICAgICAgICBpZiAoIWcuaGFzTm9kZSh2LmlkKSkge1xuICAgICAgICAgICAgZy5hZGROb2RlKHtcbiAgICAgICAgICAgICAgICBpZDogdi5pZCxcbiAgICAgICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0QXR0cnMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50ID0gaW5wdXRHcmFwaC5oYXNUcmVlU3RydWN0dXJlKCdjb21ibycpXG4gICAgICAgICAgICA/IGlucHV0R3JhcGguZ2V0UGFyZW50KHYuaWQsICdjb21ibycpXG4gICAgICAgICAgICA6IGlucHV0R3JhcGguZ2V0UGFyZW50KHYuaWQpO1xuICAgICAgICBpZiAoIWlzTmlsKHBhcmVudCkpIHtcbiAgICAgICAgICAgIGlmICghZy5oYXNOb2RlKHBhcmVudC5pZCkpIHtcbiAgICAgICAgICAgICAgICBnLmFkZE5vZGUoT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnLnNldFBhcmVudCh2LmlkLCBwYXJlbnQuaWQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaW5wdXRHcmFwaC5nZXRBbGxFZGdlcygpLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgY29uc3QgZWRnZSA9IGNhbm9uaWNhbGl6ZShpbnB1dEdyYXBoLmdldEVkZ2UoZS5pZCkuZGF0YSk7XG4gICAgICAgIGNvbnN0IHBpY2tlZFByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgZWRnZUF0dHJzID09PSBudWxsIHx8IGVkZ2VBdHRycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWRnZUF0dHJzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVkZ2Vba2V5XSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHBpY2tlZFByb3BlcnRpZXNba2V5XSA9IGVkZ2Vba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIGcuYWRkRWRnZSh7XG4gICAgICAgICAgICBpZDogZS5pZCxcbiAgICAgICAgICAgIHNvdXJjZTogZS5zb3VyY2UsXG4gICAgICAgICAgICB0YXJnZXQ6IGUudGFyZ2V0LFxuICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgZWRnZURlZmF1bHRzLCBzZWxlY3ROdW1iZXJBdHRycyhlZGdlLCBlZGdlTnVtQXR0cnMpLCBwaWNrZWRQcm9wZXJ0aWVzKSxcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGc7XG59O1xuLypcbiAqIFRoaXMgaWRlYSBjb21lcyBmcm9tIHRoZSBHYW5zbmVyIHBhcGVyOiB0byBhY2NvdW50IGZvciBlZGdlIGxhYmVscyBpbiBvdXJcbiAqIGxheW91dCB3ZSBzcGxpdCBlYWNoIHJhbmsgaW4gaGFsZiBieSBkb3VibGluZyBtaW5sZW4gYW5kIGhhbHZpbmcgcmFua3NlcC5cbiAqIFRoZW4gd2UgY2FuIHBsYWNlIGxhYmVscyBhdCB0aGVzZSBtaWQtcG9pbnRzIGJldHdlZW4gbm9kZXMuXG4gKlxuICogV2UgYWxzbyBhZGQgc29tZSBtaW5pbWFsIHBhZGRpbmcgdG8gdGhlIHdpZHRoIHRvIHB1c2ggdGhlIGxhYmVsIGZvciB0aGUgZWRnZVxuICogYXdheSBmcm9tIHRoZSBlZGdlIGl0c2VsZiBhIGJpdC5cbiAqL1xuY29uc3QgbWFrZVNwYWNlRm9yRWRnZUxhYmVscyA9IChnLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgeyByYW5rc2VwID0gMCwgcmFua2RpciB9ID0gb3B0aW9ucztcbiAgICBnLmdldEFsbE5vZGVzKCkuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBpZiAoIWlzTmFOKG5vZGUuZGF0YS5sYXllcikpIHtcbiAgICAgICAgICAgIGlmICghbm9kZS5kYXRhLmxheWVyKVxuICAgICAgICAgICAgICAgIG5vZGUuZGF0YS5sYXllciA9IDA7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBnLmdldEFsbEVkZ2VzKCkuZm9yRWFjaCgoZWRnZSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGVkZ2UuZGF0YS5taW5sZW4gKj0gMjtcbiAgICAgICAgaWYgKCgoX2EgPSBlZGdlLmRhdGEubGFiZWxwb3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpKSAhPT0gJ2MnKSB7XG4gICAgICAgICAgICBpZiAocmFua2RpciA9PT0gJ1RCJyB8fCByYW5rZGlyID09PSAnQlQnKSB7XG4gICAgICAgICAgICAgICAgZWRnZS5kYXRhLndpZHRoICs9IGVkZ2UuZGF0YS5sYWJlbG9mZnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVkZ2UuZGF0YS5oZWlnaHQgKz0gZWRnZS5kYXRhLmxhYmVsb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJhbmtzZXAgLyAyO1xufTtcbi8qXG4gKiBDcmVhdGVzIHRlbXBvcmFyeSBkdW1teSBub2RlcyB0aGF0IGNhcHR1cmUgdGhlIHJhbmsgaW4gd2hpY2ggZWFjaCBlZGdlJ3NcbiAqIGxhYmVsIGlzIGdvaW5nIHRvLCBpZiBpdCBoYXMgb25lIG9mIG5vbi16ZXJvIHdpZHRoIGFuZCBoZWlnaHQuIFdlIGRvIHRoaXNcbiAqIHNvIHRoYXQgd2UgY2FuIHNhZmVseSByZW1vdmUgZW1wdHkgcmFua3Mgd2hpbGUgcHJlc2VydmluZyBiYWxhbmNlIGZvciB0aGVcbiAqIGxhYmVsJ3MgcG9zaXRpb24uXG4gKi9cbmNvbnN0IGluamVjdEVkZ2VMYWJlbFByb3hpZXMgPSAoZykgPT4ge1xuICAgIGcuZ2V0QWxsRWRnZXMoKS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgIGlmIChlLmRhdGEud2lkdGggJiYgZS5kYXRhLmhlaWdodCkge1xuICAgICAgICAgICAgY29uc3QgdiA9IGcuZ2V0Tm9kZShlLnNvdXJjZSk7XG4gICAgICAgICAgICBjb25zdCB3ID0gZy5nZXROb2RlKGUudGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IGxhYmVsID0ge1xuICAgICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgICAgcmFuazogKHcuZGF0YS5yYW5rIC0gdi5kYXRhLnJhbmspIC8gMiArIHYuZGF0YS5yYW5rLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGFkZER1bW15Tm9kZShnLCAnZWRnZS1wcm94eScsIGxhYmVsLCAnX2VwJyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5jb25zdCBhc3NpZ25SYW5rTWluTWF4ID0gKGcpID0+IHtcbiAgICBsZXQgbWF4UmFuayA9IDA7XG4gICAgZy5nZXRBbGxOb2RlcygpLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKG5vZGUuZGF0YS5ib3JkZXJUb3ApIHtcbiAgICAgICAgICAgIG5vZGUuZGF0YS5taW5SYW5rID0gKF9hID0gZy5nZXROb2RlKG5vZGUuZGF0YS5ib3JkZXJUb3ApKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGF0YS5yYW5rO1xuICAgICAgICAgICAgbm9kZS5kYXRhLm1heFJhbmsgPSAoX2IgPSBnLmdldE5vZGUobm9kZS5kYXRhLmJvcmRlckJvdHRvbSkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kYXRhLnJhbms7XG4gICAgICAgICAgICBtYXhSYW5rID0gTWF0aC5tYXgobWF4UmFuaywgbm9kZS5kYXRhLm1heFJhbmsgfHwgLUluZmluaXR5KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtYXhSYW5rO1xufTtcbmNvbnN0IHJlbW92ZUVkZ2VMYWJlbFByb3hpZXMgPSAoZykgPT4ge1xuICAgIGcuZ2V0QWxsTm9kZXMoKS5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgIGlmIChub2RlLmRhdGEuZHVtbXkgPT09ICdlZGdlLXByb3h5Jykge1xuICAgICAgICAgICAgZy5nZXRFZGdlKG5vZGUuZGF0YS5lLmlkKS5kYXRhLmxhYmVsUmFuayA9IG5vZGUuZGF0YS5yYW5rO1xuICAgICAgICAgICAgZy5yZW1vdmVOb2RlKG5vZGUuaWQpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuY29uc3QgdHJhbnNsYXRlR3JhcGggPSAoZywgb3B0aW9ucykgPT4ge1xuICAgIGxldCBtaW5YO1xuICAgIGxldCBtYXhYID0gMDtcbiAgICBsZXQgbWluWTtcbiAgICBsZXQgbWF4WSA9IDA7XG4gICAgY29uc3QgeyBtYXJnaW54OiBtYXJnaW5YID0gMCwgbWFyZ2lueTogbWFyZ2luWSA9IDAgfSA9IG9wdGlvbnMgfHwge307XG4gICAgY29uc3QgZ2V0RXh0cmVtZXMgPSAoYXR0cnMpID0+IHtcbiAgICAgICAgaWYgKCFhdHRycy5kYXRhKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB4ID0gYXR0cnMuZGF0YS54O1xuICAgICAgICBjb25zdCB5ID0gYXR0cnMuZGF0YS55O1xuICAgICAgICBjb25zdCB3ID0gYXR0cnMuZGF0YS53aWR0aDtcbiAgICAgICAgY29uc3QgaCA9IGF0dHJzLmRhdGEuaGVpZ2h0O1xuICAgICAgICBpZiAoIWlzTmFOKHgpICYmICFpc05hTih3KSkge1xuICAgICAgICAgICAgaWYgKG1pblggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1pblggPSB4IC0gdyAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeCAtIHcgLyAyKTtcbiAgICAgICAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCB4ICsgdyAvIDIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNOYU4oeSkgJiYgIWlzTmFOKGgpKSB7XG4gICAgICAgICAgICBpZiAobWluWSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWluWSA9IHkgLSBoIC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCB5IC0gaCAvIDIpO1xuICAgICAgICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIHkgKyBoIC8gMik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGcuZ2V0QWxsTm9kZXMoKS5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAgIGdldEV4dHJlbWVzKHYpO1xuICAgIH0pO1xuICAgIGcuZ2V0QWxsRWRnZXMoKS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgIGlmIChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUuZGF0YS5oYXNPd25Qcm9wZXJ0eSgneCcpKSB7XG4gICAgICAgICAgICBnZXRFeHRyZW1lcyhlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIG1pblggLT0gbWFyZ2luWDtcbiAgICBtaW5ZIC09IG1hcmdpblk7XG4gICAgZy5nZXRBbGxOb2RlcygpLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgbm9kZS5kYXRhLnggLT0gbWluWDtcbiAgICAgICAgbm9kZS5kYXRhLnkgLT0gbWluWTtcbiAgICB9KTtcbiAgICBnLmdldEFsbEVkZ2VzKCkuZm9yRWFjaCgoZWRnZSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IGVkZ2UuZGF0YS5wb2ludHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgICAgICBwLnggLT0gbWluWDtcbiAgICAgICAgICAgIHAueSAtPSBtaW5ZO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVkZ2UuZGF0YS5oYXNPd25Qcm9wZXJ0eSgneCcpKSB7XG4gICAgICAgICAgICBlZGdlLmRhdGEueCAtPSBtaW5YO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlZGdlLmRhdGEuaGFzT3duUHJvcGVydHkoJ3knKSkge1xuICAgICAgICAgICAgZWRnZS5kYXRhLnkgLT0gbWluWTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBtYXhYIC0gbWluWCArIG1hcmdpblgsXG4gICAgICAgIGhlaWdodDogbWF4WSAtIG1pblkgKyBtYXJnaW5ZLFxuICAgIH07XG59O1xuY29uc3QgYXNzaWduTm9kZUludGVyc2VjdHMgPSAoZykgPT4ge1xuICAgIGcuZ2V0QWxsRWRnZXMoKS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGVWID0gZy5nZXROb2RlKGUuc291cmNlKTtcbiAgICAgICAgY29uc3Qgbm9kZVcgPSBnLmdldE5vZGUoZS50YXJnZXQpO1xuICAgICAgICBsZXQgcDE7XG4gICAgICAgIGxldCBwMjtcbiAgICAgICAgaWYgKCFlLmRhdGEucG9pbnRzKSB7XG4gICAgICAgICAgICBlLmRhdGEucG9pbnRzID0gW107XG4gICAgICAgICAgICBwMSA9IHsgeDogbm9kZVcuZGF0YS54LCB5OiBub2RlVy5kYXRhLnkgfTtcbiAgICAgICAgICAgIHAyID0geyB4OiBub2RlVi5kYXRhLngsIHk6IG5vZGVWLmRhdGEueSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcDEgPSBlLmRhdGEucG9pbnRzWzBdO1xuICAgICAgICAgICAgcDIgPSBlLmRhdGEucG9pbnRzW2UuZGF0YS5wb2ludHMubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgZS5kYXRhLnBvaW50cy51bnNoaWZ0KGludGVyc2VjdFJlY3Qobm9kZVYuZGF0YSwgcDEpKTtcbiAgICAgICAgZS5kYXRhLnBvaW50cy5wdXNoKGludGVyc2VjdFJlY3Qobm9kZVcuZGF0YSwgcDIpKTtcbiAgICB9KTtcbn07XG5jb25zdCBmaXh1cEVkZ2VMYWJlbENvb3JkcyA9IChnKSA9PiB7XG4gICAgZy5nZXRBbGxFZGdlcygpLmZvckVhY2goKGVkZ2UpID0+IHtcbiAgICAgICAgaWYgKGVkZ2UuZGF0YS5oYXNPd25Qcm9wZXJ0eSgneCcpKSB7XG4gICAgICAgICAgICBpZiAoZWRnZS5kYXRhLmxhYmVscG9zID09PSAnbCcgfHwgZWRnZS5kYXRhLmxhYmVscG9zID09PSAncicpIHtcbiAgICAgICAgICAgICAgICBlZGdlLmRhdGEud2lkdGggLT0gZWRnZS5kYXRhLmxhYmVsb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChlZGdlLmRhdGEubGFiZWxwb3MpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgICAgICAgICAgZWRnZS5kYXRhLnggLT0gZWRnZS5kYXRhLndpZHRoIC8gMiArIGVkZ2UuZGF0YS5sYWJlbG9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICAgICAgICAgIGVkZ2UuZGF0YS54ICs9IGVkZ2UuZGF0YS53aWR0aCAvIDIgKyBlZGdlLmRhdGEubGFiZWxvZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59O1xuY29uc3QgcmV2ZXJzZVBvaW50c0ZvclJldmVyc2VkRWRnZXMgPSAoZykgPT4ge1xuICAgIGcuZ2V0QWxsRWRnZXMoKS5mb3JFYWNoKChlZGdlKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGVkZ2UuZGF0YS5yZXZlcnNlZCkge1xuICAgICAgICAgICAgKF9hID0gZWRnZS5kYXRhLnBvaW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmNvbnN0IHJlbW92ZUJvcmRlck5vZGVzID0gKGcpID0+IHtcbiAgICBnLmdldEFsbE5vZGVzKCkuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgaWYgKChfYSA9IGcuZ2V0Q2hpbGRyZW4odi5pZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBnLmdldE5vZGUodi5pZCk7XG4gICAgICAgICAgICBjb25zdCB0ID0gZy5nZXROb2RlKG5vZGUuZGF0YS5ib3JkZXJUb3ApO1xuICAgICAgICAgICAgY29uc3QgYiA9IGcuZ2V0Tm9kZShub2RlLmRhdGEuYm9yZGVyQm90dG9tKTtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBnLmdldE5vZGUobm9kZS5kYXRhLmJvcmRlckxlZnRbKChfYiA9IG5vZGUuZGF0YS5ib3JkZXJMZWZ0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGVuZ3RoKSAtIDFdKTtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBnLmdldE5vZGUobm9kZS5kYXRhLmJvcmRlclJpZ2h0WygoX2MgPSBub2RlLmRhdGEuYm9yZGVyUmlnaHQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5sZW5ndGgpIC0gMV0pO1xuICAgICAgICAgICAgbm9kZS5kYXRhLndpZHRoID0gTWF0aC5hYnMoKHIgPT09IG51bGwgfHwgciA9PT0gdm9pZCAwID8gdm9pZCAwIDogci5kYXRhLngpIC0gKGwgPT09IG51bGwgfHwgbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbC5kYXRhLngpKSB8fCAxMDtcbiAgICAgICAgICAgIG5vZGUuZGF0YS5oZWlnaHQgPSBNYXRoLmFicygoYiA9PT0gbnVsbCB8fCBiID09PSB2b2lkIDAgPyB2b2lkIDAgOiBiLmRhdGEueSkgLSAodCA9PT0gbnVsbCB8fCB0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0LmRhdGEueSkpIHx8IDEwO1xuICAgICAgICAgICAgbm9kZS5kYXRhLnggPSAoKGwgPT09IG51bGwgfHwgbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbC5kYXRhLngpIHx8IDApICsgbm9kZS5kYXRhLndpZHRoIC8gMjtcbiAgICAgICAgICAgIG5vZGUuZGF0YS55ID0gKCh0ID09PSBudWxsIHx8IHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHQuZGF0YS55KSB8fCAwKSArIG5vZGUuZGF0YS5oZWlnaHQgLyAyO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZy5nZXRBbGxOb2RlcygpLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgaWYgKG4uZGF0YS5kdW1teSA9PT0gJ2JvcmRlcicpIHtcbiAgICAgICAgICAgIGcucmVtb3ZlTm9kZShuLmlkKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmNvbnN0IHJlbW92ZVNlbGZFZGdlcyA9IChnKSA9PiB7XG4gICAgZy5nZXRBbGxFZGdlcygpLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgaWYgKGUuc291cmNlID09PSBlLnRhcmdldCkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGcuZ2V0Tm9kZShlLnNvdXJjZSk7XG4gICAgICAgICAgICBpZiAoIW5vZGUuZGF0YS5zZWxmRWRnZXMpIHtcbiAgICAgICAgICAgICAgICBub2RlLmRhdGEuc2VsZkVkZ2VzID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlLmRhdGEuc2VsZkVkZ2VzLnB1c2goZSk7XG4gICAgICAgICAgICBnLnJlbW92ZUVkZ2UoZS5pZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5jb25zdCBpbnNlcnRTZWxmRWRnZXMgPSAoZykgPT4ge1xuICAgIGNvbnN0IGxheWVycyA9IGJ1aWxkTGF5ZXJNYXRyaXgoZyk7XG4gICAgbGF5ZXJzID09PSBudWxsIHx8IGxheWVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXJzLmZvckVhY2goKGxheWVyKSA9PiB7XG4gICAgICAgIGxldCBvcmRlclNoaWZ0ID0gMDtcbiAgICAgICAgbGF5ZXIgPT09IG51bGwgfHwgbGF5ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheWVyLmZvckVhY2goKHYsIGkpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBnLmdldE5vZGUodik7XG4gICAgICAgICAgICBub2RlLmRhdGEub3JkZXIgPSBpICsgb3JkZXJTaGlmdDtcbiAgICAgICAgICAgIChfYSA9IG5vZGUuZGF0YS5zZWxmRWRnZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChzZWxmRWRnZSkgPT4ge1xuICAgICAgICAgICAgICAgIGFkZER1bW15Tm9kZShnLCAnc2VsZmVkZ2UnLCB7XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiBzZWxmRWRnZS5kYXRhLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHNlbGZFZGdlLmRhdGEuaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICByYW5rOiBub2RlLmRhdGEucmFuayxcbiAgICAgICAgICAgICAgICAgICAgb3JkZXI6IGkgKyArK29yZGVyU2hpZnQsXG4gICAgICAgICAgICAgICAgICAgIGU6IHNlbGZFZGdlLFxuICAgICAgICAgICAgICAgIH0sICdfc2UnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVsZXRlIG5vZGUuZGF0YS5zZWxmRWRnZXM7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmNvbnN0IHBvc2l0aW9uU2VsZkVkZ2VzID0gKGcpID0+IHtcbiAgICBnLmdldEFsbE5vZGVzKCkuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICBjb25zdCBub2RlID0gZy5nZXROb2RlKHYuaWQpO1xuICAgICAgICBpZiAobm9kZS5kYXRhLmR1bW15ID09PSAnc2VsZmVkZ2UnKSB7XG4gICAgICAgICAgICBjb25zdCBzZWxmTm9kZSA9IGcuZ2V0Tm9kZShub2RlLmRhdGEuZS5zb3VyY2UpO1xuICAgICAgICAgICAgY29uc3QgeCA9IHNlbGZOb2RlLmRhdGEueCArIHNlbGZOb2RlLmRhdGEud2lkdGggLyAyO1xuICAgICAgICAgICAgY29uc3QgeSA9IHNlbGZOb2RlLmRhdGEueTtcbiAgICAgICAgICAgIGNvbnN0IGR4ID0gbm9kZS5kYXRhLnggLSB4O1xuICAgICAgICAgICAgY29uc3QgZHkgPSBzZWxmTm9kZS5kYXRhLmhlaWdodCAvIDI7XG4gICAgICAgICAgICBpZiAoZy5oYXNFZGdlKG5vZGUuZGF0YS5lLmlkKSkge1xuICAgICAgICAgICAgICAgIGcudXBkYXRlRWRnZURhdGEobm9kZS5kYXRhLmUuaWQsIG5vZGUuZGF0YS5lLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZy5hZGRFZGdlKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGUuZGF0YS5lLmlkLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IG5vZGUuZGF0YS5lLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBub2RlLmRhdGEuZS50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG5vZGUuZGF0YS5lLmRhdGEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnLnJlbW92ZU5vZGUodi5pZCk7XG4gICAgICAgICAgICBub2RlLmRhdGEuZS5kYXRhLnBvaW50cyA9IFtcbiAgICAgICAgICAgICAgICB7IHg6IHggKyAoMiAqIGR4KSAvIDMsIHk6IHkgLSBkeSB9LFxuICAgICAgICAgICAgICAgIHsgeDogeCArICg1ICogZHgpIC8gNiwgeTogeSAtIGR5IH0sXG4gICAgICAgICAgICAgICAgeyB5LCB4OiB4ICsgZHggfSxcbiAgICAgICAgICAgICAgICB7IHg6IHggKyAoNSAqIGR4KSAvIDYsIHk6IHkgKyBkeSB9LFxuICAgICAgICAgICAgICAgIHsgeDogeCArICgyICogZHgpIC8gMywgeTogeSArIGR5IH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgbm9kZS5kYXRhLmUuZGF0YS54ID0gbm9kZS5kYXRhLng7XG4gICAgICAgICAgICBub2RlLmRhdGEuZS5kYXRhLnkgPSBub2RlLmRhdGEueTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmNvbnN0IHNlbGVjdE51bWJlckF0dHJzID0gKG9iaiwgYXR0cnMpID0+IHtcbiAgICBjb25zdCBwaWNrZWRQcm9wZXJ0aWVzID0ge307XG4gICAgYXR0cnMgPT09IG51bGwgfHwgYXR0cnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF0dHJzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAob2JqW2tleV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcGlja2VkUHJvcGVydGllc1trZXldID0gK29ialtrZXldO1xuICAgIH0pO1xuICAgIHJldHVybiBwaWNrZWRQcm9wZXJ0aWVzO1xufTtcbmNvbnN0IGNhbm9uaWNhbGl6ZSA9IChhdHRycyA9IHt9KSA9PiB7XG4gICAgY29uc3QgbmV3QXR0cnMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgICBuZXdBdHRyc1trLnRvTG93ZXJDYXNlKCldID0gYXR0cnNba107XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ld0F0dHJzO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxheW91dC5qcy5tYXAiLCJpbXBvcnQgeyBhZGRCb3JkZXJOb2RlLCBhZGREdW1teU5vZGUgfSBmcm9tICcuL3V0aWwnO1xuLypcbiAqIEEgbmVzdGluZyBncmFwaCBjcmVhdGVzIGR1bW15IG5vZGVzIGZvciB0aGUgdG9wcyBhbmQgYm90dG9tcyBvZiBzdWJncmFwaHMsXG4gKiBhZGRzIGFwcHJvcHJpYXRlIGVkZ2VzIHRvIGVuc3VyZSB0aGF0IGFsbCBjbHVzdGVyIG5vZGVzIGFyZSBwbGFjZWQgYmV0d2VlblxuICogdGhlc2UgYm91bmRyaWVzLCBhbmQgZW5zdXJlcyB0aGF0IHRoZSBncmFwaCBpcyBjb25uZWN0ZWQuXG4gKlxuICogSW4gYWRkaXRpb24gd2UgZW5zdXJlLCB0aHJvdWdoIHRoZSB1c2Ugb2YgdGhlIG1pbmxlbiBwcm9wZXJ0eSwgdGhhdCBub2Rlc1xuICogYW5kIHN1YmdyYXBoIGJvcmRlciBub2RlcyB0byBub3QgZW5kIHVwIG9uIHRoZSBzYW1lIHJhbmsuXG4gKlxuICogUHJlY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBJbnB1dCBncmFwaCBpcyBhIERBR1xuICogICAgMi4gTm9kZXMgaW4gdGhlIGlucHV0IGdyYXBoIGhhcyBhIG1pbmxlbiBhdHRyaWJ1dGVcbiAqXG4gKiBQb3N0Y29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBJbnB1dCBncmFwaCBpcyBjb25uZWN0ZWQuXG4gKiAgICAyLiBEdW1teSBub2RlcyBhcmUgYWRkZWQgZm9yIHRoZSB0b3BzIGFuZCBib3R0b21zIG9mIHN1YmdyYXBocy5cbiAqICAgIDMuIFRoZSBtaW5sZW4gYXR0cmlidXRlIGZvciBub2RlcyBpcyBhZGp1c3RlZCB0byBlbnN1cmUgbm9kZXMgZG8gbm90XG4gKiAgICAgICBnZXQgcGxhY2VkIG9uIHRoZSBzYW1lIHJhbmsgYXMgc3ViZ3JhcGggYm9yZGVyIG5vZGVzLlxuICpcbiAqIFRoZSBuZXN0aW5nIGdyYXBoIGlkZWEgY29tZXMgZnJvbSBTYW5kZXIsIFwiTGF5b3V0IG9mIENvbXBvdW5kIERpcmVjdGVkXG4gKiBHcmFwaHMuXCJcbiAqL1xuY29uc3QgcnVuID0gKGcpID0+IHtcbiAgICBjb25zdCByb290ID0gYWRkRHVtbXlOb2RlKGcsICdyb290Jywge30sICdfcm9vdCcpO1xuICAgIGNvbnN0IGRlcHRocyA9IHRyZWVEZXB0aHMoZyk7XG4gICAgbGV0IG1heERlcHRoID0gTWF0aC5tYXgoLi4uT2JqZWN0LnZhbHVlcyhkZXB0aHMpKTtcbiAgICBpZiAoTWF0aC5hYnMobWF4RGVwdGgpID09PSBJbmZpbml0eSkge1xuICAgICAgICBtYXhEZXB0aCA9IDE7XG4gICAgfVxuICAgIGNvbnN0IGhlaWdodCA9IG1heERlcHRoIC0gMTsgLy8gTm90ZTogZGVwdGhzIGlzIGFuIE9iamVjdCBub3QgYW4gYXJyYXlcbiAgICBjb25zdCBub2RlU2VwID0gMiAqIGhlaWdodCArIDE7XG4gICAgLy8gZy5ncmFwaCgpLm5lc3RpbmdSb290ID0gcm9vdDtcbiAgICAvLyBNdWx0aXBseSBtaW5sZW4gYnkgbm9kZVNlcCB0byBhbGlnbiBub2RlcyBvbiBub24tYm9yZGVyIHJhbmtzLlxuICAgIGcuZ2V0QWxsRWRnZXMoKS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgIGUuZGF0YS5taW5sZW4gKj0gbm9kZVNlcDtcbiAgICB9KTtcbiAgICAvLyBDYWxjdWxhdGUgYSB3ZWlnaHQgdGhhdCBpcyBzdWZmaWNpZW50IHRvIGtlZXAgc3ViZ3JhcGhzIHZlcnRpY2FsbHkgY29tcGFjdFxuICAgIGNvbnN0IHdlaWdodCA9IHN1bVdlaWdodHMoZykgKyAxO1xuICAgIC8vIENyZWF0ZSBib3JkZXIgbm9kZXMgYW5kIGxpbmsgdGhlbSB1cFxuICAgIC8vIGcuY2hpbGRyZW4oKT8uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAvLyAgIGRmcyhnLCByb290LCBub2RlU2VwLCB3ZWlnaHQsIGhlaWdodCwgZGVwdGhzLCBjaGlsZCk7XG4gICAgLy8gfSk7XG4gICAgZy5nZXRSb290cygpLmZvckVhY2goKGNoaWxkKSA9PiB7XG4gICAgICAgIGRmcyhnLCByb290LCBub2RlU2VwLCB3ZWlnaHQsIGhlaWdodCwgZGVwdGhzLCBjaGlsZC5pZCk7XG4gICAgfSk7XG4gICAgLy8gU2F2ZSB0aGUgbXVsdGlwbGllciBmb3Igbm9kZSBsYXllcnMgZm9yIGxhdGVyIHJlbW92YWwgb2YgZW1wdHkgYm9yZGVyXG4gICAgLy8gbGF5ZXJzLlxuICAgIC8vIGcuZ3JhcGgoKS5ub2RlUmFua0ZhY3RvciA9IG5vZGVTZXA7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmVzdGluZ1Jvb3Q6IHJvb3QsXG4gICAgICAgIG5vZGVSYW5rRmFjdG9yOiBub2RlU2VwLFxuICAgIH07XG59O1xuY29uc3QgZGZzID0gKGcsIHJvb3QsIG5vZGVTZXAsIHdlaWdodCwgaGVpZ2h0LCBkZXB0aHMsIHYpID0+IHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IGcuZ2V0Q2hpbGRyZW4odik7XG4gICAgaWYgKCEoY2hpbGRyZW4gPT09IG51bGwgfHwgY2hpbGRyZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNoaWxkcmVuLmxlbmd0aCkpIHtcbiAgICAgICAgaWYgKHYgIT09IHJvb3QpIHtcbiAgICAgICAgICAgIC8vIGcuc2V0RWRnZShyb290LCB2LCB7IHdlaWdodDogMCwgbWlubGVuOiBub2RlU2VwIH0pO1xuICAgICAgICAgICAgZy5hZGRFZGdlKHtcbiAgICAgICAgICAgICAgICBpZDogYGUke01hdGgucmFuZG9tKCl9YCxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHJvb3QsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB2LFxuICAgICAgICAgICAgICAgIGRhdGE6IHsgd2VpZ2h0OiAwLCBtaW5sZW46IG5vZGVTZXAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdG9wID0gYWRkQm9yZGVyTm9kZShnLCAnX2J0Jyk7XG4gICAgY29uc3QgYm90dG9tID0gYWRkQm9yZGVyTm9kZShnLCAnX2JiJyk7XG4gICAgY29uc3QgbGFiZWwgPSBnLmdldE5vZGUodik7XG4gICAgZy5zZXRQYXJlbnQodG9wLCB2KTtcbiAgICBsYWJlbC5kYXRhLmJvcmRlclRvcCA9IHRvcDtcbiAgICBnLnNldFBhcmVudChib3R0b20sIHYpO1xuICAgIGxhYmVsLmRhdGEuYm9yZGVyQm90dG9tID0gYm90dG9tO1xuICAgIGNoaWxkcmVuID09PSBudWxsIHx8IGNoaWxkcmVuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjaGlsZHJlbi5mb3JFYWNoKChjaGlsZE5vZGUpID0+IHtcbiAgICAgICAgZGZzKGcsIHJvb3QsIG5vZGVTZXAsIHdlaWdodCwgaGVpZ2h0LCBkZXB0aHMsIGNoaWxkTm9kZS5pZCk7XG4gICAgICAgIGNvbnN0IGNoaWxkVG9wID0gY2hpbGROb2RlLmRhdGEuYm9yZGVyVG9wXG4gICAgICAgICAgICA/IGNoaWxkTm9kZS5kYXRhLmJvcmRlclRvcFxuICAgICAgICAgICAgOiBjaGlsZE5vZGUuaWQ7XG4gICAgICAgIGNvbnN0IGNoaWxkQm90dG9tID0gY2hpbGROb2RlLmRhdGEuYm9yZGVyQm90dG9tXG4gICAgICAgICAgICA/IGNoaWxkTm9kZS5kYXRhLmJvcmRlckJvdHRvbVxuICAgICAgICAgICAgOiBjaGlsZE5vZGUuaWQ7XG4gICAgICAgIGNvbnN0IHRoaXNXZWlnaHQgPSBjaGlsZE5vZGUuZGF0YS5ib3JkZXJUb3AgPyB3ZWlnaHQgOiAyICogd2VpZ2h0O1xuICAgICAgICBjb25zdCBtaW5sZW4gPSBjaGlsZFRvcCAhPT0gY2hpbGRCb3R0b20gPyAxIDogaGVpZ2h0IC0gZGVwdGhzW3ZdICsgMTtcbiAgICAgICAgZy5hZGRFZGdlKHtcbiAgICAgICAgICAgIGlkOiBgZSR7TWF0aC5yYW5kb20oKX1gLFxuICAgICAgICAgICAgc291cmNlOiB0b3AsXG4gICAgICAgICAgICB0YXJnZXQ6IGNoaWxkVG9wLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIG1pbmxlbixcbiAgICAgICAgICAgICAgICB3ZWlnaHQ6IHRoaXNXZWlnaHQsXG4gICAgICAgICAgICAgICAgbmVzdGluZ0VkZ2U6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgZy5hZGRFZGdlKHtcbiAgICAgICAgICAgIGlkOiBgZSR7TWF0aC5yYW5kb20oKX1gLFxuICAgICAgICAgICAgc291cmNlOiBjaGlsZEJvdHRvbSxcbiAgICAgICAgICAgIHRhcmdldDogYm90dG9tLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIG1pbmxlbixcbiAgICAgICAgICAgICAgICB3ZWlnaHQ6IHRoaXNXZWlnaHQsXG4gICAgICAgICAgICAgICAgbmVzdGluZ0VkZ2U6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBpZiAoIWcuZ2V0UGFyZW50KHYpKSB7XG4gICAgICAgIGcuYWRkRWRnZSh7XG4gICAgICAgICAgICBpZDogYGUke01hdGgucmFuZG9tKCl9YCxcbiAgICAgICAgICAgIHNvdXJjZTogcm9vdCxcbiAgICAgICAgICAgIHRhcmdldDogdG9wLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIHdlaWdodDogMCxcbiAgICAgICAgICAgICAgICBtaW5sZW46IGhlaWdodCArIGRlcHRoc1t2XSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5jb25zdCB0cmVlRGVwdGhzID0gKGcpID0+IHtcbiAgICBjb25zdCBkZXB0aHMgPSB7fTtcbiAgICBjb25zdCBkZnMgPSAodiwgZGVwdGgpID0+IHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBnLmdldENoaWxkcmVuKHYpO1xuICAgICAgICBjaGlsZHJlbiA9PT0gbnVsbCB8fCBjaGlsZHJlbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IGRmcyhjaGlsZC5pZCwgZGVwdGggKyAxKSk7XG4gICAgICAgIGRlcHRoc1t2XSA9IGRlcHRoO1xuICAgIH07XG4gICAgLy8gZy5jaGlsZHJlbigpPy5mb3JFYWNoKCh2KSA9PiBkZnModiwgMSkpO1xuICAgIGcuZ2V0Um9vdHMoKS5mb3JFYWNoKCh2KSA9PiBkZnModi5pZCwgMSkpO1xuICAgIHJldHVybiBkZXB0aHM7XG59O1xuY29uc3Qgc3VtV2VpZ2h0cyA9IChnKSA9PiB7XG4gICAgbGV0IHJlc3VsdCA9IDA7XG4gICAgZy5nZXRBbGxFZGdlcygpLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgcmVzdWx0ICs9IGUuZGF0YS53ZWlnaHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5jb25zdCBjbGVhbnVwID0gKGcsIG5lc3RpbmdSb290KSA9PiB7XG4gICAgLy8gY29uc3QgZ3JhcGhMYWJlbCA9IGcuZ3JhcGgoKTtcbiAgICAvLyBncmFwaExhYmVsLm5lc3RpbmdSb290ICYmIGcucmVtb3ZlTm9kZShncmFwaExhYmVsLm5lc3RpbmdSb290KTtcbiAgICAvLyBkZWxldGUgZ3JhcGhMYWJlbC5uZXN0aW5nUm9vdDtcbiAgICBpZiAobmVzdGluZ1Jvb3QpIHtcbiAgICAgICAgZy5yZW1vdmVOb2RlKG5lc3RpbmdSb290KTtcbiAgICB9XG4gICAgZy5nZXRBbGxFZGdlcygpLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgaWYgKGUuZGF0YS5uZXN0aW5nRWRnZSkge1xuICAgICAgICAgICAgZy5yZW1vdmVFZGdlKGUuaWQpO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuZXhwb3J0IHsgcnVuLCBjbGVhbnVwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uZXN0aW5nLWdyYXBoLmpzLm1hcCIsImltcG9ydCB7IGFkZER1bW15Tm9kZSB9IGZyb20gJy4vdXRpbCc7XG4vKlxuICogQnJlYWtzIGFueSBsb25nIGVkZ2VzIGluIHRoZSBncmFwaCBpbnRvIHNob3J0IHNlZ21lbnRzIHRoYXQgc3BhbiAxIGxheWVyXG4gKiBlYWNoLiBUaGlzIG9wZXJhdGlvbiBpcyB1bmRvYWJsZSB3aXRoIHRoZSBkZW5vcm1hbGl6ZSBmdW5jdGlvbi5cbiAqXG4gKiBQcmUtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBUaGUgaW5wdXQgZ3JhcGggaXMgYSBEQUcuXG4gKiAgICAyLiBFYWNoIG5vZGUgaW4gdGhlIGdyYXBoIGhhcyBhIFwicmFua1wiIHByb3BlcnR5LlxuICpcbiAqIFBvc3QtY29uZGl0aW9uOlxuICpcbiAqICAgIDEuIEFsbCBlZGdlcyBpbiB0aGUgZ3JhcGggaGF2ZSBhIGxlbmd0aCBvZiAxLlxuICogICAgMi4gRHVtbXkgbm9kZXMgYXJlIGFkZGVkIHdoZXJlIGVkZ2VzIGhhdmUgYmVlbiBzcGxpdCBpbnRvIHNlZ21lbnRzLlxuICogICAgMy4gVGhlIGdyYXBoIGlzIGF1Z21lbnRlZCB3aXRoIGEgXCJkdW1teUNoYWluc1wiIGF0dHJpYnV0ZSB3aGljaCBjb250YWluc1xuICogICAgICAgdGhlIGZpcnN0IGR1bW15IGluIGVhY2ggY2hhaW4gb2YgZHVtbXkgbm9kZXMgcHJvZHVjZWQuXG4gKi9cbmNvbnN0IERVTU1ZX05PREVfRURHRSA9ICdlZGdlJztcbmNvbnN0IERVTU1ZX05PREVfRURHRV9MQUJFTCA9ICdlZGdlLWxhYmVsJztcbmNvbnN0IHJ1biA9IChnLCBkdW1teUNoYWlucykgPT4ge1xuICAgIGcuZ2V0QWxsRWRnZXMoKS5mb3JFYWNoKChlZGdlKSA9PiBub3JtYWxpemVFZGdlKGcsIGVkZ2UsIGR1bW15Q2hhaW5zKSk7XG59O1xuY29uc3Qgbm9ybWFsaXplRWRnZSA9IChnLCBlLCBkdW1teUNoYWlucykgPT4ge1xuICAgIGxldCB2ID0gZS5zb3VyY2U7XG4gICAgbGV0IHZSYW5rID0gZy5nZXROb2RlKHYpLmRhdGEucmFuaztcbiAgICBjb25zdCB3ID0gZS50YXJnZXQ7XG4gICAgY29uc3Qgd1JhbmsgPSBnLmdldE5vZGUodykuZGF0YS5yYW5rO1xuICAgIGNvbnN0IGxhYmVsUmFuayA9IGUuZGF0YS5sYWJlbFJhbms7XG4gICAgaWYgKHdSYW5rID09PSB2UmFuayArIDEpXG4gICAgICAgIHJldHVybjtcbiAgICBnLnJlbW92ZUVkZ2UoZS5pZCk7XG4gICAgbGV0IGR1bW15O1xuICAgIGxldCBub2RlRGF0YTtcbiAgICBsZXQgaTtcbiAgICBmb3IgKGkgPSAwLCArK3ZSYW5rOyB2UmFuayA8IHdSYW5rOyArK2ksICsrdlJhbmspIHtcbiAgICAgICAgZS5kYXRhLnBvaW50cyA9IFtdO1xuICAgICAgICBub2RlRGF0YSA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsRWRnZTogZSxcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgcmFuazogdlJhbmssXG4gICAgICAgIH07XG4gICAgICAgIGR1bW15ID0gYWRkRHVtbXlOb2RlKGcsIERVTU1ZX05PREVfRURHRSwgbm9kZURhdGEsICdfZCcpO1xuICAgICAgICBpZiAodlJhbmsgPT09IGxhYmVsUmFuaykge1xuICAgICAgICAgICAgbm9kZURhdGEud2lkdGggPSBlLmRhdGEud2lkdGg7XG4gICAgICAgICAgICBub2RlRGF0YS5oZWlnaHQgPSBlLmRhdGEuaGVpZ2h0O1xuICAgICAgICAgICAgbm9kZURhdGEuZHVtbXkgPSBEVU1NWV9OT0RFX0VER0VfTEFCRUw7XG4gICAgICAgICAgICBub2RlRGF0YS5sYWJlbHBvcyA9IGUuZGF0YS5sYWJlbHBvcztcbiAgICAgICAgfVxuICAgICAgICBnLmFkZEVkZ2Uoe1xuICAgICAgICAgICAgaWQ6IGBlJHtNYXRoLnJhbmRvbSgpfWAsXG4gICAgICAgICAgICBzb3VyY2U6IHYsXG4gICAgICAgICAgICB0YXJnZXQ6IGR1bW15LFxuICAgICAgICAgICAgZGF0YTogeyB3ZWlnaHQ6IGUuZGF0YS53ZWlnaHQgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBkdW1teUNoYWlucy5wdXNoKGR1bW15KTtcbiAgICAgICAgfVxuICAgICAgICB2ID0gZHVtbXk7XG4gICAgfVxuICAgIGcuYWRkRWRnZSh7XG4gICAgICAgIGlkOiBgZSR7TWF0aC5yYW5kb20oKX1gLFxuICAgICAgICBzb3VyY2U6IHYsXG4gICAgICAgIHRhcmdldDogdyxcbiAgICAgICAgZGF0YTogeyB3ZWlnaHQ6IGUuZGF0YS53ZWlnaHQgfSxcbiAgICB9KTtcbn07XG5jb25zdCB1bmRvID0gKGcsIGR1bW15Q2hhaW5zKSA9PiB7XG4gICAgZHVtbXlDaGFpbnMuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICBsZXQgbm9kZSA9IGcuZ2V0Tm9kZSh2KTtcbiAgICAgICAgY29uc3QgeyBkYXRhIH0gPSBub2RlO1xuICAgICAgICBjb25zdCBvcmlnaW5hbEVkZ2UgPSBkYXRhLm9yaWdpbmFsRWRnZTtcbiAgICAgICAgbGV0IHc7XG4gICAgICAgIC8vIFJlc3RvcmUgb3JpZ2luYWwgZWRnZS5cbiAgICAgICAgaWYgKG9yaWdpbmFsRWRnZSkge1xuICAgICAgICAgICAgZy5hZGRFZGdlKG9yaWdpbmFsRWRnZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnRWID0gdjtcbiAgICAgICAgd2hpbGUgKG5vZGUuZGF0YS5kdW1teSkge1xuICAgICAgICAgICAgdyA9IGcuZ2V0U3VjY2Vzc29ycyhjdXJyZW50VilbMF07XG4gICAgICAgICAgICBnLnJlbW92ZU5vZGUoY3VycmVudFYpO1xuICAgICAgICAgICAgb3JpZ2luYWxFZGdlLmRhdGEucG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHg6IG5vZGUuZGF0YS54LFxuICAgICAgICAgICAgICAgIHk6IG5vZGUuZGF0YS55LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAobm9kZS5kYXRhLmR1bW15ID09PSBEVU1NWV9OT0RFX0VER0VfTEFCRUwpIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEVkZ2UuZGF0YS54ID0gbm9kZS5kYXRhLng7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFZGdlLmRhdGEueSA9IG5vZGUuZGF0YS55O1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRWRnZS5kYXRhLndpZHRoID0gbm9kZS5kYXRhLndpZHRoO1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsRWRnZS5kYXRhLmhlaWdodCA9IG5vZGUuZGF0YS5oZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ViA9IHcuaWQ7XG4gICAgICAgICAgICBub2RlID0gZy5nZXROb2RlKGN1cnJlbnRWKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbmV4cG9ydCB7IHJ1biwgdW5kbyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9ybWFsaXplLmpzLm1hcCIsImV4cG9ydCBjb25zdCBhZGRTdWJncmFwaENvbnN0cmFpbnRzID0gKGcsIGNnLCB2cykgPT4ge1xuICAgIGNvbnN0IHByZXYgPSB7fTtcbiAgICBsZXQgcm9vdFByZXY7XG4gICAgdnMgPT09IG51bGwgfHwgdnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZzLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgbGV0IGNoaWxkID0gZy5nZXRQYXJlbnQodik7XG4gICAgICAgIGxldCBwYXJlbnQ7XG4gICAgICAgIGxldCBwcmV2Q2hpbGQ7XG4gICAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICAgICAgcGFyZW50ID0gZy5nZXRQYXJlbnQoY2hpbGQuaWQpO1xuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHByZXZDaGlsZCA9IHByZXZbcGFyZW50LmlkXTtcbiAgICAgICAgICAgICAgICBwcmV2W3BhcmVudC5pZF0gPSBjaGlsZC5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHByZXZDaGlsZCA9IHJvb3RQcmV2O1xuICAgICAgICAgICAgICAgIHJvb3RQcmV2ID0gY2hpbGQuaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldkNoaWxkICYmIHByZXZDaGlsZCAhPT0gY2hpbGQuaWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNnLmhhc05vZGUocHJldkNoaWxkKSkge1xuICAgICAgICAgICAgICAgICAgICBjZy5hZGROb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBwcmV2Q2hpbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY2cuaGFzTm9kZShjaGlsZC5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2cuYWRkTm9kZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogY2hpbGQuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghY2cuaGFzRWRnZShgZSR7cHJldkNoaWxkfS0ke2NoaWxkLmlkfWApKSB7XG4gICAgICAgICAgICAgICAgICAgIGNnLmFkZEVkZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGBlJHtwcmV2Q2hpbGR9LSR7Y2hpbGQuaWR9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogcHJldkNoaWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBjaGlsZC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHt9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGQgPSBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGQtc3ViZ3JhcGgtY29uc3RyYWludHMuanMubWFwIiwiLyoqXG4gKiBUT0RPOiBUaGUgbWVkaWFuIG1ldGhvZCBjb25zaXN0ZW50bHkgcGVyZm9ybXMgYmV0dGVyIHRoYW4gdGhlIGJhcnljZW50ZXIgbWV0aG9kIGFuZCBoYXMgYSBzbGlnaHQgdGhlb3JldGljYWwgYWR2YW50YWdlXG4gKi9cbmV4cG9ydCBjb25zdCBiYXJ5Y2VudGVyID0gKGcsIG1vdmFibGUpID0+IHtcbiAgICByZXR1cm4gbW92YWJsZS5tYXAoKHYpID0+IHtcbiAgICAgICAgY29uc3QgaW5WID0gZy5nZXRSZWxhdGVkRWRnZXModiwgJ2luJyk7XG4gICAgICAgIGlmICghKGluViA9PT0gbnVsbCB8fCBpblYgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluVi5sZW5ndGgpKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2IH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBzdW06IDAsIHdlaWdodDogMCB9O1xuICAgICAgICBpblYgPT09IG51bGwgfHwgaW5WID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpblYuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZVUgPSBnLmdldE5vZGUoZS5zb3VyY2UpO1xuICAgICAgICAgICAgcmVzdWx0LnN1bSArPSBlLmRhdGEud2VpZ2h0ICogbm9kZVUuZGF0YS5vcmRlcjtcbiAgICAgICAgICAgIHJlc3VsdC53ZWlnaHQgKz0gZS5kYXRhLndlaWdodDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2LFxuICAgICAgICAgICAgYmFyeWNlbnRlcjogcmVzdWx0LnN1bSAvIHJlc3VsdC53ZWlnaHQsXG4gICAgICAgICAgICB3ZWlnaHQ6IHJlc3VsdC53ZWlnaHQsXG4gICAgICAgIH07XG4gICAgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFyeWNlbnRlci5qcy5tYXAiLCJpbXBvcnQgeyBHcmFwaCB9IGZyb20gJ0BhbnR2L2dyYXBobGliJztcbi8qXG4gKiBDb25zdHJ1Y3RzIGEgZ3JhcGggdGhhdCBjYW4gYmUgdXNlZCB0byBzb3J0IGEgbGF5ZXIgb2Ygbm9kZXMuIFRoZSBncmFwaCB3aWxsXG4gKiBjb250YWluIGFsbCBiYXNlIGFuZCBzdWJncmFwaCBub2RlcyBmcm9tIHRoZSByZXF1ZXN0IGxheWVyIGluIHRoZWlyIG9yaWdpbmFsXG4gKiBoaWVyYXJjaHkgYW5kIGFueSBlZGdlcyB0aGF0IGFyZSBpbmNpZGVudCBvbiB0aGVzZSBub2RlcyBhbmQgYXJlIG9mIHRoZSB0eXBlXG4gKiByZXF1ZXN0ZWQgYnkgdGhlIFwicmVsYXRpb25zaGlwXCIgcGFyYW1ldGVyLlxuICpcbiAqIE5vZGVzIGZyb20gdGhlIHJlcXVlc3RlZCByYW5rIHRoYXQgZG8gbm90IGhhdmUgcGFyZW50cyBhcmUgYXNzaWduZWQgYSByb290XG4gKiBub2RlIGluIHRoZSBvdXRwdXQgZ3JhcGgsIHdoaWNoIGlzIHNldCBpbiB0aGUgcm9vdCBncmFwaCBhdHRyaWJ1dGUuIFRoaXNcbiAqIG1ha2VzIGl0IGVhc3kgdG8gd2FsayB0aGUgaGllcmFyY2h5IG9mIG1vdmFibGUgbm9kZXMgZHVyaW5nIG9yZGVyaW5nLlxuICpcbiAqIFByZS1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIElucHV0IGdyYXBoIGlzIGEgREFHXG4gKiAgICAyLiBCYXNlIG5vZGVzIGluIHRoZSBpbnB1dCBncmFwaCBoYXZlIGEgcmFuayBhdHRyaWJ1dGVcbiAqICAgIDMuIFN1YmdyYXBoIG5vZGVzIGluIHRoZSBpbnB1dCBncmFwaCBoYXMgbWluUmFuayBhbmQgbWF4UmFuayBhdHRyaWJ1dGVzXG4gKiAgICA0LiBFZGdlcyBoYXZlIGFuIGFzc2lnbmVkIHdlaWdodFxuICpcbiAqIFBvc3QtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBPdXRwdXQgZ3JhcGggaGFzIGFsbCBub2RlcyBpbiB0aGUgbW92YWJsZSByYW5rIHdpdGggcHJlc2VydmVkXG4gKiAgICAgICBoaWVyYXJjaHkuXG4gKiAgICAyLiBSb290IG5vZGVzIGluIHRoZSBtb3ZhYmxlIGxheWVyIGFyZSBtYWRlIGNoaWxkcmVuIG9mIHRoZSBub2RlXG4gKiAgICAgICBpbmRpY2F0ZWQgYnkgdGhlIHJvb3QgYXR0cmlidXRlIG9mIHRoZSBncmFwaC5cbiAqICAgIDMuIE5vbi1tb3ZhYmxlIG5vZGVzIGluY2lkZW50IG9uIG1vdmFibGUgbm9kZXMsIHNlbGVjdGVkIGJ5IHRoZVxuICogICAgICAgcmVsYXRpb25zaGlwIHBhcmFtZXRlciwgYXJlIGluY2x1ZGVkIGluIHRoZSBncmFwaCAod2l0aG91dCBoaWVyYXJjaHkpLlxuICogICAgNC4gRWRnZXMgaW5jaWRlbnQgb24gbW92YWJsZSBub2Rlcywgc2VsZWN0ZWQgYnkgdGhlIHJlbGF0aW9uc2hpcFxuICogICAgICAgcGFyYW1ldGVyLCBhcmUgYWRkZWQgdG8gdGhlIG91dHB1dCBncmFwaC5cbiAqICAgIDUuIFRoZSB3ZWlnaHRzIGZvciBjb3BpZWQgZWRnZXMgYXJlIGFnZ3JlZ2F0ZWQgYXMgbmVlZCwgc2luY2UgdGhlIG91dHB1dFxuICogICAgICAgZ3JhcGggaXMgbm90IGEgbXVsdGktZ3JhcGguXG4gKi9cbmV4cG9ydCBjb25zdCBidWlsZExheWVyR3JhcGggPSAoZywgcmFuaywgZGlyZWN0aW9uKSA9PiB7XG4gICAgY29uc3Qgcm9vdCA9IGNyZWF0ZVJvb3ROb2RlKGcpO1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBHcmFwaCh7XG4gICAgICAgIHRyZWU6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogcm9vdCxcbiAgICAgICAgICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgICAgICAgICAgZGF0YToge30sXG4gICAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgIH0pO1xuICAgIGcuZ2V0QWxsTm9kZXMoKS5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IGcuZ2V0UGFyZW50KHYuaWQpO1xuICAgICAgICBpZiAodi5kYXRhLnJhbmsgPT09IHJhbmsgfHxcbiAgICAgICAgICAgICh2LmRhdGEubWluUmFuayA8PSByYW5rICYmIHJhbmsgPD0gdi5kYXRhLm1heFJhbmspKSB7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5oYXNOb2RlKHYuaWQpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFkZE5vZGUoT2JqZWN0LmFzc2lnbih7fSwgdikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuaWQpICYmICFyZXN1bHQuaGFzTm9kZShwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuaWQpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmFkZE5vZGUoT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQuc2V0UGFyZW50KHYuaWQsIChwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuaWQpIHx8IHJvb3QpO1xuICAgICAgICAgICAgLy8gVGhpcyBhc3N1bWVzIHdlIGhhdmUgb25seSBzaG9ydCBlZGdlcyFcbiAgICAgICAgICAgIGcuZ2V0UmVsYXRlZEVkZ2VzKHYuaWQsIGRpcmVjdGlvbikuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHUgPSBlLnNvdXJjZSA9PT0gdi5pZCA/IGUudGFyZ2V0IDogZS5zb3VyY2U7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuaGFzTm9kZSh1KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuYWRkTm9kZShPYmplY3QuYXNzaWduKHt9LCBnLmdldE5vZGUodSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZWRnZSA9IHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAuZ2V0UmVsYXRlZEVkZ2VzKHUsICdvdXQnKVxuICAgICAgICAgICAgICAgICAgICAuZmluZCgoeyB0YXJnZXQgfSkgPT4gdGFyZ2V0ID09PSB2LmlkKTtcbiAgICAgICAgICAgICAgICBjb25zdCB3ZWlnaHQgPSBlZGdlICE9PSB1bmRlZmluZWQgPyBlZGdlLmRhdGEud2VpZ2h0IDogMDtcbiAgICAgICAgICAgICAgICBpZiAoIWVkZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmFkZEVkZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IHYuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0OiBlLmRhdGEud2VpZ2h0ICsgd2VpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQudXBkYXRlRWRnZURhdGEoZWRnZS5pZCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlZGdlLmRhdGEpLCB7IHdlaWdodDogZS5kYXRhLndlaWdodCArIHdlaWdodCB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh2KTtcbiAgICAgICAgICAgIGlmICh2LmRhdGEuaGFzT3duUHJvcGVydHkoJ21pblJhbmsnKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC51cGRhdGVOb2RlRGF0YSh2LmlkLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHYuZGF0YSksIHsgYm9yZGVyTGVmdDogdi5kYXRhLmJvcmRlckxlZnRbcmFua10sIGJvcmRlclJpZ2h0OiB2LmRhdGEuYm9yZGVyUmlnaHRbcmFua10gfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5jb25zdCBjcmVhdGVSb290Tm9kZSA9IChnKSA9PiB7XG4gICAgbGV0IHY7XG4gICAgd2hpbGUgKGcuaGFzTm9kZSgodiA9IGBfcm9vdCR7TWF0aC5yYW5kb20oKX1gKSkpXG4gICAgICAgIDtcbiAgICByZXR1cm4gdjtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1idWlsZC1sYXllci1ncmFwaC5qcy5tYXAiLCIvKlxuICogQSBmdW5jdGlvbiB0aGF0IHRha2VzIGEgbGF5ZXJpbmcgKGFuIGFycmF5IG9mIGxheWVycywgZWFjaCB3aXRoIGFuIGFycmF5IG9mXG4gKiBvcmRlcmVyZCBub2RlcykgYW5kIGEgZ3JhcGggYW5kIHJldHVybnMgYSB3ZWlnaHRlZCBjcm9zc2luZyBjb3VudC5cbiAqXG4gKiBQcmUtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBJbnB1dCBncmFwaCBtdXN0IGJlIHNpbXBsZSAobm90IGEgbXVsdGlncmFwaCksIGRpcmVjdGVkLCBhbmQgaW5jbHVkZVxuICogICAgICAgb25seSBzaW1wbGUgZWRnZXMuXG4gKiAgICAyLiBFZGdlcyBpbiB0aGUgaW5wdXQgZ3JhcGggbXVzdCBoYXZlIGFzc2lnbmVkIHdlaWdodHMuXG4gKlxuICogUG9zdC1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIFRoZSBncmFwaCBhbmQgbGF5ZXJpbmcgbWF0cml4IGFyZSBsZWZ0IHVuY2hhbmdlZC5cbiAqXG4gKiBUaGlzIGFsZ29yaXRobSBpcyBkZXJpdmVkIGZyb20gQmFydGgsIGV0IGFsLiwgXCJCaWxheWVyIENyb3NzIENvdW50aW5nLlwiXG4gKi9cbmltcG9ydCB7IHppcE9iamVjdCB9IGZyb20gJy4uL3V0aWwnO1xuY29uc3QgdHdvTGF5ZXJDcm9zc0NvdW50ID0gKGcsIG5vcnRoTGF5ZXIsIHNvdXRoTGF5ZXIpID0+IHtcbiAgICAvLyBTb3J0IGFsbCBvZiB0aGUgZWRnZXMgYmV0d2VlbiB0aGUgbm9ydGggYW5kIHNvdXRoIGxheWVycyBieSB0aGVpciBwb3NpdGlvblxuICAgIC8vIGluIHRoZSBub3J0aCBsYXllciBhbmQgdGhlbiB0aGUgc291dGguIE1hcCB0aGVzZSBlZGdlcyB0byB0aGUgcG9zaXRpb24gb2ZcbiAgICAvLyB0aGVpciBoZWFkIGluIHRoZSBzb3V0aCBsYXllci5cbiAgICBjb25zdCBzb3V0aFBvcyA9IHppcE9iamVjdChzb3V0aExheWVyLCBzb3V0aExheWVyLm1hcCgodiwgaSkgPT4gaSkpO1xuICAgIGNvbnN0IHVuZmxhdCA9IG5vcnRoTGF5ZXIubWFwKCh2KSA9PiB7XG4gICAgICAgIGNvbnN0IHVuc29ydCA9IGcuZ2V0UmVsYXRlZEVkZ2VzKHYsICdvdXQnKS5tYXAoKGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IHBvczogc291dGhQb3NbZS50YXJnZXRdIHx8IDAsIHdlaWdodDogZS5kYXRhLndlaWdodCB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVuc29ydCA9PT0gbnVsbCB8fCB1bnNvcnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVuc29ydC5zb3J0KChhLCBiKSA9PiBhLnBvcyAtIGIucG9zKTtcbiAgICB9KTtcbiAgICBjb25zdCBzb3V0aEVudHJpZXMgPSB1bmZsYXQuZmxhdCgpLmZpbHRlcigoZW50cnkpID0+IGVudHJ5ICE9PSB1bmRlZmluZWQpO1xuICAgIC8vIEJ1aWxkIHRoZSBhY2N1bXVsYXRvciB0cmVlXG4gICAgbGV0IGZpcnN0SW5kZXggPSAxO1xuICAgIHdoaWxlIChmaXJzdEluZGV4IDwgc291dGhMYXllci5sZW5ndGgpXG4gICAgICAgIGZpcnN0SW5kZXggPDw9IDE7XG4gICAgY29uc3QgdHJlZVNpemUgPSAyICogZmlyc3RJbmRleCAtIDE7XG4gICAgZmlyc3RJbmRleCAtPSAxO1xuICAgIGNvbnN0IHRyZWUgPSBBcnJheSh0cmVlU2l6ZSkuZmlsbCgwLCAwLCB0cmVlU2l6ZSk7XG4gICAgLy8gQ2FsY3VsYXRlIHRoZSB3ZWlnaHRlZCBjcm9zc2luZ3NcbiAgICBsZXQgY2MgPSAwO1xuICAgIHNvdXRoRW50cmllcyA9PT0gbnVsbCB8fCBzb3V0aEVudHJpZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvdXRoRW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IGVudHJ5LnBvcyArIGZpcnN0SW5kZXg7XG4gICAgICAgICAgICB0cmVlW2luZGV4XSArPSBlbnRyeS53ZWlnaHQ7XG4gICAgICAgICAgICBsZXQgd2VpZ2h0U3VtID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChpbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggJSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIHdlaWdodFN1bSArPSB0cmVlW2luZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4ID0gKGluZGV4IC0gMSkgPj4gMTtcbiAgICAgICAgICAgICAgICB0cmVlW2luZGV4XSArPSBlbnRyeS53ZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYyArPSBlbnRyeS53ZWlnaHQgKiB3ZWlnaHRTdW07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY2M7XG59O1xuZXhwb3J0IGNvbnN0IGNyb3NzQ291bnQgPSAoZywgbGF5ZXJpbmcpID0+IHtcbiAgICBsZXQgY2MgPSAwO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgKGxheWVyaW5nID09PSBudWxsIHx8IGxheWVyaW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXllcmluZy5sZW5ndGgpOyBpICs9IDEpIHtcbiAgICAgICAgY2MgKz0gdHdvTGF5ZXJDcm9zc0NvdW50KGcsIGxheWVyaW5nW2kgLSAxXSwgbGF5ZXJpbmdbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gY2M7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3Jvc3MtY291bnQuanMubWFwIiwiaW1wb3J0IHsgR3JhcGggfSBmcm9tICdAYW50di9ncmFwaGxpYic7XG5pbXBvcnQgeyBjbG9uZSB9IGZyb20gJ0BhbnR2L3V0aWwnO1xuaW1wb3J0IHsgYnVpbGRMYXllck1hdHJpeCwgbWF4UmFuayB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHsgYWRkU3ViZ3JhcGhDb25zdHJhaW50cyB9IGZyb20gJy4vYWRkLXN1YmdyYXBoLWNvbnN0cmFpbnRzJztcbmltcG9ydCB7IGJ1aWxkTGF5ZXJHcmFwaCB9IGZyb20gJy4vYnVpbGQtbGF5ZXItZ3JhcGgnO1xuaW1wb3J0IHsgY3Jvc3NDb3VudCB9IGZyb20gJy4vY3Jvc3MtY291bnQnO1xuaW1wb3J0IHsgaW5pdE9yZGVyIH0gZnJvbSAnLi9pbml0LW9yZGVyJztcbmltcG9ydCB7IHNvcnRTdWJncmFwaCB9IGZyb20gJy4vc29ydC1zdWJncmFwaCc7XG4vKlxuICogQXBwbGllcyBoZXVyaXN0aWNzIHRvIG1pbmltaXplIGVkZ2UgY3Jvc3NpbmdzIGluIHRoZSBncmFwaCBhbmQgc2V0cyB0aGUgYmVzdFxuICogb3JkZXIgc29sdXRpb24gYXMgYW4gb3JkZXIgYXR0cmlidXRlIG9uIGVhY2ggbm9kZS5cbiAqXG4gKiBQcmUtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBHcmFwaCBtdXN0IGJlIERBR1xuICogICAgMi4gR3JhcGggbm9kZXMgbXVzdCBiZSBvYmplY3RzIHdpdGggYSBcInJhbmtcIiBhdHRyaWJ1dGVcbiAqICAgIDMuIEdyYXBoIGVkZ2VzIG11c3QgaGF2ZSB0aGUgXCJ3ZWlnaHRcIiBhdHRyaWJ1dGVcbiAqXG4gKiBQb3N0LWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gR3JhcGggbm9kZXMgd2lsbCBoYXZlIGFuIFwib3JkZXJcIiBhdHRyaWJ1dGUgYmFzZWQgb24gdGhlIHJlc3VsdHMgb2YgdGhlXG4gKiAgICAgICBhbGdvcml0aG0uXG4gKi9cbmV4cG9ydCBjb25zdCBvcmRlciA9IChnLCBrZWVwTm9kZU9yZGVyKSA9PiB7XG4gICAgY29uc3QgbXhSYW5rID0gbWF4UmFuayhnKTtcbiAgICBjb25zdCByYW5nZTEgPSBbXTtcbiAgICBjb25zdCByYW5nZTIgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG14UmFuayArIDE7IGkrKylcbiAgICAgICAgcmFuZ2UxLnB1c2goaSk7XG4gICAgZm9yIChsZXQgaSA9IG14UmFuayAtIDE7IGkgPiAtMTsgaS0tKVxuICAgICAgICByYW5nZTIucHVzaChpKTtcbiAgICBjb25zdCBkb3duTGF5ZXJHcmFwaHMgPSBidWlsZExheWVyR3JhcGhzKGcsIHJhbmdlMSwgJ2luJyk7XG4gICAgY29uc3QgdXBMYXllckdyYXBocyA9IGJ1aWxkTGF5ZXJHcmFwaHMoZywgcmFuZ2UyLCAnb3V0Jyk7XG4gICAgbGV0IGxheWVyaW5nID0gaW5pdE9yZGVyKGcpO1xuICAgIGFzc2lnbk9yZGVyKGcsIGxheWVyaW5nKTtcbiAgICBsZXQgYmVzdENDID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgIGxldCBiZXN0O1xuICAgIGZvciAobGV0IGkgPSAwLCBsYXN0QmVzdCA9IDA7IGxhc3RCZXN0IDwgNDsgKytpLCArK2xhc3RCZXN0KSB7XG4gICAgICAgIHN3ZWVwTGF5ZXJHcmFwaHMoaSAlIDIgPyBkb3duTGF5ZXJHcmFwaHMgOiB1cExheWVyR3JhcGhzLCBpICUgNCA+PSAyLCBmYWxzZSwga2VlcE5vZGVPcmRlcik7XG4gICAgICAgIGxheWVyaW5nID0gYnVpbGRMYXllck1hdHJpeChnKTtcbiAgICAgICAgY29uc3QgY2MgPSBjcm9zc0NvdW50KGcsIGxheWVyaW5nKTtcbiAgICAgICAgaWYgKGNjIDwgYmVzdENDKSB7XG4gICAgICAgICAgICBsYXN0QmVzdCA9IDA7XG4gICAgICAgICAgICBiZXN0ID0gY2xvbmUobGF5ZXJpbmcpO1xuICAgICAgICAgICAgYmVzdENDID0gY2M7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gY29uc2lkZXIgdXNlIHByZXZpb3VzIHJlc3VsdCwgbWF5YmUgc29tZXdoYXQgcmVkdWVuZGFudFxuICAgIGxheWVyaW5nID0gaW5pdE9yZGVyKGcpO1xuICAgIGFzc2lnbk9yZGVyKGcsIGxheWVyaW5nKTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGFzdEJlc3QgPSAwOyBsYXN0QmVzdCA8IDQ7ICsraSwgKytsYXN0QmVzdCkge1xuICAgICAgICBzd2VlcExheWVyR3JhcGhzKGkgJSAyID8gZG93bkxheWVyR3JhcGhzIDogdXBMYXllckdyYXBocywgaSAlIDQgPj0gMiwgdHJ1ZSwga2VlcE5vZGVPcmRlcik7XG4gICAgICAgIGxheWVyaW5nID0gYnVpbGRMYXllck1hdHJpeChnKTtcbiAgICAgICAgY29uc3QgY2MgPSBjcm9zc0NvdW50KGcsIGxheWVyaW5nKTtcbiAgICAgICAgaWYgKGNjIDwgYmVzdENDKSB7XG4gICAgICAgICAgICBsYXN0QmVzdCA9IDA7XG4gICAgICAgICAgICBiZXN0ID0gY2xvbmUobGF5ZXJpbmcpO1xuICAgICAgICAgICAgYmVzdENDID0gY2M7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNzaWduT3JkZXIoZywgYmVzdCk7XG59O1xuY29uc3QgYnVpbGRMYXllckdyYXBocyA9IChnLCByYW5rcywgZGlyZWN0aW9uKSA9PiB7XG4gICAgcmV0dXJuIHJhbmtzLm1hcCgocmFuaykgPT4ge1xuICAgICAgICByZXR1cm4gYnVpbGRMYXllckdyYXBoKGcsIHJhbmssIGRpcmVjdGlvbik7XG4gICAgfSk7XG59O1xuY29uc3Qgc3dlZXBMYXllckdyYXBocyA9IChsYXllckdyYXBocywgYmlhc1JpZ2h0LCB1c2VQcmV2LCBrZWVwTm9kZU9yZGVyKSA9PiB7XG4gICAgY29uc3QgY2cgPSBuZXcgR3JhcGgoKTtcbiAgICBsYXllckdyYXBocyA9PT0gbnVsbCB8fCBsYXllckdyYXBocyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXJHcmFwaHMuZm9yRWFjaCgobGcpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBjb25zdCByb290ID0gbGcuZ3JhcGgoKS5yb290IGFzIHN0cmluZztcbiAgICAgICAgY29uc3Qgcm9vdCA9IGxnLmdldFJvb3RzKClbMF0uaWQ7XG4gICAgICAgIGNvbnN0IHNvcnRlZCA9IHNvcnRTdWJncmFwaChsZywgcm9vdCwgY2csIGJpYXNSaWdodCwgdXNlUHJldiwga2VlcE5vZGVPcmRlcik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgKChfYSA9IHNvcnRlZC52cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgfHwgMDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBsbm9kZSA9IGxnLmdldE5vZGUoc29ydGVkLnZzW2ldKTtcbiAgICAgICAgICAgIGlmIChsbm9kZSkge1xuICAgICAgICAgICAgICAgIGxub2RlLmRhdGEub3JkZXIgPSBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFkZFN1YmdyYXBoQ29uc3RyYWludHMobGcsIGNnLCBzb3J0ZWQudnMpO1xuICAgIH0pO1xufTtcbmNvbnN0IGFzc2lnbk9yZGVyID0gKGcsIGxheWVyaW5nKSA9PiB7XG4gICAgbGF5ZXJpbmcgPT09IG51bGwgfHwgbGF5ZXJpbmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheWVyaW5nLmZvckVhY2goKGxheWVyKSA9PiB7XG4gICAgICAgIGxheWVyID09PSBudWxsIHx8IGxheWVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXllci5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgICAgICAgICBnLmdldE5vZGUodikuZGF0YS5vcmRlciA9IGk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8qKlxuICog5oyJ54Wn5pWw5o2u5Lit55qE57uT5p6c6K6+572uZml4b3JkZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGluaXREYXRhT3JkZXIgPSAoZywgbm9kZU9yZGVyKSA9PiB7XG4gICAgY29uc3Qgc2ltcGxlTm9kZXMgPSBnLmdldEFsbE5vZGVzKCkuZmlsdGVyKCh2KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuICEoKF9hID0gZy5nZXRDaGlsZHJlbih2LmlkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCk7XG4gICAgfSk7XG4gICAgY29uc3QgcmFua3MgPSBzaW1wbGVOb2Rlcy5tYXAoKHYpID0+IHYuZGF0YS5yYW5rKTtcbiAgICBjb25zdCBtYXhSYW5rID0gTWF0aC5tYXgoLi4ucmFua3MpO1xuICAgIGNvbnN0IGxheWVycyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4UmFuayArIDE7IGkrKykge1xuICAgICAgICBsYXllcnNbaV0gPSBbXTtcbiAgICB9XG4gICAgbm9kZU9yZGVyID09PSBudWxsIHx8IG5vZGVPcmRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZU9yZGVyLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGcuZ2V0Tm9kZShuKTtcbiAgICAgICAgLy8g5Y+q6ICD6JmR5Y6f5pyJ6IqC54K577yMZHVtbXnoioLngrnpnIDopoHmjInnhaflkI7nu63nrpfms5XmjpLlh7pcbiAgICAgICAgaWYgKCFub2RlIHx8IG5vZGUuZGF0YS5kdW1teSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNOYU4obm9kZS5kYXRhLnJhbmspKSB7XG4gICAgICAgICAgICBub2RlLmRhdGEuZml4b3JkZXIgPSBsYXllcnNbbm9kZS5kYXRhLnJhbmtdLmxlbmd0aDsgLy8g6K6+572uZml4b3JkZXLkuLrlvZPlsYLnmoTpobrluo9cbiAgICAgICAgICAgIGxheWVyc1tub2RlLmRhdGEucmFua10ucHVzaChuKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaXQtZGF0YS1vcmRlci5qcy5tYXAiLCIvKlxuICogQXNzaWducyBhbiBpbml0aWFsIG9yZGVyIHZhbHVlIGZvciBlYWNoIG5vZGUgYnkgcGVyZm9ybWluZyBhIERGUyBzZWFyY2hcbiAqIHN0YXJ0aW5nIGZyb20gbm9kZXMgaW4gdGhlIGZpcnN0IHJhbmsuIE5vZGVzIGFyZSBhc3NpZ25lZCBhbiBvcmRlciBpbiB0aGVpclxuICogcmFuayBhcyB0aGV5IGFyZSBmaXJzdCB2aXNpdGVkLlxuICpcbiAqIFRoaXMgYXBwcm9hY2ggY29tZXMgZnJvbSBHYW5zbmVyLCBldCBhbC4sIFwiQSBUZWNobmlxdWUgZm9yIERyYXdpbmcgRGlyZWN0ZWRcbiAqIEdyYXBocy5cIlxuICpcbiAqIFJldHVybnMgYSBsYXllcmluZyBtYXRyaXggd2l0aCBhbiBhcnJheSBwZXIgbGF5ZXIgYW5kIGVhY2ggbGF5ZXIgc29ydGVkIGJ5XG4gKiB0aGUgb3JkZXIgb2YgaXRzIG5vZGVzLlxuICovXG5leHBvcnQgY29uc3QgaW5pdE9yZGVyID0gKGcpID0+IHtcbiAgICBjb25zdCB2aXNpdGVkID0ge307XG4gICAgLy8gY29uc3Qgc2ltcGxlTm9kZXMgPSBnLmdldEFsbE5vZGVzKCkuZmlsdGVyKCh2KSA9PiB7XG4gICAgLy8gICByZXR1cm4gIWcuZ2V0Q2hpbGRyZW4odi5pZCk/Lmxlbmd0aDtcbiAgICAvLyB9KTtcbiAgICBjb25zdCBzaW1wbGVOb2RlcyA9IGcuZ2V0QWxsTm9kZXMoKTtcbiAgICBjb25zdCBub2RlUmFua3MgPSBzaW1wbGVOb2Rlcy5tYXAoKHYpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdi5kYXRhLnJhbmspICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IC1JbmZpbml0eTsgfSk7XG4gICAgY29uc3QgbWF4UmFuayA9IE1hdGgubWF4KC4uLm5vZGVSYW5rcyk7XG4gICAgY29uc3QgbGF5ZXJzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXhSYW5rICsgMTsgaSsrKSB7XG4gICAgICAgIGxheWVycy5wdXNoKFtdKTtcbiAgICB9XG4gICAgY29uc3Qgb3JkZXJlZFZzID0gc2ltcGxlTm9kZXMuc29ydCgoYSwgYikgPT4gZy5nZXROb2RlKGEuaWQpLmRhdGEucmFuayAtIGcuZ2V0Tm9kZShiLmlkKS5kYXRhLnJhbmspO1xuICAgIC8vIGNvbnN0IG9yZGVyZWRWcyA9IF8uc29ydEJ5KHNpbXBsZU5vZGVzLCBmdW5jdGlvbih2KSB7IHJldHVybiBnLm5vZGUodikhLnJhbms7IH0pO1xuICAgIC8vIOaciWZpeE9yZGVy55qE77yM55u05o6l5o6S5bqP5aW95pS+6L+b5Y67XG4gICAgY29uc3QgYmVmb3JlU29ydCA9IG9yZGVyZWRWcy5maWx0ZXIoKG4pID0+IHtcbiAgICAgICAgcmV0dXJuIGcuZ2V0Tm9kZShuLmlkKS5kYXRhLmZpeG9yZGVyICE9PSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgY29uc3QgZml4T3JkZXJOb2RlcyA9IGJlZm9yZVNvcnQuc29ydCgoYSwgYikgPT4gZy5nZXROb2RlKGEuaWQpLmRhdGEuZml4b3JkZXIgLSBnLmdldE5vZGUoYi5pZCkuZGF0YS5maXhvcmRlcik7XG4gICAgZml4T3JkZXJOb2RlcyA9PT0gbnVsbCB8fCBmaXhPcmRlck5vZGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaXhPcmRlck5vZGVzLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgaWYgKCFpc05hTihnLmdldE5vZGUobi5pZCkuZGF0YS5yYW5rKSkge1xuICAgICAgICAgICAgbGF5ZXJzW2cuZ2V0Tm9kZShuLmlkKS5kYXRhLnJhbmtdLnB1c2gobi5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRlZFtuLmlkXSA9IHRydWU7XG4gICAgfSk7XG4gICAgb3JkZXJlZFZzID09PSBudWxsIHx8IG9yZGVyZWRWcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JkZXJlZFZzLmZvckVhY2goKG4pID0+IGcuZGZzVHJlZShuLmlkLCAobm9kZSkgPT4ge1xuICAgICAgICBpZiAodmlzaXRlZC5oYXNPd25Qcm9wZXJ0eShub2RlLmlkKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB2aXNpdGVkW25vZGUuaWRdID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFpc05hTihub2RlLmRhdGEucmFuaykpIHtcbiAgICAgICAgICAgIGxheWVyc1tub2RlLmRhdGEucmFua10ucHVzaChub2RlLmlkKTtcbiAgICAgICAgfVxuICAgIH0pKTtcbiAgICByZXR1cm4gbGF5ZXJzO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaXQtb3JkZXIuanMubWFwIiwiLypcbiAqIEdpdmVuIGEgbGlzdCBvZiBlbnRyaWVzIG9mIHRoZSBmb3JtIHt2LCBiYXJ5Y2VudGVyLCB3ZWlnaHR9IGFuZCBhXG4gKiBjb25zdHJhaW50IGdyYXBoIHRoaXMgZnVuY3Rpb24gd2lsbCByZXNvbHZlIGFueSBjb25mbGljdHMgYmV0d2VlbiB0aGVcbiAqIGNvbnN0cmFpbnQgZ3JhcGggYW5kIHRoZSBiYXJ5Y2VudGVycyBmb3IgdGhlIGVudHJpZXMuIElmIHRoZSBiYXJ5Y2VudGVycyBmb3JcbiAqIGFuIGVudHJ5IHdvdWxkIHZpb2xhdGUgYSBjb25zdHJhaW50IGluIHRoZSBjb25zdHJhaW50IGdyYXBoIHRoZW4gd2UgY29hbGVzY2VcbiAqIHRoZSBub2RlcyBpbiB0aGUgY29uZmxpY3QgaW50byBhIG5ldyBub2RlIHRoYXQgcmVzcGVjdHMgdGhlIGNvbnRyYWludCBhbmRcbiAqIGFnZ3JlZ2F0ZXMgYmFyeWNlbnRlciBhbmQgd2VpZ2h0IGluZm9ybWF0aW9uLlxuICpcbiAqIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgYmFzZWQgb24gdGhlIGRlc2NyaXB0aW9uIGluIEZvcnN0ZXIsIFwiQSBGYXN0IGFuZFxuICogU2ltcGxlIEh1ZXJpc3RpYyBmb3IgQ29uc3RyYWluZWQgVHdvLUxldmVsIENyb3NzaW5nIFJlZHVjdGlvbixcIiB0aG91Z2h0IGl0XG4gKiBkaWZmZXJzIGluIHNvbWUgc3BlY2lmaWMgZGV0YWlscy5cbiAqXG4gKiBQcmUtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBFYWNoIGVudHJ5IGhhcyB0aGUgZm9ybSB7diwgYmFyeWNlbnRlciwgd2VpZ2h0fSwgb3IgaWYgdGhlIG5vZGUgaGFzXG4gKiAgICAgICBubyBiYXJ5Y2VudGVyLCB0aGVuIHt2fS5cbiAqXG4gKiBSZXR1cm5zOlxuICpcbiAqICAgIEEgbmV3IGxpc3Qgb2YgZW50cmllcyBvZiB0aGUgZm9ybSB7dnMsIGksIGJhcnljZW50ZXIsIHdlaWdodH0uIFRoZSBsaXN0XG4gKiAgICBgdnNgIG1heSBlaXRoZXIgYmUgYSBzaW5nbGV0b24gb3IgaXQgbWF5IGJlIGFuIGFnZ3JlZ2F0aW9uIG9mIG5vZGVzXG4gKiAgICBvcmRlcmVkIHN1Y2ggdGhhdCB0aGV5IGRvIG5vdCB2aW9sYXRlIGNvbnN0cmFpbnRzIGZyb20gdGhlIGNvbnN0cmFpbnRcbiAqICAgIGdyYXBoLiBUaGUgcHJvcGVydHkgYGlgIGlzIHRoZSBsb3dlc3Qgb3JpZ2luYWwgaW5kZXggb2YgYW55IG9mIHRoZVxuICogICAgZWxlbWVudHMgaW4gYHZzYC5cbiAqL1xuY29uc3QgcmVzb2x2ZUNvbmZsaWN0cyA9IChlbnRyaWVzLCBjZykgPT4ge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIGNvbnN0IG1hcHBlZEVudHJpZXMgPSB7fTtcbiAgICBlbnRyaWVzID09PSBudWxsIHx8IGVudHJpZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVudHJpZXMuZm9yRWFjaCgoZW50cnksIGkpID0+IHtcbiAgICAgICAgbWFwcGVkRW50cmllc1tlbnRyeS52XSA9IHtcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBpbmRlZ3JlZTogMCxcbiAgICAgICAgICAgIGluOiBbXSxcbiAgICAgICAgICAgIG91dDogW10sXG4gICAgICAgICAgICB2czogW2VudHJ5LnZdLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0bXAgPSBtYXBwZWRFbnRyaWVzW2VudHJ5LnZdO1xuICAgICAgICBpZiAoZW50cnkuYmFyeWNlbnRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0bXAuYmFyeWNlbnRlciA9IGVudHJ5LmJhcnljZW50ZXI7XG4gICAgICAgICAgICB0bXAud2VpZ2h0ID0gZW50cnkud2VpZ2h0O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgKF9hID0gY2cuZ2V0QWxsRWRnZXMoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgY29uc3QgZW50cnlWID0gbWFwcGVkRW50cmllc1tlLnNvdXJjZV07XG4gICAgICAgIGNvbnN0IGVudHJ5VyA9IG1hcHBlZEVudHJpZXNbZS50YXJnZXRdO1xuICAgICAgICBpZiAoZW50cnlWICE9PSB1bmRlZmluZWQgJiYgZW50cnlXICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVudHJ5Vy5pbmRlZ3JlZSsrO1xuICAgICAgICAgICAgZW50cnlWLm91dC5wdXNoKG1hcHBlZEVudHJpZXNbZS50YXJnZXRdKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHNvdXJjZVNldCA9IChfYyA9IChfYiA9IE9iamVjdC52YWx1ZXMobWFwcGVkRW50cmllcykpLmZpbHRlcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IsIChlbnRyeSkgPT4gIWVudHJ5LmluZGVncmVlKTtcbiAgICByZXR1cm4gZG9SZXNvbHZlQ29uZmxpY3RzKHNvdXJjZVNldCk7XG59O1xuY29uc3QgZG9SZXNvbHZlQ29uZmxpY3RzID0gKHNvdXJjZVNldCkgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgZW50cmllcyA9IFtdO1xuICAgIGNvbnN0IGhhbmRsZUluID0gKHZFbnRyeSkgPT4ge1xuICAgICAgICByZXR1cm4gKHVFbnRyeSkgPT4ge1xuICAgICAgICAgICAgaWYgKHVFbnRyeS5tZXJnZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHVFbnRyeS5iYXJ5Y2VudGVyID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICB2RW50cnkuYmFyeWNlbnRlciA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgdUVudHJ5LmJhcnljZW50ZXIgPj0gdkVudHJ5LmJhcnljZW50ZXIpIHtcbiAgICAgICAgICAgICAgICBtZXJnZUVudHJpZXModkVudHJ5LCB1RW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlT3V0ID0gKHZFbnRyeSkgPT4ge1xuICAgICAgICByZXR1cm4gKHdFbnRyeSkgPT4ge1xuICAgICAgICAgICAgd0VudHJ5WydpbiddLnB1c2godkVudHJ5KTtcbiAgICAgICAgICAgIGlmICgtLXdFbnRyeS5pbmRlZ3JlZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHNvdXJjZVNldC5wdXNoKHdFbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICB3aGlsZSAoc291cmNlU2V0ID09PSBudWxsIHx8IHNvdXJjZVNldCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc291cmNlU2V0Lmxlbmd0aCkge1xuICAgICAgICBjb25zdCBlbnRyeSA9IHNvdXJjZVNldC5wb3AoKTtcbiAgICAgICAgZW50cmllcy5wdXNoKGVudHJ5KTtcbiAgICAgICAgKF9hID0gZW50cnlbJ2luJ10ucmV2ZXJzZSgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCgoZSkgPT4gaGFuZGxlSW4oZW50cnkpKGUpKTtcbiAgICAgICAgKF9iID0gZW50cnkub3V0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZm9yRWFjaCgoZSkgPT4gaGFuZGxlT3V0KGVudHJ5KShlKSk7XG4gICAgfVxuICAgIGNvbnN0IGZpbHRlcmVkID0gZW50cmllcy5maWx0ZXIoKGVudHJ5KSA9PiAhZW50cnkubWVyZ2VkKTtcbiAgICBjb25zdCBrZXlzID0gW1xuICAgICAgICAndnMnLFxuICAgICAgICAnaScsXG4gICAgICAgICdiYXJ5Y2VudGVyJyxcbiAgICAgICAgJ3dlaWdodCcsXG4gICAgXTtcbiAgICByZXR1cm4gZmlsdGVyZWQubWFwKChlbnRyeSkgPT4ge1xuICAgICAgICBjb25zdCBwaWNrZWQgPSB7fTtcbiAgICAgICAga2V5cyA9PT0gbnVsbCB8fCBrZXlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVudHJ5W2tleV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBwaWNrZWRba2V5XSA9IGVudHJ5W2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGlja2VkO1xuICAgIH0pO1xufTtcbmNvbnN0IG1lcmdlRW50cmllcyA9ICh0YXJnZXQsIHNvdXJjZSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBsZXQgd2VpZ2h0ID0gMDtcbiAgICBpZiAodGFyZ2V0LndlaWdodCkge1xuICAgICAgICBzdW0gKz0gdGFyZ2V0LmJhcnljZW50ZXIgKiB0YXJnZXQud2VpZ2h0O1xuICAgICAgICB3ZWlnaHQgKz0gdGFyZ2V0LndlaWdodDtcbiAgICB9XG4gICAgaWYgKHNvdXJjZS53ZWlnaHQpIHtcbiAgICAgICAgc3VtICs9IHNvdXJjZS5iYXJ5Y2VudGVyICogc291cmNlLndlaWdodDtcbiAgICAgICAgd2VpZ2h0ICs9IHNvdXJjZS53ZWlnaHQ7XG4gICAgfVxuICAgIHRhcmdldC52cyA9IChfYSA9IHNvdXJjZS52cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbmNhdCh0YXJnZXQudnMpO1xuICAgIHRhcmdldC5iYXJ5Y2VudGVyID0gc3VtIC8gd2VpZ2h0O1xuICAgIHRhcmdldC53ZWlnaHQgPSB3ZWlnaHQ7XG4gICAgdGFyZ2V0LmkgPSBNYXRoLm1pbihzb3VyY2UuaSwgdGFyZ2V0LmkpO1xuICAgIHNvdXJjZS5tZXJnZWQgPSB0cnVlO1xufTtcbmV4cG9ydCBkZWZhdWx0IHJlc29sdmVDb25mbGljdHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZXNvbHZlLWNvbmZsaWN0cy5qcy5tYXAiLCJpbXBvcnQgeyBiYXJ5Y2VudGVyIH0gZnJvbSAnLi9iYXJ5Y2VudGVyJztcbmltcG9ydCByZXNvbHZlQ29uZmxpY3RzIGZyb20gJy4vcmVzb2x2ZS1jb25mbGljdHMnO1xuaW1wb3J0IHsgc29ydCB9IGZyb20gJy4vc29ydCc7XG5leHBvcnQgY29uc3Qgc29ydFN1YmdyYXBoID0gKGcsIHYsIGNnLCBiaWFzUmlnaHQsIHVzZVByZXYsIGtlZXBOb2RlT3JkZXIpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgbGV0IG1vdmFibGUgPSBnLmdldENoaWxkcmVuKHYpLm1hcCgobikgPT4gbi5pZCk7XG4gICAgLy8gZml4b3JkZXLnmoTngrnkuI3lj4LkuI7mjpLluo/vvIjov5nkuKrmlrnmoYjkuI3lkIjpgILvvIzlj6rmjpLkuobmlrDlop7oioLngrnvvIzlkozljp/mnaXnmoTliIbnprvvvIlcbiAgICBjb25zdCBub2RlID0gZy5nZXROb2RlKHYpO1xuICAgIGNvbnN0IGJsID0gbm9kZSA/IG5vZGUuZGF0YS5ib3JkZXJMZWZ0IDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IGJyID0gbm9kZSA/IG5vZGUuZGF0YS5ib3JkZXJSaWdodCA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBzdWJncmFwaHMgPSB7fTtcbiAgICBpZiAoYmwpIHtcbiAgICAgICAgbW92YWJsZSA9IG1vdmFibGUgPT09IG51bGwgfHwgbW92YWJsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbW92YWJsZS5maWx0ZXIoKHcpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB3ICE9PSBibCAmJiB3ICE9PSBicjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGJhcnljZW50ZXJzID0gYmFyeWNlbnRlcihnLCBtb3ZhYmxlIHx8IFtdKTtcbiAgICBiYXJ5Y2VudGVycyA9PT0gbnVsbCB8fCBiYXJ5Y2VudGVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogYmFyeWNlbnRlcnMuZm9yRWFjaCgoZW50cnkpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKF9hID0gZy5nZXRDaGlsZHJlbihlbnRyeS52KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3Qgc3ViZ3JhcGhSZXN1bHQgPSBzb3J0U3ViZ3JhcGgoZywgZW50cnkudiwgY2csIGJpYXNSaWdodCwga2VlcE5vZGVPcmRlcik7XG4gICAgICAgICAgICBzdWJncmFwaHNbZW50cnkudl0gPSBzdWJncmFwaFJlc3VsdDtcbiAgICAgICAgICAgIGlmIChzdWJncmFwaFJlc3VsdC5oYXNPd25Qcm9wZXJ0eSgnYmFyeWNlbnRlcicpKSB7XG4gICAgICAgICAgICAgICAgbWVyZ2VCYXJ5Y2VudGVycyhlbnRyeSwgc3ViZ3JhcGhSZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgZW50cmllcyA9IHJlc29sdmVDb25mbGljdHMoYmFyeWNlbnRlcnMsIGNnKTtcbiAgICBleHBhbmRTdWJncmFwaHMoZW50cmllcywgc3ViZ3JhcGhzKTtcbiAgICAvLyDmt7vliqBmaXhvcmRlcuS/oeaBr+WIsGVudHJpZXPph4zovrlcbiAgICAvLyBUT0RPOiDkuI3ogIPomZHlpI3lkIjmg4XlhrXvvIzlj6rnlKjnrKzkuIDkuKrngrnnmoRmaXhvcmRlcuS/oeaBr++8jOWQjue7reiAg+iZkeabtOWujOWkh+eahOWunueOsFxuICAgIChfYSA9IGVudHJpZXNcbiAgICAgICAgLmZpbHRlcigoZSkgPT4gZS52cy5sZW5ndGggPiAwKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGcuZ2V0Tm9kZShlLnZzWzBdKTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgIGUuZml4b3JkZXIgPSBub2RlLmRhdGEuZml4b3JkZXI7XG4gICAgICAgICAgICBlLm9yZGVyID0gbm9kZS5kYXRhLm9yZGVyO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgcmVzdWx0ID0gc29ydChlbnRyaWVzLCBiaWFzUmlnaHQsIHVzZVByZXYsIGtlZXBOb2RlT3JkZXIpO1xuICAgIGlmIChibCkge1xuICAgICAgICByZXN1bHQudnMgPSBbYmwsIHJlc3VsdC52cywgYnJdLmZsYXQoKTtcbiAgICAgICAgaWYgKChfYiA9IGcuZ2V0UHJlZGVjZXNzb3JzKGJsKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgYmxQcmVkID0gZy5nZXROb2RlKCgoX2MgPSBnLmdldFByZWRlY2Vzc29ycyhibCkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY1swXS5pZCkgfHwgJycpO1xuICAgICAgICAgICAgY29uc3QgYnJQcmVkID0gZy5nZXROb2RlKCgoX2QgPSBnLmdldFByZWRlY2Vzc29ycyhicikpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZFswXS5pZCkgfHwgJycpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHQuaGFzT3duUHJvcGVydHkoJ2JhcnljZW50ZXInKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5iYXJ5Y2VudGVyID0gMDtcbiAgICAgICAgICAgICAgICByZXN1bHQud2VpZ2h0ID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5iYXJ5Y2VudGVyID1cbiAgICAgICAgICAgICAgICAocmVzdWx0LmJhcnljZW50ZXIgKiByZXN1bHQud2VpZ2h0ICtcbiAgICAgICAgICAgICAgICAgICAgYmxQcmVkLmRhdGEub3JkZXIgK1xuICAgICAgICAgICAgICAgICAgICBiclByZWQuZGF0YS5vcmRlcikgL1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LndlaWdodCArIDIpO1xuICAgICAgICAgICAgcmVzdWx0LndlaWdodCArPSAyO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuY29uc3QgZXhwYW5kU3ViZ3JhcGhzID0gKGVudHJpZXMsIHN1YmdyYXBocykgPT4ge1xuICAgIGVudHJpZXMgPT09IG51bGwgfHwgZW50cmllcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHZzcyA9IChfYSA9IGVudHJ5LnZzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKCh2KSA9PiB7XG4gICAgICAgICAgICBpZiAoc3ViZ3JhcGhzW3ZdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1YmdyYXBoc1t2XS52cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9KTtcbiAgICAgICAgZW50cnkudnMgPSB2c3MuZmxhdCgpO1xuICAgIH0pO1xufTtcbmNvbnN0IG1lcmdlQmFyeWNlbnRlcnMgPSAodGFyZ2V0LCBvdGhlcikgPT4ge1xuICAgIGlmICh0YXJnZXQuYmFyeWNlbnRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRhcmdldC5iYXJ5Y2VudGVyID1cbiAgICAgICAgICAgICh0YXJnZXQuYmFyeWNlbnRlciAqIHRhcmdldC53ZWlnaHQgKyBvdGhlci5iYXJ5Y2VudGVyICogb3RoZXIud2VpZ2h0KSAvXG4gICAgICAgICAgICAgICAgKHRhcmdldC53ZWlnaHQgKyBvdGhlci53ZWlnaHQpO1xuICAgICAgICB0YXJnZXQud2VpZ2h0ICs9IG90aGVyLndlaWdodDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRhcmdldC5iYXJ5Y2VudGVyID0gb3RoZXIuYmFyeWNlbnRlcjtcbiAgICAgICAgdGFyZ2V0LndlaWdodCA9IG90aGVyLndlaWdodDtcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29ydC1zdWJncmFwaC5qcy5tYXAiLCJpbXBvcnQgeyBwYXJ0aXRpb24gfSBmcm9tICcuLi91dGlsJztcbmV4cG9ydCBjb25zdCBzb3J0ID0gKGVudHJpZXMsIGJpYXNSaWdodCwgdXNlUHJldiwga2VlcE5vZGVPcmRlcikgPT4ge1xuICAgIGNvbnN0IHBhcnRzID0gcGFydGl0aW9uKGVudHJpZXMsIChlbnRyeSkgPT4ge1xuICAgICAgICBjb25zdCBoYXNGaXhPcmRlciA9IGVudHJ5Lmhhc093blByb3BlcnR5KCdmaXhvcmRlcicpICYmICFpc05hTihlbnRyeS5maXhvcmRlcik7XG4gICAgICAgIGlmIChrZWVwTm9kZU9yZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gIWhhc0ZpeE9yZGVyICYmIGVudHJ5Lmhhc093blByb3BlcnR5KCdiYXJ5Y2VudGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTk9URTog5pyJZml4b3JkZXLnmoTkuZ/lj6/ku6XmjpJcbiAgICAgICAgcmV0dXJuIGhhc0ZpeE9yZGVyIHx8IGVudHJ5Lmhhc093blByb3BlcnR5KCdiYXJ5Y2VudGVyJyk7XG4gICAgfSk7XG4gICAgY29uc3Qgc29ydGFibGUgPSBwYXJ0cy5saHM7XG4gICAgY29uc3QgdW5zb3J0YWJsZSA9IHBhcnRzLnJocy5zb3J0KChhLCBiKSA9PiAtYS5pIC0gLWIuaSk7XG4gICAgY29uc3QgdnMgPSBbXTtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBsZXQgd2VpZ2h0ID0gMDtcbiAgICBsZXQgdnNJbmRleCA9IDA7XG4gICAgc29ydGFibGUgPT09IG51bGwgfHwgc29ydGFibGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNvcnRhYmxlLnNvcnQoY29tcGFyZVdpdGhCaWFzKCEhYmlhc1JpZ2h0LCAhIXVzZVByZXYpKTtcbiAgICB2c0luZGV4ID0gY29uc3VtZVVuc29ydGFibGUodnMsIHVuc29ydGFibGUsIHZzSW5kZXgpO1xuICAgIHNvcnRhYmxlID09PSBudWxsIHx8IHNvcnRhYmxlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb3J0YWJsZS5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZzSW5kZXggKz0gKF9hID0gZW50cnkudnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGg7XG4gICAgICAgIHZzLnB1c2goZW50cnkudnMpO1xuICAgICAgICBzdW0gKz0gZW50cnkuYmFyeWNlbnRlciAqIGVudHJ5LndlaWdodDtcbiAgICAgICAgd2VpZ2h0ICs9IGVudHJ5LndlaWdodDtcbiAgICAgICAgdnNJbmRleCA9IGNvbnN1bWVVbnNvcnRhYmxlKHZzLCB1bnNvcnRhYmxlLCB2c0luZGV4KTtcbiAgICB9KTtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIHZzOiB2cy5mbGF0KCksXG4gICAgfTtcbiAgICBpZiAod2VpZ2h0KSB7XG4gICAgICAgIHJlc3VsdC5iYXJ5Y2VudGVyID0gc3VtIC8gd2VpZ2h0O1xuICAgICAgICByZXN1bHQud2VpZ2h0ID0gd2VpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmNvbnN0IGNvbnN1bWVVbnNvcnRhYmxlID0gKHZzLCB1bnNvcnRhYmxlLCBpbmRleCkgPT4ge1xuICAgIGxldCBpaW5kZXggPSBpbmRleDtcbiAgICBsZXQgbGFzdDtcbiAgICB3aGlsZSAodW5zb3J0YWJsZS5sZW5ndGggJiZcbiAgICAgICAgKGxhc3QgPSB1bnNvcnRhYmxlW3Vuc29ydGFibGUubGVuZ3RoIC0gMV0pLmkgPD0gaWluZGV4KSB7XG4gICAgICAgIHVuc29ydGFibGUucG9wKCk7XG4gICAgICAgIHZzID09PSBudWxsIHx8IHZzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2cy5wdXNoKGxhc3QudnMpO1xuICAgICAgICBpaW5kZXgrKztcbiAgICB9XG4gICAgcmV0dXJuIGlpbmRleDtcbn07XG4vKipcbiAqIOmFjee9ruaYr+WQpuiAg+iZkeS9v+eUqOS5i+WJjeeahOW4g+WxgOe7k+aenFxuICovXG5jb25zdCBjb21wYXJlV2l0aEJpYXMgPSAoYmlhcywgdXNlUHJldikgPT4ge1xuICAgIHJldHVybiAoZW50cnlWLCBlbnRyeVcpID0+IHtcbiAgICAgICAgLy8g5o6S5bqP55qE5pe25YCZ5YWI5Yik5patZml4b3JkZXLvvIzkuI3ooYzlho3liKTmlq3ph43lv4NcbiAgICAgICAgaWYgKGVudHJ5Vi5maXhvcmRlciAhPT0gdW5kZWZpbmVkICYmIGVudHJ5Vy5maXhvcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnlWLmZpeG9yZGVyIC0gZW50cnlXLmZpeG9yZGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbnRyeVYuYmFyeWNlbnRlciA8IGVudHJ5Vy5iYXJ5Y2VudGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudHJ5Vi5iYXJ5Y2VudGVyID4gZW50cnlXLmJhcnljZW50ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIOmHjeW/g+ebuOWQjO+8jOiAg+iZkeS5i+WJjeaOkuWlveeahOmhuuW6j1xuICAgICAgICBpZiAodXNlUHJldiAmJiBlbnRyeVYub3JkZXIgIT09IHVuZGVmaW5lZCAmJiBlbnRyeVcub3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGVudHJ5Vi5vcmRlciA8IGVudHJ5Vy5vcmRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbnRyeVYub3JkZXIgPiBlbnRyeVcub3JkZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIWJpYXMgPyBlbnRyeVYuaSAtIGVudHJ5Vy5pIDogZW50cnlXLmkgLSBlbnRyeVYuaTtcbiAgICB9O1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvcnQuanMubWFwIiwiLy8gZGVlcCBmaXJzdCBzZWFyY2ggd2l0aCBib3RoIG9yZGVyIGxvdyBmb3IgcHJlLCBsaW0gZm9yIHBvc3RcbmNvbnN0IGRmc0JvdGhPcmRlciA9IChnKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgbGV0IGxpbSA9IDA7XG4gICAgY29uc3QgZGZzID0gKHYpID0+IHtcbiAgICAgICAgY29uc3QgbG93ID0gbGltO1xuICAgICAgICBnLmdldENoaWxkcmVuKHYpLmZvckVhY2goKG4pID0+IGRmcyhuLmlkKSk7XG4gICAgICAgIHJlc3VsdFt2XSA9IHsgbG93LCBsaW06IGxpbSsrIH07XG4gICAgfTtcbiAgICBnLmdldFJvb3RzKCkuZm9yRWFjaCgobikgPT4gZGZzKG4uaWQpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbi8vIEZpbmQgYSBwYXRoIGZyb20gdiB0byB3IHRocm91Z2ggdGhlIGxvd2VzdCBjb21tb24gYW5jZXN0b3IgKExDQSkuIFJldHVybiB0aGVcbi8vIGZ1bGwgcGF0aCBhbmQgdGhlIExDQS5cbmNvbnN0IGZpbmRQYXRoID0gKGcsIHBvc3RvcmRlck51bXMsIHYsIHcpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHZQYXRoID0gW107XG4gICAgY29uc3Qgd1BhdGggPSBbXTtcbiAgICBjb25zdCBsb3cgPSBNYXRoLm1pbihwb3N0b3JkZXJOdW1zW3ZdLmxvdywgcG9zdG9yZGVyTnVtc1t3XS5sb3cpO1xuICAgIGNvbnN0IGxpbSA9IE1hdGgubWF4KHBvc3RvcmRlck51bXNbdl0ubGltLCBwb3N0b3JkZXJOdW1zW3ddLmxpbSk7XG4gICAgbGV0IHBhcmVudDtcbiAgICBsZXQgbGNhO1xuICAgIC8vIFRyYXZlcnNlIHVwIGZyb20gdiB0byBmaW5kIHRoZSBMQ0FcbiAgICBwYXJlbnQgPSB2O1xuICAgIGRvIHtcbiAgICAgICAgcGFyZW50ID0gKF9hID0gZy5nZXRQYXJlbnQocGFyZW50KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlkO1xuICAgICAgICB2UGF0aC5wdXNoKHBhcmVudCk7XG4gICAgfSB3aGlsZSAocGFyZW50ICYmXG4gICAgICAgIChwb3N0b3JkZXJOdW1zW3BhcmVudF0ubG93ID4gbG93IHx8IGxpbSA+IHBvc3RvcmRlck51bXNbcGFyZW50XS5saW0pKTtcbiAgICBsY2EgPSBwYXJlbnQ7XG4gICAgLy8gVHJhdmVyc2UgZnJvbSB3IHRvIExDQVxuICAgIHBhcmVudCA9IHc7XG4gICAgd2hpbGUgKHBhcmVudCAmJiBwYXJlbnQgIT09IGxjYSkge1xuICAgICAgICB3UGF0aC5wdXNoKHBhcmVudCk7XG4gICAgICAgIHBhcmVudCA9IChfYiA9IGcuZ2V0UGFyZW50KHBhcmVudCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pZDtcbiAgICB9XG4gICAgcmV0dXJuIHsgbGNhLCBwYXRoOiB2UGF0aC5jb25jYXQod1BhdGgucmV2ZXJzZSgpKSB9O1xufTtcbmV4cG9ydCBjb25zdCBwYXJlbnREdW1teUNoYWlucyA9IChnLCBkdW1teUNoYWlucykgPT4ge1xuICAgIGNvbnN0IHBvc3RvcmRlck51bXMgPSBkZnNCb3RoT3JkZXIoZyk7XG4gICAgZHVtbXlDaGFpbnMuZm9yRWFjaCgoc3RhcnRWKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGxldCB2ID0gc3RhcnRWO1xuICAgICAgICBsZXQgbm9kZSA9IGcuZ2V0Tm9kZSh2KTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxFZGdlID0gbm9kZS5kYXRhLm9yaWdpbmFsRWRnZTtcbiAgICAgICAgaWYgKCFvcmlnaW5hbEVkZ2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHBhdGhEYXRhID0gZmluZFBhdGgoZywgcG9zdG9yZGVyTnVtcywgb3JpZ2luYWxFZGdlLnNvdXJjZSwgb3JpZ2luYWxFZGdlLnRhcmdldCk7XG4gICAgICAgIGNvbnN0IHBhdGggPSBwYXRoRGF0YS5wYXRoO1xuICAgICAgICBjb25zdCBsY2EgPSBwYXRoRGF0YS5sY2E7XG4gICAgICAgIGxldCBwYXRoSWR4ID0gMDtcbiAgICAgICAgbGV0IHBhdGhWID0gcGF0aFtwYXRoSWR4XTtcbiAgICAgICAgbGV0IGFzY2VuZGluZyA9IHRydWU7XG4gICAgICAgIHdoaWxlICh2ICE9PSBvcmlnaW5hbEVkZ2UudGFyZ2V0KSB7XG4gICAgICAgICAgICBub2RlID0gZy5nZXROb2RlKHYpO1xuICAgICAgICAgICAgaWYgKGFzY2VuZGluZykge1xuICAgICAgICAgICAgICAgIHdoaWxlIChwYXRoViAhPT0gbGNhICYmXG4gICAgICAgICAgICAgICAgICAgICgoX2EgPSBnLmdldE5vZGUocGF0aFYpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGF0YS5tYXhSYW5rKSA8IG5vZGUuZGF0YS5yYW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhdGhJZHgrKztcbiAgICAgICAgICAgICAgICAgICAgcGF0aFYgPSBwYXRoW3BhdGhJZHhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocGF0aFYgPT09IGxjYSkge1xuICAgICAgICAgICAgICAgICAgICBhc2NlbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFzY2VuZGluZykge1xuICAgICAgICAgICAgICAgIHdoaWxlIChwYXRoSWR4IDwgcGF0aC5sZW5ndGggLSAxICYmXG4gICAgICAgICAgICAgICAgICAgICgoX2IgPSBnLmdldE5vZGUocGF0aFtwYXRoSWR4ICsgMV0pKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGF0YS5taW5SYW5rKSA8PSBub2RlLmRhdGEucmFuaykge1xuICAgICAgICAgICAgICAgICAgICBwYXRoSWR4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhdGhWID0gcGF0aFtwYXRoSWR4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnLmhhc05vZGUocGF0aFYpKSB7XG4gICAgICAgICAgICAgICAgZy5zZXRQYXJlbnQodiwgcGF0aFYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdiA9IGcuZ2V0U3VjY2Vzc29ycyh2KVswXS5pZDtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcmVudC1kdW1teS1jaGFpbnMuanMubWFwIiwiLypcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIGNvb3JkaW5hdGUgYXNzaWdubWVudCBiYXNlZCBvbiBCcmFuZGVzIGFuZCBLw7ZwZiwgXCJGYXN0XG4gKiBhbmQgU2ltcGxlIEhvcml6b250YWwgQ29vcmRpbmF0ZSBBc3NpZ25tZW50LlwiXG4gKi9cbmltcG9ydCB7IEdyYXBoIH0gZnJvbSAnQGFudHYvZ3JhcGhsaWInO1xuaW1wb3J0IHsgYnVpbGRMYXllck1hdHJpeCwgbWluQnkgfSBmcm9tICcuLi91dGlsJztcbmV4cG9ydCBjb25zdCBmaW5kVHlwZTFDb25mbGljdHMgPSAoZywgbGF5ZXJpbmcpID0+IHtcbiAgICBjb25zdCBjb25mbGljdHMgPSB7fTtcbiAgICBjb25zdCB2aXNpdExheWVyID0gKHByZXZMYXllciwgbGF5ZXIpID0+IHtcbiAgICAgICAgLy8gbGFzdCB2aXNpdGVkIG5vZGUgaW4gdGhlIHByZXZpb3VzIGxheWVyIHRoYXQgaXMgaW5jaWRlbnQgb24gYW4gaW5uZXJcbiAgICAgICAgLy8gc2VnbWVudC5cbiAgICAgICAgbGV0IGswID0gMDtcbiAgICAgICAgLy8gVHJhY2tzIHRoZSBsYXN0IG5vZGUgaW4gdGhpcyBsYXllciBzY2FubmVkIGZvciBjcm9zc2luZ3Mgd2l0aCBhIHR5cGUtMVxuICAgICAgICAvLyBzZWdtZW50LlxuICAgICAgICBsZXQgc2NhblBvcyA9IDA7XG4gICAgICAgIGNvbnN0IHByZXZMYXllckxlbmd0aCA9IHByZXZMYXllci5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGxhc3ROb2RlID0gbGF5ZXIgPT09IG51bGwgfHwgbGF5ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheWVyWyhsYXllciA9PT0gbnVsbCB8fCBsYXllciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXIubGVuZ3RoKSAtIDFdO1xuICAgICAgICBsYXllciA9PT0gbnVsbCB8fCBsYXllciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXIuZm9yRWFjaCgodiwgaSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgdyA9IGZpbmRPdGhlcklubmVyU2VnbWVudE5vZGUoZywgdik7XG4gICAgICAgICAgICBjb25zdCBrMSA9IHcgPyBnLmdldE5vZGUody5pZCkuZGF0YS5vcmRlciA6IHByZXZMYXllckxlbmd0aDtcbiAgICAgICAgICAgIGlmICh3IHx8IHYgPT09IGxhc3ROb2RlKSB7XG4gICAgICAgICAgICAgICAgKF9hID0gbGF5ZXIuc2xpY2Uoc2NhblBvcywgaSArIDEpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCgoc2Nhbk5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBnLmdldFByZWRlY2Vzc29ycyhzY2FuTm9kZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKCh1KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1TGFiZWwgPSBnLmdldE5vZGUodS5pZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1UG9zID0gdUxhYmVsLmRhdGEub3JkZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHVQb3MgPCBrMCB8fCBrMSA8IHVQb3MpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgISh1TGFiZWwuZGF0YS5kdW1teSAmJiAoKF9hID0gZy5nZXROb2RlKHNjYW5Ob2RlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhdGEuZHVtbXkpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZENvbmZsaWN0KGNvbmZsaWN0cywgdS5pZCwgc2Nhbk5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzY2FuUG9zID0gaSArIDE7XG4gICAgICAgICAgICAgICAgazAgPSBrMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICB9O1xuICAgIGlmIChsYXllcmluZyA9PT0gbnVsbCB8fCBsYXllcmluZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXJpbmcubGVuZ3RoKSB7XG4gICAgICAgIGxheWVyaW5nLnJlZHVjZSh2aXNpdExheWVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbmZsaWN0cztcbn07XG5leHBvcnQgY29uc3QgZmluZFR5cGUyQ29uZmxpY3RzID0gKGcsIGxheWVyaW5nKSA9PiB7XG4gICAgY29uc3QgY29uZmxpY3RzID0ge307XG4gICAgZnVuY3Rpb24gc2Nhbihzb3V0aCwgc291dGhQb3MsIHNvdXRoRW5kLCBwcmV2Tm9ydGhCb3JkZXIsIG5leHROb3J0aEJvcmRlcikge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBsZXQgdjtcbiAgICAgICAgZm9yIChsZXQgaSA9IHNvdXRoUG9zOyBpIDwgc291dGhFbmQ7IGkrKykge1xuICAgICAgICAgICAgdiA9IHNvdXRoW2ldO1xuICAgICAgICAgICAgaWYgKChfYSA9IGcuZ2V0Tm9kZSh2KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhdGEuZHVtbXkpIHtcbiAgICAgICAgICAgICAgICAoX2IgPSBnLmdldFByZWRlY2Vzc29ycyh2KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZvckVhY2goKHUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdU5vZGUgPSBnLmdldE5vZGUodS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1Tm9kZS5kYXRhLmR1bW15ICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAodU5vZGUuZGF0YS5vcmRlciA8IHByZXZOb3J0aEJvcmRlciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVOb2RlLmRhdGEub3JkZXIgPiBuZXh0Tm9ydGhCb3JkZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRDb25mbGljdChjb25mbGljdHMsIHUuaWQsIHYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U2Nhbm5lZEtleShwYXJhbXMpIHtcbiAgICAgICAgLy8gc291dGjmlbDnu4Tlj6/og73lvojlpKfvvIzkuI3pgILlkIjlgZprZXlcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHBhcmFtcy5zbGljZSgxKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNjYW5JZk5lZWRlZChwYXJhbXMsIHNjYW5DYWNoZSkge1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IGdldFNjYW5uZWRLZXkocGFyYW1zKTtcbiAgICAgICAgaWYgKHNjYW5DYWNoZS5nZXQoY2FjaGVLZXkpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzY2FuKC4uLnBhcmFtcyk7XG4gICAgICAgIHNjYW5DYWNoZS5zZXQoY2FjaGVLZXksIHRydWUpO1xuICAgIH1cbiAgICBjb25zdCB2aXNpdExheWVyID0gKG5vcnRoLCBzb3V0aCkgPT4ge1xuICAgICAgICBsZXQgcHJldk5vcnRoUG9zID0gLTE7XG4gICAgICAgIGxldCBuZXh0Tm9ydGhQb3M7XG4gICAgICAgIGxldCBzb3V0aFBvcyA9IDA7XG4gICAgICAgIGNvbnN0IHNjYW5uZWQgPSBuZXcgTWFwKCk7XG4gICAgICAgIHNvdXRoID09PSBudWxsIHx8IHNvdXRoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb3V0aC5mb3JFYWNoKCh2LCBzb3V0aExvb2thaGVhZCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKCgoX2EgPSBnLmdldE5vZGUodikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhLmR1bW15KSA9PT0gJ2JvcmRlcicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVkZWNlc3NvcnMgPSBnLmdldFByZWRlY2Vzc29ycyh2KSB8fCBbXTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZGVjZXNzb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0Tm9ydGhQb3MgPSBnLmdldE5vZGUocHJlZGVjZXNzb3JzWzBdLmlkKS5kYXRhLm9yZGVyO1xuICAgICAgICAgICAgICAgICAgICBzY2FuSWZOZWVkZWQoW3NvdXRoLCBzb3V0aFBvcywgc291dGhMb29rYWhlYWQsIHByZXZOb3J0aFBvcywgbmV4dE5vcnRoUG9zXSwgc2Nhbm5lZCk7XG4gICAgICAgICAgICAgICAgICAgIHNvdXRoUG9zID0gc291dGhMb29rYWhlYWQ7XG4gICAgICAgICAgICAgICAgICAgIHByZXZOb3J0aFBvcyA9IG5leHROb3J0aFBvcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzY2FuSWZOZWVkZWQoW3NvdXRoLCBzb3V0aFBvcywgc291dGgubGVuZ3RoLCBuZXh0Tm9ydGhQb3MsIG5vcnRoLmxlbmd0aF0sIHNjYW5uZWQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNvdXRoO1xuICAgIH07XG4gICAgaWYgKGxheWVyaW5nID09PSBudWxsIHx8IGxheWVyaW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXllcmluZy5sZW5ndGgpIHtcbiAgICAgICAgbGF5ZXJpbmcucmVkdWNlKHZpc2l0TGF5ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmxpY3RzO1xufTtcbmV4cG9ydCBjb25zdCBmaW5kT3RoZXJJbm5lclNlZ21lbnROb2RlID0gKGcsIHYpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICgoX2EgPSBnLmdldE5vZGUodikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kYXRhLmR1bW15KSB7XG4gICAgICAgIHJldHVybiAoX2IgPSBnLmdldFByZWRlY2Vzc29ycyh2KSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmZpbmQoKHUpID0+IGcuZ2V0Tm9kZSh1LmlkKS5kYXRhLmR1bW15KTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGFkZENvbmZsaWN0ID0gKGNvbmZsaWN0cywgdiwgdykgPT4ge1xuICAgIGxldCB2diA9IHY7XG4gICAgbGV0IHd3ID0gdztcbiAgICBpZiAodnYgPiB3dykge1xuICAgICAgICBjb25zdCB0bXAgPSB2djtcbiAgICAgICAgdnYgPSB3dztcbiAgICAgICAgd3cgPSB0bXA7XG4gICAgfVxuICAgIGxldCBjb25mbGljdHNWID0gY29uZmxpY3RzW3Z2XTtcbiAgICBpZiAoIWNvbmZsaWN0c1YpIHtcbiAgICAgICAgY29uZmxpY3RzW3Z2XSA9IGNvbmZsaWN0c1YgPSB7fTtcbiAgICB9XG4gICAgY29uZmxpY3RzVlt3d10gPSB0cnVlO1xufTtcbmV4cG9ydCBjb25zdCBoYXNDb25mbGljdCA9IChjb25mbGljdHMsIHYsIHcpID0+IHtcbiAgICBsZXQgdnYgPSB2O1xuICAgIGxldCB3dyA9IHc7XG4gICAgaWYgKHZ2ID4gd3cpIHtcbiAgICAgICAgY29uc3QgdG1wID0gdjtcbiAgICAgICAgdnYgPSB3dztcbiAgICAgICAgd3cgPSB0bXA7XG4gICAgfVxuICAgIHJldHVybiAhIWNvbmZsaWN0c1t2dl07XG59O1xuLypcbiAqIFRyeSB0byBhbGlnbiBub2RlcyBpbnRvIHZlcnRpY2FsIFwiYmxvY2tzXCIgd2hlcmUgcG9zc2libGUuIFRoaXMgYWxnb3JpdGhtXG4gKiBhdHRlbXB0cyB0byBhbGlnbiBhIG5vZGUgd2l0aCBvbmUgb2YgaXRzIG1lZGlhbiBuZWlnaGJvcnMuIElmIHRoZSBlZGdlXG4gKiBjb25uZWN0aW5nIGEgbmVpZ2hib3IgaXMgYSB0eXBlLTEgY29uZmxpY3QgdGhlbiB3ZSBpZ25vcmUgdGhhdCBwb3NzaWJpbGl0eS5cbiAqIElmIGEgcHJldmlvdXMgbm9kZSBoYXMgYWxyZWFkeSBmb3JtZWQgYSBibG9jayB3aXRoIGEgbm9kZSBhZnRlciB0aGUgbm9kZVxuICogd2UncmUgdHJ5aW5nIHRvIGZvcm0gYSBibG9jayB3aXRoLCB3ZSBhbHNvIGlnbm9yZSB0aGF0IHBvc3NpYmlsaXR5IC0gb3VyXG4gKiBibG9ja3Mgd291bGQgYmUgc3BsaXQgaW4gdGhhdCBzY2VuYXJpby5cbiAqL1xuZXhwb3J0IGNvbnN0IHZlcnRpY2FsQWxpZ25tZW50ID0gKGcsIGxheWVyaW5nLCBjb25mbGljdHMsIG5laWdoYm9yRm4pID0+IHtcbiAgICBjb25zdCByb290ID0ge307XG4gICAgY29uc3QgYWxpZ24gPSB7fTtcbiAgICBjb25zdCBwb3MgPSB7fTtcbiAgICAvLyBXZSBjYWNoZSB0aGUgcG9zaXRpb24gaGVyZSBiYXNlZCBvbiB0aGUgbGF5ZXJpbmcgYmVjYXVzZSB0aGUgZ3JhcGggYW5kXG4gICAgLy8gbGF5ZXJpbmcgbWF5IGJlIG91dCBvZiBzeW5jLiBUaGUgbGF5ZXJpbmcgbWF0cml4IGlzIG1hbmlwdWxhdGVkIHRvXG4gICAgLy8gZ2VuZXJhdGUgZGlmZmVyZW50IGV4dHJlbWUgYWxpZ25tZW50cy5cbiAgICBsYXllcmluZyA9PT0gbnVsbCB8fCBsYXllcmluZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXJpbmcuZm9yRWFjaCgobGF5ZXIpID0+IHtcbiAgICAgICAgbGF5ZXIgPT09IG51bGwgfHwgbGF5ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheWVyLmZvckVhY2goKHYsIG9yZGVyKSA9PiB7XG4gICAgICAgICAgICByb290W3ZdID0gdjtcbiAgICAgICAgICAgIGFsaWduW3ZdID0gdjtcbiAgICAgICAgICAgIHBvc1t2XSA9IG9yZGVyO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBsYXllcmluZyA9PT0gbnVsbCB8fCBsYXllcmluZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXJpbmcuZm9yRWFjaCgobGF5ZXIpID0+IHtcbiAgICAgICAgbGV0IHByZXZJZHggPSAtMTtcbiAgICAgICAgbGF5ZXIgPT09IG51bGwgfHwgbGF5ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheWVyLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgICAgIGxldCB3cyA9IG5laWdoYm9yRm4odikubWFwKChuKSA9PiBuLmlkKTtcbiAgICAgICAgICAgIGlmICh3cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB3cyA9IHdzLnNvcnQoKGEsIGIpID0+IHBvc1thXSAtIHBvc1tiXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbXAgPSAod3MubGVuZ3RoIC0gMSkgLyAyO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBNYXRoLmZsb29yKG1wKSwgaWwgPSBNYXRoLmNlaWwobXApOyBpIDw9IGlsOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdyA9IHdzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWxpZ25bdl0gPT09IHYgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZJZHggPCBwb3Nbd10gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFoYXNDb25mbGljdChjb25mbGljdHMsIHYsIHcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnblt3XSA9IHY7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGlnblt2XSA9IHJvb3Rbdl0gPSByb290W3ddO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldklkeCA9IHBvc1t3XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgcm9vdCwgYWxpZ24gfTtcbn07XG5leHBvcnQgY29uc3QgaG9yaXpvbnRhbENvbXBhY3Rpb24gPSAoZywgbGF5ZXJpbmcsIHJvb3QsIGFsaWduLCBub2Rlc2VwLCBlZGdlc2VwLCByZXZlcnNlU2VwKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIC8vIFRoaXMgcG9ydGlvbiBvZiB0aGUgYWxnb3JpdGhtIGRpZmZlcnMgZnJvbSBCSyBkdWUgdG8gYSBudW1iZXIgb2YgcHJvYmxlbXMuXG4gICAgLy8gSW5zdGVhZCBvZiB0aGVpciBhbGdvcml0aG0gd2UgY29uc3RydWN0IGEgbmV3IGJsb2NrIGdyYXBoIGFuZCBkbyB0d29cbiAgICAvLyBzd2VlcHMuIFRoZSBmaXJzdCBzd2VlcCBwbGFjZXMgYmxvY2tzIHdpdGggdGhlIHNtYWxsZXN0IHBvc3NpYmxlXG4gICAgLy8gY29vcmRpbmF0ZXMuIFRoZSBzZWNvbmQgc3dlZXAgcmVtb3ZlcyB1bnVzZWQgc3BhY2UgYnkgbW92aW5nIGJsb2NrcyB0byB0aGVcbiAgICAvLyBncmVhdGVzdCBjb29yZGluYXRlcyB3aXRob3V0IHZpb2xhdGluZyBzZXBhcmF0aW9uLlxuICAgIGNvbnN0IHhzID0ge307XG4gICAgY29uc3QgYmxvY2tHID0gYnVpbGRCbG9ja0dyYXBoKGcsIGxheWVyaW5nLCByb290LCBub2Rlc2VwLCBlZGdlc2VwLCByZXZlcnNlU2VwKTtcbiAgICBjb25zdCBib3JkZXJUeXBlID0gcmV2ZXJzZVNlcCA/ICdib3JkZXJMZWZ0JyA6ICdib3JkZXJSaWdodCc7XG4gICAgY29uc3QgaXRlcmF0ZSA9IChzZXRYc0Z1bmMsIG5leHROb2Rlc0Z1bmMpID0+IHtcbiAgICAgICAgbGV0IHN0YWNrID0gYmxvY2tHLmdldEFsbE5vZGVzKCk7XG4gICAgICAgIGxldCBlbGVtID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGNvbnN0IHZpc2l0ZWQgPSB7fTtcbiAgICAgICAgd2hpbGUgKGVsZW0pIHtcbiAgICAgICAgICAgIGlmICh2aXNpdGVkW2VsZW0uaWRdKSB7XG4gICAgICAgICAgICAgICAgc2V0WHNGdW5jKGVsZW0uaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmlzaXRlZFtlbGVtLmlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaChlbGVtKTtcbiAgICAgICAgICAgICAgICBzdGFjayA9IHN0YWNrLmNvbmNhdChuZXh0Tm9kZXNGdW5jKGVsZW0uaWQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsZW0gPSBzdGFjay5wb3AoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gRmlyc3QgcGFzcywgYXNzaWduIHNtYWxsZXN0IGNvb3JkaW5hdGVzXG4gICAgY29uc3QgcGFzczEgPSAoZWxlbSkgPT4ge1xuICAgICAgICB4c1tlbGVtXSA9IChibG9ja0cuZ2V0UmVsYXRlZEVkZ2VzKGVsZW0sICdpbicpIHx8IFtdKS5yZWR1Y2UoKGFjYywgZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KGFjYywgKHhzW2Uuc291cmNlXSB8fCAwKSArIGUuZGF0YS53ZWlnaHQpO1xuICAgICAgICB9LCAwKTtcbiAgICB9O1xuICAgIC8vIFNlY29uZCBwYXNzLCBhc3NpZ24gZ3JlYXRlc3QgY29vcmRpbmF0ZXNcbiAgICBjb25zdCBwYXNzMiA9IChlbGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IG1pbiA9IChibG9ja0cuZ2V0UmVsYXRlZEVkZ2VzKGVsZW0sICdvdXQnKSB8fCBbXSkucmVkdWNlKChhY2MsIGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLm1pbihhY2MsICh4c1tlLnRhcmdldF0gfHwgMCkgLSBlLmRhdGEud2VpZ2h0KTtcbiAgICAgICAgfSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGcuZ2V0Tm9kZShlbGVtKTtcbiAgICAgICAgaWYgKG1pbiAhPT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZICYmXG4gICAgICAgICAgICBub2RlLmRhdGEuYm9yZGVyVHlwZSAhPT0gYm9yZGVyVHlwZSkge1xuICAgICAgICAgICAgeHNbZWxlbV0gPSBNYXRoLm1heCh4c1tlbGVtXSwgbWluKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgaXRlcmF0ZShwYXNzMSwgYmxvY2tHLmdldFByZWRlY2Vzc29ycy5iaW5kKGJsb2NrRykpO1xuICAgIGl0ZXJhdGUocGFzczIsIGJsb2NrRy5nZXRTdWNjZXNzb3JzLmJpbmQoYmxvY2tHKSk7XG4gICAgLy8gQXNzaWduIHggY29vcmRpbmF0ZXMgdG8gYWxsIG5vZGVzXG4gICAgKF9hID0gT2JqZWN0LnZhbHVlcyhhbGlnbikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKCh2KSA9PiB7XG4gICAgICAgIHhzW3ZdID0geHNbcm9vdFt2XV07XG4gICAgfSk7XG4gICAgcmV0dXJuIHhzO1xufTtcbmV4cG9ydCBjb25zdCBidWlsZEJsb2NrR3JhcGggPSAoZywgbGF5ZXJpbmcsIHJvb3QsIG5vZGVzZXAsIGVkZ2VzZXAsIHJldmVyc2VTZXApID0+IHtcbiAgICBjb25zdCBibG9ja0dyYXBoID0gbmV3IEdyYXBoKCk7XG4gICAgY29uc3Qgc2VwRm4gPSBzZXAobm9kZXNlcCwgZWRnZXNlcCwgcmV2ZXJzZVNlcCk7XG4gICAgbGF5ZXJpbmcgPT09IG51bGwgfHwgbGF5ZXJpbmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheWVyaW5nLmZvckVhY2goKGxheWVyKSA9PiB7XG4gICAgICAgIGxldCB1O1xuICAgICAgICBsYXllciA9PT0gbnVsbCB8fCBsYXllciA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGF5ZXIuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICAgICAgY29uc3QgdlJvb3QgPSByb290W3ZdO1xuICAgICAgICAgICAgaWYgKCFibG9ja0dyYXBoLmhhc05vZGUodlJvb3QpKSB7XG4gICAgICAgICAgICAgICAgYmxvY2tHcmFwaC5hZGROb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHZSb290LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdVJvb3QgPSByb290W3VdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVkZ2UgPSBibG9ja0dyYXBoXG4gICAgICAgICAgICAgICAgICAgIC5nZXRSZWxhdGVkRWRnZXModVJvb3QsICdvdXQnKVxuICAgICAgICAgICAgICAgICAgICAuZmluZCgoZWRnZSkgPT4gZWRnZS50YXJnZXQgPT09IHZSb290KTtcbiAgICAgICAgICAgICAgICBpZiAoIWVkZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tHcmFwaC5hZGRFZGdlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBgZSR7TWF0aC5yYW5kb20oKX1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiB1Um9vdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogdlJvb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0OiBNYXRoLm1heChzZXBGbihnLCB2LCB1KSwgMCksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrR3JhcGgudXBkYXRlRWRnZURhdGEoZWRnZS5pZCwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlZGdlLmRhdGEpLCB7IHdlaWdodDogTWF0aC5tYXgoc2VwRm4oZywgdiwgdSksIGVkZ2UuZGF0YS53ZWlnaHQgfHwgMCkgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHUgPSB2O1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gYmxvY2tHcmFwaDtcbn07XG4vKlxuICogUmV0dXJucyB0aGUgYWxpZ25tZW50IHRoYXQgaGFzIHRoZSBzbWFsbGVzdCB3aWR0aCBvZiB0aGUgZ2l2ZW4gYWxpZ25tZW50cy5cbiAqL1xuZXhwb3J0IGNvbnN0IGZpbmRTbWFsbGVzdFdpZHRoQWxpZ25tZW50ID0gKGcsIHhzcykgPT4ge1xuICAgIHJldHVybiBtaW5CeShPYmplY3QudmFsdWVzKHhzcyksICh4cykgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCBtYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIGxldCBtaW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIChfYSA9IE9iamVjdC5rZXlzKHhzKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHggPSB4c1t2XTtcbiAgICAgICAgICAgIGNvbnN0IGhhbGZXaWR0aCA9IHdpZHRoKGcsIHYpIC8gMjtcbiAgICAgICAgICAgIG1heCA9IE1hdGgubWF4KHggKyBoYWxmV2lkdGgsIG1heCk7XG4gICAgICAgICAgICBtaW4gPSBNYXRoLm1pbih4IC0gaGFsZldpZHRoLCBtaW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1heCAtIG1pbjtcbiAgICB9KTtcbn07XG4vKlxuICogQWxpZ24gdGhlIGNvb3JkaW5hdGVzIG9mIGVhY2ggb2YgdGhlIGxheW91dCBhbGlnbm1lbnRzIHN1Y2ggdGhhdFxuICogbGVmdC1iaWFzZWQgYWxpZ25tZW50cyBoYXZlIHRoZWlyIG1pbmltdW0gY29vcmRpbmF0ZSBhdCB0aGUgc2FtZSBwb2ludCBhc1xuICogdGhlIG1pbmltdW0gY29vcmRpbmF0ZSBvZiB0aGUgc21hbGxlc3Qgd2lkdGggYWxpZ25tZW50IGFuZCByaWdodC1iaWFzZWRcbiAqIGFsaWdubWVudHMgaGF2ZSB0aGVpciBtYXhpbXVtIGNvb3JkaW5hdGUgYXQgdGhlIHNhbWUgcG9pbnQgYXMgdGhlIG1heGltdW1cbiAqIGNvb3JkaW5hdGUgb2YgdGhlIHNtYWxsZXN0IHdpZHRoIGFsaWdubWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFsaWduQ29vcmRpbmF0ZXMoeHNzLCBhbGlnblRvKSB7XG4gICAgY29uc3QgYWxpZ25Ub1ZhbHMgPSBPYmplY3QudmFsdWVzKGFsaWduVG8pO1xuICAgIGNvbnN0IGFsaWduVG9NaW4gPSBNYXRoLm1pbiguLi5hbGlnblRvVmFscyk7XG4gICAgY29uc3QgYWxpZ25Ub01heCA9IE1hdGgubWF4KC4uLmFsaWduVG9WYWxzKTtcbiAgICBbJ3UnLCAnZCddLmZvckVhY2goKHZlcnQpID0+IHtcbiAgICAgICAgWydsJywgJ3InXS5mb3JFYWNoKChob3JpeikgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWxpZ25tZW50ID0gdmVydCArIGhvcml6O1xuICAgICAgICAgICAgY29uc3QgeHMgPSB4c3NbYWxpZ25tZW50XTtcbiAgICAgICAgICAgIGxldCBkZWx0YTtcbiAgICAgICAgICAgIGlmICh4cyA9PT0gYWxpZ25UbylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCB4c1ZhbHMgPSBPYmplY3QudmFsdWVzKHhzKTtcbiAgICAgICAgICAgIGRlbHRhID1cbiAgICAgICAgICAgICAgICBob3JpeiA9PT0gJ2wnXG4gICAgICAgICAgICAgICAgICAgID8gYWxpZ25Ub01pbiAtIE1hdGgubWluKC4uLnhzVmFscylcbiAgICAgICAgICAgICAgICAgICAgOiBhbGlnblRvTWF4IC0gTWF0aC5tYXgoLi4ueHNWYWxzKTtcbiAgICAgICAgICAgIGlmIChkZWx0YSkge1xuICAgICAgICAgICAgICAgIHhzc1thbGlnbm1lbnRdID0ge307XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoeHMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB4c3NbYWxpZ25tZW50XVtrZXldID0geHNba2V5XSArIGRlbHRhO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBiYWxhbmNlID0gKHhzcywgYWxpZ24pID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyh4c3MudWwpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAoYWxpZ24pIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0geHNzW2FsaWduLnRvTG93ZXJDYXNlKCldW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKHhzcykubWFwKCh4KSA9PiB4W2tleV0pO1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSAodmFsdWVzWzBdICsgdmFsdWVzWzFdKSAvIDI7IC8vICh1ciArIHVsKSAvIDJcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuZXhwb3J0IGNvbnN0IHBvc2l0aW9uWCA9IChnLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgeyBhbGlnbjogZ3JhcGhBbGlnbiwgbm9kZXNlcCA9IDAsIGVkZ2VzZXAgPSAwIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGxheWVyaW5nID0gYnVpbGRMYXllck1hdHJpeChnKTtcbiAgICBjb25zdCBjb25mbGljdHMgPSBPYmplY3QuYXNzaWduKGZpbmRUeXBlMUNvbmZsaWN0cyhnLCBsYXllcmluZyksIGZpbmRUeXBlMkNvbmZsaWN0cyhnLCBsYXllcmluZykpO1xuICAgIGNvbnN0IHhzcyA9IHt9O1xuICAgIGxldCBhZGp1c3RlZExheWVyaW5nO1xuICAgIFsndScsICdkJ10uZm9yRWFjaCgodmVydCkgPT4ge1xuICAgICAgICBhZGp1c3RlZExheWVyaW5nID1cbiAgICAgICAgICAgIHZlcnQgPT09ICd1JyA/IGxheWVyaW5nIDogT2JqZWN0LnZhbHVlcyhsYXllcmluZykucmV2ZXJzZSgpO1xuICAgICAgICBbJ2wnLCAnciddLmZvckVhY2goKGhvcml6KSA9PiB7XG4gICAgICAgICAgICBpZiAoaG9yaXogPT09ICdyJykge1xuICAgICAgICAgICAgICAgIGFkanVzdGVkTGF5ZXJpbmcgPSBhZGp1c3RlZExheWVyaW5nLm1hcCgoaW5uZXIpID0+IE9iamVjdC52YWx1ZXMoaW5uZXIpLnJldmVyc2UoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuZWlnaGJvckZuID0gKHZlcnQgPT09ICd1JyA/IGcuZ2V0UHJlZGVjZXNzb3JzIDogZy5nZXRTdWNjZXNzb3JzKS5iaW5kKGcpO1xuICAgICAgICAgICAgY29uc3QgYWxpZ24gPSB2ZXJ0aWNhbEFsaWdubWVudChnLCBhZGp1c3RlZExheWVyaW5nLCBjb25mbGljdHMsIG5laWdoYm9yRm4pO1xuICAgICAgICAgICAgY29uc3QgeHMgPSBob3Jpem9udGFsQ29tcGFjdGlvbihnLCBhZGp1c3RlZExheWVyaW5nLCBhbGlnbi5yb290LCBhbGlnbi5hbGlnbiwgbm9kZXNlcCwgZWRnZXNlcCwgaG9yaXogPT09ICdyJyk7XG4gICAgICAgICAgICBpZiAoaG9yaXogPT09ICdyJykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHhzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgeHNba2V5XSA9IC14c1trZXldO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeHNzW3ZlcnQgKyBob3Jpel0gPSB4cztcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3Qgc21hbGxlc3RXaWR0aCA9IGZpbmRTbWFsbGVzdFdpZHRoQWxpZ25tZW50KGcsIHhzcyk7XG4gICAgYWxpZ25Db29yZGluYXRlcyh4c3MsIHNtYWxsZXN0V2lkdGgpO1xuICAgIHJldHVybiBiYWxhbmNlKHhzcywgZ3JhcGhBbGlnbik7XG59O1xuZXhwb3J0IGNvbnN0IHNlcCA9IChub2RlU2VwLCBlZGdlU2VwLCByZXZlcnNlU2VwKSA9PiB7XG4gICAgcmV0dXJuIChnLCB2LCB3KSA9PiB7XG4gICAgICAgIGNvbnN0IHZMYWJlbCA9IGcuZ2V0Tm9kZSh2KTtcbiAgICAgICAgY29uc3Qgd0xhYmVsID0gZy5nZXROb2RlKHcpO1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgbGV0IGRlbHRhID0gMDtcbiAgICAgICAgc3VtICs9IHZMYWJlbC5kYXRhLndpZHRoIC8gMjtcbiAgICAgICAgaWYgKHZMYWJlbC5kYXRhLmhhc093blByb3BlcnR5KCdsYWJlbHBvcycpKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKCh2TGFiZWwuZGF0YS5sYWJlbHBvcyB8fCAnJykudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IC12TGFiZWwuZGF0YS53aWR0aCAvIDI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgICAgICAgICBkZWx0YSA9IHZMYWJlbC5kYXRhLndpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbHRhKSB7XG4gICAgICAgICAgICBzdW0gKz0gcmV2ZXJzZVNlcCA/IGRlbHRhIDogLWRlbHRhO1xuICAgICAgICB9XG4gICAgICAgIGRlbHRhID0gMDtcbiAgICAgICAgc3VtICs9ICh2TGFiZWwuZGF0YS5kdW1teSA/IGVkZ2VTZXAgOiBub2RlU2VwKSAvIDI7XG4gICAgICAgIHN1bSArPSAod0xhYmVsLmRhdGEuZHVtbXkgPyBlZGdlU2VwIDogbm9kZVNlcCkgLyAyO1xuICAgICAgICBzdW0gKz0gd0xhYmVsLmRhdGEud2lkdGggLyAyO1xuICAgICAgICBpZiAod0xhYmVsLmRhdGEubGFiZWxwb3MpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoKHdMYWJlbC5kYXRhLmxhYmVscG9zIHx8ICcnKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbCc6XG4gICAgICAgICAgICAgICAgICAgIGRlbHRhID0gd0xhYmVsLmRhdGEud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdyJzpcbiAgICAgICAgICAgICAgICAgICAgZGVsdGEgPSAtd0xhYmVsLmRhdGEud2lkdGggLyAyO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsdGEpIHtcbiAgICAgICAgICAgIHN1bSArPSByZXZlcnNlU2VwID8gZGVsdGEgOiAtZGVsdGE7XG4gICAgICAgIH1cbiAgICAgICAgZGVsdGEgPSAwO1xuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH07XG59O1xuZXhwb3J0IGNvbnN0IHdpZHRoID0gKGcsIHYpID0+IGcuZ2V0Tm9kZSh2KS5kYXRhLndpZHRoIHx8IDA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iay5qcy5tYXAiLCJpbXBvcnQgeyBhc05vbkNvbXBvdW5kR3JhcGgsIGJ1aWxkTGF5ZXJNYXRyaXggfSBmcm9tICcuLi91dGlsJztcbmltcG9ydCB7IGFsaWduQ29vcmRpbmF0ZXMsIGJhbGFuY2UsIGZpbmRTbWFsbGVzdFdpZHRoQWxpZ25tZW50LCBmaW5kVHlwZTFDb25mbGljdHMsIGZpbmRUeXBlMkNvbmZsaWN0cywgaG9yaXpvbnRhbENvbXBhY3Rpb24sIHZlcnRpY2FsQWxpZ25tZW50LCB9IGZyb20gJy4vYmsnO1xuY29uc3QgcG9zaXRpb25ZID0gKGcsIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCB7IHJhbmtzZXAgPSAwIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGxheWVyaW5nID0gYnVpbGRMYXllck1hdHJpeChnKTtcbiAgICBsZXQgcHJldlkgPSAwO1xuICAgIGxheWVyaW5nID09PSBudWxsIHx8IGxheWVyaW5nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXllcmluZy5mb3JFYWNoKChsYXllcikgPT4ge1xuICAgICAgICBjb25zdCBoZWlnaHRzID0gbGF5ZXIubWFwKCh2KSA9PiBnLmdldE5vZGUodikuZGF0YS5oZWlnaHQpO1xuICAgICAgICBjb25zdCBtYXhIZWlnaHQgPSBNYXRoLm1heCguLi5oZWlnaHRzLCAwKTtcbiAgICAgICAgbGF5ZXIgPT09IG51bGwgfHwgbGF5ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheWVyLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgICAgIGcuZ2V0Tm9kZSh2KS5kYXRhLnkgPSBwcmV2WSArIG1heEhlaWdodCAvIDI7XG4gICAgICAgIH0pO1xuICAgICAgICBwcmV2WSArPSBtYXhIZWlnaHQgKyByYW5rc2VwO1xuICAgIH0pO1xufTtcbmNvbnN0IHBvc2l0aW9uWCA9IChnLCBvcHRpb25zKSA9PiB7XG4gICAgY29uc3QgeyBhbGlnbjogZ3JhcGhBbGlnbiwgbm9kZXNlcCA9IDAsIGVkZ2VzZXAgPSAwIH0gPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGxheWVyaW5nID0gYnVpbGRMYXllck1hdHJpeChnKTtcbiAgICBjb25zdCBjb25mbGljdHMgPSBPYmplY3QuYXNzaWduKGZpbmRUeXBlMUNvbmZsaWN0cyhnLCBsYXllcmluZyksIGZpbmRUeXBlMkNvbmZsaWN0cyhnLCBsYXllcmluZykpO1xuICAgIGNvbnN0IHhzcyA9IHt9O1xuICAgIGxldCBhZGp1c3RlZExheWVyaW5nID0gW107XG4gICAgWyd1JywgJ2QnXS5mb3JFYWNoKCh2ZXJ0KSA9PiB7XG4gICAgICAgIGFkanVzdGVkTGF5ZXJpbmcgPVxuICAgICAgICAgICAgdmVydCA9PT0gJ3UnID8gbGF5ZXJpbmcgOiBPYmplY3QudmFsdWVzKGxheWVyaW5nKS5yZXZlcnNlKCk7XG4gICAgICAgIFsnbCcsICdyJ10uZm9yRWFjaCgoaG9yaXopID0+IHtcbiAgICAgICAgICAgIGlmIChob3JpeiA9PT0gJ3InKSB7XG4gICAgICAgICAgICAgICAgYWRqdXN0ZWRMYXllcmluZyA9IGFkanVzdGVkTGF5ZXJpbmcubWFwKChpbm5lcikgPT4gT2JqZWN0LnZhbHVlcyhpbm5lcikucmV2ZXJzZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5laWdoYm9yRm4gPSAodmVydCA9PT0gJ3UnID8gZy5nZXRQcmVkZWNlc3NvcnMgOiBnLmdldFN1Y2Nlc3NvcnMpLmJpbmQoZyk7XG4gICAgICAgICAgICBjb25zdCBhbGlnbiA9IHZlcnRpY2FsQWxpZ25tZW50KGcsIGFkanVzdGVkTGF5ZXJpbmcsIGNvbmZsaWN0cywgbmVpZ2hib3JGbik7XG4gICAgICAgICAgICBjb25zdCB4cyA9IGhvcml6b250YWxDb21wYWN0aW9uKGcsIGFkanVzdGVkTGF5ZXJpbmcsIGFsaWduLnJvb3QsIGFsaWduLmFsaWduLCBub2Rlc2VwLCBlZGdlc2VwLCBob3JpeiA9PT0gJ3InKTtcbiAgICAgICAgICAgIGlmIChob3JpeiA9PT0gJ3InKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoeHMpLmZvckVhY2goKHhzS2V5KSA9PiAoeHNbeHNLZXldID0gLXhzW3hzS2V5XSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeHNzW3ZlcnQgKyBob3Jpel0gPSB4cztcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29uc3Qgc21hbGxlc3RXaWR0aCA9IGZpbmRTbWFsbGVzdFdpZHRoQWxpZ25tZW50KGcsIHhzcyk7XG4gICAgc21hbGxlc3RXaWR0aCAmJiBhbGlnbkNvb3JkaW5hdGVzKHhzcywgc21hbGxlc3RXaWR0aCk7XG4gICAgcmV0dXJuIGJhbGFuY2UoeHNzLCBncmFwaEFsaWduKTtcbn07XG5leHBvcnQgY29uc3QgcG9zaXRpb24gPSAoZywgb3B0aW9ucykgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBuZyA9IGFzTm9uQ29tcG91bmRHcmFwaChnKTtcbiAgICBwb3NpdGlvblkobmcsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHhzID0gcG9zaXRpb25YKG5nLCBvcHRpb25zKTtcbiAgICAoX2EgPSBPYmplY3Qua2V5cyh4cykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgbmcuZ2V0Tm9kZShrZXkpLmRhdGEueCA9IHhzW2tleV07XG4gICAgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHsgR3JhcGggfSBmcm9tICdAYW50di9ncmFwaGxpYic7XG5pbXBvcnQgeyBtaW5CeSB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHsgc2xhY2sgfSBmcm9tICcuL3V0aWwnO1xuLypcbiAqIENvbnN0cnVjdHMgYSBzcGFubmluZyB0cmVlIHdpdGggdGlnaHQgZWRnZXMgYW5kIGFkanVzdGVkIHRoZSBpbnB1dCBub2RlJ3NcbiAqIHJhbmtzIHRvIGFjaGlldmUgdGhpcy4gQSB0aWdodCBlZGdlIGlzIG9uZSB0aGF0IGlzIGhhcyBhIGxlbmd0aCB0aGF0IG1hdGNoZXNcbiAqIGl0cyBcIm1pbmxlblwiIGF0dHJpYnV0ZS5cbiAqXG4gKiBUaGUgYmFzaWMgc3RydWN0dXJlIGZvciB0aGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBHYW5zbmVyLCBldCBhbC4sIFwiQVxuICogVGVjaG5pcXVlIGZvciBEcmF3aW5nIERpcmVjdGVkIEdyYXBocy5cIlxuICpcbiAqIFByZS1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIEdyYXBoIG11c3QgYmUgYSBEQUcuXG4gKiAgICAyLiBHcmFwaCBtdXN0IGJlIGNvbm5lY3RlZC5cbiAqICAgIDMuIEdyYXBoIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgbm9kZS5cbiAqICAgIDUuIEdyYXBoIG5vZGVzIG11c3QgaGF2ZSBiZWVuIHByZXZpb3VzbHkgYXNzaWduZWQgYSBcInJhbmtcIiBwcm9wZXJ0eSB0aGF0XG4gKiAgICAgICByZXNwZWN0cyB0aGUgXCJtaW5sZW5cIiBwcm9wZXJ0eSBvZiBpbmNpZGVudCBlZGdlcy5cbiAqICAgIDYuIEdyYXBoIGVkZ2VzIG11c3QgaGF2ZSBhIFwibWlubGVuXCIgcHJvcGVydHkuXG4gKlxuICogUG9zdC1jb25kaXRpb25zOlxuICpcbiAqICAgIC0gR3JhcGggbm9kZXMgd2lsbCBoYXZlIHRoZWlyIHJhbmsgYWRqdXN0ZWQgdG8gZW5zdXJlIHRoYXQgYWxsIGVkZ2VzIGFyZVxuICogICAgICB0aWdodC5cbiAqXG4gKiBSZXR1cm5zIGEgdHJlZSAodW5kaXJlY3RlZCBncmFwaCkgdGhhdCBpcyBjb25zdHJ1Y3RlZCB1c2luZyBvbmx5IFwidGlnaHRcIlxuICogZWRnZXMuXG4gKi9cbmNvbnN0IGZlYXNpYmxlVHJlZSA9IChnKSA9PiB7XG4gICAgY29uc3QgdCA9IG5ldyBHcmFwaCh7XG4gICAgICAgIHRyZWU6IFtdLFxuICAgIH0pO1xuICAgIC8vIENob29zZSBhcmJpdHJhcnkgbm9kZSBmcm9tIHdoaWNoIHRvIHN0YXJ0IG91ciB0cmVlXG4gICAgY29uc3Qgc3RhcnQgPSBnLmdldEFsbE5vZGVzKClbMF07XG4gICAgY29uc3Qgc2l6ZSA9IGcuZ2V0QWxsTm9kZXMoKS5sZW5ndGg7XG4gICAgdC5hZGROb2RlKHN0YXJ0KTtcbiAgICBsZXQgZWRnZTtcbiAgICBsZXQgZGVsdGE7XG4gICAgd2hpbGUgKHRpZ2h0VHJlZSh0LCBnKSA8IHNpemUpIHtcbiAgICAgICAgZWRnZSA9IGZpbmRNaW5TbGFja0VkZ2UodCwgZyk7XG4gICAgICAgIGRlbHRhID0gdC5oYXNOb2RlKGVkZ2Uuc291cmNlKSA/IHNsYWNrKGcsIGVkZ2UpIDogLXNsYWNrKGcsIGVkZ2UpO1xuICAgICAgICBzaGlmdFJhbmtzKHQsIGcsIGRlbHRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuLypcbiAqIEZpbmRzIGEgbWF4aW1hbCB0cmVlIG9mIHRpZ2h0IGVkZ2VzIGFuZCByZXR1cm5zIHRoZSBudW1iZXIgb2Ygbm9kZXMgaW4gdGhlXG4gKiB0cmVlLlxuICovXG5jb25zdCB0aWdodFRyZWUgPSAodCwgZykgPT4ge1xuICAgIGNvbnN0IGRmcyA9ICh2KSA9PiB7XG4gICAgICAgIGcuZ2V0UmVsYXRlZEVkZ2VzKHYsICdib3RoJykuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZWRnZVYgPSBlLnNvdXJjZTtcbiAgICAgICAgICAgIGNvbnN0IHcgPSB2ID09PSBlZGdlViA/IGUudGFyZ2V0IDogZWRnZVY7XG4gICAgICAgICAgICBpZiAoIXQuaGFzTm9kZSh3KSAmJiAhc2xhY2soZywgZSkpIHtcbiAgICAgICAgICAgICAgICB0LmFkZE5vZGUoe1xuICAgICAgICAgICAgICAgICAgICBpZDogdyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge30sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdC5hZGRFZGdlKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGUuaWQsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogdixcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB3LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkZnModyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdC5nZXRBbGxOb2RlcygpLmZvckVhY2goKG4pID0+IGRmcyhuLmlkKSk7XG4gICAgcmV0dXJuIHQuZ2V0QWxsTm9kZXMoKS5sZW5ndGg7XG59O1xuLypcbiAqIENvbnN0cnVjdHMgYSBzcGFubmluZyB0cmVlIHdpdGggdGlnaHQgZWRnZXMgYW5kIGFkanVzdGVkIHRoZSBpbnB1dCBub2RlJ3NcbiAqIHJhbmtzIHRvIGFjaGlldmUgdGhpcy4gQSB0aWdodCBlZGdlIGlzIG9uZSB0aGF0IGlzIGhhcyBhIGxlbmd0aCB0aGF0IG1hdGNoZXNcbiAqIGl0cyBcIm1pbmxlblwiIGF0dHJpYnV0ZS5cbiAqXG4gKiBUaGUgYmFzaWMgc3RydWN0dXJlIGZvciB0aGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBHYW5zbmVyLCBldCBhbC4sIFwiQVxuICogVGVjaG5pcXVlIGZvciBEcmF3aW5nIERpcmVjdGVkIEdyYXBocy5cIlxuICpcbiAqIFByZS1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIEdyYXBoIG11c3QgYmUgYSBEQUcuXG4gKiAgICAyLiBHcmFwaCBtdXN0IGJlIGNvbm5lY3RlZC5cbiAqICAgIDMuIEdyYXBoIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgbm9kZS5cbiAqICAgIDUuIEdyYXBoIG5vZGVzIG11c3QgaGF2ZSBiZWVuIHByZXZpb3VzbHkgYXNzaWduZWQgYSBcInJhbmtcIiBwcm9wZXJ0eSB0aGF0XG4gKiAgICAgICByZXNwZWN0cyB0aGUgXCJtaW5sZW5cIiBwcm9wZXJ0eSBvZiBpbmNpZGVudCBlZGdlcy5cbiAqICAgIDYuIEdyYXBoIGVkZ2VzIG11c3QgaGF2ZSBhIFwibWlubGVuXCIgcHJvcGVydHkuXG4gKlxuICogUG9zdC1jb25kaXRpb25zOlxuICpcbiAqICAgIC0gR3JhcGggbm9kZXMgd2lsbCBoYXZlIHRoZWlyIHJhbmsgYWRqdXN0ZWQgdG8gZW5zdXJlIHRoYXQgYWxsIGVkZ2VzIGFyZVxuICogICAgICB0aWdodC5cbiAqXG4gKiBSZXR1cm5zIGEgdHJlZSAodW5kaXJlY3RlZCBncmFwaCkgdGhhdCBpcyBjb25zdHJ1Y3RlZCB1c2luZyBvbmx5IFwidGlnaHRcIlxuICogZWRnZXMuXG4gKi9cbmNvbnN0IGZlYXNpYmxlVHJlZVdpdGhMYXllciA9IChnKSA9PiB7XG4gICAgY29uc3QgdCA9IG5ldyBHcmFwaCh7IHRyZWU6IFtdIH0pO1xuICAgIC8vIENob29zZSBhcmJpdHJhcnkgbm9kZSBmcm9tIHdoaWNoIHRvIHN0YXJ0IG91ciB0cmVlXG4gICAgY29uc3Qgc3RhcnQgPSBnLmdldEFsbE5vZGVzKClbMF07XG4gICAgY29uc3Qgc2l6ZSA9IGcuZ2V0QWxsTm9kZXMoKS5sZW5ndGg7XG4gICAgdC5hZGROb2RlKHN0YXJ0KTtcbiAgICBsZXQgZWRnZTtcbiAgICBsZXQgZGVsdGE7XG4gICAgd2hpbGUgKHRpZ2h0VHJlZVdpdGhMYXllcih0LCBnKSA8IHNpemUpIHtcbiAgICAgICAgZWRnZSA9IGZpbmRNaW5TbGFja0VkZ2UodCwgZyk7XG4gICAgICAgIGRlbHRhID0gdC5oYXNOb2RlKGVkZ2Uuc291cmNlKSA/IHNsYWNrKGcsIGVkZ2UpIDogLXNsYWNrKGcsIGVkZ2UpO1xuICAgICAgICBzaGlmdFJhbmtzKHQsIGcsIGRlbHRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHQ7XG59O1xuLypcbiAqIEZpbmRzIGEgbWF4aW1hbCB0cmVlIG9mIHRpZ2h0IGVkZ2VzIGFuZCByZXR1cm5zIHRoZSBudW1iZXIgb2Ygbm9kZXMgaW4gdGhlXG4gKiB0cmVlLlxuICovXG5jb25zdCB0aWdodFRyZWVXaXRoTGF5ZXIgPSAodCwgZykgPT4ge1xuICAgIGNvbnN0IGRmcyA9ICh2KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gZy5nZXRSZWxhdGVkRWRnZXModiwgJ2JvdGgnKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVkZ2VWID0gZS5zb3VyY2U7XG4gICAgICAgICAgICBjb25zdCB3ID0gdiA9PT0gZWRnZVYgPyBlLnRhcmdldCA6IGVkZ2VWO1xuICAgICAgICAgICAgLy8g5a+55LqO5oyH5a6abGF5ZXLnmoTvvIznm7TmjqXliqDlhaV0aWdodC10cmVl77yM5LiN5Y+C5LiO6LCD5pW0XG4gICAgICAgICAgICBpZiAoIXQuaGFzTm9kZSh3KSAmJlxuICAgICAgICAgICAgICAgIChnLmdldE5vZGUodykuZGF0YS5sYXllciAhPT0gdW5kZWZpbmVkIHx8ICFzbGFjayhnLCBlKSkpIHtcbiAgICAgICAgICAgICAgICB0LmFkZE5vZGUoe1xuICAgICAgICAgICAgICAgICAgICBpZDogdyxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge30sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdC5hZGRFZGdlKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGUuaWQsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogdixcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB3LFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7fSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBkZnModyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdC5nZXRBbGxOb2RlcygpLmZvckVhY2goKG4pID0+IGRmcyhuLmlkKSk7XG4gICAgcmV0dXJuIHQuZ2V0QWxsTm9kZXMoKS5sZW5ndGg7XG59O1xuLypcbiAqIEZpbmRzIHRoZSBlZGdlIHdpdGggdGhlIHNtYWxsZXN0IHNsYWNrIHRoYXQgaXMgaW5jaWRlbnQgb24gdHJlZSBhbmQgcmV0dXJuc1xuICogaXQuXG4gKi9cbmNvbnN0IGZpbmRNaW5TbGFja0VkZ2UgPSAodCwgZykgPT4ge1xuICAgIHJldHVybiBtaW5CeShnLmdldEFsbEVkZ2VzKCksIChlKSA9PiB7XG4gICAgICAgIGlmICh0Lmhhc05vZGUoZS5zb3VyY2UpICE9PSB0Lmhhc05vZGUoZS50YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2xhY2soZywgZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgIH0pO1xufTtcbmNvbnN0IHNoaWZ0UmFua3MgPSAodCwgZywgZGVsdGEpID0+IHtcbiAgICB0LmdldEFsbE5vZGVzKCkuZm9yRWFjaCgodG4pID0+IHtcbiAgICAgICAgY29uc3QgdiA9IGcuZ2V0Tm9kZSh0bi5pZCk7XG4gICAgICAgIGlmICghdi5kYXRhLnJhbmspXG4gICAgICAgICAgICB2LmRhdGEucmFuayA9IDA7XG4gICAgICAgIHYuZGF0YS5yYW5rICs9IGRlbHRhO1xuICAgIH0pO1xufTtcbmV4cG9ydCB7IGZlYXNpYmxlVHJlZSwgZmVhc2libGVUcmVlV2l0aExheWVyIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mZWFzaWJsZS10cmVlLmpzLm1hcCIsImltcG9ydCB7IGZlYXNpYmxlVHJlZVdpdGhMYXllciBhcyBmZWFzaWJsZVRyZWUgfSBmcm9tICcuL2ZlYXNpYmxlLXRyZWUnO1xuaW1wb3J0IHsgbmV0d29ya1NpbXBsZXggfSBmcm9tICcuL25ldHdvcmstc2ltcGxleCc7XG5pbXBvcnQgeyBsb25nZXN0UGF0aCwgbG9uZ2VzdFBhdGhXaXRoTGF5ZXIgfSBmcm9tICcuL3V0aWwnO1xuLypcbiAqIEFzc2lnbnMgYSByYW5rIHRvIGVhY2ggbm9kZSBpbiB0aGUgaW5wdXQgZ3JhcGggdGhhdCByZXNwZWN0cyB0aGUgXCJtaW5sZW5cIlxuICogY29uc3RyYWludCBzcGVjaWZpZWQgb24gZWRnZXMgYmV0d2VlbiBub2Rlcy5cbiAqXG4gKiBUaGlzIGJhc2ljIHN0cnVjdHVyZSBpcyBkZXJpdmVkIGZyb20gR2Fuc25lciwgZXQgYWwuLCBcIkEgVGVjaG5pcXVlIGZvclxuICogRHJhd2luZyBEaXJlY3RlZCBHcmFwaHMuXCJcbiAqXG4gKiBQcmUtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBHcmFwaCBtdXN0IGJlIGEgY29ubmVjdGVkIERBR1xuICogICAgMi4gR3JhcGggbm9kZXMgbXVzdCBiZSBvYmplY3RzXG4gKiAgICAzLiBHcmFwaCBlZGdlcyBtdXN0IGhhdmUgXCJ3ZWlnaHRcIiBhbmQgXCJtaW5sZW5cIiBhdHRyaWJ1dGVzXG4gKlxuICogUG9zdC1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIEdyYXBoIG5vZGVzIHdpbGwgaGF2ZSBhIFwicmFua1wiIGF0dHJpYnV0ZSBiYXNlZCBvbiB0aGUgcmVzdWx0cyBvZiB0aGVcbiAqICAgICAgIGFsZ29yaXRobS4gUmFua3MgY2FuIHN0YXJ0IGF0IGFueSBpbmRleCAoaW5jbHVkaW5nIG5lZ2F0aXZlKSwgd2UnbGxcbiAqICAgICAgIGZpeCB0aGVtIHVwIGxhdGVyLlxuICovXG5leHBvcnQgY29uc3QgcmFuayA9IChnLCByYW5rZXIpID0+IHtcbiAgICBzd2l0Y2ggKHJhbmtlcikge1xuICAgICAgICBjYXNlICduZXR3b3JrLXNpbXBsZXgnOlxuICAgICAgICAgICAgbmV0d29ya1NpbXBsZXhSYW5rZXIoZyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGlnaHQtdHJlZSc6XG4gICAgICAgICAgICB0aWdodFRyZWVSYW5rZXIoZyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbG9uZ2VzdC1wYXRoJzpcbiAgICAgICAgICAgIGxvbmdlc3RQYXRoUmFua2VyKGcpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIGRlZmF1bHQ6IG5ldHdvcmtTaW1wbGV4UmFua2VyKGcpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGlnaHRUcmVlUmFua2VyKGcpO1xuICAgIH1cbn07XG4vLyBBIGZhc3QgYW5kIHNpbXBsZSByYW5rZXIsIGJ1dCByZXN1bHRzIGFyZSBmYXIgZnJvbSBvcHRpbWFsLlxuY29uc3QgbG9uZ2VzdFBhdGhSYW5rZXIgPSBsb25nZXN0UGF0aDtcbmNvbnN0IHRpZ2h0VHJlZVJhbmtlciA9IChnKSA9PiB7XG4gICAgbG9uZ2VzdFBhdGhXaXRoTGF5ZXIoZyk7XG4gICAgZmVhc2libGVUcmVlKGcpO1xufTtcbmNvbnN0IG5ldHdvcmtTaW1wbGV4UmFua2VyID0gKGcpID0+IHtcbiAgICBuZXR3b3JrU2ltcGxleChnKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgeyBkZnMsIG1pbkJ5LCBzaW1wbGlmeSB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHsgZmVhc2libGVUcmVlIH0gZnJvbSAnLi9mZWFzaWJsZS10cmVlJztcbmltcG9ydCB7IGxvbmdlc3RQYXRoIGFzIGluaXRSYW5rLCBzbGFjayB9IGZyb20gJy4vdXRpbCc7XG4vKlxuICogVGhlIG5ldHdvcmsgc2ltcGxleCBhbGdvcml0aG0gYXNzaWducyByYW5rcyB0byBlYWNoIG5vZGUgaW4gdGhlIGlucHV0IGdyYXBoXG4gKiBhbmQgaXRlcmF0aXZlbHkgaW1wcm92ZXMgdGhlIHJhbmtpbmcgdG8gcmVkdWNlIHRoZSBsZW5ndGggb2YgZWRnZXMuXG4gKlxuICogUHJlY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBUaGUgaW5wdXQgZ3JhcGggbXVzdCBiZSBhIERBRy5cbiAqICAgIDIuIEFsbCBub2RlcyBpbiB0aGUgZ3JhcGggbXVzdCBoYXZlIGFuIG9iamVjdCB2YWx1ZS5cbiAqICAgIDMuIEFsbCBlZGdlcyBpbiB0aGUgZ3JhcGggbXVzdCBoYXZlIFwibWlubGVuXCIgYW5kIFwid2VpZ2h0XCIgYXR0cmlidXRlcy5cbiAqXG4gKiBQb3N0Y29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBBbGwgbm9kZXMgaW4gdGhlIGdyYXBoIHdpbGwgaGF2ZSBhbiBhc3NpZ25lZCBcInJhbmtcIiBhdHRyaWJ1dGUgdGhhdCBoYXNcbiAqICAgICAgIGJlZW4gb3B0aW1pemVkIGJ5IHRoZSBuZXR3b3JrIHNpbXBsZXggYWxnb3JpdGhtLiBSYW5rcyBzdGFydCBhdCAwLlxuICpcbiAqXG4gKiBBIHJvdWdoIHNrZXRjaCBvZiB0aGUgYWxnb3JpdGhtIGlzIGFzIGZvbGxvd3M6XG4gKlxuICogICAgMS4gQXNzaWduIGluaXRpYWwgcmFua3MgdG8gZWFjaCBub2RlLiBXZSB1c2UgdGhlIGxvbmdlc3QgcGF0aCBhbGdvcml0aG0sXG4gKiAgICAgICB3aGljaCBhc3NpZ25zIHJhbmtzIHRvIHRoZSBsb3dlc3QgcG9zaXRpb24gcG9zc2libGUuIEluIGdlbmVyYWwgdGhpc1xuICogICAgICAgbGVhZHMgdG8gdmVyeSB3aWRlIGJvdHRvbSByYW5rcyBhbmQgdW5uZWNlc3NhcmlseSBsb25nIGVkZ2VzLlxuICogICAgMi4gQ29uc3RydWN0IGEgZmVhc2libGUgdGlnaHQgdHJlZS4gQSB0aWdodCB0cmVlIGlzIG9uZSBzdWNoIHRoYXQgYWxsXG4gKiAgICAgICBlZGdlcyBpbiB0aGUgdHJlZSBoYXZlIG5vIHNsYWNrIChkaWZmZXJlbmNlIGJldHdlZW4gbGVuZ3RoIG9mIGVkZ2VcbiAqICAgICAgIGFuZCBtaW5sZW4gZm9yIHRoZSBlZGdlKS4gVGhpcyBieSBpdHNlbGYgZ3JlYXRseSBpbXByb3ZlcyB0aGUgYXNzaWduZWRcbiAqICAgICAgIHJhbmtpbmdzIGJ5IHNob3J0aW5nIGVkZ2VzLlxuICogICAgMy4gSXRlcmF0aXZlbHkgZmluZCBlZGdlcyB0aGF0IGhhdmUgbmVnYXRpdmUgY3V0IHZhbHVlcy4gR2VuZXJhbGx5IGFcbiAqICAgICAgIG5lZ2F0aXZlIGN1dCB2YWx1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgZWRnZSBjb3VsZCBiZSByZW1vdmVkIGFuZCBhIG5ld1xuICogICAgICAgdHJlZSBlZGdlIGNvdWxkIGJlIGFkZGVkIHRvIHByb2R1Y2UgYSBtb3JlIGNvbXBhY3QgZ3JhcGguXG4gKlxuICogTXVjaCBvZiB0aGUgYWxnb3JpdGhtcyBoZXJlIGFyZSBkZXJpdmVkIGZyb20gR2Fuc25lciwgZXQgYWwuLCBcIkEgVGVjaG5pcXVlXG4gKiBmb3IgRHJhd2luZyBEaXJlY3RlZCBHcmFwaHMuXCIgVGhlIHN0cnVjdHVyZSBvZiB0aGUgZmlsZSByb3VnaGx5IGZvbGxvd3MgdGhlXG4gKiBzdHJ1Y3R1cmUgb2YgdGhlIG92ZXJhbGwgYWxnb3JpdGhtLlxuICovXG5leHBvcnQgY29uc3QgbmV0d29ya1NpbXBsZXggPSAob2cpID0+IHtcbiAgICBjb25zdCBnID0gc2ltcGxpZnkob2cpO1xuICAgIGluaXRSYW5rKGcpO1xuICAgIGNvbnN0IHQgPSBmZWFzaWJsZVRyZWUoZyk7XG4gICAgaW5pdExvd0xpbVZhbHVlcyh0KTtcbiAgICBpbml0Q3V0VmFsdWVzKHQsIGcpO1xuICAgIGxldCBlO1xuICAgIGxldCBmO1xuICAgIHdoaWxlICgoZSA9IGxlYXZlRWRnZSh0KSkpIHtcbiAgICAgICAgZiA9IGVudGVyRWRnZSh0LCBnLCBlKTtcbiAgICAgICAgZXhjaGFuZ2VFZGdlcyh0LCBnLCBlLCBmKTtcbiAgICB9XG59O1xuLypcbiAqIEluaXRpYWxpemVzIGN1dCB2YWx1ZXMgZm9yIGFsbCBlZGdlcyBpbiB0aGUgdHJlZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGluaXRDdXRWYWx1ZXMgPSAodCwgZykgPT4ge1xuICAgIGxldCB2cyA9IGRmcyh0LCB0LmdldEFsbE5vZGVzKCksICdwb3N0JywgZmFsc2UpO1xuICAgIHZzID0gdnMuc2xpY2UoMCwgKHZzID09PSBudWxsIHx8IHZzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2cy5sZW5ndGgpIC0gMSk7XG4gICAgdnMuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICBhc3NpZ25DdXRWYWx1ZSh0LCBnLCB2KTtcbiAgICB9KTtcbn07XG5jb25zdCBhc3NpZ25DdXRWYWx1ZSA9ICh0LCBnLCBjaGlsZCkgPT4ge1xuICAgIGNvbnN0IGNoaWxkTGFiID0gdC5nZXROb2RlKGNoaWxkKTtcbiAgICBjb25zdCBwYXJlbnQgPSBjaGlsZExhYi5kYXRhLnBhcmVudDtcbiAgICAvLyBGSVhNRTogdXNlIHVuZGlyZWN0ZWQgZWRnZT9cbiAgICBjb25zdCBlZGdlID0gdFxuICAgICAgICAuZ2V0UmVsYXRlZEVkZ2VzKGNoaWxkLCAnYm90aCcpXG4gICAgICAgIC5maW5kKChlKSA9PiBlLnRhcmdldCA9PT0gcGFyZW50IHx8IGUuc291cmNlID09PSBwYXJlbnQpO1xuICAgIGVkZ2UuZGF0YS5jdXR2YWx1ZSA9IGNhbGNDdXRWYWx1ZSh0LCBnLCBjaGlsZCk7XG59O1xuLypcbiAqIEdpdmVuIHRoZSB0aWdodCB0cmVlLCBpdHMgZ3JhcGgsIGFuZCBhIGNoaWxkIGluIHRoZSBncmFwaCBjYWxjdWxhdGUgYW5kXG4gKiByZXR1cm4gdGhlIGN1dCB2YWx1ZSBmb3IgdGhlIGVkZ2UgYmV0d2VlbiB0aGUgY2hpbGQgYW5kIGl0cyBwYXJlbnQuXG4gKi9cbmV4cG9ydCBjb25zdCBjYWxjQ3V0VmFsdWUgPSAodCwgZywgY2hpbGQpID0+IHtcbiAgICBjb25zdCBjaGlsZExhYiA9IHQuZ2V0Tm9kZShjaGlsZCk7XG4gICAgY29uc3QgcGFyZW50ID0gY2hpbGRMYWIuZGF0YS5wYXJlbnQ7XG4gICAgLy8gVHJ1ZSBpZiB0aGUgY2hpbGQgaXMgb24gdGhlIHRhaWwgZW5kIG9mIHRoZSBlZGdlIGluIHRoZSBkaXJlY3RlZCBncmFwaFxuICAgIGxldCBjaGlsZElzVGFpbCA9IHRydWU7XG4gICAgLy8gVGhlIGdyYXBoJ3MgdmlldyBvZiB0aGUgdHJlZSBlZGdlIHdlJ3JlIGluc3BlY3RpbmdcbiAgICBsZXQgZ3JhcGhFZGdlID0gZ1xuICAgICAgICAuZ2V0UmVsYXRlZEVkZ2VzKGNoaWxkLCAnb3V0JylcbiAgICAgICAgLmZpbmQoKGUpID0+IGUudGFyZ2V0ID09PSBwYXJlbnQpO1xuICAgIC8vIFRoZSBhY2N1bXVsYXRlZCBjdXQgdmFsdWUgZm9yIHRoZSBlZGdlIGJldHdlZW4gdGhpcyBub2RlIGFuZCBpdHMgcGFyZW50XG4gICAgbGV0IGN1dFZhbHVlID0gMDtcbiAgICBpZiAoIWdyYXBoRWRnZSkge1xuICAgICAgICBjaGlsZElzVGFpbCA9IGZhbHNlO1xuICAgICAgICBncmFwaEVkZ2UgPSBnXG4gICAgICAgICAgICAuZ2V0UmVsYXRlZEVkZ2VzKHBhcmVudCwgJ291dCcpXG4gICAgICAgICAgICAuZmluZCgoZSkgPT4gZS50YXJnZXQgPT09IGNoaWxkKTtcbiAgICB9XG4gICAgY3V0VmFsdWUgPSBncmFwaEVkZ2UuZGF0YS53ZWlnaHQ7XG4gICAgZy5nZXRSZWxhdGVkRWRnZXMoY2hpbGQsICdib3RoJykuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICBjb25zdCBpc091dEVkZ2UgPSBlLnNvdXJjZSA9PT0gY2hpbGQ7XG4gICAgICAgIGNvbnN0IG90aGVyID0gaXNPdXRFZGdlID8gZS50YXJnZXQgOiBlLnNvdXJjZTtcbiAgICAgICAgaWYgKG90aGVyICE9PSBwYXJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50c1RvSGVhZCA9IGlzT3V0RWRnZSA9PT0gY2hpbGRJc1RhaWw7XG4gICAgICAgICAgICBjb25zdCBvdGhlcldlaWdodCA9IGUuZGF0YS53ZWlnaHQ7XG4gICAgICAgICAgICBjdXRWYWx1ZSArPSBwb2ludHNUb0hlYWQgPyBvdGhlcldlaWdodCA6IC1vdGhlcldlaWdodDtcbiAgICAgICAgICAgIGlmIChpc1RyZWVFZGdlKHQsIGNoaWxkLCBvdGhlcikpIHtcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogdXNlIHVuZGlyZWN0ZWQgZWRnZT9cbiAgICAgICAgICAgICAgICBjb25zdCBvdGhlckN1dFZhbHVlID0gdFxuICAgICAgICAgICAgICAgICAgICAuZ2V0UmVsYXRlZEVkZ2VzKGNoaWxkLCAnYm90aCcpXG4gICAgICAgICAgICAgICAgICAgIC5maW5kKChlKSA9PiBlLnNvdXJjZSA9PT0gb3RoZXIgfHwgZS50YXJnZXQgPT09IG90aGVyKS5kYXRhXG4gICAgICAgICAgICAgICAgICAgIC5jdXR2YWx1ZTtcbiAgICAgICAgICAgICAgICBjdXRWYWx1ZSArPSBwb2ludHNUb0hlYWQgPyAtb3RoZXJDdXRWYWx1ZSA6IG90aGVyQ3V0VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gY3V0VmFsdWU7XG59O1xuZXhwb3J0IGNvbnN0IGluaXRMb3dMaW1WYWx1ZXMgPSAodHJlZSwgcm9vdCA9IHRyZWUuZ2V0QWxsTm9kZXMoKVswXS5pZCkgPT4ge1xuICAgIGRmc0Fzc2lnbkxvd0xpbSh0cmVlLCB7fSwgMSwgcm9vdCk7XG59O1xuY29uc3QgZGZzQXNzaWduTG93TGltID0gKHRyZWUsIHZpc2l0ZWQsIG5leHRMaW0sIHYsIHBhcmVudCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBsb3cgPSBuZXh0TGltO1xuICAgIGxldCB1c2VOZXh0TGltID0gbmV4dExpbTtcbiAgICBjb25zdCBsYWJlbCA9IHRyZWUuZ2V0Tm9kZSh2KTtcbiAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcbiAgICAoX2EgPSB0cmVlLmdldE5laWdoYm9ycyh2KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKHcpID0+IHtcbiAgICAgICAgaWYgKCF2aXNpdGVkW3cuaWRdKSB7XG4gICAgICAgICAgICB1c2VOZXh0TGltID0gZGZzQXNzaWduTG93TGltKHRyZWUsIHZpc2l0ZWQsIHVzZU5leHRMaW0sIHcuaWQsIHYpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGFiZWwuZGF0YS5sb3cgPSBsb3c7XG4gICAgbGFiZWwuZGF0YS5saW0gPSB1c2VOZXh0TGltKys7XG4gICAgaWYgKHBhcmVudCkge1xuICAgICAgICBsYWJlbC5kYXRhLnBhcmVudCA9IHBhcmVudDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFRPRE8gc2hvdWxkIGJlIGFibGUgdG8gcmVtb3ZlIHRoaXMgd2hlbiB3ZSBpbmNyZW1lbnRhbGx5IHVwZGF0ZSBsb3cgbGltXG4gICAgICAgIGRlbGV0ZSBsYWJlbC5kYXRhLnBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHVzZU5leHRMaW07XG59O1xuZXhwb3J0IGNvbnN0IGxlYXZlRWRnZSA9ICh0cmVlKSA9PiB7XG4gICAgcmV0dXJuIHRyZWUuZ2V0QWxsRWRnZXMoKS5maW5kKChlKSA9PiB7XG4gICAgICAgIHJldHVybiBlLmRhdGEuY3V0dmFsdWUgPCAwO1xuICAgIH0pO1xufTtcbmV4cG9ydCBjb25zdCBlbnRlckVkZ2UgPSAodCwgZywgZWRnZSkgPT4ge1xuICAgIGxldCB2ID0gZWRnZS5zb3VyY2U7XG4gICAgbGV0IHcgPSBlZGdlLnRhcmdldDtcbiAgICAvLyBGb3IgdGhlIHJlc3Qgb2YgdGhpcyBmdW5jdGlvbiB3ZSBhc3N1bWUgdGhhdCB2IGlzIHRoZSB0YWlsIGFuZCB3IGlzIHRoZVxuICAgIC8vIGhlYWQsIHNvIGlmIHdlIGRvbid0IGhhdmUgdGhpcyBlZGdlIGluIHRoZSBncmFwaCB3ZSBzaG91bGQgZmxpcCBpdCB0b1xuICAgIC8vIG1hdGNoIHRoZSBjb3JyZWN0IG9yaWVudGF0aW9uLlxuICAgIGlmICghZy5nZXRSZWxhdGVkRWRnZXModiwgJ291dCcpLmZpbmQoKGUpID0+IGUudGFyZ2V0ID09PSB3KSkge1xuICAgICAgICB2ID0gZWRnZS50YXJnZXQ7XG4gICAgICAgIHcgPSBlZGdlLnNvdXJjZTtcbiAgICB9XG4gICAgY29uc3QgdkxhYmVsID0gdC5nZXROb2RlKHYpO1xuICAgIGNvbnN0IHdMYWJlbCA9IHQuZ2V0Tm9kZSh3KTtcbiAgICBsZXQgdGFpbExhYmVsID0gdkxhYmVsO1xuICAgIGxldCBmbGlwID0gZmFsc2U7XG4gICAgLy8gSWYgdGhlIHJvb3QgaXMgaW4gdGhlIHRhaWwgb2YgdGhlIGVkZ2UgdGhlbiB3ZSBuZWVkIHRvIGZsaXAgdGhlIGxvZ2ljIHRoYXRcbiAgICAvLyBjaGVja3MgZm9yIHRoZSBoZWFkIGFuZCB0YWlsIG5vZGVzIGluIHRoZSBjYW5kaWRhdGVzIGZ1bmN0aW9uIGJlbG93LlxuICAgIGlmICh2TGFiZWwuZGF0YS5saW0gPiB3TGFiZWwuZGF0YS5saW0pIHtcbiAgICAgICAgdGFpbExhYmVsID0gd0xhYmVsO1xuICAgICAgICBmbGlwID0gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgY2FuZGlkYXRlcyA9IGcuZ2V0QWxsRWRnZXMoKS5maWx0ZXIoKGVkZ2UpID0+IHtcbiAgICAgICAgcmV0dXJuIChmbGlwID09PSBpc0Rlc2NlbmRhbnQodC5nZXROb2RlKGVkZ2Uuc291cmNlKSwgdGFpbExhYmVsKSAmJlxuICAgICAgICAgICAgZmxpcCAhPT0gaXNEZXNjZW5kYW50KHQuZ2V0Tm9kZShlZGdlLnRhcmdldCksIHRhaWxMYWJlbCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBtaW5CeShjYW5kaWRhdGVzLCAoZWRnZSkgPT4ge1xuICAgICAgICByZXR1cm4gc2xhY2soZywgZWRnZSk7XG4gICAgfSk7XG59O1xuLyoqXG4gKlxuICogQHBhcmFtIHRcbiAqIEBwYXJhbSBnXG4gKiBAcGFyYW0gZSBlZGdlIHRvIHJlbW92ZVxuICogQHBhcmFtIGYgZWRnZSB0byBhZGRcbiAqL1xuZXhwb3J0IGNvbnN0IGV4Y2hhbmdlRWRnZXMgPSAodCwgZywgZSwgZikgPT4ge1xuICAgIC8vIEZJWE1FOiB1c2UgdW5kaXJlY3RlZCBlZGdlP1xuICAgIGNvbnN0IGV4aXN0ZWQgPSB0XG4gICAgICAgIC5nZXRSZWxhdGVkRWRnZXMoZS5zb3VyY2UsICdib3RoJylcbiAgICAgICAgLmZpbmQoKGVkZ2UpID0+IGVkZ2Uuc291cmNlID09PSBlLnRhcmdldCB8fCBlZGdlLnRhcmdldCA9PT0gZS50YXJnZXQpO1xuICAgIGlmIChleGlzdGVkKSB7XG4gICAgICAgIHQucmVtb3ZlRWRnZShleGlzdGVkLmlkKTtcbiAgICB9XG4gICAgdC5hZGRFZGdlKHtcbiAgICAgICAgaWQ6IGBlJHtNYXRoLnJhbmRvbSgpfWAsXG4gICAgICAgIHNvdXJjZTogZi5zb3VyY2UsXG4gICAgICAgIHRhcmdldDogZi50YXJnZXQsXG4gICAgICAgIGRhdGE6IHt9LFxuICAgIH0pO1xuICAgIGluaXRMb3dMaW1WYWx1ZXModCk7XG4gICAgaW5pdEN1dFZhbHVlcyh0LCBnKTtcbiAgICB1cGRhdGVSYW5rcyh0LCBnKTtcbn07XG5jb25zdCB1cGRhdGVSYW5rcyA9ICh0LCBnKSA9PiB7XG4gICAgY29uc3Qgcm9vdCA9IHQuZ2V0QWxsTm9kZXMoKS5maW5kKCh2KSA9PiB7XG4gICAgICAgIHJldHVybiAhdi5kYXRhLnBhcmVudDtcbiAgICB9KTtcbiAgICBsZXQgdnMgPSBkZnModCwgcm9vdCwgJ3ByZScsIGZhbHNlKTtcbiAgICB2cyA9IHZzLnNsaWNlKDEpO1xuICAgIHZzLmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gdC5nZXROb2RlKHYpLmRhdGEucGFyZW50O1xuICAgICAgICBsZXQgZWRnZSA9IGcuZ2V0UmVsYXRlZEVkZ2VzKHYsICdvdXQnKS5maW5kKChlKSA9PiBlLnRhcmdldCA9PT0gcGFyZW50KTtcbiAgICAgICAgLy8gbGV0IGVkZ2UgPSBnLmVkZ2VGcm9tQXJncyh2LCBwYXJlbnQpO1xuICAgICAgICBsZXQgZmxpcHBlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoIWVkZ2UgJiYgZy5oYXNOb2RlKHBhcmVudCkpIHtcbiAgICAgICAgICAgIC8vIGVkZ2UgPSBnLmVkZ2VGcm9tQXJncyhwYXJlbnQsIHYpITtcbiAgICAgICAgICAgIGVkZ2UgPSBnLmdldFJlbGF0ZWRFZGdlcyhwYXJlbnQsICdvdXQnKS5maW5kKChlKSA9PiBlLnRhcmdldCA9PT0gdik7XG4gICAgICAgICAgICBmbGlwcGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBnLmdldE5vZGUodikuZGF0YS5yYW5rID1cbiAgICAgICAgICAgICgoZy5oYXNOb2RlKHBhcmVudCkgJiYgZy5nZXROb2RlKHBhcmVudCkuZGF0YS5yYW5rKSB8fCAwKSArXG4gICAgICAgICAgICAgICAgKGZsaXBwZWQgPyBlZGdlID09PSBudWxsIHx8IGVkZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVkZ2UuZGF0YS5taW5sZW4gOiAtKGVkZ2UgPT09IG51bGwgfHwgZWRnZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWRnZS5kYXRhLm1pbmxlbikpO1xuICAgIH0pO1xufTtcbi8qXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGVkZ2UgaXMgaW4gdGhlIHRyZWUuXG4gKi9cbmNvbnN0IGlzVHJlZUVkZ2UgPSAodHJlZSwgdSwgdikgPT4ge1xuICAgIC8vIEZJWE1FOiB1c2UgdW5kaXJlY3RlZCBlZGdlP1xuICAgIHJldHVybiB0cmVlXG4gICAgICAgIC5nZXRSZWxhdGVkRWRnZXModSwgJ2JvdGgnKVxuICAgICAgICAuZmluZCgoZSkgPT4gZS5zb3VyY2UgPT09IHYgfHwgZS50YXJnZXQgPT09IHYpO1xufTtcbi8qXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHNwZWNpZmllZCBub2RlIGlzIGRlc2NlbmRhbnQgb2YgdGhlIHJvb3Qgbm9kZSBwZXIgdGhlXG4gKiBhc3NpZ25lZCBsb3cgYW5kIGxpbSBhdHRyaWJ1dGVzIGluIHRoZSB0cmVlLlxuICovXG5jb25zdCBpc0Rlc2NlbmRhbnQgPSAodkxhYmVsLCByb290TGFiZWwpID0+IHtcbiAgICByZXR1cm4gKHJvb3RMYWJlbC5kYXRhLmxvdyA8PSB2TGFiZWwuZGF0YS5saW0gJiZcbiAgICAgICAgdkxhYmVsLmRhdGEubGltIDw9IHJvb3RMYWJlbC5kYXRhLmxpbSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmV0d29yay1zaW1wbGV4LmpzLm1hcCIsIi8qXG4gKiBJbml0aWFsaXplcyByYW5rcyBmb3IgdGhlIGlucHV0IGdyYXBoIHVzaW5nIHRoZSBsb25nZXN0IHBhdGggYWxnb3JpdGhtLiBUaGlzXG4gKiBhbGdvcml0aG0gc2NhbGVzIHdlbGwgYW5kIGlzIGZhc3QgaW4gcHJhY3RpY2UsIGl0IHlpZWxkcyByYXRoZXIgcG9vclxuICogc29sdXRpb25zLiBOb2RlcyBhcmUgcHVzaGVkIHRvIHRoZSBsb3dlc3QgbGF5ZXIgcG9zc2libGUsIGxlYXZpbmcgdGhlIGJvdHRvbVxuICogcmFua3Mgd2lkZSBhbmQgbGVhdmluZyBlZGdlcyBsb25nZXIgdGhhbiBuZWNlc3NhcnkuIEhvd2V2ZXIsIGR1ZSB0byBpdHNcbiAqIHNwZWVkLCB0aGlzIGFsZ29yaXRobSBpcyBnb29kIGZvciBnZXR0aW5nIGFuIGluaXRpYWwgcmFua2luZyB0aGF0IGNhbiBiZSBmZWRcbiAqIGludG8gb3RoZXIgYWxnb3JpdGhtcy5cbiAqXG4gKiBUaGlzIGFsZ29yaXRobSBkb2VzIG5vdCBub3JtYWxpemUgbGF5ZXJzIGJlY2F1c2UgaXQgd2lsbCBiZSB1c2VkIGJ5IG90aGVyXG4gKiBhbGdvcml0aG1zIGluIG1vc3QgY2FzZXMuIElmIHVzaW5nIHRoaXMgYWxnb3JpdGhtIGRpcmVjdGx5LCBiZSBzdXJlIHRvXG4gKiBydW4gbm9ybWFsaXplIGF0IHRoZSBlbmQuXG4gKlxuICogUHJlLWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gSW5wdXQgZ3JhcGggaXMgYSBEQUcuXG4gKiAgICAyLiBJbnB1dCBncmFwaCBub2RlIGxhYmVscyBjYW4gYmUgYXNzaWduZWQgcHJvcGVydGllcy5cbiAqXG4gKiBQb3N0LWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gRWFjaCBub2RlIHdpbGwgYmUgYXNzaWduIGFuICh1bm5vcm1hbGl6ZWQpIFwicmFua1wiIHByb3BlcnR5LlxuICovXG5jb25zdCBsb25nZXN0UGF0aCA9IChnKSA9PiB7XG4gICAgY29uc3QgdmlzaXRlZCA9IHt9O1xuICAgIGNvbnN0IGRmcyA9ICh2KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBnLmdldE5vZGUodik7XG4gICAgICAgIGlmICghbGFiZWwpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgaWYgKHZpc2l0ZWRbdl0pIHtcbiAgICAgICAgICAgIHJldHVybiBsYWJlbC5kYXRhLnJhbms7XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRlZFt2XSA9IHRydWU7XG4gICAgICAgIGxldCByYW5rO1xuICAgICAgICAoX2EgPSBnLmdldFJlbGF0ZWRFZGdlcyh2LCAnb3V0JykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3UmFuayA9IGRmcyhlLnRhcmdldCk7XG4gICAgICAgICAgICBjb25zdCBtaW5MZW4gPSBlLmRhdGEubWlubGVuO1xuICAgICAgICAgICAgY29uc3QgciA9IHdSYW5rIC0gbWluTGVuO1xuICAgICAgICAgICAgaWYgKHIpIHtcbiAgICAgICAgICAgICAgICBpZiAocmFuayA9PT0gdW5kZWZpbmVkIHx8IHIgPCByYW5rKSB7XG4gICAgICAgICAgICAgICAgICAgIHJhbmsgPSByO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghcmFuaykge1xuICAgICAgICAgICAgcmFuayA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGFiZWwuZGF0YS5yYW5rID0gcmFuaztcbiAgICAgICAgcmV0dXJuIHJhbms7XG4gICAgfTtcbiAgICBnLmdldEFsbE5vZGVzKClcbiAgICAgICAgLmZpbHRlcigobikgPT4gZy5nZXRSZWxhdGVkRWRnZXMobi5pZCwgJ2luJykubGVuZ3RoID09PSAwKVxuICAgICAgICAuZm9yRWFjaCgoc291cmNlKSA9PiBkZnMoc291cmNlLmlkKSk7XG59O1xuY29uc3QgbG9uZ2VzdFBhdGhXaXRoTGF5ZXIgPSAoZykgPT4ge1xuICAgIC8vIOeUqGxvbmdlc3QgcGF0aO+8jOaJvuWHuuacgOa3seeahOeCuVxuICAgIGNvbnN0IHZpc2l0ZWQgPSB7fTtcbiAgICBsZXQgbWluUmFuaztcbiAgICBjb25zdCBkZnMgPSAodikgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gZy5nZXROb2RlKHYpO1xuICAgICAgICBpZiAoIWxhYmVsKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGlmICh2aXNpdGVkW3ZdKSB7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWwuZGF0YS5yYW5rO1xuICAgICAgICB9XG4gICAgICAgIHZpc2l0ZWRbdl0gPSB0cnVlO1xuICAgICAgICBsZXQgcmFuaztcbiAgICAgICAgKF9hID0gZy5nZXRSZWxhdGVkRWRnZXModiwgJ291dCcpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgd1JhbmsgPSBkZnMoZS50YXJnZXQpO1xuICAgICAgICAgICAgY29uc3QgbWluTGVuID0gZS5kYXRhLm1pbmxlbjtcbiAgICAgICAgICAgIGNvbnN0IHIgPSB3UmFuayAtIG1pbkxlbjtcbiAgICAgICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmsgPT09IHVuZGVmaW5lZCB8fCByIDwgcmFuaykge1xuICAgICAgICAgICAgICAgICAgICByYW5rID0gcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJhbmspIHtcbiAgICAgICAgICAgIHJhbmsgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW5SYW5rID09PSB1bmRlZmluZWQgfHwgcmFuayA8IG1pblJhbmspIHtcbiAgICAgICAgICAgIG1pblJhbmsgPSByYW5rO1xuICAgICAgICB9XG4gICAgICAgIGxhYmVsLmRhdGEucmFuayA9IHJhbms7XG4gICAgICAgIHJldHVybiByYW5rO1xuICAgIH07XG4gICAgZy5nZXRBbGxOb2RlcygpXG4gICAgICAgIC5maWx0ZXIoKG4pID0+IGcuZ2V0UmVsYXRlZEVkZ2VzKG4uaWQsICdpbicpLmxlbmd0aCA9PT0gMClcbiAgICAgICAgLmZvckVhY2goKHNvdXJjZSkgPT4ge1xuICAgICAgICBpZiAoc291cmNlKVxuICAgICAgICAgICAgZGZzKHNvdXJjZS5pZCk7XG4gICAgfSk7XG4gICAgaWYgKG1pblJhbmsgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBtaW5SYW5rID0gMDtcbiAgICB9XG4gICAgLy8gbWluUmFuayArPSAxOyAvLyBOT1RFOiDmnIDlsI/nmoTlsYLnuqfmmK9kdW1teSByb29077yMKzFcbiAgICAvLyBmb3J3YXJk5LiA6YGN77yM6LWL5YC85bGC57qnXG4gICAgY29uc3QgZm9yd2FyZFZpc2l0ZWQgPSB7fTtcbiAgICBjb25zdCBkZnNGb3J3YXJkID0gKHYsIG5leHRSYW5rKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBnLmdldE5vZGUodik7XG4gICAgICAgIGNvbnN0IGN1cnJSYW5rID0gIWlzTmFOKGxhYmVsLmRhdGEubGF5ZXIpID8gbGFiZWwuZGF0YS5sYXllciA6IG5leHRSYW5rO1xuICAgICAgICAvLyDmsqHmnInmjIflrprvvIzlj5bmnIDlpKflgLxcbiAgICAgICAgaWYgKGxhYmVsLmRhdGEucmFuayA9PT0gdW5kZWZpbmVkIHx8IGxhYmVsLmRhdGEucmFuayA8IGN1cnJSYW5rKSB7XG4gICAgICAgICAgICBsYWJlbC5kYXRhLnJhbmsgPSBjdXJyUmFuaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9yd2FyZFZpc2l0ZWRbdl0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGZvcndhcmRWaXNpdGVkW3ZdID0gdHJ1ZTtcbiAgICAgICAgLy8gREZT6YGN5Y6G5a2Q6IqC54K5XG4gICAgICAgIChfYSA9IGcuZ2V0UmVsYXRlZEVkZ2VzKHYsICdvdXQnKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgICAgIGRmc0ZvcndhcmQoZS50YXJnZXQsIGN1cnJSYW5rICsgZS5kYXRhLm1pbmxlbik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8g5oyH5a6a5bGC57qn55qE77yM5pu05paw5LiL5ri4XG4gICAgZy5nZXRBbGxOb2RlcygpLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBuLmRhdGE7XG4gICAgICAgIGlmICghbGFiZWwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghaXNOYU4obGFiZWwubGF5ZXIpKSB7XG4gICAgICAgICAgICBkZnNGb3J3YXJkKG4uaWQsIGxhYmVsLmxheWVyKTsgLy8g6buY6K6k55qEZHVtbXkgcm9vdOaJgOWcqOWxgueahHJhbmvmmK8tMVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGFiZWwucmFuayAtPSBtaW5SYW5rO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuLypcbiAqIFJldHVybnMgdGhlIGFtb3VudCBvZiBzbGFjayBmb3IgdGhlIGdpdmVuIGVkZ2UuIFRoZSBzbGFjayBpcyBkZWZpbmVkIGFzIHRoZVxuICogZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBsZW5ndGggb2YgdGhlIGVkZ2UgYW5kIGl0cyBtaW5pbXVtIGxlbmd0aC5cbiAqL1xuY29uc3Qgc2xhY2sgPSAoZywgZSkgPT4ge1xuICAgIHJldHVybiAoZy5nZXROb2RlKGUudGFyZ2V0KS5kYXRhLnJhbmsgLVxuICAgICAgICBnLmdldE5vZGUoZS5zb3VyY2UpLmRhdGEucmFuayAtXG4gICAgICAgIGUuZGF0YS5taW5sZW4pO1xufTtcbmV4cG9ydCB7IGxvbmdlc3RQYXRoLCBsb25nZXN0UGF0aFdpdGhMYXllciwgc2xhY2sgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIiwiaW1wb3J0IHsgR3JhcGggfSBmcm9tICdAYW50di9ncmFwaGxpYic7XG5pbXBvcnQgeyBpc051bWJlciB9IGZyb20gJ0BhbnR2L3V0aWwnO1xuY29uc3Qgc2FmZVNvcnQgPSAodmFsdWVBLCB2YWx1ZUIpID0+IHtcbiAgICByZXR1cm4gTnVtYmVyKHZhbHVlQSkgLSBOdW1iZXIodmFsdWVCKTtcbn07XG4vKlxuICogQWRkcyBhIGR1bW15IG5vZGUgdG8gdGhlIGdyYXBoIGFuZCByZXR1cm4gdi5cbiAqL1xuZXhwb3J0IGNvbnN0IGFkZER1bW15Tm9kZSA9IChnLCB0eXBlLCBkYXRhLCBuYW1lKSA9PiB7XG4gICAgbGV0IHY7XG4gICAgZG8ge1xuICAgICAgICB2ID0gYCR7bmFtZX0ke01hdGgucmFuZG9tKCl9YDtcbiAgICB9IHdoaWxlIChnLmhhc05vZGUodikpO1xuICAgIGRhdGEuZHVtbXkgPSB0eXBlO1xuICAgIGcuYWRkTm9kZSh7XG4gICAgICAgIGlkOiB2LFxuICAgICAgICBkYXRhLFxuICAgIH0pO1xuICAgIHJldHVybiB2O1xufTtcbi8qXG4gKiBSZXR1cm5zIGEgbmV3IGdyYXBoIHdpdGggb25seSBzaW1wbGUgZWRnZXMuIEhhbmRsZXMgYWdncmVnYXRpb24gb2YgZGF0YVxuICogYXNzb2NpYXRlZCB3aXRoIG11bHRpLWVkZ2VzLlxuICovXG5leHBvcnQgY29uc3Qgc2ltcGxpZnkgPSAoZykgPT4ge1xuICAgIGNvbnN0IHNpbXBsaWZpZWQgPSBuZXcgR3JhcGgoKTtcbiAgICBnLmdldEFsbE5vZGVzKCkuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICBzaW1wbGlmaWVkLmFkZE5vZGUoT2JqZWN0LmFzc2lnbih7fSwgdikpO1xuICAgIH0pO1xuICAgIGcuZ2V0QWxsRWRnZXMoKS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgIGNvbnN0IGVkZ2UgPSBzaW1wbGlmaWVkXG4gICAgICAgICAgICAuZ2V0UmVsYXRlZEVkZ2VzKGUuc291cmNlLCAnb3V0JylcbiAgICAgICAgICAgIC5maW5kKChlZGdlKSA9PiBlZGdlLnRhcmdldCA9PT0gZS50YXJnZXQpO1xuICAgICAgICBpZiAoIWVkZ2UpIHtcbiAgICAgICAgICAgIHNpbXBsaWZpZWQuYWRkRWRnZSh7XG4gICAgICAgICAgICAgICAgaWQ6IGUuaWQsXG4gICAgICAgICAgICAgICAgc291cmNlOiBlLnNvdXJjZSxcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IGUudGFyZ2V0LFxuICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgd2VpZ2h0OiBlLmRhdGEud2VpZ2h0IHx8IDAsXG4gICAgICAgICAgICAgICAgICAgIG1pbmxlbjogZS5kYXRhLm1pbmxlbiB8fCAxLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNpbXBsaWZpZWQudXBkYXRlRWRnZURhdGEoZWRnZSA9PT0gbnVsbCB8fCBlZGdlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlZGdlLmlkLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVkZ2UuZGF0YSksIHsgd2VpZ2h0OiBlZGdlLmRhdGEud2VpZ2h0ICsgZS5kYXRhLndlaWdodCB8fCAwLCBtaW5sZW46IE1hdGgubWF4KGVkZ2UuZGF0YS5taW5sZW4sIGUuZGF0YS5taW5sZW4gfHwgMSkgfSkpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNpbXBsaWZpZWQ7XG59O1xuZXhwb3J0IGNvbnN0IGFzTm9uQ29tcG91bmRHcmFwaCA9IChnKSA9PiB7XG4gICAgY29uc3Qgc2ltcGxpZmllZCA9IG5ldyBHcmFwaCgpO1xuICAgIGcuZ2V0QWxsTm9kZXMoKS5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgIGlmICghZy5nZXRDaGlsZHJlbihub2RlLmlkKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNpbXBsaWZpZWQuYWRkTm9kZShPYmplY3QuYXNzaWduKHt9LCBub2RlKSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBnLmdldEFsbEVkZ2VzKCkuZm9yRWFjaCgoZWRnZSkgPT4ge1xuICAgICAgICBzaW1wbGlmaWVkLmFkZEVkZ2UoZWRnZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNpbXBsaWZpZWQ7XG59O1xuZXhwb3J0IGNvbnN0IHppcE9iamVjdCA9IChrZXlzLCB2YWx1ZXMpID0+IHtcbiAgICByZXR1cm4ga2V5cyA9PT0gbnVsbCB8fCBrZXlzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBrZXlzLnJlZHVjZSgob2JqLCBrZXksIGkpID0+IHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZXNbaV07XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSwge30pO1xufTtcbmV4cG9ydCBjb25zdCBzdWNjZXNzb3JXZWlnaHRzID0gKGcpID0+IHtcbiAgICBjb25zdCB3ZWlnaHRzTWFwID0ge307XG4gICAgZy5nZXRBbGxOb2RlcygpLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3Qgc3VjcyA9IHt9O1xuICAgICAgICBnLmdldFJlbGF0ZWRFZGdlcyhub2RlLmlkLCAnb3V0JykuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICAgICAgc3Vjc1tlLnRhcmdldF0gPSAoc3Vjc1tlLnRhcmdldF0gfHwgMCkgKyAoZS5kYXRhLndlaWdodCB8fCAwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHdlaWdodHNNYXBbbm9kZS5pZF0gPSBzdWNzO1xuICAgIH0pO1xuICAgIHJldHVybiB3ZWlnaHRzTWFwO1xufTtcbmV4cG9ydCBjb25zdCBwcmVkZWNlc3NvcldlaWdodHMgPSAoZykgPT4ge1xuICAgIGNvbnN0IG5vZGVzID0gZy5nZXRBbGxOb2RlcygpO1xuICAgIGNvbnN0IHdlaWdodE1hcCA9IG5vZGVzLm1hcCgodikgPT4ge1xuICAgICAgICBjb25zdCBwcmVkcyA9IHt9O1xuICAgICAgICBnLmdldFJlbGF0ZWRFZGdlcyh2LmlkLCAnaW4nKS5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgICAgICBwcmVkc1tlLnNvdXJjZV0gPSAocHJlZHNbZS5zb3VyY2VdIHx8IDApICsgZS5kYXRhLndlaWdodDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcmVkcztcbiAgICB9KTtcbiAgICByZXR1cm4gemlwT2JqZWN0KG5vZGVzLm1hcCgobikgPT4gbi5pZCksIHdlaWdodE1hcCk7XG59O1xuLypcbiAqIEZpbmRzIHdoZXJlIGEgbGluZSBzdGFydGluZyBhdCBwb2ludCAoe3gsIHl9KSB3b3VsZCBpbnRlcnNlY3QgYSByZWN0YW5nbGVcbiAqICh7eCwgeSwgd2lkdGgsIGhlaWdodH0pIGlmIGl0IHdlcmUgcG9pbnRpbmcgYXQgdGhlIHJlY3RhbmdsZSdzIGNlbnRlci5cbiAqL1xuZXhwb3J0IGNvbnN0IGludGVyc2VjdFJlY3QgPSAocmVjdCwgcG9pbnQpID0+IHtcbiAgICBjb25zdCB4ID0gTnVtYmVyKHJlY3QueCk7XG4gICAgY29uc3QgeSA9IE51bWJlcihyZWN0LnkpO1xuICAgIC8vIFJlY3RhbmdsZSBpbnRlcnNlY3Rpb24gYWxnb3JpdGhtIGZyb206XG4gICAgLy8gaHR0cDovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzEwODExMy9maW5kLWVkZ2UtYmV0d2Vlbi10d28tYm94ZXNcbiAgICBjb25zdCBkeCA9IE51bWJlcihwb2ludC54KSAtIHg7XG4gICAgY29uc3QgZHkgPSBOdW1iZXIocG9pbnQueSkgLSB5O1xuICAgIGxldCB3ID0gTnVtYmVyKHJlY3Qud2lkdGgpIC8gMjtcbiAgICBsZXQgaCA9IE51bWJlcihyZWN0LmhlaWdodCkgLyAyO1xuICAgIGlmICghZHggJiYgIWR5KSB7XG4gICAgICAgIC8vIGNvbXBsZXRlbHkgb3ZlcmxhcHBlZCBkaXJlY3RseSwgdGhlbiByZXR1cm4gcG9pbnRzIGl0cyBzZWxmXG4gICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbiAgICB9XG4gICAgbGV0IHN4O1xuICAgIGxldCBzeTtcbiAgICBpZiAoTWF0aC5hYnMoZHkpICogdyA+IE1hdGguYWJzKGR4KSAqIGgpIHtcbiAgICAgICAgLy8gSW50ZXJzZWN0aW9uIGlzIHRvcCBvciBib3R0b20gb2YgcmVjdC5cbiAgICAgICAgaWYgKGR5IDwgMCkge1xuICAgICAgICAgICAgaCA9IC1oO1xuICAgICAgICB9XG4gICAgICAgIHN4ID0gKGggKiBkeCkgLyBkeTtcbiAgICAgICAgc3kgPSBoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSW50ZXJzZWN0aW9uIGlzIGxlZnQgb3IgcmlnaHQgb2YgcmVjdC5cbiAgICAgICAgaWYgKGR4IDwgMCkge1xuICAgICAgICAgICAgdyA9IC13O1xuICAgICAgICB9XG4gICAgICAgIHN4ID0gdztcbiAgICAgICAgc3kgPSAodyAqIGR5KSAvIGR4O1xuICAgIH1cbiAgICByZXR1cm4geyB4OiB4ICsgc3gsIHk6IHkgKyBzeSB9O1xufTtcbi8qXG4gKiBHaXZlbiBhIERBRyB3aXRoIGVhY2ggbm9kZSBhc3NpZ25lZCBcInJhbmtcIiBhbmQgXCJvcmRlclwiIHByb3BlcnRpZXMsIHRoaXNcbiAqIGNvbnN0IHdpbGwgcHJvZHVjZSBhIG1hdHJpeCB3aXRoIHRoZSBpZHMgb2YgZWFjaCBub2RlLlxuICovXG5leHBvcnQgY29uc3QgYnVpbGRMYXllck1hdHJpeCA9IChnKSA9PiB7XG4gICAgY29uc3QgbGF5ZXJpbmdOb2RlcyA9IFtdO1xuICAgIGNvbnN0IHJhbmtNYXggPSBtYXhSYW5rKGcpICsgMTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJhbmtNYXg7IGkrKykge1xuICAgICAgICBsYXllcmluZ05vZGVzLnB1c2goW10pO1xuICAgIH1cbiAgICAvLyBjb25zdCBsYXllcmluZyA9IF8ubWFwKF8ucmFuZ2UobWF4UmFuayhnKSArIDEpLCBmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9KTtcbiAgICBnLmdldEFsbE5vZGVzKCkuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBjb25zdCByYW5rID0gbm9kZS5kYXRhLnJhbms7XG4gICAgICAgIGlmIChyYW5rICE9PSB1bmRlZmluZWQgJiYgbGF5ZXJpbmdOb2Rlc1tyYW5rXSkge1xuICAgICAgICAgICAgbGF5ZXJpbmdOb2Rlc1tyYW5rXS5wdXNoKG5vZGUuaWQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5rTWF4OyBpKyspIHtcbiAgICAgICAgbGF5ZXJpbmdOb2Rlc1tpXSA9IGxheWVyaW5nTm9kZXNbaV0uc29ydCgodmEsIHZiKSA9PiBzYWZlU29ydChnLmdldE5vZGUodmEpLmRhdGEub3JkZXIsIGcuZ2V0Tm9kZSh2YikuZGF0YS5vcmRlcikpO1xuICAgIH1cbiAgICByZXR1cm4gbGF5ZXJpbmdOb2Rlcztcbn07XG4vKlxuICogQWRqdXN0cyB0aGUgcmFua3MgZm9yIGFsbCBub2RlcyBpbiB0aGUgZ3JhcGggc3VjaCB0aGF0IGFsbCBub2RlcyB2IGhhdmVcbiAqIHJhbmsodikgPj0gMCBhbmQgYXQgbGVhc3Qgb25lIG5vZGUgdyBoYXMgcmFuayh3KSA9IDAuXG4gKi9cbmV4cG9ydCBjb25zdCBub3JtYWxpemVSYW5rcyA9IChnKSA9PiB7XG4gICAgY29uc3Qgbm9kZVJhbmtzID0gZ1xuICAgICAgICAuZ2V0QWxsTm9kZXMoKVxuICAgICAgICAuZmlsdGVyKCh2KSA9PiB2LmRhdGEucmFuayAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAubWFwKCh2KSA9PiB2LmRhdGEucmFuayk7XG4gICAgY29uc3QgbWluID0gTWF0aC5taW4oLi4ubm9kZVJhbmtzKTtcbiAgICBnLmdldEFsbE5vZGVzKCkuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICBpZiAodi5kYXRhLmhhc093blByb3BlcnR5KCdyYW5rJykgJiYgbWluICE9PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgdi5kYXRhLnJhbmsgLT0gbWluO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuZXhwb3J0IGNvbnN0IHJlbW92ZUVtcHR5UmFua3MgPSAoZywgbm9kZVJhbmtGYWN0b3IgPSAwKSA9PiB7XG4gICAgLy8gUmFua3MgbWF5IG5vdCBzdGFydCBhdCAwLCBzbyB3ZSBuZWVkIHRvIG9mZnNldCB0aGVtXG4gICAgY29uc3Qgbm9kZXMgPSBnLmdldEFsbE5vZGVzKCk7XG4gICAgY29uc3Qgbm9kZVJhbmtzID0gbm9kZXNcbiAgICAgICAgLmZpbHRlcigodikgPT4gdi5kYXRhLnJhbmsgIT09IHVuZGVmaW5lZClcbiAgICAgICAgLm1hcCgodikgPT4gdi5kYXRhLnJhbmspO1xuICAgIGNvbnN0IG9mZnNldCA9IE1hdGgubWluKC4uLm5vZGVSYW5rcyk7XG4gICAgY29uc3QgbGF5ZXJzID0gW107XG4gICAgbm9kZXMuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICBjb25zdCByYW5rID0gKHYuZGF0YS5yYW5rIHx8IDApIC0gb2Zmc2V0O1xuICAgICAgICBpZiAoIWxheWVyc1tyYW5rXSkge1xuICAgICAgICAgICAgbGF5ZXJzW3JhbmtdID0gW107XG4gICAgICAgIH1cbiAgICAgICAgbGF5ZXJzW3JhbmtdLnB1c2godi5pZCk7XG4gICAgfSk7XG4gICAgbGV0IGRlbHRhID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB2cyA9IGxheWVyc1tpXTtcbiAgICAgICAgaWYgKHZzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChpICUgbm9kZVJhbmtGYWN0b3IgIT09IDApIHtcbiAgICAgICAgICAgICAgICBkZWx0YSAtPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlbHRhKSB7XG4gICAgICAgICAgICB2cyA9PT0gbnVsbCB8fCB2cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdnMuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBnLmdldE5vZGUodik7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5kYXRhLnJhbmsgPSBub2RlLmRhdGEucmFuayB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBub2RlLmRhdGEucmFuayArPSBkZWx0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgYWRkQm9yZGVyTm9kZSA9IChnLCBwcmVmaXgsIHJhbmssIG9yZGVyKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICB9O1xuICAgIGlmIChpc051bWJlcihyYW5rKSAmJiBpc051bWJlcihvcmRlcikpIHtcbiAgICAgICAgbm9kZS5yYW5rID0gcmFuaztcbiAgICAgICAgbm9kZS5vcmRlciA9IG9yZGVyO1xuICAgIH1cbiAgICByZXR1cm4gYWRkRHVtbXlOb2RlKGcsICdib3JkZXInLCBub2RlLCBwcmVmaXgpO1xufTtcbmV4cG9ydCBjb25zdCBtYXhSYW5rID0gKGcpID0+IHtcbiAgICBsZXQgbWF4UmFuaztcbiAgICBnLmdldEFsbE5vZGVzKCkuZm9yRWFjaCgodikgPT4ge1xuICAgICAgICBjb25zdCByYW5rID0gdi5kYXRhLnJhbms7XG4gICAgICAgIGlmIChyYW5rICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChtYXhSYW5rID09PSB1bmRlZmluZWQgfHwgcmFuayA+IG1heFJhbmspIHtcbiAgICAgICAgICAgICAgICBtYXhSYW5rID0gcmFuaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghbWF4UmFuaykge1xuICAgICAgICBtYXhSYW5rID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIG1heFJhbms7XG59O1xuLypcbiAqIFBhcnRpdGlvbiBhIGNvbGxlY3Rpb24gaW50byB0d28gZ3JvdXBzOiBgbGhzYCBhbmQgYHJoc2AuIElmIHRoZSBzdXBwbGllZFxuICogY29uc3QgcmV0dXJucyB0cnVlIGZvciBhbiBlbnRyeSBpdCBnb2VzIGludG8gYGxoc2AuIE90aGVyd2lzZSBpdCBnb2VzXG4gKiBpbnRvIGByaHMuXG4gKi9cbmV4cG9ydCBjb25zdCBwYXJ0aXRpb24gPSAoY29sbGVjdGlvbiwgZm4pID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7IGxoczogW10sIHJoczogW10gfTtcbiAgICBjb2xsZWN0aW9uID09PSBudWxsIHx8IGNvbGxlY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbGxlY3Rpb24uZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKGZuKHZhbHVlKSkge1xuICAgICAgICAgICAgcmVzdWx0Lmxocy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5yaHMucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmV4cG9ydCBjb25zdCBtaW5CeSA9IChhcnJheSwgZnVuYykgPT4ge1xuICAgIHJldHVybiBhcnJheS5yZWR1Y2UoKGEsIGIpID0+IHtcbiAgICAgICAgY29uc3QgdmFsQSA9IGZ1bmMoYSk7XG4gICAgICAgIGNvbnN0IHZhbEIgPSBmdW5jKGIpO1xuICAgICAgICByZXR1cm4gdmFsQSA+IHZhbEIgPyBiIDogYTtcbiAgICB9KTtcbn07XG5jb25zdCBkb0RGUyA9IChncmFwaCwgbm9kZSwgcG9zdG9yZGVyLCB2aXNpdGVkLCBuYXZpZ2F0b3IsIHJlc3VsdCkgPT4ge1xuICAgIGlmICghdmlzaXRlZC5pbmNsdWRlcyhub2RlLmlkKSkge1xuICAgICAgICB2aXNpdGVkLnB1c2gobm9kZS5pZCk7XG4gICAgICAgIGlmICghcG9zdG9yZGVyKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChub2RlLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBuYXZpZ2F0b3Iobm9kZS5pZCkuZm9yRWFjaCgobikgPT4gZG9ERlMoZ3JhcGgsIG4sIHBvc3RvcmRlciwgdmlzaXRlZCwgbmF2aWdhdG9yLCByZXN1bHQpKTtcbiAgICAgICAgaWYgKHBvc3RvcmRlcikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9kZS5pZCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gREZTIHRyYXZlcnNhbC5cbiAqIEBkZXNjcmlwdGlvbi56aC1DTiBERlMg6YGN5Y6G44CCXG4gKi9cbmV4cG9ydCBjb25zdCBkZnMgPSAoZ3JhcGgsIG5vZGUsIG9yZGVyLCBpc0RpcmVjdGVkKSA9PiB7XG4gICAgY29uc3Qgbm9kZXMgPSBBcnJheS5pc0FycmF5KG5vZGUpID8gbm9kZSA6IFtub2RlXTtcbiAgICBjb25zdCBuYXZpZ2F0b3IgPSAobikgPT4gKGlzRGlyZWN0ZWQgPyBncmFwaC5nZXRTdWNjZXNzb3JzKG4pIDogZ3JhcGguZ2V0TmVpZ2hib3JzKG4pKTtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgY29uc3QgdmlzaXRlZCA9IFtdO1xuICAgIG5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgaWYgKCFncmFwaC5oYXNOb2RlKG5vZGUuaWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdyYXBoIGRvZXMgbm90IGhhdmUgbm9kZTogJHtub2RlfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZG9ERlMoZ3JhcGgsIG5vZGUsIG9yZGVyID09PSAncG9zdCcsIHZpc2l0ZWQsIG5hdmlnYXRvciwgcmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgY2xvbmVGb3JtYXREYXRhLCBmb3JtYXROdW1iZXJGbiwgZm9ybWF0U2l6ZUZuIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IGhhbmRsZVNpbmdsZU5vZGVHcmFwaCB9IGZyb20gJy4vdXRpbC9jb21tb24nO1xuY29uc3QgREVGQVVMVFNfTEFZT1VUX09QVElPTlMgPSB7XG4gICAgcmFkaXVzOiBudWxsLFxuICAgIHN0YXJ0UmFkaXVzOiBudWxsLFxuICAgIGVuZFJhZGl1czogbnVsbCxcbiAgICBzdGFydEFuZ2xlOiAwLFxuICAgIGVuZEFuZ2xlOiAyICogTWF0aC5QSSxcbiAgICBjbG9ja3dpc2U6IHRydWUsXG4gICAgZGl2aXNpb25zOiAxLFxuICAgIG9yZGVyaW5nOiBudWxsLFxuICAgIGFuZ2xlUmF0aW86IDEsXG59O1xuLyoqXG4gKiA8emgvPiDnjq/lvaLluIPlsYBcbiAqXG4gKiA8ZW4vPiBDaXJjdWxhciBsYXlvdXRcbiAqL1xuZXhwb3J0IGNsYXNzIENpcmN1bGFyTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5pZCA9ICdjaXJjdWxhcic7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVFNfTEFZT1VUX09QVElPTlMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBwb3NpdGlvbnMgb2Ygbm9kZXMgYW5kIGVkZ2VzKGlmIG5lZWRlZCkuXG4gICAgICovXG4gICAgZXhlY3V0ZShncmFwaCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJpY0NpcmN1bGFyTGF5b3V0KGZhbHNlLCBncmFwaCwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUbyBkaXJlY3RseSBhc3NpZ24gdGhlIHBvc2l0aW9ucyB0byB0aGUgbm9kZXMuXG4gICAgICovXG4gICAgYXNzaWduKGdyYXBoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdlbmVyaWNDaXJjdWxhckxheW91dCh0cnVlLCBncmFwaCwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZW5lcmljQ2lyY3VsYXJMYXlvdXQoYXNzaWduLCBncmFwaCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIGNlbnRlciwgZGl2aXNpb25zLCBzdGFydEFuZ2xlID0gMCwgZW5kQW5nbGUgPSAyICogTWF0aC5QSSwgYW5nbGVSYXRpbywgb3JkZXJpbmcsIGNsb2Nrd2lzZSwgbm9kZVNwYWNpbmc6IHBhcmFtTm9kZVNwYWNpbmcsIG5vZGVTaXplOiBwYXJhbU5vZGVTaXplLCB9ID0gbWVyZ2VkT3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gZ3JhcGguZ2V0QWxsTm9kZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGVkZ2VzID0gZ3JhcGguZ2V0QWxsRWRnZXMoKTtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBjZW50ZXIgYWNjb3JkaW5nIHRvIGB3aW5kb3dgIGlmIG5vdCBwcm92aWRlZC5cbiAgICAgICAgICAgIGNvbnN0IFtjYWxjdWxhdGVkV2lkdGgsIGNhbGN1bGF0ZWRIZWlnaHQsIGNhbGN1bGF0ZWRDZW50ZXJdID0gY2FsY3VsYXRlQ2VudGVyKHdpZHRoLCBoZWlnaHQsIGNlbnRlcik7XG4gICAgICAgICAgICBjb25zdCBuID0gbm9kZXMgPT09IG51bGwgfHwgbm9kZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICghbiB8fCBuID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVNpbmdsZU5vZGVHcmFwaChncmFwaCwgYXNzaWduLCBjYWxjdWxhdGVkQ2VudGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFuZ2xlU3RlcCA9IChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUpIC8gbjtcbiAgICAgICAgICAgIGxldCB7IHJhZGl1cywgc3RhcnRSYWRpdXMsIGVuZFJhZGl1cyB9ID0gbWVyZ2VkT3B0aW9ucztcbiAgICAgICAgICAgIGlmIChwYXJhbU5vZGVTcGFjaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVNwYWNpbmcgPSBmb3JtYXROdW1iZXJGbigxMCwgcGFyYW1Ob2RlU3BhY2luZyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVNpemUgPSBmb3JtYXRTaXplRm4oMTAsIHBhcmFtTm9kZVNpemUpO1xuICAgICAgICAgICAgICAgIGxldCBtYXhOb2RlU2l6ZSA9IC1JbmZpbml0eTtcbiAgICAgICAgICAgICAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5TaXplID0gbm9kZVNpemUobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXhOb2RlU2l6ZSA8IG5TaXplKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4Tm9kZVNpemUgPSBuU2l6ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBsZXQgcGVyaW1ldGVyID0gMDtcbiAgICAgICAgICAgICAgICBub2Rlcy5mb3JFYWNoKChub2RlLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyaW1ldGVyICs9IG1heE5vZGVTaXplIHx8IDEwO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBwZXJpbWV0ZXIgKz0gKG5vZGVTcGFjaW5nKG5vZGUpIHx8IDApICsgKG1heE5vZGVTaXplIHx8IDEwKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByYWRpdXMgPSBwZXJpbWV0ZXIgLyAoMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXJhZGl1cyAmJiAhc3RhcnRSYWRpdXMgJiYgIWVuZFJhZGl1cykge1xuICAgICAgICAgICAgICAgIHJhZGl1cyA9IE1hdGgubWluKGNhbGN1bGF0ZWRIZWlnaHQsIGNhbGN1bGF0ZWRXaWR0aCkgLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXN0YXJ0UmFkaXVzICYmIGVuZFJhZGl1cykge1xuICAgICAgICAgICAgICAgIHN0YXJ0UmFkaXVzID0gZW5kUmFkaXVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhcnRSYWRpdXMgJiYgIWVuZFJhZGl1cykge1xuICAgICAgICAgICAgICAgIGVuZFJhZGl1cyA9IHN0YXJ0UmFkaXVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXN0ZXAgPSBhbmdsZVN0ZXAgKiBhbmdsZVJhdGlvO1xuICAgICAgICAgICAgLy8gY2FsY3VsYXRlZCBub2RlcyBhcyB0ZW1wb3JhcnkgcmVzdWx0XG4gICAgICAgICAgICBsZXQgbGF5b3V0Tm9kZXMgPSBbXTtcbiAgICAgICAgICAgIGlmIChvcmRlcmluZyA9PT0gJ3RvcG9sb2d5Jykge1xuICAgICAgICAgICAgICAgIC8vIGxheW91dCBhY2NvcmRpbmcgdG8gdGhlIHRvcG9sb2d5XG4gICAgICAgICAgICAgICAgbGF5b3V0Tm9kZXMgPSB0b3BvbG9neU9yZGVyaW5nKGdyYXBoLCBub2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcmRlcmluZyA9PT0gJ3RvcG9sb2d5LWRpcmVjdGVkJykge1xuICAgICAgICAgICAgICAgIC8vIGxheW91dCBhY2NvcmRpbmcgdG8gdGhlIHRvcG9sb2d5XG4gICAgICAgICAgICAgICAgbGF5b3V0Tm9kZXMgPSB0b3BvbG9neU9yZGVyaW5nKGdyYXBoLCBub2RlcywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcmRlcmluZyA9PT0gJ2RlZ3JlZScpIHtcbiAgICAgICAgICAgICAgICAvLyBsYXlvdXQgYWNjb3JkaW5nIHRvIHRoZSBkZXNjZW50IG9yZGVyIG9mIGRlZ3JlZXNcbiAgICAgICAgICAgICAgICBsYXlvdXROb2RlcyA9IGRlZ3JlZU9yZGVyaW5nKGdyYXBoLCBub2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBsYXlvdXQgYWNjb3JkaW5nIHRvIHRoZSBvcmlnaW5hbCBvcmRlciBpbiB0aGUgZGF0YS5ub2Rlc1xuICAgICAgICAgICAgICAgIGxheW91dE5vZGVzID0gbm9kZXMubWFwKChub2RlKSA9PiBjbG9uZUZvcm1hdERhdGEobm9kZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGl2TiA9IE1hdGguY2VpbChuIC8gZGl2aXNpb25zKTsgLy8gbm9kZSBudW1iZXIgaW4gZWFjaCBkaXZpc2lvblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICAgICAgICBsZXQgciA9IHJhZGl1cztcbiAgICAgICAgICAgICAgICBpZiAoIXIgJiYgc3RhcnRSYWRpdXMgIT09IG51bGwgJiYgZW5kUmFkaXVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHIgPSBzdGFydFJhZGl1cyArIChpICogKGVuZFJhZGl1cyAtIHN0YXJ0UmFkaXVzKSkgLyAobiAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICAgICAgICAgICAgciA9IDEwICsgKGkgKiAxMDApIC8gKG4gLSAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGFuZ2xlID0gc3RhcnRBbmdsZSArXG4gICAgICAgICAgICAgICAgICAgIChpICUgZGl2TikgKiBhc3RlcCArXG4gICAgICAgICAgICAgICAgICAgICgoMiAqIE1hdGguUEkpIC8gZGl2aXNpb25zKSAqIE1hdGguZmxvb3IoaSAvIGRpdk4pO1xuICAgICAgICAgICAgICAgIGlmICghY2xvY2t3aXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZEFuZ2xlIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaSAlIGRpdk4pICogYXN0ZXAgLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoMiAqIE1hdGguUEkpIC8gZGl2aXNpb25zKSAqIE1hdGguZmxvb3IoaSAvIGRpdk4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXlvdXROb2Rlc1tpXS5kYXRhLnggPSBjYWxjdWxhdGVkQ2VudGVyWzBdICsgTWF0aC5jb3MoYW5nbGUpICogcjtcbiAgICAgICAgICAgICAgICBsYXlvdXROb2Rlc1tpXS5kYXRhLnkgPSBjYWxjdWxhdGVkQ2VudGVyWzFdICsgTWF0aC5zaW4oYW5nbGUpICogcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhc3NpZ24pIHtcbiAgICAgICAgICAgICAgICBsYXlvdXROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGdyYXBoLm1lcmdlTm9kZURhdGEobm9kZS5pZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogbm9kZS5kYXRhLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBub2RlLmRhdGEueSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgbm9kZXM6IGxheW91dE5vZGVzLFxuICAgICAgICAgICAgICAgIGVkZ2VzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogb3JkZXIgdGhlIG5vZGVzIGFjb29yZGluZyB0byB0aGUgZ3JhcGggdG9wb2xvZ3lcbiAqIEBwYXJhbSBncmFwaFxuICogQHBhcmFtIG5vZGVzXG4gKiBAcGFyYW0gZGlyZWN0ZWRcbiAqIEByZXR1cm5zXG4gKi9cbmNvbnN0IHRvcG9sb2d5T3JkZXJpbmcgPSAoZ3JhcGgsIG5vZGVzLCBkaXJlY3RlZCA9IGZhbHNlKSA9PiB7XG4gICAgY29uc3Qgb3JkZXJlZENOb2RlcyA9IFtjbG9uZUZvcm1hdERhdGEobm9kZXNbMF0pXTtcbiAgICBjb25zdCBwaWNrRmxhZ3MgPSB7fTtcbiAgICBjb25zdCBuID0gbm9kZXMubGVuZ3RoO1xuICAgIHBpY2tGbGFnc1tub2Rlc1swXS5pZF0gPSB0cnVlO1xuICAgIC8vIHdyaXRlIGNoaWxkcmVuIGludG8gY25vZGVzXG4gICAgbGV0IGsgPSAwO1xuICAgIG5vZGVzLmZvckVhY2goKG5vZGUsIGkpID0+IHtcbiAgICAgICAgaWYgKGkgIT09IDApIHtcbiAgICAgICAgICAgIGlmICgoaSA9PT0gbiAtIDEgfHxcbiAgICAgICAgICAgICAgICBncmFwaC5nZXREZWdyZWUobm9kZS5pZCwgJ2JvdGgnKSAhPT1cbiAgICAgICAgICAgICAgICAgICAgZ3JhcGguZ2V0RGVncmVlKG5vZGVzW2kgKyAxXS5pZCwgJ2JvdGgnKSB8fFxuICAgICAgICAgICAgICAgIGdyYXBoLmFyZU5laWdoYm9ycyhvcmRlcmVkQ05vZGVzW2tdLmlkLCBub2RlLmlkKSkgJiZcbiAgICAgICAgICAgICAgICAhcGlja0ZsYWdzW25vZGUuaWRdKSB7XG4gICAgICAgICAgICAgICAgb3JkZXJlZENOb2Rlcy5wdXNoKGNsb25lRm9ybWF0RGF0YShub2RlKSk7XG4gICAgICAgICAgICAgICAgcGlja0ZsYWdzW25vZGUuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IGRpcmVjdGVkXG4gICAgICAgICAgICAgICAgICAgID8gZ3JhcGguZ2V0U3VjY2Vzc29ycyhvcmRlcmVkQ05vZGVzW2tdLmlkKVxuICAgICAgICAgICAgICAgICAgICA6IGdyYXBoLmdldE5laWdoYm9ycyhvcmRlcmVkQ05vZGVzW2tdLmlkKTtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmRDaGlsZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjaGlsZHJlbltqXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdyYXBoLmdldERlZ3JlZShjaGlsZC5pZCkgPT09IGdyYXBoLmdldERlZ3JlZShub2RlLmlkKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIXBpY2tGbGFnc1tjaGlsZC5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyZWRDTm9kZXMucHVzaChjbG9uZUZvcm1hdERhdGEoY2hpbGQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBpY2tGbGFnc1tjaGlsZC5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgaWkgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlICghZm91bmRDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBpY2tGbGFnc1tub2Rlc1tpaV0uaWRdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmRlcmVkQ05vZGVzLnB1c2goY2xvbmVGb3JtYXREYXRhKG5vZGVzW2lpXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGlja0ZsYWdzW25vZGVzW2lpXS5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWkrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlpID09PSBuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBvcmRlcmVkQ05vZGVzO1xufTtcbi8qKlxuICogb3JkZXIgdGhlIG5vZGVzIGFjY29yZGluZyB0byB0aGVpciBkZWdyZWVcbiAqIEBwYXJhbSBncmFwaFxuICogQHBhcmFtIG5vZGVzXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBkZWdyZWVPcmRlcmluZyhncmFwaCwgbm9kZXMpIHtcbiAgICBjb25zdCBvcmRlcmVkTm9kZXMgPSBbXTtcbiAgICBub2Rlcy5mb3JFYWNoKChub2RlLCBpKSA9PiB7XG4gICAgICAgIG9yZGVyZWROb2Rlcy5wdXNoKGNsb25lRm9ybWF0RGF0YShub2RlKSk7XG4gICAgfSk7XG4gICAgb3JkZXJlZE5vZGVzLnNvcnQoKG5vZGVBLCBub2RlQikgPT4gZ3JhcGguZ2V0RGVncmVlKG5vZGVBLmlkLCAnYm90aCcpIC0gZ3JhcGguZ2V0RGVncmVlKG5vZGVCLmlkLCAnYm90aCcpKTtcbiAgICByZXR1cm4gb3JkZXJlZE5vZGVzO1xufVxuLyoqXG4gKiBmb3JtYXQgdGhlIGludmFsaWRlIHdpZHRoIGFuZCBoZWlnaHQsIGFuZCBnZXQgdGhlIGNlbnRlciBwb3NpdGlvblxuICogQHBhcmFtIHdpZHRoXG4gKiBAcGFyYW0gaGVpZ2h0XG4gKiBAcGFyYW0gY2VudGVyXG4gKiBAcmV0dXJuc1xuICovXG5jb25zdCBjYWxjdWxhdGVDZW50ZXIgPSAod2lkdGgsIGhlaWdodCwgY2VudGVyKSA9PiB7XG4gICAgbGV0IGNhbGN1bGF0ZWRXaWR0aCA9IHdpZHRoO1xuICAgIGxldCBjYWxjdWxhdGVkSGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGxldCBjYWxjdWxhdGVkQ2VudGVyID0gY2VudGVyO1xuICAgIGlmICghY2FsY3VsYXRlZFdpZHRoICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNhbGN1bGF0ZWRXaWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoO1xuICAgIH1cbiAgICBpZiAoIWNhbGN1bGF0ZWRIZWlnaHQgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY2FsY3VsYXRlZEhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodDtcbiAgICB9XG4gICAgaWYgKCFjYWxjdWxhdGVkQ2VudGVyKSB7XG4gICAgICAgIGNhbGN1bGF0ZWRDZW50ZXIgPSBbY2FsY3VsYXRlZFdpZHRoIC8gMiwgY2FsY3VsYXRlZEhlaWdodCAvIDJdO1xuICAgIH1cbiAgICByZXR1cm4gW2NhbGN1bGF0ZWRXaWR0aCwgY2FsY3VsYXRlZEhlaWdodCwgY2FsY3VsYXRlZENlbnRlcl07XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2lyY3VsYXIuanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBHcmFwaCBhcyBHcmFwaENvcmUgfSBmcm9tICdAYW50di9ncmFwaGxpYic7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uLCBpc051bWJlciwgaXNPYmplY3QgfSBmcm9tICdAYW50di91dGlsJztcbmltcG9ydCB7IENvbmNlbnRyaWNMYXlvdXQgfSBmcm9tICcuL2NvbmNlbnRyaWMnO1xuaW1wb3J0IHsgRm9yY2VMYXlvdXQgfSBmcm9tICcuL2ZvcmNlJztcbmltcG9ydCB7IE1EU0xheW91dCB9IGZyb20gJy4vbWRzJztcbmltcG9ydCB7IGlzTGF5b3V0V2l0aEl0ZXJhdGlvbnMgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IGdldExheW91dEJCb3gsIGdyYXBoVHJlZURmcywgaXNBcnJheSB9IGZyb20gJy4vdXRpbCc7XG5pbXBvcnQgeyBoYW5kbGVTaW5nbGVOb2RlR3JhcGggfSBmcm9tICcuL3V0aWwvY29tbW9uJztcbmNvbnN0IEZPUkNFX0xBWU9VVF9UWVBFX01BUCA9IHtcbiAgICBnRm9yY2U6IHRydWUsXG4gICAgZm9yY2UyOiB0cnVlLFxuICAgIGQzZm9yY2U6IHRydWUsXG4gICAgZnJ1Y2h0ZXJtYW46IHRydWUsXG4gICAgZm9yY2VBdGxhczI6IHRydWUsXG4gICAgZm9yY2U6IHRydWUsXG4gICAgJ2dyYXBoaW4tZm9yY2UnOiB0cnVlLFxufTtcbmNvbnN0IERFRkFVTFRTX0xBWU9VVF9PUFRJT05TID0ge1xuICAgIGNlbnRlcjogWzAsIDBdLFxuICAgIGNvbWJvUGFkZGluZzogMTAsXG4gICAgdHJlZUtleTogJ2NvbWJvJyxcbn07XG4vKipcbiAqIDx6aC8+IOe7hOWQiOW4g+WxgFxuICpcbiAqIDxlbi8+IENvbWJvLUNvbWJpbmVkIGxheW91dFxuICovXG5leHBvcnQgY2xhc3MgQ29tYm9Db21iaW5lZExheW91dCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuaWQgPSAnY29tYm9Db21iaW5lZCc7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVFNfTEFZT1VUX09QVElPTlMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBwb3NpdGlvbnMgb2Ygbm9kZXMgYW5kIGVkZ2VzKGlmIG5lZWRlZCkuXG4gICAgICovXG4gICAgZXhlY3V0ZShncmFwaCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJpY0NvbWJvQ29tYmluZWRMYXlvdXQoZmFsc2UsIGdyYXBoLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvIGRpcmVjdGx5IGFzc2lnbiB0aGUgcG9zaXRpb25zIHRvIHRoZSBub2Rlcy5cbiAgICAgKi9cbiAgICBhc3NpZ24oZ3JhcGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2VuZXJpY0NvbWJvQ29tYmluZWRMYXlvdXQodHJ1ZSwgZ3JhcGgsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2VuZXJpY0NvbWJvQ29tYmluZWRMYXlvdXQoYXNzaWduLCBncmFwaCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IHRoaXMuaW5pdFZhbHMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpLCBvcHRpb25zKSk7XG4gICAgICAgICAgICBjb25zdCB7IGNlbnRlciwgdHJlZUtleSwgb3V0ZXJMYXlvdXQ6IHByb3BzT3V0ZXJMYXlvdXQgfSA9IG1lcmdlZE9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBub2RlcyA9IGdyYXBoXG4gICAgICAgICAgICAgICAgLmdldEFsbE5vZGVzKClcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChub2RlKSA9PiAhbm9kZS5kYXRhLl9pc0NvbWJvKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbWJvcyA9IGdyYXBoXG4gICAgICAgICAgICAgICAgLmdldEFsbE5vZGVzKClcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChub2RlKSA9PiBub2RlLmRhdGEuX2lzQ29tYm8pO1xuICAgICAgICAgICAgY29uc3QgZWRnZXMgPSBncmFwaC5nZXRBbGxFZGdlcygpO1xuICAgICAgICAgICAgY29uc3QgbiA9IG5vZGVzID09PSBudWxsIHx8IG5vZGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgICBpZiAoIW4gfHwgbiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVTaW5nbGVOb2RlR3JhcGgoZ3JhcGgsIGFzc2lnbiwgY2VudGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG91dHB1dCBub2Rlc1xuICAgICAgICAgICAgY29uc3QgbGF5b3V0Tm9kZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgbm9kZU1hcC5zZXQobm9kZS5pZCwgbm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbWJvTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgY29tYm9zLmZvckVhY2goKGNvbWJvKSA9PiB7XG4gICAgICAgICAgICAgICAgY29tYm9NYXAuc2V0KGNvbWJvLmlkLCBjb21ibyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGVhY2ggb25lIGluIGNvbWJvTm9kZXMgaXMgYSBjb21ibyBjb250YWlucyB0aGUgc2l6ZSBhbmQgY2hpbGQgbm9kZXNcbiAgICAgICAgICAgIC8vIGNvbWJvTm9kZXMgaW5jbHVkZXMgdGhlIG5vZGUgd2hvIGhhcyBubyBwYXJlbnQgY29tYm9cbiAgICAgICAgICAgIGNvbnN0IGNvbWJvTm9kZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAvLyB0aGUgaW5uZXIgbGF5b3V0cywgdGhlIHJlc3VsdCBwb3NpdGlvbnMgYXJlIHN0b3JlZCBpbiBjb21ib05vZGVzIGFuZCB0aGVpciBjaGlsZCBub2Rlc1xuICAgICAgICAgICAgY29uc3QgaW5uZXJHcmFwaExheW91dFByb21pc2VzID0gdGhpcy5nZXRJbm5lckdyYXBocyhncmFwaCwgdHJlZUtleSwgbm9kZU1hcCwgY29tYm9NYXAsIGVkZ2VzLCBtZXJnZWRPcHRpb25zLCBjb21ib05vZGVzKTtcbiAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKGlubmVyR3JhcGhMYXlvdXRQcm9taXNlcyk7XG4gICAgICAgICAgICBjb25zdCBvdXRlck5vZGVJZHMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBjb25zdCBvdXRlckxheW91dE5vZGVzID0gW107XG4gICAgICAgICAgICBjb25zdCBub2RlQW5jZXN0b3JJZE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGxldCBhbGxIYXZlTm9Qb3NpdGlvbiA9IHRydWU7XG4gICAgICAgICAgICBncmFwaC5nZXRSb290cyh0cmVlS2V5KS5mb3JFYWNoKChyb290KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tYm8gPSBjb21ib05vZGVzLmdldChyb290LmlkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjYWNoZUNvbWJvID0gY29tYm9NYXAuZ2V0KHJvb3QuaWQpIHx8IG5vZGVNYXAuZ2V0KHJvb3QuaWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbWJvTGF5b3V0Tm9kZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHJvb3QuaWQsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcm9vdC5kYXRhKSwgeyB4OiBjb21iby5kYXRhLnggfHwgY2FjaGVDb21iby5kYXRhLngsIHk6IGNvbWJvLmRhdGEueSB8fCBjYWNoZUNvbWJvLmRhdGEueSwgZng6IGNvbWJvLmRhdGEuZnggfHwgY2FjaGVDb21iby5kYXRhLmZ4LCBmeTogY29tYm8uZGF0YS5meSB8fCBjYWNoZUNvbWJvLmRhdGEuZnksIG1hc3M6IGNvbWJvLmRhdGEubWFzcyB8fCBjYWNoZUNvbWJvLmRhdGEubWFzcywgc2l6ZTogY29tYm8uZGF0YS5zaXplIH0pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgb3V0ZXJMYXlvdXROb2Rlcy5wdXNoKGNvbWJvTGF5b3V0Tm9kZSk7XG4gICAgICAgICAgICAgICAgb3V0ZXJOb2RlSWRzLnNldChyb290LmlkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGNvbWJvTGF5b3V0Tm9kZS5kYXRhLngpICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbWJvTGF5b3V0Tm9kZS5kYXRhLnggIT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgIWlzTmFOKGNvbWJvTGF5b3V0Tm9kZS5kYXRhLnkpICYmXG4gICAgICAgICAgICAgICAgICAgIGNvbWJvTGF5b3V0Tm9kZS5kYXRhLnkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsSGF2ZU5vUG9zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbWJvTGF5b3V0Tm9kZS5kYXRhLnggPSBNYXRoLnJhbmRvbSgpICogMTAwO1xuICAgICAgICAgICAgICAgICAgICBjb21ib0xheW91dE5vZGUuZGF0YS55ID0gTWF0aC5yYW5kb20oKSAqIDEwMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ3JhcGhUcmVlRGZzKGdyYXBoLCBbcm9vdF0sIChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuaWQgIT09IHJvb3QuaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlQW5jZXN0b3JJZE1hcC5zZXQoY2hpbGQuaWQsIHJvb3QuaWQpO1xuICAgICAgICAgICAgICAgIH0sICdUQicsIHRyZWVLZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBvdXRlckxheW91dEVkZ2VzID0gW107XG4gICAgICAgICAgICBlZGdlcy5mb3JFYWNoKChlZGdlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlQW5jZXN0b3JJZCA9IG5vZGVBbmNlc3RvcklkTWFwLmdldChlZGdlLnNvdXJjZSkgfHwgZWRnZS5zb3VyY2U7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0QW5jZXN0b3JJZCA9IG5vZGVBbmNlc3RvcklkTWFwLmdldChlZGdlLnRhcmdldCkgfHwgZWRnZS50YXJnZXQ7XG4gICAgICAgICAgICAgICAgLy8gY3JlYXRlIGFuIGVkZ2UgZm9yIG91dGVyIGxheW91dCBpZiBib3RoIHNvdXJjZSBhbmQgdGFyZ2V0J3MgYW5jZXN0b3IgY29tYm8gaXMgaW4gb3V0ZXIgbGF5b3V0IG5vZGVzXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZUFuY2VzdG9ySWQgIT09IHRhcmdldEFuY2VzdG9ySWQgJiZcbiAgICAgICAgICAgICAgICAgICAgb3V0ZXJOb2RlSWRzLmhhcyhzb3VyY2VBbmNlc3RvcklkKSAmJlxuICAgICAgICAgICAgICAgICAgICBvdXRlck5vZGVJZHMuaGFzKHRhcmdldEFuY2VzdG9ySWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dGVyTGF5b3V0RWRnZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogZWRnZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlQW5jZXN0b3JJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGFyZ2V0QW5jZXN0b3JJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHt9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIOiLpeaciemcgOimgeacgOWkluWxgueahCBjb21ibyDmiJboioLngrnvvIzliJnlr7nmnIDlpJblsYLmiafooYzlipvlr7zlkJFcbiAgICAgICAgICAgIGxldCBvdXRlclBvc2l0aW9ucztcbiAgICAgICAgICAgIGlmIChvdXRlckxheW91dE5vZGVzID09PSBudWxsIHx8IG91dGVyTGF5b3V0Tm9kZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG91dGVyTGF5b3V0Tm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG91dGVyTGF5b3V0Tm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dGVyTGF5b3V0Tm9kZXNbMF0uZGF0YS54ID0gY2VudGVyWzBdO1xuICAgICAgICAgICAgICAgICAgICBvdXRlckxheW91dE5vZGVzWzBdLmRhdGEueSA9IGNlbnRlclsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dGVyTGF5b3V0R3JhcGggPSBuZXcgR3JhcGhDb3JlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzOiBvdXRlckxheW91dE5vZGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWRnZXM6IG91dGVyTGF5b3V0RWRnZXMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXRlckxheW91dCA9IHByb3BzT3V0ZXJMYXlvdXQgfHwgbmV3IEZvcmNlTGF5b3V0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXNldCB0aGUgbm9kZXMgaWYgdGhlIG91dGVyTGF5b3V0IGlzIGEgZm9yY2UgZmFtaWx5IGxheW91dFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxsSGF2ZU5vUG9zaXRpb24gJiYgRk9SQ0VfTEFZT1VUX1RZUEVfTUFQW291dGVyTGF5b3V0LmlkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3V0ZXJMYXlvdXRQcmVzZXQgPSBvdXRlckxheW91dE5vZGVzLmxlbmd0aCA8IDEwMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gbmV3IE1EU0xheW91dCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXcgQ29uY2VudHJpY0xheW91dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgb3V0ZXJMYXlvdXRQcmVzZXQuYXNzaWduKG91dGVyTGF5b3V0R3JhcGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHsgY2VudGVyLCBrZzogNSwgcHJldmVudE92ZXJsYXA6IHRydWUsIGFuaW1hdGU6IGZhbHNlIH0sIChvdXRlckxheW91dC5pZCA9PT0gJ2ZvcmNlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3Jhdml0eTogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWN0b3I6IDQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua0Rpc3RhbmNlOiAoZWRnZSwgc291cmNlLCB0YXJnZXQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc291cmNlU2l6ZSA9IE1hdGgubWF4KC4uLnNvdXJjZS5kYXRhLnNpemUpIHx8IDMyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRTaXplID0gTWF0aC5tYXgoLi4udGFyZ2V0LmRhdGEuc2l6ZSkgfHwgMzI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2VTaXplIC8gMiArIHRhcmdldFNpemUgLyAyICsgMjAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHt9KSk7XG4gICAgICAgICAgICAgICAgICAgIG91dGVyUG9zaXRpb25zID0geWllbGQgZXhlY3V0ZUxheW91dChvdXRlckxheW91dCwgb3V0ZXJMYXlvdXRHcmFwaCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG1vdmUgdGhlIGNvbWJvcyBhbmQgdGhlaXIgY2hpbGQgbm9kZXNcbiAgICAgICAgICAgICAgICBjb21ib05vZGVzLmZvckVhY2goKGNvbWJvTm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dGVyUG9zaXRpb24gPSBvdXRlclBvc2l0aW9ucy5ub2Rlcy5maW5kKChwb3MpID0+IHBvcy5pZCA9PT0gY29tYm9Ob2RlLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dGVyUG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0IGlzIG9uZSBvZiB0aGUgb3V0ZXIgbGF5b3V0IG5vZGVzLCB1cGRhdGUgdGhlIHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBvdXRlclBvc2l0aW9uLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21ib05vZGUuZGF0YS52aXNpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbWJvTm9kZS5kYXRhLnggPSB4O1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tYm9Ob2RlLmRhdGEueSA9IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXROb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogY29tYm9Ob2RlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgeCwgeSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gbW92ZSB0aGUgY2hpbGQgbm9kZXNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBjb21ib05vZGUuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gY29tYm9Ob2RlLmRhdGEubm9kZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXROb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7IHg6IG5vZGUuZGF0YS54ICsgeCwgeTogbm9kZS5kYXRhLnkgKyB5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gbW92ZSB0aGUgbm9kZXMgZnJvbSB0b3AgdG8gYm90dG9tXG4gICAgICAgICAgICAgICAgY29tYm9Ob2Rlcy5mb3JFYWNoKCh7IGRhdGEgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHgsIHksIHZpc2l0ZWQsIG5vZGVzIH0gPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICBub2RlcyA9PT0gbnVsbCB8fCBub2RlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF2aXNpdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGF5b3V0Tm9kZSA9IGxheW91dE5vZGVzLmZpbmQoKG4pID0+IG4uaWQgPT09IG5vZGUuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dE5vZGUuZGF0YS54ICs9IHggfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXROb2RlLmRhdGEueSArPSB5IHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFzc2lnbikge1xuICAgICAgICAgICAgICAgIGxheW91dE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGgubWVyZ2VOb2RlRGF0YShub2RlLmlkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBub2RlLmRhdGEueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IG5vZGUuZGF0YS55LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBub2RlczogbGF5b3V0Tm9kZXMsXG4gICAgICAgICAgICAgICAgZWRnZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluaXRWYWxzKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZm9ybWF0dGVkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB7IG5vZGVTaXplLCBzcGFjaW5nLCBjb21ib1BhZGRpbmcgfSA9IG9wdGlvbnM7XG4gICAgICAgIGxldCBub2RlU2l6ZUZ1bmM7XG4gICAgICAgIGxldCBzcGFjaW5nRnVuYztcbiAgICAgICAgLy8gbm9kZVNwYWNpbmcgdG8gZnVuY3Rpb25cbiAgICAgICAgaWYgKGlzTnVtYmVyKHNwYWNpbmcpKSB7XG4gICAgICAgICAgICBzcGFjaW5nRnVuYyA9ICgpID0+IHNwYWNpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihzcGFjaW5nKSkge1xuICAgICAgICAgICAgc3BhY2luZ0Z1bmMgPSBzcGFjaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3BhY2luZ0Z1bmMgPSAoKSA9PiAwO1xuICAgICAgICB9XG4gICAgICAgIGZvcm1hdHRlZE9wdGlvbnMuc3BhY2luZyA9IHNwYWNpbmdGdW5jO1xuICAgICAgICAvLyBub2RlU2l6ZSB0byBmdW5jdGlvblxuICAgICAgICBpZiAoIW5vZGVTaXplKSB7XG4gICAgICAgICAgICBub2RlU2l6ZUZ1bmMgPSAoZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwYWNpbmcgPSBzcGFjaW5nRnVuYyhkKTtcbiAgICAgICAgICAgICAgICBpZiAoZC5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGQuc2l6ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGQuc2l6ZVswXSA+IGQuc2l6ZVsxXSA/IGQuc2l6ZVswXSA6IGQuc2l6ZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAocmVzICsgc3BhY2luZykgLyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChkLnNpemUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXMgPSBkLnNpemUud2lkdGggPiBkLnNpemUuaGVpZ2h0ID8gZC5zaXplLndpZHRoIDogZC5zaXplLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAocmVzICsgc3BhY2luZykgLyAyO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoZC5zaXplICsgc3BhY2luZykgLyAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gMzIgKyBzcGFjaW5nIC8gMjtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihub2RlU2l6ZSkpIHtcbiAgICAgICAgICAgIG5vZGVTaXplRnVuYyA9IChkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IG5vZGVTaXplKGQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwYWNpbmcgPSBzcGFjaW5nRnVuYyhkKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShkLnNpemUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcyA9IGQuc2l6ZVswXSA+IGQuc2l6ZVsxXSA/IGQuc2l6ZVswXSA6IGQuc2l6ZVsxXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChyZXMgKyBzcGFjaW5nKSAvIDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoKHNpemUgfHwgMzIpICsgc3BhY2luZykgLyAyO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0FycmF5KG5vZGVTaXplKSkge1xuICAgICAgICAgICAgY29uc3QgbGFyZ2VyID0gbm9kZVNpemVbMF0gPiBub2RlU2l6ZVsxXSA/IG5vZGVTaXplWzBdIDogbm9kZVNpemVbMV07XG4gICAgICAgICAgICBjb25zdCByYWRpdXMgPSBsYXJnZXIgLyAyO1xuICAgICAgICAgICAgbm9kZVNpemVGdW5jID0gKGQpID0+IHJhZGl1cyArIHNwYWNpbmdGdW5jKGQpIC8gMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIG51bWJlciB0eXBlXG4gICAgICAgICAgICBjb25zdCByYWRpdXMgPSBub2RlU2l6ZSAvIDI7XG4gICAgICAgICAgICBub2RlU2l6ZUZ1bmMgPSAoZCkgPT4gcmFkaXVzICsgc3BhY2luZ0Z1bmMoZCkgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGZvcm1hdHRlZE9wdGlvbnMubm9kZVNpemUgPSBub2RlU2l6ZUZ1bmM7XG4gICAgICAgIC8vIGNvbWJvUGFkZGluZyB0byBmdW5jdGlvblxuICAgICAgICBsZXQgY29tYm9QYWRkaW5nRnVuYztcbiAgICAgICAgaWYgKGlzTnVtYmVyKGNvbWJvUGFkZGluZykpIHtcbiAgICAgICAgICAgIGNvbWJvUGFkZGluZ0Z1bmMgPSAoKSA9PiBjb21ib1BhZGRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNBcnJheShjb21ib1BhZGRpbmcpKSB7XG4gICAgICAgICAgICBjb21ib1BhZGRpbmdGdW5jID0gKCkgPT4gTWF0aC5tYXguYXBwbHkobnVsbCwgY29tYm9QYWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKGNvbWJvUGFkZGluZykpIHtcbiAgICAgICAgICAgIGNvbWJvUGFkZGluZ0Z1bmMgPSBjb21ib1BhZGRpbmc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBudWxsIHR5cGVcbiAgICAgICAgICAgIGNvbWJvUGFkZGluZ0Z1bmMgPSAoKSA9PiAwO1xuICAgICAgICB9XG4gICAgICAgIGZvcm1hdHRlZE9wdGlvbnMuY29tYm9QYWRkaW5nID0gY29tYm9QYWRkaW5nRnVuYztcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZE9wdGlvbnM7XG4gICAgfVxuICAgIGdldElubmVyR3JhcGhzKGdyYXBoLCB0cmVlS2V5LCBub2RlTWFwLCBjb21ib01hcCwgZWRnZXMsIG9wdGlvbnMsIGNvbWJvTm9kZXMpIHtcbiAgICAgICAgY29uc3QgeyBub2RlU2l6ZSwgY29tYm9QYWRkaW5nLCBzcGFjaW5nLCBpbm5lckxheW91dCB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgaW5uZXJHcmFwaExheW91dCA9IGlubmVyTGF5b3V0IHx8IG5ldyBDb25jZW50cmljTGF5b3V0KHt9KTtcbiAgICAgICAgY29uc3QgaW5uZXJMYXlvdXRPcHRpb25zID0ge1xuICAgICAgICAgICAgY2VudGVyOiBbMCwgMF0sXG4gICAgICAgICAgICBwcmV2ZW50T3ZlcmxhcDogdHJ1ZSxcbiAgICAgICAgICAgIG5vZGVTcGFjaW5nOiBzcGFjaW5nLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBpbm5lckxheW91dFByb21pc2VzID0gW107XG4gICAgICAgIGNvbnN0IGdldFNpemUgPSAobm9kZSkgPT4ge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgbGV0IHBhZGRpbmcgPSAoY29tYm9QYWRkaW5nID09PSBudWxsIHx8IGNvbWJvUGFkZGluZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29tYm9QYWRkaW5nKG5vZGUpKSB8fCAxMDtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KHBhZGRpbmcpKVxuICAgICAgICAgICAgICAgIHBhZGRpbmcgPSBNYXRoLm1heCguLi5wYWRkaW5nKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2l6ZTogcGFkZGluZyA/IFtwYWRkaW5nICogMiwgcGFkZGluZyAqIDJdIDogWzMwLCAzMF0sXG4gICAgICAgICAgICAgICAgcGFkZGluZyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGdyYXBoLmdldFJvb3RzKHRyZWVLZXkpLmZvckVhY2goKHJvb3QpID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbWJvTm9kZXMuc2V0KHJvb3QuaWQsIHtcbiAgICAgICAgICAgICAgICBpZDogcm9vdC5pZCxcbiAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZTogZ2V0U2l6ZShyb290KS5zaXplLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgLy8gUmVnYXJkIHRoZSBjaGlsZCBub2RlcyBpbiBvbmUgY29tYm8gYXMgYSBncmFwaCwgYW5kIGxheW91dCB0aGVtIGZyb20gYm90dG9tIHRvIHRvcFxuICAgICAgICAgICAgZ3JhcGhUcmVlRGZzKGdyYXBoLCBbcm9vdF0sICh0cmVlTm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICBpZiAoIXRyZWVOb2RlLmRhdGEuX2lzQ29tYm8pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNpemU6IG5zaXplLCBwYWRkaW5nIH0gPSBnZXRTaXplKHRyZWVOb2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoISgoX2EgPSBncmFwaC5nZXRDaGlsZHJlbih0cmVlTm9kZS5pZCwgdHJlZUtleSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVtcHR5IGNvbWJvXG4gICAgICAgICAgICAgICAgICAgIGNvbWJvTm9kZXMuc2V0KHRyZWVOb2RlLmlkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdHJlZU5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRyZWVOb2RlLmRhdGEpLCB7IHNpemU6IG5zaXplIH0pLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbWJvIG5vdCBlbXB0eVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21ib05vZGUgPSBjb21ib05vZGVzLmdldCh0cmVlTm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbWJvTm9kZXMuc2V0KHRyZWVOb2RlLmlkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdHJlZU5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKHsgbm9kZXM6IFtdIH0sIGNvbWJvTm9kZSA9PT0gbnVsbCB8fCBjb21ib05vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbWJvTm9kZS5kYXRhKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyTGF5b3V0Tm9kZUlkcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5uZXJMYXlvdXROb2RlcyA9IGdyYXBoXG4gICAgICAgICAgICAgICAgICAgICAgICAuZ2V0Q2hpbGRyZW4odHJlZU5vZGUuaWQsIHRyZWVLZXkpXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmRhdGEuX2lzQ29tYm8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbWJvTm9kZXMuaGFzKGNoaWxkLmlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21ib05vZGVzLnNldChjaGlsZC5pZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGNoaWxkLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgY2hpbGQuZGF0YSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lckxheW91dE5vZGVJZHMuc2V0KGNoaWxkLmlkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tYm9Ob2Rlcy5nZXQoY2hpbGQuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpTm9kZSA9IG5vZGVNYXAuZ2V0KGNoaWxkLmlkKSB8fCBjb21ib01hcC5nZXQoY2hpbGQuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJMYXlvdXROb2RlSWRzLnNldChjaGlsZC5pZCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjaGlsZC5pZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9yaU5vZGUuZGF0YSksIGNoaWxkLmRhdGEpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyR3JhcGhEYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXM6IGlubmVyTGF5b3V0Tm9kZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlczogZWRnZXMuZmlsdGVyKChlZGdlKSA9PiBpbm5lckxheW91dE5vZGVJZHMuaGFzKGVkZ2Uuc291cmNlKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyTGF5b3V0Tm9kZUlkcy5oYXMoZWRnZS50YXJnZXQpKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1pbk5vZGVTaXplID0gSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgICAgIGlubmVyTGF5b3V0Tm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHsgc2l6ZSB9ID0gbm9kZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSA9ICgoX2EgPSBjb21ib05vZGVzLmdldChub2RlLmlkKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRhdGEuc2l6ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5vZGVTaXplID09PSBudWxsIHx8IG5vZGVTaXplID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlU2l6ZShub2RlKSkgfHwgWzMwLCAzMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOdW1iZXIoc2l6ZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZSA9IFtzaXplLCBzaXplXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IFtzaXplMCwgc2l6ZTFdID0gc2l6ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtaW5Ob2RlU2l6ZSA+IHNpemUwKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbk5vZGVTaXplID0gc2l6ZTA7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluTm9kZVNpemUgPiBzaXplMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5Ob2RlU2l6ZSA9IHNpemUxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5kYXRhLnNpemUgPSBzaXplO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW5uZXJHcmFwaExheW91dC5hc3NpZ24oaW5uZXJHcmFwaENvcmUsIGlubmVyTGF5b3V0T3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQudGhlbigoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbm5lckdyYXBoQ29yZSA9IG5ldyBHcmFwaENvcmUoaW5uZXJHcmFwaERhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgZXhlY3V0ZUxheW91dChpbm5lckdyYXBoTGF5b3V0LCBpbm5lckdyYXBoQ29yZSwgaW5uZXJMYXlvdXRPcHRpb25zLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbWluWCwgbWluWSwgbWF4WCwgbWF4WSB9ID0gZ2V0TGF5b3V0QkJveChpbm5lckxheW91dE5vZGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1vdmUgdGhlIGlubmVyR3JhcGggdG8gWzAsIDBdLCBmb3IgbGF0ZXIgY29udHJvbGxlZCBieSBwYXJlbnQgbGF5b3V0XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXIgPSB7IHg6IChtYXhYICsgbWluWCkgLyAyLCB5OiAobWF4WSArIG1pblkpIC8gMiB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJHcmFwaERhdGEubm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGF0YS54IC09IGNlbnRlci54O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGF0YS55IC09IGNlbnRlci55O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaXplID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KG1heFggLSBtaW5YLCBtaW5Ob2RlU2l6ZSkgKyBwYWRkaW5nICogMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChtYXhZIC0gbWluWSwgbWluTm9kZVNpemUpICsgcGFkZGluZyAqIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tYm9Ob2Rlcy5nZXQodHJlZU5vZGUuaWQpLmRhdGEuc2l6ZSA9IHNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21ib05vZGVzLmdldCh0cmVlTm9kZS5pZCkuZGF0YS5ub2RlcyA9IGlubmVyTGF5b3V0Tm9kZXM7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9LCAnQlQnLCB0cmVlS2V5KTtcbiAgICAgICAgICAgIGlubmVyTGF5b3V0UHJvbWlzZXMucHVzaChzdGFydCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW5uZXJMYXlvdXRQcm9taXNlcztcbiAgICB9XG59XG5mdW5jdGlvbiBleGVjdXRlTGF5b3V0KGxheW91dCwgZ3JhcGgsIG9wdGlvbnMsIGFzc2lnbikge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAoaXNMYXlvdXRXaXRoSXRlcmF0aW9ucyhsYXlvdXQpKSB7XG4gICAgICAgICAgICBsYXlvdXQuZXhlY3V0ZShncmFwaCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBsYXlvdXQuc3RvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIGxheW91dC50aWNrKChfYSA9IG9wdGlvbnMuaXRlcmF0aW9ucykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMzAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXNzaWduKVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGxheW91dC5hc3NpZ24oZ3JhcGgsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4geWllbGQgbGF5b3V0LmV4ZWN1dGUoZ3JhcGgsIG9wdGlvbnMpO1xuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tYm8tY29tYmluZWQuanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uLCBpc051bWJlciwgaXNPYmplY3QsIGlzU3RyaW5nIH0gZnJvbSAnQGFudHYvdXRpbCc7XG5pbXBvcnQgeyBjbG9uZUZvcm1hdERhdGEsIGlzQXJyYXkgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgaGFuZGxlU2luZ2xlTm9kZUdyYXBoIH0gZnJvbSAnLi91dGlsL2NvbW1vbic7XG5pbXBvcnQgeyBwYXJzZVNpemUgfSBmcm9tICcuL3V0aWwvc2l6ZSc7XG5jb25zdCBERUZBVUxUU19MQVlPVVRfT1BUSU9OUyA9IHtcbiAgICBub2RlU2l6ZTogMzAsXG4gICAgbm9kZVNwYWNpbmc6IDEwLFxuICAgIHByZXZlbnRPdmVybGFwOiBmYWxzZSxcbiAgICBzd2VlcDogdW5kZWZpbmVkLFxuICAgIGVxdWlkaXN0YW50OiBmYWxzZSxcbiAgICBzdGFydEFuZ2xlOiAoMyAvIDIpICogTWF0aC5QSSxcbiAgICBjbG9ja3dpc2U6IHRydWUsXG4gICAgbWF4TGV2ZWxEaWZmOiB1bmRlZmluZWQsXG4gICAgc29ydEJ5OiAnZGVncmVlJyxcbn07XG4vKipcbiAqIDx6aC8+IOWQjOW/g+WchuW4g+WxgFxuICpcbiAqIDxlbi8+IENvbmNlbnRyaWMgbGF5b3V0XG4gKi9cbmV4cG9ydCBjbGFzcyBDb25jZW50cmljTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5pZCA9ICdjb25jZW50cmljJztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUU19MQVlPVVRfT1BUSU9OUyksIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHBvc2l0aW9ucyBvZiBub2RlcyBhbmQgZWRnZXMoaWYgbmVlZGVkKS5cbiAgICAgKi9cbiAgICBleGVjdXRlKGdyYXBoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmljQ29uY2VudHJpY0xheW91dChmYWxzZSwgZ3JhcGgsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG8gZGlyZWN0bHkgYXNzaWduIHRoZSBwb3NpdGlvbnMgdG8gdGhlIG5vZGVzLlxuICAgICAqL1xuICAgIGFzc2lnbihncmFwaCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZW5lcmljQ29uY2VudHJpY0xheW91dCh0cnVlLCBncmFwaCwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZW5lcmljQ29uY2VudHJpY0xheW91dChhc3NpZ24sIGdyYXBoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWRPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHsgY2VudGVyOiBwcm9wc0NlbnRlciwgd2lkdGg6IHByb3BzV2lkdGgsIGhlaWdodDogcHJvcHNIZWlnaHQsIHNvcnRCeTogcHJvcHNTb3J0QnksIG1heExldmVsRGlmZjogcHJvcHNNYXhMZXZlbERpZmYsIHN3ZWVwOiBwcm9wc1N3ZWVwLCBjbG9ja3dpc2UsIGVxdWlkaXN0YW50LCBwcmV2ZW50T3ZlcmxhcCwgc3RhcnRBbmdsZSA9ICgzIC8gMikgKiBNYXRoLlBJLCBub2RlU2l6ZSwgbm9kZVNwYWNpbmcsIH0gPSBtZXJnZWRPcHRpb25zO1xuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBncmFwaC5nZXRBbGxOb2RlcygpO1xuICAgICAgICAgICAgY29uc3QgZWRnZXMgPSBncmFwaC5nZXRBbGxFZGdlcygpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSAhcHJvcHNXaWR0aCAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgID8gd2luZG93LmlubmVyV2lkdGhcbiAgICAgICAgICAgICAgICA6IHByb3BzV2lkdGg7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSAhcHJvcHNIZWlnaHQgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/IHdpbmRvdy5pbm5lckhlaWdodFxuICAgICAgICAgICAgICAgIDogcHJvcHNIZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBjZW50ZXIgPSAoIXByb3BzQ2VudGVyID8gW3dpZHRoIC8gMiwgaGVpZ2h0IC8gMl0gOiBwcm9wc0NlbnRlcik7XG4gICAgICAgICAgICBpZiAoIShub2RlcyA9PT0gbnVsbCB8fCBub2RlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZXMubGVuZ3RoKSB8fCBub2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlU2luZ2xlTm9kZUdyYXBoKGdyYXBoLCBhc3NpZ24sIGNlbnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsYXlvdXROb2RlcyA9IFtdO1xuICAgICAgICAgICAgbGV0IG1heE5vZGVTaXplO1xuICAgICAgICAgICAgbGV0IG1heE5vZGVTcGFjaW5nID0gMDtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KG5vZGVTaXplKSkge1xuICAgICAgICAgICAgICAgIG1heE5vZGVTaXplID0gTWF0aC5tYXgobm9kZVNpemVbMF0sIG5vZGVTaXplWzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24obm9kZVNpemUpKSB7XG4gICAgICAgICAgICAgICAgbWF4Tm9kZVNpemUgPSAtSW5maW5pdHk7XG4gICAgICAgICAgICAgICAgbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50U2l6ZSA9IE1hdGgubWF4KC4uLnBhcnNlU2l6ZShub2RlU2l6ZShub2RlKSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNpemUgPiBtYXhOb2RlU2l6ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heE5vZGVTaXplID0gY3VycmVudFNpemU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXhOb2RlU2l6ZSA9IG5vZGVTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQXJyYXkobm9kZVNwYWNpbmcpKSB7XG4gICAgICAgICAgICAgICAgbWF4Tm9kZVNwYWNpbmcgPSBNYXRoLm1heChub2RlU3BhY2luZ1swXSwgbm9kZVNwYWNpbmdbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNOdW1iZXIobm9kZVNwYWNpbmcpKSB7XG4gICAgICAgICAgICAgICAgbWF4Tm9kZVNwYWNpbmcgPSBub2RlU3BhY2luZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbm9kZSA9IGNsb25lRm9ybWF0RGF0YShub2RlKTtcbiAgICAgICAgICAgICAgICBsYXlvdXROb2Rlcy5wdXNoKGNub2RlKTtcbiAgICAgICAgICAgICAgICBsZXQgbm9kZVNpemUgPSBtYXhOb2RlU2l6ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEgfSA9IGNub2RlO1xuICAgICAgICAgICAgICAgIGlmIChpc0FycmF5KGRhdGEuc2l6ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZVNpemUgPSBNYXRoLm1heChkYXRhLnNpemVbMF0sIGRhdGEuc2l6ZVsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzTnVtYmVyKGRhdGEuc2l6ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZVNpemUgPSBkYXRhLnNpemU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KGRhdGEuc2l6ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZVNpemUgPSBNYXRoLm1heChkYXRhLnNpemUud2lkdGgsIGRhdGEuc2l6ZS5oZWlnaHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXhOb2RlU2l6ZSA9IE1hdGgubWF4KG1heE5vZGVTaXplLCBub2RlU2l6ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24obm9kZVNwYWNpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1heE5vZGVTcGFjaW5nID0gTWF0aC5tYXgobm9kZVNwYWNpbmcobm9kZSksIG1heE5vZGVTcGFjaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGxheW91dFxuICAgICAgICAgICAgY29uc3Qgbm9kZUlkeE1hcCA9IHt9O1xuICAgICAgICAgICAgbGF5b3V0Tm9kZXMuZm9yRWFjaCgobm9kZSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIG5vZGVJZHhNYXBbbm9kZS5pZF0gPSBpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBnZXQgdGhlIG5vZGUgZGVncmVlc1xuICAgICAgICAgICAgbGV0IHNvcnRCeSA9IHByb3BzU29ydEJ5O1xuICAgICAgICAgICAgaWYgKCFpc1N0cmluZyhzb3J0QnkpIHx8XG4gICAgICAgICAgICAgICAgbGF5b3V0Tm9kZXNbMF0uZGF0YVtzb3J0QnldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBzb3J0QnkgPSAnZGVncmVlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3J0QnkgPT09ICdkZWdyZWUnKSB7XG4gICAgICAgICAgICAgICAgbGF5b3V0Tm9kZXMuc29ydCgobjEsIG4yKSA9PiBncmFwaC5nZXREZWdyZWUobjIuaWQsICdib3RoJykgLSBncmFwaC5nZXREZWdyZWUobjEuaWQsICdib3RoJykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc29ydCBub2RlcyBieSB2YWx1ZVxuICAgICAgICAgICAgICAgIGxheW91dE5vZGVzLnNvcnQoKG4xLCBuMikgPT4gbjIuZGF0YVtzb3J0QnldIC0gbjEuZGF0YVtzb3J0QnldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1heFZhbHVlTm9kZSA9IGxheW91dE5vZGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgbWF4TGV2ZWxEaWZmID0gKHByb3BzTWF4TGV2ZWxEaWZmIHx8XG4gICAgICAgICAgICAgICAgKHNvcnRCeSA9PT0gJ2RlZ3JlZSdcbiAgICAgICAgICAgICAgICAgICAgPyBncmFwaC5nZXREZWdyZWUobWF4VmFsdWVOb2RlLmlkLCAnYm90aCcpXG4gICAgICAgICAgICAgICAgICAgIDogbWF4VmFsdWVOb2RlLmRhdGFbc29ydEJ5XSkpIC8gNDtcbiAgICAgICAgICAgIC8vIHB1dCB0aGUgdmFsdWVzIGludG8gbGV2ZWxzXG4gICAgICAgICAgICBjb25zdCBsZXZlbHMgPSBbeyBub2RlczogW10gfV07XG4gICAgICAgICAgICBsZXQgY3VycmVudExldmVsID0gbGV2ZWxzWzBdO1xuICAgICAgICAgICAgbGF5b3V0Tm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TGV2ZWwubm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkaWZmID0gc29ydEJ5ID09PSAnZGVncmVlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBNYXRoLmFicyhncmFwaC5nZXREZWdyZWUoY3VycmVudExldmVsLm5vZGVzWzBdLmlkLCAnYm90aCcpIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncmFwaC5nZXREZWdyZWUobm9kZS5pZCwgJ2JvdGgnKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogTWF0aC5hYnMoY3VycmVudExldmVsLm5vZGVzWzBdLmRhdGFbc29ydEJ5XSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5kYXRhW3NvcnRCeV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF4TGV2ZWxEaWZmICYmIGRpZmYgPj0gbWF4TGV2ZWxEaWZmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwgPSB7IG5vZGVzOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV2ZWxzLnB1c2goY3VycmVudExldmVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50TGV2ZWwubm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gY3JlYXRlIHBvc2l0aW9ucyBmb3IgbGV2ZWxzXG4gICAgICAgICAgICBsZXQgbWluRGlzdCA9IG1heE5vZGVTaXplICsgbWF4Tm9kZVNwYWNpbmc7IC8vIG1pbiBkaXN0IGJldHdlZW4gbm9kZXNcbiAgICAgICAgICAgIGlmICghcHJldmVudE92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICAvLyB0aGVuIHN0cmljdGx5IGNvbnN0cmFpbiB0byBiYlxuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0THZsSGFzTXVsdGkgPSBsZXZlbHMubGVuZ3RoID4gMCAmJiBsZXZlbHNbMF0ubm9kZXMubGVuZ3RoID4gMTtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXhSID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCkgLyAyIC0gbWluRGlzdDtcbiAgICAgICAgICAgICAgICBjb25zdCByU3RlcCA9IG1heFIgLyAobGV2ZWxzLmxlbmd0aCArIChmaXJzdEx2bEhhc011bHRpID8gMSA6IDApKTtcbiAgICAgICAgICAgICAgICBtaW5EaXN0ID0gTWF0aC5taW4obWluRGlzdCwgclN0ZXApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZmluZCB0aGUgbWV0cmljcyBmb3IgZWFjaCBsZXZlbFxuICAgICAgICAgICAgbGV0IHIgPSAwO1xuICAgICAgICAgICAgbGV2ZWxzLmZvckVhY2goKGxldmVsKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3dlZXAgPSBwcm9wc1N3ZWVwID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgPyAyICogTWF0aC5QSSAtICgyICogTWF0aC5QSSkgLyBsZXZlbC5ub2Rlcy5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgOiBwcm9wc1N3ZWVwO1xuICAgICAgICAgICAgICAgIGxldmVsLmRUaGV0YSA9IHN3ZWVwIC8gTWF0aC5tYXgoMSwgbGV2ZWwubm9kZXMubGVuZ3RoIC0gMSk7XG4gICAgICAgICAgICAgICAgLy8gY2FsY3VsYXRlIHRoZSByYWRpdXNcbiAgICAgICAgICAgICAgICBpZiAobGV2ZWwubm9kZXMubGVuZ3RoID4gMSAmJiBwcmV2ZW50T3ZlcmxhcCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBidXQgb25seSBpZiBtb3JlIHRoYW4gb25lIG5vZGUgKGNhbid0IG92ZXJsYXApXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRjb3MgPSBNYXRoLmNvcyhsZXZlbC5kVGhldGEpIC0gTWF0aC5jb3MoMCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRzaW4gPSBNYXRoLnNpbihsZXZlbC5kVGhldGEpIC0gTWF0aC5zaW4oMCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJNaW4gPSBNYXRoLnNxcnQoKG1pbkRpc3QgKiBtaW5EaXN0KSAvIChkY29zICogZGNvcyArIGRzaW4gKiBkc2luKSk7IC8vIHMudC4gbm8gbm9kZXMgb3ZlcmxhcHBpbmdcbiAgICAgICAgICAgICAgICAgICAgciA9IE1hdGgubWF4KHJNaW4sIHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXZlbC5yID0gcjtcbiAgICAgICAgICAgICAgICByICs9IG1pbkRpc3Q7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChlcXVpZGlzdGFudCkge1xuICAgICAgICAgICAgICAgIGxldCByRGVsdGFNYXggPSAwO1xuICAgICAgICAgICAgICAgIGxldCByciA9IDA7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGV2ZWwgPSBsZXZlbHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJEZWx0YSA9IChsZXZlbC5yIHx8IDApIC0gcnI7XG4gICAgICAgICAgICAgICAgICAgIHJEZWx0YU1heCA9IE1hdGgubWF4KHJEZWx0YU1heCwgckRlbHRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcnIgPSAwO1xuICAgICAgICAgICAgICAgIGxldmVscy5mb3JFYWNoKChsZXZlbCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnIgPSBsZXZlbC5yIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV2ZWwuciA9IHJyO1xuICAgICAgICAgICAgICAgICAgICByciArPSByRGVsdGFNYXg7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIG5vZGUgcG9zaXRpb25zXG4gICAgICAgICAgICBsZXZlbHMuZm9yRWFjaCgobGV2ZWwpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkVGhldGEgPSBsZXZlbC5kVGhldGEgfHwgMDtcbiAgICAgICAgICAgICAgICBjb25zdCByciA9IGxldmVsLnIgfHwgMDtcbiAgICAgICAgICAgICAgICBsZXZlbC5ub2Rlcy5mb3JFYWNoKChub2RlLCBqKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRoZXRhID0gc3RhcnRBbmdsZSArIChjbG9ja3dpc2UgPyAxIDogLTEpICogZFRoZXRhICogajtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5kYXRhLnggPSBjZW50ZXJbMF0gKyByciAqIE1hdGguY29zKHRoZXRhKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5kYXRhLnkgPSBjZW50ZXJbMV0gKyByciAqIE1hdGguc2luKHRoZXRhKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGFzc2lnbikge1xuICAgICAgICAgICAgICAgIGxheW91dE5vZGVzLmZvckVhY2goKG5vZGUpID0+IGdyYXBoLm1lcmdlTm9kZURhdGEobm9kZS5pZCwge1xuICAgICAgICAgICAgICAgICAgICB4OiBub2RlLmRhdGEueCxcbiAgICAgICAgICAgICAgICAgICAgeTogbm9kZS5kYXRhLnksXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIG5vZGVzOiBsYXlvdXROb2RlcyxcbiAgICAgICAgICAgICAgICBlZGdlcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25jZW50cmljLmpzLm1hcCIsImltcG9ydCB7IGZvcmNlQ2VudGVyLCBmb3JjZUNvbGxpZGUsIGZvcmNlTGluaywgZm9yY2VNYW55Qm9keSwgZm9yY2VSYWRpYWwsIGZvcmNlU2ltdWxhdGlvbiwgZm9yY2VYLCBmb3JjZVksIGZvcmNlWiwgfSBmcm9tICdkMy1mb3JjZS0zZCc7XG5pbXBvcnQgeyBEM0ZvcmNlTGF5b3V0IH0gZnJvbSAnLi4vZDMtZm9yY2UnO1xuZXhwb3J0IGNsYXNzIEQzRm9yY2UzRExheW91dCBleHRlbmRzIEQzRm9yY2VMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmlkID0gJ2QzLWZvcmNlLTNkJztcbiAgICAgICAgdGhpcy5jb25maWcgPSB7XG4gICAgICAgICAgICBpbnB1dE5vZGVBdHRyczogWyd4JywgJ3knLCAneicsICd2eCcsICd2eScsICd2eicsICdmeCcsICdmeScsICdmeiddLFxuICAgICAgICAgICAgb3V0cHV0Tm9kZUF0dHJzOiBbJ3gnLCAneScsICd6JywgJ3Z4JywgJ3Z5JywgJ3Z6J10sXG4gICAgICAgICAgICBzaW11bGF0aW9uQXR0cnM6IFtcbiAgICAgICAgICAgICAgICAnYWxwaGEnLFxuICAgICAgICAgICAgICAgICdhbHBoYU1pbicsXG4gICAgICAgICAgICAgICAgJ2FscGhhRGVjYXknLFxuICAgICAgICAgICAgICAgICdhbHBoYVRhcmdldCcsXG4gICAgICAgICAgICAgICAgJ3ZlbG9jaXR5RGVjYXknLFxuICAgICAgICAgICAgICAgICdyYW5kb21Tb3VyY2UnLFxuICAgICAgICAgICAgICAgICdudW1EaW1lbnNpb25zJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZm9yY2VNYXAgPSB7XG4gICAgICAgICAgICBsaW5rOiBmb3JjZUxpbmssXG4gICAgICAgICAgICBtYW55Qm9keTogZm9yY2VNYW55Qm9keSxcbiAgICAgICAgICAgIGNlbnRlcjogZm9yY2VDZW50ZXIsXG4gICAgICAgICAgICBjb2xsaWRlOiBmb3JjZUNvbGxpZGUsXG4gICAgICAgICAgICByYWRpYWw6IGZvcmNlUmFkaWFsLFxuICAgICAgICAgICAgeDogZm9yY2VYLFxuICAgICAgICAgICAgeTogZm9yY2VZLFxuICAgICAgICAgICAgejogZm9yY2VaLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgICAgICBudW1EaW1lbnNpb25zOiAzLFxuICAgICAgICAgICAgbGluazoge1xuICAgICAgICAgICAgICAgIGlkOiAoZWRnZSkgPT4gZWRnZS5pZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYW55Qm9keToge30sXG4gICAgICAgICAgICBjZW50ZXI6IHtcbiAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgejogMCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGluaXRTaW11bGF0aW9uKCkge1xuICAgICAgICByZXR1cm4gZm9yY2VTaW11bGF0aW9uKCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBkZWVwTWl4LCBwaWNrIH0gZnJvbSAnQGFudHYvdXRpbCc7XG5pbXBvcnQgeyBmb3JjZUNlbnRlciwgZm9yY2VDb2xsaWRlLCBmb3JjZUxpbmssIGZvcmNlTWFueUJvZHksIGZvcmNlUmFkaWFsLCBmb3JjZVNpbXVsYXRpb24sIGZvcmNlWCwgZm9yY2VZLCB9IGZyb20gJ2QzLWZvcmNlJztcbmV4cG9ydCBjbGFzcyBEM0ZvcmNlTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaWQgPSAnZDMtZm9yY2UnO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IHtcbiAgICAgICAgICAgIGlucHV0Tm9kZUF0dHJzOiBbJ3gnLCAneScsICd2eCcsICd2eScsICdmeCcsICdmeSddLFxuICAgICAgICAgICAgb3V0cHV0Tm9kZUF0dHJzOiBbJ3gnLCAneScsICd2eCcsICd2eSddLFxuICAgICAgICAgICAgc2ltdWxhdGlvbkF0dHJzOiBbXG4gICAgICAgICAgICAgICAgJ2FscGhhJyxcbiAgICAgICAgICAgICAgICAnYWxwaGFNaW4nLFxuICAgICAgICAgICAgICAgICdhbHBoYURlY2F5JyxcbiAgICAgICAgICAgICAgICAnYWxwaGFUYXJnZXQnLFxuICAgICAgICAgICAgICAgICd2ZWxvY2l0eURlY2F5JyxcbiAgICAgICAgICAgICAgICAncmFuZG9tU291cmNlJyxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZm9yY2VNYXAgPSB7XG4gICAgICAgICAgICBsaW5rOiBmb3JjZUxpbmssXG4gICAgICAgICAgICBtYW55Qm9keTogZm9yY2VNYW55Qm9keSxcbiAgICAgICAgICAgIGNlbnRlcjogZm9yY2VDZW50ZXIsXG4gICAgICAgICAgICBjb2xsaWRlOiBmb3JjZUNvbGxpZGUsXG4gICAgICAgICAgICByYWRpYWw6IGZvcmNlUmFkaWFsLFxuICAgICAgICAgICAgeDogZm9yY2VYLFxuICAgICAgICAgICAgeTogZm9yY2VZLFxuICAgICAgICB9O1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGxpbms6IHtcbiAgICAgICAgICAgICAgICBpZDogKGVkZ2UpID0+IGVkZ2UuaWQsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWFueUJvZHk6IHt9LFxuICAgICAgICAgICAgY2VudGVyOiB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0ge1xuICAgICAgICAgICAgb3B0aW9uczoge30sXG4gICAgICAgICAgICBhc3NpZ246IGZhbHNlLFxuICAgICAgICAgICAgbm9kZXM6IFtdLFxuICAgICAgICAgICAgZWRnZXM6IFtdLFxuICAgICAgICB9O1xuICAgICAgICBkZWVwTWl4KHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZm9yY2VTaW11bGF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnNpbXVsYXRpb24gPSB0aGlzLm9wdGlvbnMuZm9yY2VTaW11bGF0aW9uO1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4ZWN1dGUoZ3JhcGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyaWNMYXlvdXQoZmFsc2UsIGdyYXBoLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzc2lnbihncmFwaCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZW5lcmljTGF5b3V0KHRydWUsIGdyYXBoLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuc2ltdWxhdGlvbi5zdG9wKCk7XG4gICAgfVxuICAgIHRpY2soaXRlcmF0aW9ucykge1xuICAgICAgICB0aGlzLnNpbXVsYXRpb24udGljayhpdGVyYXRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVzdWx0KCk7XG4gICAgfVxuICAgIHJlc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc2ltdWxhdGlvbi5yZXN0YXJ0KCk7XG4gICAgfVxuICAgIHNldEZpeGVkUG9zaXRpb24oaWQsIHBvc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmNvbnRleHQubm9kZXMuZmluZCgobikgPT4gbi5pZCA9PT0gaWQpO1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHBvc2l0aW9uLmZvckVhY2goKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBbJ2Z4JywgJ2Z5JywgJ2Z6J11baW5kZXhdO1xuICAgICAgICAgICAgICAgIG5vZGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IF8gPSBkZWVwTWl4KHt9LCB0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAvLyBwcm9jZXNzIG5vZGVTaXplXG4gICAgICAgIGlmIChfLmNvbGxpZGUgJiYgKChfYSA9IF8uY29sbGlkZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJhZGl1cykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgXy5jb2xsaWRlID0gXy5jb2xsaWRlIHx8IHt9O1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgXy5jb2xsaWRlLnJhZGl1cyA9IChfYiA9IF8ubm9kZVNpemUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDEwO1xuICAgICAgICB9XG4gICAgICAgIC8vIHByb2Nlc3MgaXRlcmF0aW9uc1xuICAgICAgICBpZiAoXy5pdGVyYXRpb25zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChfLmxpbmsgJiYgXy5saW5rLml0ZXJhdGlvbnMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIF8uaXRlcmF0aW9ucyA9IF8ubGluay5pdGVyYXRpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF8uY29sbGlkZSAmJiBfLmNvbGxpZGUuaXRlcmF0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgXy5pdGVyYXRpb25zID0gXy5jb2xsaWRlLml0ZXJhdGlvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXNzaWduIHRvIGNvbnRleHRcbiAgICAgICAgdGhpcy5jb250ZXh0Lm9wdGlvbnMgPSBfO1xuICAgICAgICByZXR1cm4gXztcbiAgICB9XG4gICAgZ2VuZXJpY0xheW91dChhc3NpZ24sIGdyYXBoLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IF9vcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBncmFwaC5nZXRBbGxOb2RlcygpLm1hcCgoeyBpZCwgZGF0YSB9KSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHsgaWQgfSwgZGF0YSksIHBpY2soZGF0YS5kYXRhLCB0aGlzLmNvbmZpZy5pbnB1dE5vZGVBdHRycykpKSk7XG4gICAgICAgICAgICBjb25zdCBlZGdlcyA9IGdyYXBoLmdldEFsbEVkZ2VzKCkubWFwKChlZGdlKSA9PiAoT2JqZWN0LmFzc2lnbih7fSwgZWRnZSkpKTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5jb250ZXh0LCB7IGFzc2lnbiwgbm9kZXMsIGVkZ2VzLCBncmFwaCB9KTtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZXIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc29sdmVyID0gcmVzb2x2ZXI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNpbXVsYXRpb24gPSB0aGlzLnNldFNpbXVsYXRpb24oX29wdGlvbnMpO1xuICAgICAgICAgICAgc2ltdWxhdGlvbi5ub2Rlcyhub2Rlcyk7XG4gICAgICAgICAgICAoX2EgPSBzaW11bGF0aW9uLmZvcmNlKCdsaW5rJykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5saW5rcyhlZGdlcyk7XG4gICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFJlc3VsdCgpIHtcbiAgICAgICAgY29uc3QgeyBhc3NpZ24sIG5vZGVzLCBlZGdlcywgZ3JhcGggfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgY29uc3Qgbm9kZXNSZXN1bHQgPSBub2Rlcy5tYXAoKG5vZGUpID0+ICh7XG4gICAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICAgIGRhdGE6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbm9kZS5kYXRhKSwgcGljayhub2RlLCB0aGlzLmNvbmZpZy5vdXRwdXROb2RlQXR0cnMpKSxcbiAgICAgICAgfSkpO1xuICAgICAgICBjb25zdCBlZGdlUmVzdWx0ID0gZWRnZXMubWFwKCh7IGlkLCBzb3VyY2UsIHRhcmdldCwgZGF0YSB9KSA9PiAoe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBzb3VyY2U6IHR5cGVvZiBzb3VyY2UgPT09ICdvYmplY3QnID8gc291cmNlLmlkIDogc291cmNlLFxuICAgICAgICAgICAgdGFyZ2V0OiB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0JyA/IHRhcmdldC5pZCA6IHRhcmdldCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKGFzc2lnbikge1xuICAgICAgICAgICAgbm9kZXNSZXN1bHQuZm9yRWFjaCgobm9kZSkgPT4gZ3JhcGgubWVyZ2VOb2RlRGF0YShub2RlLmlkLCBub2RlLmRhdGEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBub2Rlczogbm9kZXNSZXN1bHQsIGVkZ2VzOiBlZGdlUmVzdWx0IH07XG4gICAgfVxuICAgIGluaXRTaW11bGF0aW9uKCkge1xuICAgICAgICByZXR1cm4gZm9yY2VTaW11bGF0aW9uKCk7XG4gICAgfVxuICAgIHNldFNpbXVsYXRpb24ob3B0aW9ucykge1xuICAgICAgICBjb25zdCBzaW11bGF0aW9uID0gdGhpcy5zaW11bGF0aW9uIHx8IHRoaXMub3B0aW9ucy5mb3JjZVNpbXVsYXRpb24gfHwgdGhpcy5pbml0U2ltdWxhdGlvbigpO1xuICAgICAgICBpZiAoIXRoaXMuc2ltdWxhdGlvbikge1xuICAgICAgICAgICAgdGhpcy5zaW11bGF0aW9uID0gc2ltdWxhdGlvblxuICAgICAgICAgICAgICAgIC5vbigndGljaycsICgpID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gb3B0aW9ucy5vblRpY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMsIHRoaXMuZ2V0UmVzdWx0KCkpOyB9KVxuICAgICAgICAgICAgICAgIC5vbignZW5kJywgKCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSB0aGlzLnJlc29sdmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCB0aGlzLmdldFJlc3VsdCgpKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYXBwbHkoc2ltdWxhdGlvbiwgdGhpcy5jb25maWcuc2ltdWxhdGlvbkF0dHJzLm1hcCgobmFtZSkgPT4gW1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIG9wdGlvbnNbbmFtZV0sXG4gICAgICAgIF0pKTtcbiAgICAgICAgT2JqZWN0LmVudHJpZXModGhpcy5mb3JjZU1hcCkuZm9yRWFjaCgoW25hbWUsIEN0b3JdKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmb3JjZU5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBsZXQgZm9yY2UgPSBzaW11bGF0aW9uLmZvcmNlKGZvcmNlTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3JjZSkge1xuICAgICAgICAgICAgICAgICAgICBmb3JjZSA9IEN0b3IoKTtcbiAgICAgICAgICAgICAgICAgICAgc2ltdWxhdGlvbi5mb3JjZShmb3JjZU5hbWUsIGZvcmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXBwbHkoZm9yY2UsIE9iamVjdC5lbnRyaWVzKG9wdGlvbnNbZm9yY2VOYW1lXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHNpbXVsYXRpb24uZm9yY2UoZm9yY2VOYW1lLCBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzaW11bGF0aW9uO1xuICAgIH1cbn1cbmNvbnN0IGFwcGx5ID0gKHRhcmdldCwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIHBhcmFtcy5yZWR1Y2UoKGFjYywgW21ldGhvZCwgcGFyYW1dKSA9PiB7XG4gICAgICAgIGlmICghYWNjW21ldGhvZF0gfHwgcGFyYW0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHJldHVybiBhY2NbbWV0aG9kXS5jYWxsKHRhcmdldCwgcGFyYW0pO1xuICAgIH0sIHRhcmdldCk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHsgX19hd2FpdGVyLCBfX3Jlc3QgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGlzRnVuY3Rpb24sIGlzTnVtYmVyIH0gZnJvbSAnQGFudHYvdXRpbCc7XG5pbXBvcnQgZGFncmUsIHsgZ3JhcGhsaWIgfSBmcm9tICdkYWdyZSc7XG5pbXBvcnQgeyBwYXJzZVNpemUgfSBmcm9tICcuL3V0aWwvc2l6ZSc7XG4vKipcbiAqIDx6aC8+IERhZ3JlIOW4g+WxgFxuICpcbiAqIDxlbi8+IERhZ3JlIGxheW91dFxuICovXG5leHBvcnQgY2xhc3MgRGFncmVMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pZCA9ICdkYWdyZSc7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMub3B0aW9ucywgRGFncmVMYXlvdXQuZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBleGVjdXRlKGdyYXBoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmljRGFncmVMYXlvdXQoZmFsc2UsIGdyYXBoLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucyksIG9wdGlvbnMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzc2lnbihncmFwaCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZW5lcmljRGFncmVMYXlvdXQodHJ1ZSwgZ3JhcGgsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKSwgb3B0aW9ucykpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2VuZXJpY0RhZ3JlTGF5b3V0KGFzc2lnbiwgZ3JhcGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZVNpemUgfSA9IG9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBnID0gbmV3IGdyYXBobGliLkdyYXBoKCk7XG4gICAgICAgICAgICBnLnNldEdyYXBoKG9wdGlvbnMpO1xuICAgICAgICAgICAgZy5zZXREZWZhdWx0RWRnZUxhYmVsKCgpID0+ICh7fSkpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBncmFwaC5nZXRBbGxOb2RlcygpO1xuICAgICAgICAgICAgY29uc3QgZWRnZXMgPSBncmFwaC5nZXRBbGxFZGdlcygpO1xuICAgICAgICAgICAgaWYgKFsuLi5ub2RlcywgLi4uZWRnZXNdLnNvbWUoKHsgaWQgfSkgPT4gaXNOdW1iZXIoaWQpKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0RhZ3JlIGxheW91dCBvbmx5IHN1cHBvcnQgc3RyaW5nIGlkLCBpdCB3aWxsIGNvbnZlcnQgbnVtYmVyIHRvIHN0cmluZy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyYXBoLmdldEFsbE5vZGVzKCkuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaWQgfSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YSA9IE9iamVjdC5hc3NpZ24oe30sIG5vZGUuZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gcGFyc2VTaXplKGlzRnVuY3Rpb24obm9kZVNpemUpID8gbm9kZVNpemUobm9kZSkgOiBub2RlU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZGF0YSwgeyB3aWR0aCwgaGVpZ2h0IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnLnNldE5vZGUoaWQudG9TdHJpbmcoKSwgZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGdyYXBoLmdldEFsbEVkZ2VzKCkuZm9yRWFjaCgoeyBpZCwgc291cmNlLCB0YXJnZXQgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGcuc2V0RWRnZShzb3VyY2UudG9TdHJpbmcoKSwgdGFyZ2V0LnRvU3RyaW5nKCksIHsgaWQgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRhZ3JlLmxheW91dChnKTtcbiAgICAgICAgICAgIGNvbnN0IG1hcHBpbmcgPSB7IG5vZGVzOiBbXSwgZWRnZXM6IFtdIH07XG4gICAgICAgICAgICBnLm5vZGVzKCkuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gZy5ub2RlKGlkKTtcbiAgICAgICAgICAgICAgICBtYXBwaW5nLm5vZGVzLnB1c2goeyBpZCwgZGF0YSB9KTtcbiAgICAgICAgICAgICAgICBpZiAoYXNzaWduKVxuICAgICAgICAgICAgICAgICAgICBncmFwaC5tZXJnZU5vZGVEYXRhKGlkLCBkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZy5lZGdlcygpLmZvckVhY2goKGVkZ2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBfYSA9IGcuZWRnZShlZGdlKSwgeyBpZCB9ID0gX2EsIGRhdGEgPSBfX3Jlc3QoX2EsIFtcImlkXCJdKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHY6IHNvdXJjZSwgdzogdGFyZ2V0IH0gPSBlZGdlO1xuICAgICAgICAgICAgICAgIG1hcHBpbmcuZWRnZXMucHVzaCh7IGlkLCBzb3VyY2UsIHRhcmdldCwgZGF0YSB9KTtcbiAgICAgICAgICAgICAgICBpZiAoYXNzaWduKVxuICAgICAgICAgICAgICAgICAgICBncmFwaC5tZXJnZUVkZ2VEYXRhKGlkLCBkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG1hcHBpbmc7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbkRhZ3JlTGF5b3V0LmRlZmF1bHRPcHRpb25zID0ge307XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYWdyZS5qcy5tYXAiLCIvLyByZXByZXNlbnRzIGEgYm9keShhIHBvaW50IG1hc3MpIGFuZCBpdHMgcG9zaXRpb25cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJvZHkge1xuICAgIGNvbnN0cnVjdG9yKHBhcmFtcykge1xuICAgICAgICAvKipcbiAgICAgICAgICogdGhlIGlkIG9mIHRoaXMgYm9keSwgdGhlIHNhbWUgd2l0aCB0aGUgbm9kZSBpZFxuICAgICAgICAgKiBAdHlwZSAge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBwYXJhbXMuaWQgfHwgMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRoZSBwb3NpdGlvbiBvZiB0aGlzIGJvZHlcbiAgICAgICAgICogQHR5cGUgIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJ4ID0gcGFyYW1zLnJ4O1xuICAgICAgICAvKipcbiAgICAgICAgICogdGhlIHBvc2l0aW9uIG9mIHRoaXMgYm9keVxuICAgICAgICAgKiBAdHlwZSAge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucnkgPSBwYXJhbXMucnk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGUgZm9yY2UgYWN0aW5nIG9uIHRoaXMgYm9keVxuICAgICAgICAgKiBAdHlwZSAge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZnggPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogdGhlIGZvcmNlIGFjdGluZyBvbiB0aGlzIGJvZHlcbiAgICAgICAgICogQHR5cGUgIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmZ5ID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRoZSBtYXNzIG9mIHRoaXMgYm9keSwgPTEgZm9yIGEgbm9kZVxuICAgICAgICAgKiBAdHlwZSAge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFzcyA9IHBhcmFtcy5tYXNzO1xuICAgICAgICAvKipcbiAgICAgICAgICogdGhlIGRlZ3JlZSBvZiB0aGUgbm9kZSByZXByZXNlbnRlZCBieSB0aGlzIGJvZHlcbiAgICAgICAgICogQHR5cGUgIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRlZ3JlZSA9IHBhcmFtcy5kZWdyZWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGUgcGFyYW1ldGVyIGZvciByZXB1bHNpdmUgZm9yY2UsID0ga3JcbiAgICAgICAgICogQHR5cGUgIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmcgPSBwYXJhbXMuZyB8fCAwO1xuICAgIH1cbiAgICAvLyByZXR1cm5zIHRoZSBldWNsaWRlYW4gZGlzdGFuY2VcbiAgICBkaXN0YW5jZVRvKGJvKSB7XG4gICAgICAgIGNvbnN0IGR4ID0gdGhpcy5yeCAtIGJvLnJ4O1xuICAgICAgICBjb25zdCBkeSA9IHRoaXMucnkgLSBiby5yeTtcbiAgICAgICAgcmV0dXJuIE1hdGguaHlwb3QoZHgsIGR5KTtcbiAgICB9XG4gICAgc2V0UG9zKHgsIHkpIHtcbiAgICAgICAgdGhpcy5yeCA9IHg7XG4gICAgICAgIHRoaXMucnkgPSB5O1xuICAgIH1cbiAgICAvLyByZXNldHMgdGhlIGZvcmNlc1xuICAgIHJlc2V0Rm9yY2UoKSB7XG4gICAgICAgIHRoaXMuZnggPSAwO1xuICAgICAgICB0aGlzLmZ5ID0gMDtcbiAgICB9XG4gICAgYWRkRm9yY2UoYikge1xuICAgICAgICBjb25zdCBkeCA9IGIucnggLSB0aGlzLnJ4O1xuICAgICAgICBjb25zdCBkeSA9IGIucnkgLSB0aGlzLnJ5O1xuICAgICAgICBsZXQgZGlzdCA9IE1hdGguaHlwb3QoZHgsIGR5KTtcbiAgICAgICAgZGlzdCA9IGRpc3QgPCAwLjAwMDEgPyAwLjAwMDEgOiBkaXN0O1xuICAgICAgICAvLyB0aGUgcmVwdWxzaXZlIGRlZmluZWQgYnkgZm9yY2UgYXRsYXMgMlxuICAgICAgICBjb25zdCBGID0gKHRoaXMuZyAqICh0aGlzLmRlZ3JlZSArIDEpICogKGIuZGVncmVlICsgMSkpIC8gZGlzdDtcbiAgICAgICAgdGhpcy5meCArPSAoRiAqIGR4KSAvIGRpc3Q7XG4gICAgICAgIHRoaXMuZnkgKz0gKEYgKiBkeSkgLyBkaXN0O1xuICAgIH1cbiAgICAvLyBpZiBxdWFkIGNvbnRhaW5zIHRoaXMgYm9keVxuICAgIGluKHF1YWQpIHtcbiAgICAgICAgcmV0dXJuIHF1YWQuY29udGFpbnModGhpcy5yeCwgdGhpcy5yeSk7XG4gICAgfVxuICAgIC8vIHJldHVybnMgYSBuZXcgYm9keVxuICAgIGFkZChibykge1xuICAgICAgICBjb25zdCBuZW53TWFzcyA9IHRoaXMubWFzcyArIGJvLm1hc3M7XG4gICAgICAgIGNvbnN0IHggPSAodGhpcy5yeCAqIHRoaXMubWFzcyArIGJvLnJ4ICogYm8ubWFzcykgLyBuZW53TWFzcztcbiAgICAgICAgY29uc3QgeSA9ICh0aGlzLnJ5ICogdGhpcy5tYXNzICsgYm8ucnkgKiBiby5tYXNzKSAvIG5lbndNYXNzO1xuICAgICAgICBjb25zdCBkZyA9IHRoaXMuZGVncmVlICsgYm8uZGVncmVlO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICByeDogeCxcbiAgICAgICAgICAgIHJ5OiB5LFxuICAgICAgICAgICAgbWFzczogbmVud01hc3MsXG4gICAgICAgICAgICBkZWdyZWU6IGRnLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IEJvZHkocGFyYW1zKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib2R5LmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgR3JhcGggYXMgR0dyYXBoIH0gZnJvbSAnQGFudHYvZ3JhcGhsaWInO1xuaW1wb3J0IHsgaXNOdW1iZXIgfSBmcm9tICdAYW50di91dGlsJztcbmltcG9ydCB7IGNsb25lRm9ybWF0RGF0YSwgZm9ybWF0Tm9kZVNpemVUb051bWJlciB9IGZyb20gJy4uL3V0aWwnO1xuaW1wb3J0IHsgaGFuZGxlU2luZ2xlTm9kZUdyYXBoIH0gZnJvbSAnLi4vdXRpbC9jb21tb24nO1xuaW1wb3J0IEJvZHkgZnJvbSAnLi9ib2R5JztcbmltcG9ydCBRdWFkIGZyb20gJy4vcXVhZCc7XG5pbXBvcnQgUXVhZFRyZWUgZnJvbSAnLi9xdWFkLXRyZWUnO1xuY29uc3QgREVGQVVMVFNfTEFZT1VUX09QVElPTlMgPSB7XG4gICAgY2VudGVyOiBbMCwgMF0sXG4gICAgd2lkdGg6IDMwMCxcbiAgICBoZWlnaHQ6IDMwMCxcbiAgICBrcjogNSxcbiAgICBrZzogMSxcbiAgICBtb2RlOiAnbm9ybWFsJyxcbiAgICBwcmV2ZW50T3ZlcmxhcDogZmFsc2UsXG4gICAgZGlzc3VhZGVIdWJzOiBmYWxzZSxcbiAgICBtYXhJdGVyYXRpb246IDAsXG4gICAga3M6IDAuMSxcbiAgICBrc21heDogMTAsXG4gICAgdGFvOiAwLjEsXG59O1xuLyoqXG4gKiA8emgvPiBBdGxhczIg5Yqb5a+85ZCR5biD5bGAXG4gKlxuICogPGVuLz4gRm9yY2UgQXRsYXMgMiBsYXlvdXRcbiAqL1xuZXhwb3J0IGNsYXNzIEZvcmNlQXRsYXMyTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5pZCA9ICdmb3JjZUF0bGFzMic7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVFNfTEFZT1VUX09QVElPTlMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBwb3NpdGlvbnMgb2Ygbm9kZXMgYW5kIGVkZ2VzKGlmIG5lZWRlZCkuXG4gICAgICovXG4gICAgZXhlY3V0ZShncmFwaCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJpY0ZvcmNlQXRsYXMyTGF5b3V0KGZhbHNlLCBncmFwaCwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUbyBkaXJlY3RseSBhc3NpZ24gdGhlIHBvc2l0aW9ucyB0byB0aGUgbm9kZXMuXG4gICAgICovXG4gICAgYXNzaWduKGdyYXBoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdlbmVyaWNGb3JjZUF0bGFzMkxheW91dCh0cnVlLCBncmFwaCwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZW5lcmljRm9yY2VBdGxhczJMYXlvdXQoYXNzaWduLCBncmFwaCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZWRnZXMgPSBncmFwaC5nZXRBbGxFZGdlcygpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBncmFwaC5nZXRBbGxOb2RlcygpO1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IHRoaXMuZm9ybWF0T3B0aW9ucyhvcHRpb25zLCBub2Rlcy5sZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCBwcnVuZSwgbWF4SXRlcmF0aW9uLCBub2RlU2l6ZSwgY2VudGVyIH0gPSBtZXJnZWRPcHRpb25zO1xuICAgICAgICAgICAgaWYgKCEobm9kZXMgPT09IG51bGwgfHwgbm9kZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGVzLmxlbmd0aCkgfHwgbm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVNpbmdsZU5vZGVHcmFwaChncmFwaCwgYXNzaWduLCBjZW50ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2FsY05vZGVzID0gbm9kZXMubWFwKChub2RlKSA9PiBjbG9uZUZvcm1hdERhdGEobm9kZSwgW3dpZHRoLCBoZWlnaHRdKSk7XG4gICAgICAgICAgICBjb25zdCBjYWxjRWRnZXMgPSBlZGdlcy5maWx0ZXIoKGVkZ2UpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNvdXJjZSwgdGFyZ2V0IH0gPSBlZGdlO1xuICAgICAgICAgICAgICAgIHJldHVybiBzb3VyY2UgIT09IHRhcmdldDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY2FsY0dyYXBoID0gbmV3IEdHcmFwaCh7XG4gICAgICAgICAgICAgICAgbm9kZXM6IGNhbGNOb2RlcyxcbiAgICAgICAgICAgICAgICBlZGdlczogY2FsY0VkZ2VzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzaXplcyA9IHRoaXMuZ2V0U2l6ZXMoY2FsY0dyYXBoLCBub2RlU2l6ZSk7XG4gICAgICAgICAgICB0aGlzLnJ1bihjYWxjR3JhcGgsIGdyYXBoLCBtYXhJdGVyYXRpb24sIHNpemVzLCBhc3NpZ24sIG1lcmdlZE9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gaWYgcHJ1bmUsIHBsYWNlIHRoZSBsZWF2ZXMgYXJvdW5kIHRoZWlyIHBhcmVudHMsIGFuZCB0aGVuIHJlLWxheW91dCBmb3Igc2V2ZXJhbCBpdGVyYXRpb25zLlxuICAgICAgICAgICAgaWYgKHBydW5lKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjYWxjRWRnZXMubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzb3VyY2UsIHRhcmdldCB9ID0gY2FsY0VkZ2VzW2pdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VEZWdyZWUgPSBjYWxjR3JhcGguZ2V0RGVncmVlKHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldERlZ3JlZSA9IGNhbGNHcmFwaC5nZXREZWdyZWUoc291cmNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZURlZ3JlZSA8PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXROb2RlID0gY2FsY0dyYXBoLmdldE5vZGUodGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGNHcmFwaC5tZXJnZU5vZGVEYXRhKHNvdXJjZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IHRhcmdldE5vZGUuZGF0YS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IHRhcmdldE5vZGUuZGF0YS55LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0RGVncmVlIDw9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZU5vZGUgPSBjYWxjR3JhcGguZ2V0Tm9kZShzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsY0dyYXBoLm1lcmdlTm9kZURhdGEodGFyZ2V0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogc291cmNlTm9kZS5kYXRhLngsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogc291cmNlTm9kZS5kYXRhLnksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwb3N0T3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbWVyZ2VkT3B0aW9ucyksIHsgcHJ1bmU6IGZhbHNlLCBiYXJuZXNIdXQ6IGZhbHNlIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucnVuKGNhbGNHcmFwaCwgZ3JhcGgsIDEwMCwgc2l6ZXMsIGFzc2lnbiwgcG9zdE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBub2RlczogY2FsY05vZGVzLFxuICAgICAgICAgICAgICAgIGVkZ2VzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXQgdGhlIG5vZGUgcG9zaXRpb25zIGlmIHRoZXJlIGlzIG5vIGluaXRpYWwgcG9zaXRpb25zLlxuICAgICAqIEFuZCBwcmUtY2FsY3VsYXRlIHRoZSBzaXplIChtYXggb2Ygd2lkdGggYW5kIGhlaWdodCkgZm9yIGVhY2ggbm9kZS5cbiAgICAgKiBAcGFyYW0gY2FsY0dyYXBoIGdyYXBoIGZvciBjYWxjdWxhdGlvblxuICAgICAqIEBwYXJhbSBub2RlU2l6ZSBub2RlIHNpemUgY29uZmlnIGZyb20gbGF5b3V0IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7U2l6ZU1hcH0gbm9kZSdpZCBtYXBwZWQgdG8gbWF4IG9mIGl0cyB3aWR0aCBhbmQgaGVpZ2h0XG4gICAgICovXG4gICAgZ2V0U2l6ZXMoY2FsY0dyYXBoLCBub2RlU2l6ZSkge1xuICAgICAgICBjb25zdCBub2RlcyA9IGNhbGNHcmFwaC5nZXRBbGxOb2RlcygpO1xuICAgICAgICBjb25zdCBzaXplcyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgICAgICBzaXplc1tub2RlLmlkXSA9IGZvcm1hdE5vZGVTaXplVG9OdW1iZXIobm9kZVNpemUsIHVuZGVmaW5lZCkobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpemVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgdGhlIG9wdGlvbnMuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgaW5wdXQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSBub2RlTnVtIG51bWJlciBvZiBub2Rlc1xuICAgICAqIEByZXR1cm5zIGZvcm1hdHRlZCBvcHRpb25zXG4gICAgICovXG4gICAgZm9ybWF0T3B0aW9ucyhvcHRpb25zID0ge30sIG5vZGVOdW0pIHtcbiAgICAgICAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHsgY2VudGVyLCB3aWR0aCwgaGVpZ2h0LCBiYXJuZXNIdXQsIHBydW5lLCBtYXhJdGVyYXRpb24sIGtyLCBrZyB9ID0gbWVyZ2VkT3B0aW9ucztcbiAgICAgICAgbWVyZ2VkT3B0aW9ucy53aWR0aCA9XG4gICAgICAgICAgICAhd2lkdGggJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuaW5uZXJXaWR0aCA6IHdpZHRoO1xuICAgICAgICBtZXJnZWRPcHRpb25zLmhlaWdodCA9XG4gICAgICAgICAgICAhaGVpZ2h0ICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93LmlubmVySGVpZ2h0IDogaGVpZ2h0O1xuICAgICAgICBtZXJnZWRPcHRpb25zLmNlbnRlciA9ICFjZW50ZXJcbiAgICAgICAgICAgID8gW21lcmdlZE9wdGlvbnMud2lkdGggLyAyLCBtZXJnZWRPcHRpb25zLmhlaWdodCAvIDJdXG4gICAgICAgICAgICA6IGNlbnRlcjtcbiAgICAgICAgaWYgKGJhcm5lc0h1dCA9PT0gdW5kZWZpbmVkICYmIG5vZGVOdW0gPiAyNTApIHtcbiAgICAgICAgICAgIG1lcmdlZE9wdGlvbnMuYmFybmVzSHV0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJ1bmUgPT09IHVuZGVmaW5lZCAmJiBub2RlTnVtID4gMTAwKVxuICAgICAgICAgICAgbWVyZ2VkT3B0aW9ucy5wcnVuZSA9IHRydWU7XG4gICAgICAgIGlmIChtYXhJdGVyYXRpb24gPT09IDAgJiYgIXBydW5lKSB7XG4gICAgICAgICAgICBtZXJnZWRPcHRpb25zLm1heEl0ZXJhdGlvbiA9IDI1MDtcbiAgICAgICAgICAgIGlmIChub2RlTnVtIDw9IDIwMCAmJiBub2RlTnVtID4gMTAwKVxuICAgICAgICAgICAgICAgIG1lcmdlZE9wdGlvbnMubWF4SXRlcmF0aW9uID0gMTAwMDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGVOdW0gPiAyMDApXG4gICAgICAgICAgICAgICAgbWVyZ2VkT3B0aW9ucy5tYXhJdGVyYXRpb24gPSAxMjAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1heEl0ZXJhdGlvbiA9PT0gMCAmJiBwcnVuZSkge1xuICAgICAgICAgICAgbWVyZ2VkT3B0aW9ucy5tYXhJdGVyYXRpb24gPSAxMDA7XG4gICAgICAgICAgICBpZiAobm9kZU51bSA8PSAyMDAgJiYgbm9kZU51bSA+IDEwMClcbiAgICAgICAgICAgICAgICBtZXJnZWRPcHRpb25zLm1heEl0ZXJhdGlvbiA9IDUwMDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGVOdW0gPiAyMDApXG4gICAgICAgICAgICAgICAgbWVyZ2VkT3B0aW9ucy5tYXhJdGVyYXRpb24gPSA5NTA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFrcikge1xuICAgICAgICAgICAgbWVyZ2VkT3B0aW9ucy5rciA9IDUwO1xuICAgICAgICAgICAgaWYgKG5vZGVOdW0gPiAxMDAgJiYgbm9kZU51bSA8PSA1MDApXG4gICAgICAgICAgICAgICAgbWVyZ2VkT3B0aW9ucy5rciA9IDIwO1xuICAgICAgICAgICAgZWxzZSBpZiAobm9kZU51bSA+IDUwMClcbiAgICAgICAgICAgICAgICBtZXJnZWRPcHRpb25zLmtyID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWtnKSB7XG4gICAgICAgICAgICBtZXJnZWRPcHRpb25zLmtnID0gMjA7XG4gICAgICAgICAgICBpZiAobm9kZU51bSA+IDEwMCAmJiBub2RlTnVtIDw9IDUwMClcbiAgICAgICAgICAgICAgICBtZXJnZWRPcHRpb25zLmtnID0gMTA7XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlTnVtID4gNTAwKVxuICAgICAgICAgICAgICAgIG1lcmdlZE9wdGlvbnMua2cgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZXJnZWRPcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb29wcyBmb3IgZmEyLlxuICAgICAqIEBwYXJhbSBjYWxjR3JhcGggZ3JhcGggZm9yIGNhbGN1bGF0aW9uXG4gICAgICogQHBhcmFtIGdyYXBoIG9yaWdpbmFsIGdyYXBoXG4gICAgICogQHBhcmFtIGl0ZXJhdGlvbiBpdGVyYXRpb24gbnVtYmVyXG4gICAgICogQHBhcmFtIHNpemVzIG5vZGVzJyBzaXplXG4gICAgICogQHBhcmFtIG9wdGlvbnMgZm9ybWF0dGVkIGxheW91dCBvcHRpb25zXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICBydW4oY2FsY0dyYXBoLCBncmFwaCwgaXRlcmF0aW9uLCBzaXplcywgYXNzaWduLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsga3IsIGJhcm5lc0h1dCwgb25UaWNrIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBjYWxjTm9kZXMgPSBjYWxjR3JhcGguZ2V0QWxsTm9kZXMoKTtcbiAgICAgICAgbGV0IHNnID0gMDtcbiAgICAgICAgbGV0IGl0ZXIgPSBpdGVyYXRpb247XG4gICAgICAgIGNvbnN0IGZvcmNlcyA9IHt9O1xuICAgICAgICBjb25zdCBwcmVGb3JjZXMgPSB7fTtcbiAgICAgICAgY29uc3QgYm9kaWVzID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsY05vZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGlkIH0gPSBjYWxjTm9kZXNbaV07XG4gICAgICAgICAgICBmb3JjZXNbaWRdID0gWzAsIDBdO1xuICAgICAgICAgICAgaWYgKGJhcm5lc0h1dCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGksXG4gICAgICAgICAgICAgICAgICAgIHJ4OiBkYXRhLngsXG4gICAgICAgICAgICAgICAgICAgIHJ5OiBkYXRhLnksXG4gICAgICAgICAgICAgICAgICAgIG1hc3M6IDEsXG4gICAgICAgICAgICAgICAgICAgIGc6IGtyLFxuICAgICAgICAgICAgICAgICAgICBkZWdyZWU6IGNhbGNHcmFwaC5nZXREZWdyZWUoaWQpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYm9kaWVzW2lkXSA9IG5ldyBCb2R5KHBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGl0ZXIgPiAwKSB7XG4gICAgICAgICAgICBzZyA9IHRoaXMub25lU3RlcChjYWxjR3JhcGgsIHtcbiAgICAgICAgICAgICAgICBpdGVyLFxuICAgICAgICAgICAgICAgIHByZXZlbnRPdmVybGFwSXRlcnM6IDUwLFxuICAgICAgICAgICAgICAgIGtyUHJpbWU6IDEwMCxcbiAgICAgICAgICAgICAgICBzZyxcbiAgICAgICAgICAgICAgICBmb3JjZXMsXG4gICAgICAgICAgICAgICAgcHJlRm9yY2VzLFxuICAgICAgICAgICAgICAgIGJvZGllcyxcbiAgICAgICAgICAgICAgICBzaXplcyxcbiAgICAgICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgaXRlci0tO1xuICAgICAgICAgICAgb25UaWNrID09PSBudWxsIHx8IG9uVGljayA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25UaWNrKHtcbiAgICAgICAgICAgICAgICBub2RlczogY2FsY05vZGVzLFxuICAgICAgICAgICAgICAgIGVkZ2VzOiBncmFwaC5nZXRBbGxFZGdlcygpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBpZiAoYXNzaWduKSB7XG4gICAgICAgICAgICAvLyAgIGNhbGNOb2Rlcy5mb3JFYWNoKCh7IGlkLCBkYXRhIH0pID0+IGdyYXBoLm1lcmdlTm9kZURhdGEoaWQsIHtcbiAgICAgICAgICAgIC8vICAgICB4OiBkYXRhLngsXG4gICAgICAgICAgICAvLyAgICAgeTogZGF0YS55XG4gICAgICAgICAgICAvLyAgIH0pKVxuICAgICAgICAgICAgLy8gfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxjR3JhcGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9uZSBzdGVwIGZvciBhIGxvb3AuXG4gICAgICogQHBhcmFtIGdyYXBoIGdyYXBoIGZvciBjYWxjdWxhdGlvblxuICAgICAqIEBwYXJhbSBwYXJhbXMgcGFyYW1ldGVycyBmb3IgYSBsb29wXG4gICAgICogQHBhcmFtIG9wdGlvbnMgZm9ybWF0dGVkIGxheW91dCdzIGlucHV0IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIG9uZVN0ZXAoZ3JhcGgsIHBhcmFtcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGl0ZXIsIHByZXZlbnRPdmVybGFwSXRlcnMsIGtyUHJpbWUsIHNnLCBwcmVGb3JjZXMsIGJvZGllcywgc2l6ZXMgfSA9IHBhcmFtcztcbiAgICAgICAgbGV0IHsgZm9yY2VzIH0gPSBwYXJhbXM7XG4gICAgICAgIGNvbnN0IHsgcHJldmVudE92ZXJsYXAsIGJhcm5lc0h1dCB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBncmFwaC5nZXRBbGxOb2RlcygpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCB7IGlkIH0gPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIHByZUZvcmNlc1tpZF0gPSBbLi4uZm9yY2VzW2lkXV07XG4gICAgICAgICAgICBmb3JjZXNbaWRdID0gWzAsIDBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGF0dHJhY3RpdmUgZm9yY2VzLCBleGlzdGluZyBvbiBldmVyeSBhY3R1YWwgZWRnZVxuICAgICAgICBmb3JjZXMgPSB0aGlzLmdldEF0dHJGb3JjZXMoZ3JhcGgsIGl0ZXIsIHByZXZlbnRPdmVybGFwSXRlcnMsIHNpemVzLCBmb3JjZXMsIG9wdGlvbnMpO1xuICAgICAgICAvLyByZXB1bHNpdmUgZm9yY2VzIGFuZCBHcmF2aXR5LCBleGlzdGluZyBvbiBldmVyeSBub2RlIHBhaXJcbiAgICAgICAgLy8gaWYgcHJldmVudE92ZXJsYXAsIHVzaW5nIHRoZSBuby1vcHRpbWl6ZWQgbWV0aG9kIGluIHRoZSBsYXN0IHByZXZlbnRPdmVybGFwSXRlcnMgaW5zdGVhZC5cbiAgICAgICAgaWYgKGJhcm5lc0h1dCAmJlxuICAgICAgICAgICAgKChwcmV2ZW50T3ZlcmxhcCAmJiBpdGVyID4gcHJldmVudE92ZXJsYXBJdGVycykgfHwgIXByZXZlbnRPdmVybGFwKSkge1xuICAgICAgICAgICAgZm9yY2VzID0gdGhpcy5nZXRPcHRSZXBHcmFGb3JjZXMoZ3JhcGgsIGZvcmNlcywgYm9kaWVzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvcmNlcyA9IHRoaXMuZ2V0UmVwR3JhRm9yY2VzKGdyYXBoLCBpdGVyLCBwcmV2ZW50T3ZlcmxhcEl0ZXJzLCBmb3JjZXMsIGtyUHJpbWUsIHNpemVzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgdGhlIHBvc2l0aW9uc1xuICAgICAgICByZXR1cm4gdGhpcy51cGRhdGVQb3MoZ3JhcGgsIGZvcmNlcywgcHJlRm9yY2VzLCBzZywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgYXR0cmFjdCBmb3JjZXMgZm9yIG5vZGVzLlxuICAgICAqIEBwYXJhbSBncmFwaCBncmFwaCBmb3IgY2FsY3VsYXRpb25cbiAgICAgKiBAcGFyYW0gaXRlciBjdXJyZW50IGl0ZXJhdGlvbiBpbmRleFxuICAgICAqIEBwYXJhbSBwcmV2ZW50T3ZlcmxhcEl0ZXJzIHRoZSBpdGVyYXRpb24gbnVtYmVyIGZvciBwcmV2ZW50aW5nIG92ZXJsYXBwaW5nc1xuICAgICAqIEBwYXJhbSBzaXplcyBub2Rlcycgc2l6ZXNcbiAgICAgKiBAcGFyYW0gZm9yY2VzIGZvcmNlcyBmb3Igbm9kZXMsIHdoaWNoIHdpbGwgYmUgbW9kaWZpZWRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBmb3JtYXR0ZWQgbGF5b3V0J3MgaW5wdXQgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgZ2V0QXR0ckZvcmNlcyhncmFwaCwgaXRlciwgcHJldmVudE92ZXJsYXBJdGVycywgc2l6ZXMsIGZvcmNlcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHByZXZlbnRPdmVybGFwLCBkaXNzdWFkZUh1YnMsIG1vZGUsIHBydW5lIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBlZGdlcyA9IGdyYXBoLmdldEFsbEVkZ2VzKCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWRnZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc291cmNlLCB0YXJnZXQgfSA9IGVkZ2VzW2ldO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlTm9kZSA9IGdyYXBoLmdldE5vZGUoc291cmNlKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBncmFwaC5nZXROb2RlKHRhcmdldCk7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VEZWdyZWUgPSBncmFwaC5nZXREZWdyZWUoc291cmNlKTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldERlZ3JlZSA9IGdyYXBoLmdldERlZ3JlZSh0YXJnZXQpO1xuICAgICAgICAgICAgaWYgKHBydW5lICYmIChzb3VyY2VEZWdyZWUgPD0gMSB8fCB0YXJnZXREZWdyZWUgPD0gMSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBkaXIgPSBbXG4gICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZS5kYXRhLnggLSBzb3VyY2VOb2RlLmRhdGEueCxcbiAgICAgICAgICAgICAgICB0YXJnZXROb2RlLmRhdGEueSAtIHNvdXJjZU5vZGUuZGF0YS55LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGxldCBldWNsaURpcyA9IE1hdGguaHlwb3QoZGlyWzBdLCBkaXJbMV0pO1xuICAgICAgICAgICAgZXVjbGlEaXMgPSBldWNsaURpcyA8IDAuMDAwMSA/IDAuMDAwMSA6IGV1Y2xpRGlzO1xuICAgICAgICAgICAgZGlyWzBdID0gZGlyWzBdIC8gZXVjbGlEaXM7XG4gICAgICAgICAgICBkaXJbMV0gPSBkaXJbMV0gLyBldWNsaURpcztcbiAgICAgICAgICAgIGlmIChwcmV2ZW50T3ZlcmxhcCAmJiBpdGVyIDwgcHJldmVudE92ZXJsYXBJdGVycykge1xuICAgICAgICAgICAgICAgIGV1Y2xpRGlzID0gZXVjbGlEaXMgLSBzaXplc1tzb3VyY2VdIC0gc2l6ZXNbdGFyZ2V0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmYTEgPSBldWNsaURpcztcbiAgICAgICAgICAgIGxldCBmYTIgPSBmYTE7XG4gICAgICAgICAgICBpZiAobW9kZSA9PT0gJ2xpbmxvZycpIHtcbiAgICAgICAgICAgICAgICBmYTEgPSBNYXRoLmxvZygxICsgZXVjbGlEaXMpO1xuICAgICAgICAgICAgICAgIGZhMiA9IGZhMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXNzdWFkZUh1YnMpIHtcbiAgICAgICAgICAgICAgICBmYTEgPSBldWNsaURpcyAvIHNvdXJjZURlZ3JlZTtcbiAgICAgICAgICAgICAgICBmYTIgPSBldWNsaURpcyAvIHRhcmdldERlZ3JlZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2ZW50T3ZlcmxhcCAmJiBpdGVyIDwgcHJldmVudE92ZXJsYXBJdGVycyAmJiBldWNsaURpcyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgZmExID0gMDtcbiAgICAgICAgICAgICAgICBmYTIgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJldmVudE92ZXJsYXAgJiYgaXRlciA8IHByZXZlbnRPdmVybGFwSXRlcnMgJiYgZXVjbGlEaXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgZmExID0gZXVjbGlEaXM7XG4gICAgICAgICAgICAgICAgZmEyID0gZXVjbGlEaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3JjZXNbc291cmNlXVswXSArPSBmYTEgKiBkaXJbMF07XG4gICAgICAgICAgICBmb3JjZXNbdGFyZ2V0XVswXSAtPSBmYTIgKiBkaXJbMF07XG4gICAgICAgICAgICBmb3JjZXNbc291cmNlXVsxXSArPSBmYTEgKiBkaXJbMV07XG4gICAgICAgICAgICBmb3JjZXNbdGFyZ2V0XVsxXSAtPSBmYTIgKiBkaXJbMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcmNlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSByZXB1bHNpdmUgZm9yY2VzIGZvciBub2RlcyB1bmRlciBiYXJuZXNIdXQgbW9kZS5cbiAgICAgKiBAcGFyYW0gZ3JhcGggZ3JhcGggZm9yIGNhbGN1bGF0aWlvblxuICAgICAqIEBwYXJhbSBmb3JjZXMgZm9yY2VzIGZvciBub2Rlcywgd2hpY2ggd2lsbCBiZSBtb2RpZmllZFxuICAgICAqIEBwYXJhbSBib2RpZXMgZm9yY2UgYm9keSBtYXBcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBmb3JtYXR0ZWQgbGF5b3V0J3MgaW5wdXQgb3B0aW9uc1xuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgZ2V0T3B0UmVwR3JhRm9yY2VzKGdyYXBoLCBmb3JjZXMsIGJvZGllcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGtnLCBjZW50ZXIsIHBydW5lIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBub2RlcyA9IGdyYXBoLmdldEFsbE5vZGVzKCk7XG4gICAgICAgIGNvbnN0IG5vZGVOdW0gPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIGxldCBtaW54ID0gOWUxMDtcbiAgICAgICAgbGV0IG1heHggPSAtOWUxMDtcbiAgICAgICAgbGV0IG1pbnkgPSA5ZTEwO1xuICAgICAgICBsZXQgbWF4eSA9IC05ZTEwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVOdW07IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgeyBpZCwgZGF0YSB9ID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAocHJ1bmUgJiYgZ3JhcGguZ2V0RGVncmVlKGlkKSA8PSAxKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgYm9kaWVzW2lkXS5zZXRQb3MoZGF0YS54LCBkYXRhLnkpO1xuICAgICAgICAgICAgaWYgKGRhdGEueCA+PSBtYXh4KVxuICAgICAgICAgICAgICAgIG1heHggPSBkYXRhLng7XG4gICAgICAgICAgICBpZiAoZGF0YS54IDw9IG1pbngpXG4gICAgICAgICAgICAgICAgbWlueCA9IGRhdGEueDtcbiAgICAgICAgICAgIGlmIChkYXRhLnkgPj0gbWF4eSlcbiAgICAgICAgICAgICAgICBtYXh5ID0gZGF0YS55O1xuICAgICAgICAgICAgaWYgKGRhdGEueSA8PSBtaW55KVxuICAgICAgICAgICAgICAgIG1pbnkgPSBkYXRhLnk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2lkdGggPSBNYXRoLm1heChtYXh4IC0gbWlueCwgbWF4eSAtIG1pbnkpO1xuICAgICAgICBjb25zdCBxdWFkUGFyYW1zID0ge1xuICAgICAgICAgICAgeG1pZDogKG1heHggKyBtaW54KSAvIDIsXG4gICAgICAgICAgICB5bWlkOiAobWF4eSArIG1pbnkpIC8gMixcbiAgICAgICAgICAgIGxlbmd0aDogd2lkdGgsXG4gICAgICAgICAgICBtYXNzQ2VudGVyOiBjZW50ZXIsXG4gICAgICAgICAgICBtYXNzOiBub2RlTnVtLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBxdWFkID0gbmV3IFF1YWQocXVhZFBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHF1YWRUcmVlID0gbmV3IFF1YWRUcmVlKHF1YWQpO1xuICAgICAgICAvLyBidWlsZCB0aGUgdHJlZSwgaW5zZXJ0IHRoZSBub2RlcyhxdWFkcykgaW50byB0aGUgdHJlZVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVOdW07IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgeyBpZCB9ID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAocHJ1bmUgJiYgZ3JhcGguZ2V0RGVncmVlKGlkKSA8PSAxKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKGJvZGllc1tpZF0uaW4ocXVhZCkpXG4gICAgICAgICAgICAgICAgcXVhZFRyZWUuaW5zZXJ0KGJvZGllc1tpZF0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZSB0aGUgcmVwdWxzaXZlIGZvcmNlcyBhbmQgdGhlIGdyYXZpdHkuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZU51bTsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCB7IGlkLCBkYXRhIH0gPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGRlZ3JlZSA9IGdyYXBoLmdldERlZ3JlZShpZCk7XG4gICAgICAgICAgICBpZiAocHJ1bmUgJiYgZGVncmVlIDw9IDEpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBib2RpZXNbaWRdLnJlc2V0Rm9yY2UoKTtcbiAgICAgICAgICAgIHF1YWRUcmVlLnVwZGF0ZUZvcmNlKGJvZGllc1tpZF0pO1xuICAgICAgICAgICAgZm9yY2VzW2lkXVswXSAtPSBib2RpZXNbaWRdLmZ4O1xuICAgICAgICAgICAgZm9yY2VzW2lkXVsxXSAtPSBib2RpZXNbaWRdLmZ5O1xuICAgICAgICAgICAgLy8gZ3Jhdml0eVxuICAgICAgICAgICAgY29uc3QgZGlyID0gW2RhdGEueCAtIGNlbnRlclswXSwgZGF0YS55IC0gY2VudGVyWzFdXTtcbiAgICAgICAgICAgIGxldCBldWNsaURpcyA9IE1hdGguaHlwb3QoZGlyWzBdLCBkaXJbMV0pO1xuICAgICAgICAgICAgZXVjbGlEaXMgPSBldWNsaURpcyA8IDAuMDAwMSA/IDAuMDAwMSA6IGV1Y2xpRGlzO1xuICAgICAgICAgICAgZGlyWzBdID0gZGlyWzBdIC8gZXVjbGlEaXM7XG4gICAgICAgICAgICBkaXJbMV0gPSBkaXJbMV0gLyBldWNsaURpcztcbiAgICAgICAgICAgIGNvbnN0IGZnID0ga2cgKiAoZGVncmVlICsgMSk7IC8vIHRzbGludDpkaXNhYmxlLWxpbmVcbiAgICAgICAgICAgIGZvcmNlc1tpZF1bMF0gLT0gZmcgKiBkaXJbMF07XG4gICAgICAgICAgICBmb3JjZXNbaWRdWzFdIC09IGZnICogZGlyWzFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JjZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgcmVwdWxzaXZlIGZvcmNlcyBmb3Igbm9kZXMuXG4gICAgICogQHBhcmFtIGdyYXBoIGdyYXBoIGZvciBjYWxjdWxhdGlpb25cbiAgICAgKiBAcGFyYW0gaXRlciBjdXJyZW50IGl0ZXJhdGlvbiBpbmRleFxuICAgICAqIEBwYXJhbSBwcmV2ZW50T3ZlcmxhcEl0ZXJzIHRoZSBpdGVyYXRpb24gbnVtYmVyIGZvciBwcmV2ZW50aW5nIG92ZXJsYXBwaW5nc1xuICAgICAqIEBwYXJhbSBmb3JjZXMgZm9yY2VzIGZvciBub2Rlcywgd2hpY2ggd2lsbCBiZSBtb2RpZmllZFxuICAgICAqIEBwYXJhbSBrclByaW1lIGxhcmdlciB0aGUga3JQcmltZSwgbGFyZ2VyIHRoZSByZXB1bHNpdmUgZm9yY2VcbiAgICAgKiBAcGFyYW0gc2l6ZXMgbm9kZXMnIHNpemVzXG4gICAgICogQHBhcmFtIG9wdGlvbnMgZm9ybWF0dGVkIGxheW91dCdzIGlucHV0IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIGdldFJlcEdyYUZvcmNlcyhncmFwaCwgaXRlciwgcHJldmVudE92ZXJsYXBJdGVycywgZm9yY2VzLCBrclByaW1lLCBzaXplcywgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHByZXZlbnRPdmVybGFwLCBrciwga2csIGNlbnRlciwgcHJ1bmUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gZ3JhcGguZ2V0QWxsTm9kZXMoKTtcbiAgICAgICAgY29uc3Qgbm9kZU51bSA9IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlTnVtOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVpID0gbm9kZXNbaV07XG4gICAgICAgICAgICBjb25zdCBkZWdyZWVpID0gZ3JhcGguZ2V0RGVncmVlKG5vZGVpLmlkKTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBpICsgMTsgaiA8IG5vZGVOdW07IGogKz0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVqID0gbm9kZXNbal07XG4gICAgICAgICAgICAgICAgY29uc3QgZGVncmVlaiA9IGdyYXBoLmdldERlZ3JlZShub2Rlai5pZCk7XG4gICAgICAgICAgICAgICAgaWYgKHBydW5lICYmIChkZWdyZWVpIDw9IDEgfHwgZGVncmVlaiA8PSAxKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlyID0gW25vZGVqLmRhdGEueCAtIG5vZGVpLmRhdGEueCwgbm9kZWouZGF0YS55IC0gbm9kZWkuZGF0YS55XTtcbiAgICAgICAgICAgICAgICBsZXQgZXVjbGlEaXMgPSBNYXRoLmh5cG90KGRpclswXSwgZGlyWzFdKTtcbiAgICAgICAgICAgICAgICBldWNsaURpcyA9IGV1Y2xpRGlzIDwgMC4wMDAxID8gMC4wMDAxIDogZXVjbGlEaXM7XG4gICAgICAgICAgICAgICAgZGlyWzBdID0gZGlyWzBdIC8gZXVjbGlEaXM7XG4gICAgICAgICAgICAgICAgZGlyWzFdID0gZGlyWzFdIC8gZXVjbGlEaXM7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZlbnRPdmVybGFwICYmIGl0ZXIgPCBwcmV2ZW50T3ZlcmxhcEl0ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGV1Y2xpRGlzID0gZXVjbGlEaXMgLSBzaXplc1tub2RlaS5pZF0gLSBzaXplc1tub2Rlai5pZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBmciA9IChrciAqIChkZWdyZWVpICsgMSkgKiAoZGVncmVlaiArIDEpKSAvIGV1Y2xpRGlzO1xuICAgICAgICAgICAgICAgIGlmIChwcmV2ZW50T3ZlcmxhcCAmJiBpdGVyIDwgcHJldmVudE92ZXJsYXBJdGVycyAmJiBldWNsaURpcyA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZnIgPSBrclByaW1lICogKGRlZ3JlZWkgKyAxKSAqIChkZWdyZWVqICsgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHByZXZlbnRPdmVybGFwICYmXG4gICAgICAgICAgICAgICAgICAgIGl0ZXIgPCBwcmV2ZW50T3ZlcmxhcEl0ZXJzICYmXG4gICAgICAgICAgICAgICAgICAgIGV1Y2xpRGlzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocHJldmVudE92ZXJsYXAgJiZcbiAgICAgICAgICAgICAgICAgICAgaXRlciA8IHByZXZlbnRPdmVybGFwSXRlcnMgJiZcbiAgICAgICAgICAgICAgICAgICAgZXVjbGlEaXMgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyID0gKGtyICogKGRlZ3JlZWkgKyAxKSAqIChkZWdyZWVqICsgMSkpIC8gZXVjbGlEaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvcmNlc1tub2RlaS5pZF1bMF0gLT0gZnIgKiBkaXJbMF07XG4gICAgICAgICAgICAgICAgZm9yY2VzW25vZGVqLmlkXVswXSArPSBmciAqIGRpclswXTtcbiAgICAgICAgICAgICAgICBmb3JjZXNbbm9kZWkuaWRdWzFdIC09IGZyICogZGlyWzFdO1xuICAgICAgICAgICAgICAgIGZvcmNlc1tub2Rlai5pZF1bMV0gKz0gZnIgKiBkaXJbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBncmF2aXR5XG4gICAgICAgICAgICBjb25zdCBkaXIgPSBbbm9kZWkuZGF0YS54IC0gY2VudGVyWzBdLCBub2RlaS5kYXRhLnkgLSBjZW50ZXJbMV1dO1xuICAgICAgICAgICAgY29uc3QgZXVjbGlEaXMgPSBNYXRoLmh5cG90KGRpclswXSwgZGlyWzFdKTtcbiAgICAgICAgICAgIGRpclswXSA9IGRpclswXSAvIGV1Y2xpRGlzO1xuICAgICAgICAgICAgZGlyWzFdID0gZGlyWzFdIC8gZXVjbGlEaXM7XG4gICAgICAgICAgICBjb25zdCBmZyA9IGtnICogKGRlZ3JlZWkgKyAxKTsgLy8gdHNsaW50OmRpc2FibGUtbGluZVxuICAgICAgICAgICAgZm9yY2VzW25vZGVpLmlkXVswXSAtPSBmZyAqIGRpclswXTtcbiAgICAgICAgICAgIGZvcmNlc1tub2RlaS5pZF1bMV0gLT0gZmcgKiBkaXJbMV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvcmNlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIG5vZGUgcG9zaXRpb25zLlxuICAgICAqIEBwYXJhbSBncmFwaCBncmFwaCBmb3IgY2FsY3VsYXRpaW9uXG4gICAgICogQHBhcmFtIGZvcmNlcyBmb3JjZXMgZm9yIG5vZGVzLCB3aGljaCB3aWxsIGJlIG1vZGlmaWVkXG4gICAgICogQHBhcmFtIHByZUZvcmNlcyBwcmV2aW91cyBmb3JjZXMgZm9yIG5vZGVzLCB3aGljaCB3aWxsIGJlIG1vZGlmaWVkXG4gICAgICogQHBhcmFtIHNnIGNvbnN0YW50IGZvciBtb3ZlIGRpc3RhbmNlIG9mIG9uZSBzdGVwXG4gICAgICogQHBhcmFtIG9wdGlvbnMgZm9ybWF0dGVkIGxheW91dCdzIGlucHV0IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHVwZGF0ZVBvcyhncmFwaCwgZm9yY2VzLCBwcmVGb3JjZXMsIHNnLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsga3MsIHRhbywgcHJ1bmUsIGtzbWF4IH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBub2RlcyA9IGdyYXBoLmdldEFsbE5vZGVzKCk7XG4gICAgICAgIGNvbnN0IG5vZGVOdW0gPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IHN3Z25zID0gW107XG4gICAgICAgIGNvbnN0IHRyYW5zID0gW107XG4gICAgICAgIC8vIHN3ZyhHKSBhbmQgdHJhKEcpXG4gICAgICAgIGxldCBzd2dHID0gMDtcbiAgICAgICAgbGV0IHRyYUcgPSAwO1xuICAgICAgICBsZXQgdXNpbmdTZyA9IHNnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVOdW07IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgeyBpZCB9ID0gbm9kZXNbaV07XG4gICAgICAgICAgICBjb25zdCBkZWdyZWUgPSBncmFwaC5nZXREZWdyZWUoaWQpO1xuICAgICAgICAgICAgaWYgKHBydW5lICYmIGRlZ3JlZSA8PSAxKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgbWludXMgPSBbXG4gICAgICAgICAgICAgICAgZm9yY2VzW2lkXVswXSAtIHByZUZvcmNlc1tpZF1bMF0sXG4gICAgICAgICAgICAgICAgZm9yY2VzW2lkXVsxXSAtIHByZUZvcmNlc1tpZF1bMV0sXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgY29uc3QgbWludXNOb3JtID0gTWF0aC5oeXBvdChtaW51c1swXSwgbWludXNbMV0pO1xuICAgICAgICAgICAgY29uc3QgYWRkID0gW1xuICAgICAgICAgICAgICAgIGZvcmNlc1tpZF1bMF0gKyBwcmVGb3JjZXNbaWRdWzBdLFxuICAgICAgICAgICAgICAgIGZvcmNlc1tpZF1bMV0gKyBwcmVGb3JjZXNbaWRdWzFdLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IGFkZE5vcm0gPSBNYXRoLmh5cG90KGFkZFswXSwgYWRkWzFdKTtcbiAgICAgICAgICAgIHN3Z25zW2ldID0gbWludXNOb3JtO1xuICAgICAgICAgICAgdHJhbnNbaV0gPSBhZGROb3JtIC8gMjtcbiAgICAgICAgICAgIHN3Z0cgKz0gKGRlZ3JlZSArIDEpICogc3dnbnNbaV07XG4gICAgICAgICAgICB0cmFHICs9IChkZWdyZWUgKyAxKSAqIHRyYW5zW2ldO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZVNHID0gdXNpbmdTZztcbiAgICAgICAgdXNpbmdTZyA9ICh0YW8gKiB0cmFHKSAvIHN3Z0c7XG4gICAgICAgIGlmIChwcmVTRyAhPT0gMCkge1xuICAgICAgICAgICAgdXNpbmdTZyA9IHVzaW5nU2cgPiAxLjUgKiBwcmVTRyA/IDEuNSAqIHByZVNHIDogdXNpbmdTZztcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgdGhlIG5vZGUgcG9zaXRpb25zXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZU51bTsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCB7IGlkLCBkYXRhIH0gPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGRlZ3JlZSA9IGdyYXBoLmdldERlZ3JlZShpZCk7XG4gICAgICAgICAgICBpZiAocHJ1bmUgJiYgZGVncmVlIDw9IDEpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIoZGF0YS5meCkgJiYgaXNOdW1iZXIoZGF0YS5meSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsZXQgc24gPSAoa3MgKiB1c2luZ1NnKSAvICgxICsgdXNpbmdTZyAqIE1hdGguc3FydChzd2duc1tpXSkpO1xuICAgICAgICAgICAgbGV0IGFic0ZvcmNlID0gTWF0aC5oeXBvdChmb3JjZXNbaWRdWzBdLCBmb3JjZXNbaWRdWzFdKTtcbiAgICAgICAgICAgIGFic0ZvcmNlID0gYWJzRm9yY2UgPCAwLjAwMDEgPyAwLjAwMDEgOiBhYnNGb3JjZTtcbiAgICAgICAgICAgIGNvbnN0IG1heCA9IGtzbWF4IC8gYWJzRm9yY2U7XG4gICAgICAgICAgICBzbiA9IHNuID4gbWF4ID8gbWF4IDogc247XG4gICAgICAgICAgICBjb25zdCBkbnggPSBzbiAqIGZvcmNlc1tpZF1bMF07XG4gICAgICAgICAgICBjb25zdCBkbnkgPSBzbiAqIGZvcmNlc1tpZF1bMV07XG4gICAgICAgICAgICBncmFwaC5tZXJnZU5vZGVEYXRhKGlkLCB7XG4gICAgICAgICAgICAgICAgeDogZGF0YS54ICsgZG54LFxuICAgICAgICAgICAgICAgIHk6IGRhdGEueSArIGRueSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1c2luZ1NnO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8qKlxuICogQGZpbGVPdmVydmlldyBxdWFkVHJlZVxuICogQGF1dGhvciBzaGl3dS53eXlAYW50ZmluLmNvbVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBRdWFkVHJlZSB7XG4gICAgLy8gZWFjaCBxdWFkdHJlZSByZXByZXNlbnRzIGEgcXVhZHJhbnQgYW5kIGFuIGFnZ3JlZ2F0ZSBib2R5XG4gICAgLy8gdGhhdCByZXByZXNlbnRzIGFsbCBib2RpZXMgaW5zaWRlIHRoZSBxdWFkcmFudFxuICAgIGNvbnN0cnVjdG9yKHBhcmFtKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiAoYWdncmVnYXRlZCkgYm9keSBpbiB0aGlzIHF1YWRcbiAgICAgICAgICogQHR5cGUgIHtvYmplY3R9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmJvZHkgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogdHJlZSByZXByZXNlbnRpbmcgdGhlIG5vcnRod2VzdCBxdWFkcmFudFxuICAgICAgICAgKiBAdHlwZSAge29iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucXVhZCA9IG51bGw7XG4gICAgICAgIHRoaXMuTlcgPSBudWxsO1xuICAgICAgICB0aGlzLk5FID0gbnVsbDtcbiAgICAgICAgdGhpcy5TVyA9IG51bGw7XG4gICAgICAgIHRoaXMuU0UgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogdGhyZXNob2xkXG4gICAgICAgICAqIEB0eXBlICB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aGV0YSA9IDAuNTtcbiAgICAgICAgaWYgKHBhcmFtICE9IG51bGwpXG4gICAgICAgICAgICB0aGlzLnF1YWQgPSBwYXJhbTtcbiAgICB9XG4gICAgLy8gaW5zZXJ0IGEgYm9keShub2RlKSBpbnRvIHRoZSB0cmVlXG4gICAgaW5zZXJ0KGJvKSB7XG4gICAgICAgIC8vIGlmIHRoaXMgbm9kZSBkb2VzIG5vdCBjb250YWluIGEgYm9keSwgcHV0IHRoZSBuZXcgYm9keSBibyBoZXJlXG4gICAgICAgIGlmICh0aGlzLmJvZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gYm87XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW50ZXJuYWwgbm9kZVxuICAgICAgICBpZiAoIXRoaXMuX2lzRXh0ZXJuYWwoKSkge1xuICAgICAgICAgICAgLy8gdXBkYXRlIG1hc3MgaW5mb1xuICAgICAgICAgICAgdGhpcy5ib2R5ID0gdGhpcy5ib2R5LmFkZChibyk7XG4gICAgICAgICAgICAvLyBpbnNlcnQgYm9keSBpbnRvIHF1YWRyYW50XG4gICAgICAgICAgICB0aGlzLl9wdXRCb2R5KGJvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGV4dGVybmFsIG5vZGVcbiAgICAgICAgICAgIC8vIGRpdmlkZSB0aGlzIHJlZ2lvbiBpbnRvIGZvdXIgY2hpbGRyZW5cbiAgICAgICAgICAgIGlmICh0aGlzLnF1YWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLk5XID0gbmV3IFF1YWRUcmVlKHRoaXMucXVhZC5OVygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLk5FID0gbmV3IFF1YWRUcmVlKHRoaXMucXVhZC5ORSgpKTtcbiAgICAgICAgICAgICAgICB0aGlzLlNXID0gbmV3IFF1YWRUcmVlKHRoaXMucXVhZC5TVygpKTtcbiAgICAgICAgICAgICAgICB0aGlzLlNFID0gbmV3IFF1YWRUcmVlKHRoaXMucXVhZC5TRSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGluc2VydCB0aGlzIGJvZHkgYW5kIGJvXG4gICAgICAgICAgICB0aGlzLl9wdXRCb2R5KHRoaXMuYm9keSk7XG4gICAgICAgICAgICB0aGlzLl9wdXRCb2R5KGJvKTtcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgbWFzcyBpbmZvXG4gICAgICAgICAgICB0aGlzLmJvZHkgPSB0aGlzLmJvZHkuYWRkKGJvKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBpbnNlcnRzIGJvIGludG8gYSBxdWFkXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgX3B1dEJvZHkoYm8pIHtcbiAgICAgICAgaWYgKCF0aGlzLnF1YWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChiby5pbih0aGlzLnF1YWQuTlcoKSkgJiYgdGhpcy5OVylcbiAgICAgICAgICAgIHRoaXMuTlcuaW5zZXJ0KGJvKTtcbiAgICAgICAgZWxzZSBpZiAoYm8uaW4odGhpcy5xdWFkLk5FKCkpICYmIHRoaXMuTkUpXG4gICAgICAgICAgICB0aGlzLk5FLmluc2VydChibyk7XG4gICAgICAgIGVsc2UgaWYgKGJvLmluKHRoaXMucXVhZC5TVygpKSAmJiB0aGlzLlNXKVxuICAgICAgICAgICAgdGhpcy5TVy5pbnNlcnQoYm8pO1xuICAgICAgICBlbHNlIGlmIChiby5pbih0aGlzLnF1YWQuU0UoKSkgJiYgdGhpcy5TRSlcbiAgICAgICAgICAgIHRoaXMuU0UuaW5zZXJ0KGJvKTtcbiAgICB9XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgX2lzRXh0ZXJuYWwoKSB7XG4gICAgICAgIC8vIGZvdXIgY2hpbGRyZW4gYXJlIG51bGxcbiAgICAgICAgcmV0dXJuICh0aGlzLk5XID09IG51bGwgJiYgdGhpcy5ORSA9PSBudWxsICYmIHRoaXMuU1cgPT0gbnVsbCAmJiB0aGlzLlNFID09IG51bGwpO1xuICAgIH1cbiAgICAvLyB1cGRhdGUgdGhlIGZvcmNlc1xuICAgIHVwZGF0ZUZvcmNlKGJvKSB7XG4gICAgICAgIGlmICh0aGlzLmJvZHkgPT0gbnVsbCB8fCBibyA9PT0gdGhpcy5ib2R5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIGN1cnJlbnQgbm9kZSBpcyBleHRlcm5hbFxuICAgICAgICBpZiAodGhpcy5faXNFeHRlcm5hbCgpKVxuICAgICAgICAgICAgYm8uYWRkRm9yY2UodGhpcy5ib2R5KTtcbiAgICAgICAgLy8gaW50ZXJuYWwgbm9kZXNcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzID0gdGhpcy5xdWFkID8gdGhpcy5xdWFkLmdldExlbmd0aCgpIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGQgPSB0aGlzLmJvZHkuZGlzdGFuY2VUbyhibyk7XG4gICAgICAgICAgICAvLyBiIGlzIGZhciBlbm91Z2hcbiAgICAgICAgICAgIGlmIChzIC8gZCA8IHRoaXMudGhldGEpXG4gICAgICAgICAgICAgICAgYm8uYWRkRm9yY2UodGhpcy5ib2R5KTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuTlcgJiYgdGhpcy5OVy51cGRhdGVGb3JjZShibyk7XG4gICAgICAgICAgICAgICAgdGhpcy5ORSAmJiB0aGlzLk5FLnVwZGF0ZUZvcmNlKGJvKTtcbiAgICAgICAgICAgICAgICB0aGlzLlNXICYmIHRoaXMuU1cudXBkYXRlRm9yY2UoYm8pO1xuICAgICAgICAgICAgICAgIHRoaXMuU0UgJiYgdGhpcy5TRS51cGRhdGVGb3JjZShibyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWFkLXRyZWUuanMubWFwIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgUXVhZCB7XG4gICAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiB0aGUgY2VudGVyIHBvc2l0aW9uIG9mIHRoaXMgcXVhZFxuICAgICAgICAgKiBAdHlwZSAge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMueG1pZCA9IHBhcmFtcy54bWlkO1xuICAgICAgICAvKipcbiAgICAgICAgICogdGhlIGNlbnRlciBwb3NpdGlvbiBvZiB0aGlzIHF1YWRcbiAgICAgICAgICogQHR5cGUgIHtudW1iZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnltaWQgPSBwYXJhbXMueW1pZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRoZSBsZW5ndGggb2YgdGhpcyBxdWFkXG4gICAgICAgICAqIEB0eXBlICB7bnVtYmVyfVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sZW5ndGggPSBwYXJhbXMubGVuZ3RoO1xuICAgICAgICAvKipcbiAgICAgICAgICogdGhlIG1hc3MgY2VudGVyIG9mIHRoaXMgcXVhZFxuICAgICAgICAgKiBAdHlwZSAge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFzc0NlbnRlciA9IHBhcmFtcy5tYXNzQ2VudGVyIHx8IFswLCAwXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRoZSBtYXNzIG9mIHRoaXMgcXVhZFxuICAgICAgICAgKiBAdHlwZSAge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWFzcyA9IHBhcmFtcy5tYXNzIHx8IDE7XG4gICAgfVxuICAgIGdldExlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgIH1cbiAgICBjb250YWlucyh4LCB5KSB7XG4gICAgICAgIGNvbnN0IGhhbGZMZW4gPSB0aGlzLmxlbmd0aCAvIDI7XG4gICAgICAgIHJldHVybiAoeCA8PSB0aGlzLnhtaWQgKyBoYWxmTGVuICYmXG4gICAgICAgICAgICB4ID49IHRoaXMueG1pZCAtIGhhbGZMZW4gJiZcbiAgICAgICAgICAgIHkgPD0gdGhpcy55bWlkICsgaGFsZkxlbiAmJlxuICAgICAgICAgICAgeSA+PSB0aGlzLnltaWQgLSBoYWxmTGVuKTtcbiAgICB9XG4gICAgLy8gbm9ydGh3ZXN0IHF1YWRyYW50XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgTlcoKSB7XG4gICAgICAgIGNvbnN0IHggPSB0aGlzLnhtaWQgLSB0aGlzLmxlbmd0aCAvIDQ7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLnltaWQgKyB0aGlzLmxlbmd0aCAvIDQ7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgeG1pZDogeCxcbiAgICAgICAgICAgIHltaWQ6IHksXG4gICAgICAgICAgICBsZW5ndGg6IGxlbixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgTlcgPSBuZXcgUXVhZChwYXJhbXMpO1xuICAgICAgICByZXR1cm4gTlc7XG4gICAgfVxuICAgIC8vIG5vcnRoZWFzdFxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgIE5FKCkge1xuICAgICAgICBjb25zdCB4ID0gdGhpcy54bWlkICsgdGhpcy5sZW5ndGggLyA0O1xuICAgICAgICBjb25zdCB5ID0gdGhpcy55bWlkICsgdGhpcy5sZW5ndGggLyA0O1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aCAvIDI7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgIHhtaWQ6IHgsXG4gICAgICAgICAgICB5bWlkOiB5LFxuICAgICAgICAgICAgbGVuZ3RoOiBsZW4sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IE5FID0gbmV3IFF1YWQocGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIE5FO1xuICAgIH1cbiAgICAvLyBzb3V0aHdlc3RcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmVcbiAgICBTVygpIHtcbiAgICAgICAgY29uc3QgeCA9IHRoaXMueG1pZCAtIHRoaXMubGVuZ3RoIC8gNDtcbiAgICAgICAgY29uc3QgeSA9IHRoaXMueW1pZCAtIHRoaXMubGVuZ3RoIC8gNDtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICB4bWlkOiB4LFxuICAgICAgICAgICAgeW1pZDogeSxcbiAgICAgICAgICAgIGxlbmd0aDogbGVuLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBTVyA9IG5ldyBRdWFkKHBhcmFtcyk7XG4gICAgICAgIHJldHVybiBTVztcbiAgICB9XG4gICAgLy8gc291dGhlYXN0XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lXG4gICAgU0UoKSB7XG4gICAgICAgIGNvbnN0IHggPSB0aGlzLnhtaWQgKyB0aGlzLmxlbmd0aCAvIDQ7XG4gICAgICAgIGNvbnN0IHkgPSB0aGlzLnltaWQgLSB0aGlzLmxlbmd0aCAvIDQ7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgeG1pZDogeCxcbiAgICAgICAgICAgIHltaWQ6IHksXG4gICAgICAgICAgICBsZW5ndGg6IGxlbixcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgU0UgPSBuZXcgUXVhZChwYXJhbXMpO1xuICAgICAgICByZXR1cm4gU0U7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cXVhZC5qcy5tYXAiLCJpbXBvcnQgeyBxdWFkdHJlZSB9IGZyb20gJ2QzLXF1YWR0cmVlJztcbi8vIEB0cy1pZ25vcmVcbmltcG9ydCB7IG9jdHJlZSB9IGZyb20gJ2QzLW9jdHJlZSc7XG5jb25zdCB0aGV0YTIgPSAwLjgxOyAvLyBCYXJuZXMtSHV0IGFwcHJveGltYXRpb24gdGhyZXNob2xkXG5jb25zdCBlcHNpbG9uID0gMC4xOyAvLyDkuLrkuobpmLLmraLlh7rnjrDpmaQw55qE5oOF5Ya177yM5Yqg5LiA5LiqZXBzaWxvblxuZXhwb3J0IGZ1bmN0aW9uIGZvcmNlTkJvZHkoY2FsY0dyYXBoLCBmYWN0b3IsIGNvdWxvbWJEaXNTY2FsZTIsIGFjY01hcCwgZGltZW5zaW9ucyA9IDIpIHtcbiAgICBjb25zdCB3ZWlnaHRQYXJhbSA9IGZhY3RvciAvIGNvdWxvbWJEaXNTY2FsZTI7XG4gICAgY29uc3QgY2FsY05vZGVzID0gY2FsY0dyYXBoLmdldEFsbE5vZGVzKCk7XG4gICAgY29uc3QgZGF0YSA9IGNhbGNOb2Rlcy5tYXAoKGNhbGNOb2RlLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbm9kZVN0cmVuZ3RoLCB4LCB5LCB6LCBzaXplIH0gPSBjYWxjTm9kZS5kYXRhO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICB6LFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgaWQ6IGNhbGNOb2RlLmlkLFxuICAgICAgICAgICAgdng6IDAsXG4gICAgICAgICAgICB2eTogMCxcbiAgICAgICAgICAgIHZ6OiAwLFxuICAgICAgICAgICAgd2VpZ2h0OiB3ZWlnaHRQYXJhbSAqIG5vZGVTdHJlbmd0aCxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCB0cmVlID0gKGRpbWVuc2lvbnMgPT09IDJcbiAgICAgICAgPyBxdWFkdHJlZShkYXRhLCAoZCkgPT4gZC54LCAoZCkgPT4gZC55KVxuICAgICAgICA6IG9jdHJlZShkYXRhLCAoZCkgPT4gZC54LCAoZCkgPT4gZC55LCAoZCkgPT4gZC56KSkudmlzaXRBZnRlcihhY2N1bXVsYXRlKTsgLy8gaW5pdCBpbnRlcm5hbCBub2RlXG4gICAgY29uc3Qgbm9kZU1hcCA9IG5ldyBNYXAoKTtcbiAgICBkYXRhLmZvckVhY2goKG4pID0+IHtcbiAgICAgICAgbm9kZU1hcC5zZXQobi5pZCwgbik7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29tcHV0ZUZvcmNlKG4sIHRyZWUsIGRpbWVuc2lvbnMpO1xuICAgIH0pO1xuICAgIGRhdGEubWFwKChuLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgaWQsIGRhdGEgfSA9IGNhbGNOb2Rlc1tpXTtcbiAgICAgICAgY29uc3QgeyBtYXNzID0gMSB9ID0gZGF0YTtcbiAgICAgICAgLy8g5LuOIDAg5byA5aeL77yMPSDliJ3lp4vljJYgKyDliqDmlqXliptcbiAgICAgICAgYWNjTWFwW2lkXSA9IHtcbiAgICAgICAgICAgIHg6IG4udnggLyBtYXNzLFxuICAgICAgICAgICAgeTogbi52eSAvIG1hc3MsXG4gICAgICAgICAgICB6OiBuLnZ6IC8gbWFzcyxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjTWFwO1xufVxuZnVuY3Rpb24gYWNjdW11bGF0ZSh0cmVlTm9kZSkge1xuICAgIGxldCBhY2NXZWlnaHQgPSAwO1xuICAgIGxldCBhY2NYID0gMDtcbiAgICBsZXQgYWNjWSA9IDA7XG4gICAgbGV0IGFjY1ogPSAwO1xuICAgIGxldCBhY2NTaXplID0gMDtcbiAgICBjb25zdCBudW1DaGlsZHJlbiA9IHRyZWVOb2RlLmxlbmd0aDtcbiAgICBpZiAobnVtQ2hpbGRyZW4pIHtcbiAgICAgICAgLy8gaW50ZXJuYWwgbm9kZSwgYWNjdW11bGF0ZSA0IGNoaWxkIHF1YWRzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ2hpbGRyZW47IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcSA9IHRyZWVOb2RlW2ldO1xuICAgICAgICAgICAgaWYgKHEgJiYgcS53ZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBhY2NXZWlnaHQgKz0gcS53ZWlnaHQ7XG4gICAgICAgICAgICAgICAgYWNjWCArPSBxLnggKiBxLndlaWdodDtcbiAgICAgICAgICAgICAgICBhY2NZICs9IHEueSAqIHEud2VpZ2h0O1xuICAgICAgICAgICAgICAgIGFjY1ogKz0gcS56ICogcS53ZWlnaHQ7XG4gICAgICAgICAgICAgICAgYWNjU2l6ZSArPSBxLnNpemUgKiBxLndlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVlTm9kZS54ID0gYWNjWCAvIGFjY1dlaWdodDtcbiAgICAgICAgdHJlZU5vZGUueSA9IGFjY1kgLyBhY2NXZWlnaHQ7XG4gICAgICAgIHRyZWVOb2RlLnogPSBhY2NaIC8gYWNjV2VpZ2h0O1xuICAgICAgICB0cmVlTm9kZS5zaXplID0gYWNjU2l6ZSAvIGFjY1dlaWdodDtcbiAgICAgICAgdHJlZU5vZGUud2VpZ2h0ID0gYWNjV2VpZ2h0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gbGVhZiBub2RlXG4gICAgICAgIGNvbnN0IHEgPSB0cmVlTm9kZTtcbiAgICAgICAgdHJlZU5vZGUueCA9IHEuZGF0YS54O1xuICAgICAgICB0cmVlTm9kZS55ID0gcS5kYXRhLnk7XG4gICAgICAgIHRyZWVOb2RlLnogPSBxLmRhdGEuejtcbiAgICAgICAgdHJlZU5vZGUuc2l6ZSA9IHEuZGF0YS5zaXplO1xuICAgICAgICB0cmVlTm9kZS53ZWlnaHQgPSBxLmRhdGEud2VpZ2h0O1xuICAgIH1cbn1cbmNvbnN0IGFwcGx5ID0gKHRyZWVOb2RlLCB4MSwgYXJnMSwgYXJnMiwgYXJnMywgbm9kZSwgZGltZW5zaW9ucykgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpZiAoKChfYSA9IHRyZWVOb2RlLmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pZCkgPT09IG5vZGUuaWQpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zdCB4MiA9IFthcmcxLCBhcmcyLCBhcmczXVtkaW1lbnNpb25zIC0gMV07XG4gICAgY29uc3QgZHggPSBub2RlLnggLSB0cmVlTm9kZS54IHx8IGVwc2lsb247XG4gICAgY29uc3QgZHkgPSBub2RlLnkgLSB0cmVlTm9kZS55IHx8IGVwc2lsb247XG4gICAgY29uc3QgZHogPSBub2RlLnogLSB0cmVlTm9kZS56IHx8IGVwc2lsb247XG4gICAgY29uc3QgcG9zID0gW2R4LCBkeSwgZHpdO1xuICAgIGNvbnN0IHdpZHRoID0geDIgLSB4MTtcbiAgICBsZXQgbGVuMiA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaW1lbnNpb25zOyBpKyspIHtcbiAgICAgICAgbGVuMiArPSBwb3NbaV0gKiBwb3NbaV07XG4gICAgfVxuICAgIGNvbnN0IGxlbjEgPSBNYXRoLnNxcnQobGVuMik7XG4gICAgY29uc3QgbGVuMyA9IGxlbjEgKiBsZW4yO1xuICAgIC8vIGZhciBub2RlLCBhcHBseSBCYXJuZXMtSHV0IGFwcHJveGltYXRpb25cbiAgICBpZiAod2lkdGggKiB3aWR0aCAqIHRoZXRhMiA8IGxlbjIpIHtcbiAgICAgICAgY29uc3QgcGFyYW0gPSB0cmVlTm9kZS53ZWlnaHQgLyBsZW4zO1xuICAgICAgICBub2RlLnZ4ICs9IGR4ICogcGFyYW07XG4gICAgICAgIG5vZGUudnkgKz0gZHkgKiBwYXJhbTtcbiAgICAgICAgbm9kZS52eiArPSBkeiAqIHBhcmFtO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gbmVhciBxdWFkLCBjb21wdXRlIGZvcmNlIGRpcmVjdGx5XG4gICAgaWYgKHRyZWVOb2RlLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBpbnRlcm5hbCBub2RlLCB2aXNpdCBjaGlsZHJlblxuICAgIC8vIGxlYWYgbm9kZVxuICAgIGlmICh0cmVlTm9kZS5kYXRhICE9PSBub2RlKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtID0gdHJlZU5vZGUuZGF0YS53ZWlnaHQgLyBsZW4zO1xuICAgICAgICBub2RlLnZ4ICs9IGR4ICogcGFyYW07XG4gICAgICAgIG5vZGUudnkgKz0gZHkgKiBwYXJhbTtcbiAgICAgICAgbm9kZS52eiArPSBkeiAqIHBhcmFtO1xuICAgIH1cbn07XG4vLyBAdHMtaWdub3JlXG5mdW5jdGlvbiBjb21wdXRlRm9yY2Uobm9kZSwgdHJlZSwgZGltZW5zaW9ucykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0cmVlLnZpc2l0KCh0cmVlTm9kZSwgeDEsIHkxLCB4MiwgeTIpID0+IGFwcGx5KHRyZWVOb2RlLCB4MSwgeTEsIHgyLCB5Miwgbm9kZSwgZGltZW5zaW9ucykpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9yY2Utbi1ib2R5LmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgR3JhcGggYXMgSUdyYXBoIH0gZnJvbSAnQGFudHYvZ3JhcGhsaWInO1xuaW1wb3J0IHsgaXNOdW1iZXIgfSBmcm9tICdAYW50di91dGlsJztcbmltcG9ydCB7IGZvcm1hdE5vZGVTaXplVG9OdW1iZXIsIGZvcm1hdE51bWJlckZuIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgeyBmb3JjZU5Cb2R5IH0gZnJvbSAnLi9mb3JjZS1uLWJvZHknO1xuY29uc3QgREVGQVVMVFNfTEFZT1VUX09QVElPTlMgPSB7XG4gICAgZGltZW5zaW9uczogMixcbiAgICBtYXhJdGVyYXRpb246IDUwMCxcbiAgICBncmF2aXR5OiAxMCxcbiAgICBmYWN0b3I6IDEsXG4gICAgZWRnZVN0cmVuZ3RoOiA1MCxcbiAgICBub2RlU3RyZW5ndGg6IDEwMDAsXG4gICAgY291bG9tYkRpc1NjYWxlOiAwLjAwNSxcbiAgICBkYW1waW5nOiAwLjksXG4gICAgbWF4U3BlZWQ6IDIwMCxcbiAgICBtaW5Nb3ZlbWVudDogMC40LFxuICAgIGludGVydmFsOiAwLjAyLFxuICAgIGxpbmtEaXN0YW5jZTogMjAwLFxuICAgIGNsdXN0ZXJOb2RlU3RyZW5ndGg6IDIwLFxuICAgIHByZXZlbnRPdmVybGFwOiB0cnVlLFxuICAgIGRpc3RhbmNlVGhyZXNob2xkTW9kZTogJ21lYW4nLFxufTtcbi8qKlxuICogPHpoLz4g5Yqb5a+85ZCR5biD5bGAXG4gKlxuICogPGVuLz4gRm9yY2UtZGlyZWN0ZWQgbGF5b3V0XG4gKi9cbmV4cG9ydCBjbGFzcyBGb3JjZUxheW91dCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuaWQgPSAnZm9yY2UnO1xuICAgICAgICAvKipcbiAgICAgICAgICogdGltZSBpbnRlcnZhbCBmb3IgbGF5b3V0IGZvcmNlIGFuaW1hdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGltZUludGVydmFsID0gMDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNvbXBhcmUgd2l0aCBtaW5Nb3ZlbWVudCB0byBlbmQgdGhlIG5vZGVzJyBtb3ZlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5qdWRnaW5nRGlzdGFuY2UgPSAwO1xuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUU19MQVlPVVRfT1BUSU9OUyksIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHBvc2l0aW9ucyBvZiBub2RlcyBhbmQgZWRnZXMoaWYgbmVlZGVkKS5cbiAgICAgKi9cbiAgICBleGVjdXRlKGdyYXBoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmljRm9yY2VMYXlvdXQoZmFsc2UsIGdyYXBoLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvIGRpcmVjdGx5IGFzc2lnbiB0aGUgcG9zaXRpb25zIHRvIHRoZSBub2Rlcy5cbiAgICAgKi9cbiAgICBhc3NpZ24oZ3JhcGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2VuZXJpY0ZvcmNlTGF5b3V0KHRydWUsIGdyYXBoLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3Agc2ltdWxhdGlvbiBpbW1lZGlhdGVseS5cbiAgICAgKi9cbiAgICBzdG9wKCkge1xuICAgICAgICBpZiAodGhpcy50aW1lSW50ZXJ2YWwgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMudGltZUludGVydmFsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFudWFsbHkgc3RlcHMgdGhlIHNpbXVsYXRpb24gYnkgdGhlIHNwZWNpZmllZCBudW1iZXIgb2YgaXRlcmF0aW9ucy5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9kMy9kMy1mb3JjZSNzaW11bGF0aW9uX3RpY2tcbiAgICAgKi9cbiAgICB0aWNrKGl0ZXJhdGlvbnMgPSB0aGlzLm9wdGlvbnMubWF4SXRlcmF0aW9uIHx8IDEpIHtcbiAgICAgICAgaWYgKHRoaXMubGFzdFJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGFzdFJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgKHRoaXMuanVkZ2luZ0Rpc3RhbmNlID4gdGhpcy5sYXN0T3B0aW9ucy5taW5Nb3ZlbWVudCB8fCBpIDwgMSkgJiZcbiAgICAgICAgICAgIGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucnVuT25lU3RlcCh0aGlzLmxhc3RDYWxjR3JhcGgsIHRoaXMubGFzdEdyYXBoLCBpLCB0aGlzLmxhc3RWZWxNYXAsIHRoaXMubGFzdE9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQb3NpdGlvbih0aGlzLmxhc3RHcmFwaCwgdGhpcy5sYXN0Q2FsY0dyYXBoLCB0aGlzLmxhc3RWZWxNYXAsIHRoaXMubGFzdE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIG5vZGVzOiB0aGlzLmxhc3RMYXlvdXROb2RlcyxcbiAgICAgICAgICAgIGVkZ2VzOiB0aGlzLmxhc3RMYXlvdXRFZGdlcyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMubGFzdEFzc2lnbikge1xuICAgICAgICAgICAgcmVzdWx0Lm5vZGVzLmZvckVhY2goKG5vZGUpID0+IHRoaXMubGFzdEdyYXBoLm1lcmdlTm9kZURhdGEobm9kZS5pZCwge1xuICAgICAgICAgICAgICAgIHg6IG5vZGUuZGF0YS54LFxuICAgICAgICAgICAgICAgIHk6IG5vZGUuZGF0YS55LFxuICAgICAgICAgICAgICAgIHo6IHRoaXMub3B0aW9ucy5kaW1lbnNpb25zID09PSAzID8gbm9kZS5kYXRhLnogOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZ2VuZXJpY0ZvcmNlTGF5b3V0KGFzc2lnbiwgZ3JhcGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBncmFwaC5nZXRBbGxOb2RlcygpO1xuICAgICAgICAgICAgY29uc3QgZWRnZXMgPSBncmFwaC5nZXRBbGxFZGdlcygpO1xuICAgICAgICAgICAgY29uc3QgZm9ybWF0dGVkT3B0aW9ucyA9IHRoaXMuZm9ybWF0T3B0aW9ucyhtZXJnZWRPcHRpb25zLCBncmFwaCk7XG4gICAgICAgICAgICBjb25zdCB7IGRpbWVuc2lvbnMsIHdpZHRoLCBoZWlnaHQsIG5vZGVTaXplLCBnZXRNYXNzLCBub2RlU3RyZW5ndGgsIGVkZ2VTdHJlbmd0aCwgbGlua0Rpc3RhbmNlLCB9ID0gZm9ybWF0dGVkT3B0aW9ucztcbiAgICAgICAgICAgIC8vIGNsb25lcyB0aGUgb3JpZ2luYWwgZGF0YSBhbmQgYXR0YWNoZXMgY2FsY3VsYXRpb24gYXR0cmlidXRlcyBmb3IgdGhpcyBsYXlvdXQgYWxnb3JpdGhtXG4gICAgICAgICAgICBjb25zdCBsYXlvdXROb2RlcyA9IG5vZGVzLm1hcCgobm9kZSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG5vZGUpLCB7IGRhdGE6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbm9kZS5kYXRhKSwgeyBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIC4uLnJhbmRvbURpc3RyaWJ1dGlvbihub2RlLCBkaW1lbnNpb25zLCAzMCwgaSksXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBpc051bWJlcihub2RlLmRhdGEueCkgPyBub2RlLmRhdGEueCA6IE1hdGgucmFuZG9tKCkgKiB3aWR0aCwgeTogaXNOdW1iZXIobm9kZS5kYXRhLnkpID8gbm9kZS5kYXRhLnkgOiBNYXRoLnJhbmRvbSgpICogaGVpZ2h0LCB6OiBpc051bWJlcihub2RlLmRhdGEueilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG5vZGUuZGF0YS56XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBNYXRoLnJhbmRvbSgpICogTWF0aC5zcXJ0KHdpZHRoICogaGVpZ2h0KSwgc2l6ZTogbm9kZVNpemUobm9kZSkgfHwgMzAsIG1hc3M6IGdldE1hc3Mobm9kZSksIG5vZGVTdHJlbmd0aDogbm9kZVN0cmVuZ3RoKG5vZGUpIH0pIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBsYXlvdXRFZGdlcyA9IGVkZ2VzLm1hcCgoZWRnZSkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZWRnZSksIHsgZGF0YTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlZGdlLmRhdGEpLCB7IGVkZ2VTdHJlbmd0aDogZWRnZVN0cmVuZ3RoKGVkZ2UpLCBsaW5rRGlzdGFuY2U6IGxpbmtEaXN0YW5jZShlZGdlLCBncmFwaC5nZXROb2RlKGVkZ2Uuc291cmNlKSwgZ3JhcGguZ2V0Tm9kZShlZGdlLnRhcmdldCkpIH0pIH0pKSk7XG4gICAgICAgICAgICBpZiAoIShub2RlcyA9PT0gbnVsbCB8fCBub2RlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZXMubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFJlc3VsdCA9IHsgbm9kZXM6IFtdLCBlZGdlcyB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG5vZGVzOiBbXSwgZWRnZXMgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZlbE1hcCA9IHt9O1xuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaCgobm9kZSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHZlbE1hcFtub2RlLmlkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgICAgICAgICAgejogMCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjYWxjR3JhcGggPSBuZXcgSUdyYXBoKHtcbiAgICAgICAgICAgICAgICBub2RlczogbGF5b3V0Tm9kZXMsXG4gICAgICAgICAgICAgICAgZWRnZXM6IGxheW91dEVkZ2VzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmZvcm1hdENlbnRyaXBldGFsKGZvcm1hdHRlZE9wdGlvbnMsIGNhbGNHcmFwaCk7XG4gICAgICAgICAgICBjb25zdCB7IG1heEl0ZXJhdGlvbiwgbWluTW92ZW1lbnQsIG9uVGljayB9ID0gZm9ybWF0dGVkT3B0aW9ucztcbiAgICAgICAgICAgIC8vIFVzZSB0aGVtIGxhdGVyIGluIGB0aWNrYC5cbiAgICAgICAgICAgIHRoaXMubGFzdExheW91dE5vZGVzID0gbGF5b3V0Tm9kZXM7XG4gICAgICAgICAgICB0aGlzLmxhc3RMYXlvdXRFZGdlcyA9IGxheW91dEVkZ2VzO1xuICAgICAgICAgICAgdGhpcy5sYXN0QXNzaWduID0gYXNzaWduO1xuICAgICAgICAgICAgdGhpcy5sYXN0R3JhcGggPSBncmFwaDtcbiAgICAgICAgICAgIHRoaXMubGFzdENhbGNHcmFwaCA9IGNhbGNHcmFwaDtcbiAgICAgICAgICAgIHRoaXMubGFzdE9wdGlvbnMgPSBmb3JtYXR0ZWRPcHRpb25zO1xuICAgICAgICAgICAgdGhpcy5sYXN0VmVsTWFwID0gdmVsTWFwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBpdGVyID0gMDtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGludGVydmFsIGZvciByZW5kZXIgdGhlIHJlc3VsdCBhZnRlciBlYWNoIGl0ZXJhdGlvblxuICAgICAgICAgICAgICAgIHRoaXMudGltZUludGVydmFsID0gd2luZG93LnNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFub2RlcyB8fCAhdGhpcy5ydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlczogZm9ybWF0T3V0Tm9kZXMoZ3JhcGgsIGxheW91dE5vZGVzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlZGdlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVuT25lU3RlcChjYWxjR3JhcGgsIGdyYXBoLCBpdGVyLCB2ZWxNYXAsIGZvcm1hdHRlZE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKGdyYXBoLCBjYWxjR3JhcGgsIHZlbE1hcCwgZm9ybWF0dGVkT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhc3NpZ24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheW91dE5vZGVzLmZvckVhY2goKG5vZGUpID0+IGdyYXBoLm1lcmdlTm9kZURhdGEobm9kZS5pZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IG5vZGUuZGF0YS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IG5vZGUuZGF0YS55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHo6IGRpbWVuc2lvbnMgPT09IDMgPyBub2RlLmRhdGEueiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvblRpY2sgPT09IG51bGwgfHwgb25UaWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblRpY2soe1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXM6IGZvcm1hdE91dE5vZGVzKGdyYXBoLCBsYXlvdXROb2RlcyksXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlcyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXIrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZXIgPj0gbWF4SXRlcmF0aW9uIHx8IHRoaXMuanVkZ2luZ0Rpc3RhbmNlIDwgbWluTW92ZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMudGltZUludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzOiBmb3JtYXRPdXROb2RlcyhncmFwaCwgbGF5b3V0Tm9kZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVkZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3JtYXQgbWVyZ2VkIGxheW91dCBvcHRpb25zLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIG1lcmdlZCBsYXlvdXQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSBncmFwaCBvcmlnaW5hbCBncmFwaFxuICAgICAqIEByZXR1cm5zXG4gICAgICovXG4gICAgZm9ybWF0T3B0aW9ucyhvcHRpb25zLCBncmFwaCkge1xuICAgICAgICBjb25zdCBmb3JtYXR0ZWRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHsgd2lkdGg6IHByb3BzV2lkdGgsIGhlaWdodDogcHJvcHNIZWlnaHQsIGdldE1hc3MgfSA9IG9wdGlvbnM7XG4gICAgICAgIC8vID09PSBmb3JtYXRpbmcgd2lkdGgsIGhlaWdodCwgYW5kIGNlbnRlciA9PT09PVxuICAgICAgICBmb3JtYXR0ZWRPcHRpb25zLndpZHRoID1cbiAgICAgICAgICAgICFwcm9wc1dpZHRoICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgPyB3aW5kb3cuaW5uZXJXaWR0aFxuICAgICAgICAgICAgICAgIDogcHJvcHNXaWR0aDtcbiAgICAgICAgZm9ybWF0dGVkT3B0aW9ucy5oZWlnaHQgPVxuICAgICAgICAgICAgIXByb3BzSGVpZ2h0ICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgPyB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICAgICAgICAgICAgICA6IHByb3BzSGVpZ2h0O1xuICAgICAgICBpZiAoIW9wdGlvbnMuY2VudGVyKSB7XG4gICAgICAgICAgICBmb3JtYXR0ZWRPcHRpb25zLmNlbnRlciA9IFtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRPcHRpb25zLndpZHRoIC8gMixcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRPcHRpb25zLmhlaWdodCAvIDIsXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIC8vID09PSBmb3JtYXRpbmcgbm9kZSBtYXNzID09PT09XG4gICAgICAgIGlmICghZ2V0TWFzcykge1xuICAgICAgICAgICAgZm9ybWF0dGVkT3B0aW9ucy5nZXRNYXNzID0gKGQpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgbWFzc1dlaWdodCA9IDE7XG4gICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGQgPT09IG51bGwgfHwgZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZC5kYXRhLm1hc3MpKVxuICAgICAgICAgICAgICAgICAgICBtYXNzV2VpZ2h0ID0gZCA9PT0gbnVsbCB8fCBkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkLmRhdGEubWFzcztcbiAgICAgICAgICAgICAgICBjb25zdCBkZWdyZWUgPSBncmFwaC5nZXREZWdyZWUoZC5pZCwgJ2JvdGgnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWRlZ3JlZSB8fCBkZWdyZWUgPCA1ID8gbWFzc1dlaWdodCA6IGRlZ3JlZSAqIDUgKiBtYXNzV2VpZ2h0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyA9PT0gZm9ybWF0aW5nIG5vZGUgc2l6ZSA9PT09PVxuICAgICAgICBmb3JtYXR0ZWRPcHRpb25zLm5vZGVTaXplID0gZm9ybWF0Tm9kZVNpemVUb051bWJlcihvcHRpb25zLm5vZGVTaXplLCBvcHRpb25zLm5vZGVTcGFjaW5nKTtcbiAgICAgICAgLy8gPT09IGZvcm1hdGluZyBub2RlIC8gZWRnZSBzdHJlbmd0aHMgPT09PT1cbiAgICAgICAgY29uc3QgbGlua0Rpc3RhbmNlRm4gPSBvcHRpb25zLmxpbmtEaXN0YW5jZVxuICAgICAgICAgICAgPyBmb3JtYXROdW1iZXJGbigxLCBvcHRpb25zLmxpbmtEaXN0YW5jZSlcbiAgICAgICAgICAgIDogKGVkZ2UpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKDEgK1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXR0ZWRPcHRpb25zLm5vZGVTaXplKGdyYXBoLmdldE5vZGUoZWRnZS5zb3VyY2UpKSArXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdHRlZE9wdGlvbnMubm9kZVNpemUoZ3JhcGguZ2V0Tm9kZShlZGdlLnRhcmdldCkpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGZvcm1hdHRlZE9wdGlvbnMubGlua0Rpc3RhbmNlID0gbGlua0Rpc3RhbmNlRm47XG4gICAgICAgIGZvcm1hdHRlZE9wdGlvbnMubm9kZVN0cmVuZ3RoID0gZm9ybWF0TnVtYmVyRm4oMSwgb3B0aW9ucy5ub2RlU3RyZW5ndGgpO1xuICAgICAgICBmb3JtYXR0ZWRPcHRpb25zLmVkZ2VTdHJlbmd0aCA9IGZvcm1hdE51bWJlckZuKDEsIG9wdGlvbnMuZWRnZVN0cmVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGZvcm1hdHRlZE9wdGlvbnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZvcm1hdCBjZW50cmlwZXRhbE9wdGlvbiBpbiB0aGUgb3B0aW9uLlxuICAgICAqIEBwYXJhbSBvcHRpb25zIG1lcmdlZCBsYXlvdXQgb3B0aW9uc1xuICAgICAqIEBwYXJhbSBjYWxjR3JhcGggY2FsY3VsYXRpb24gZ3JhcGhcbiAgICAgKi9cbiAgICBmb3JtYXRDZW50cmlwZXRhbChvcHRpb25zLCBjYWxjR3JhcGgpIHtcbiAgICAgICAgY29uc3QgeyBkaW1lbnNpb25zLCBjZW50cmlwZXRhbE9wdGlvbnMsIGNlbnRlciwgY2x1c3Rlck5vZGVTdHJlbmd0aCwgbGVhZkNsdXN0ZXIsIGNsdXN0ZXJpbmcsIG5vZGVDbHVzdGVyQnksIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBjYWxjTm9kZXMgPSBjYWxjR3JhcGguZ2V0QWxsTm9kZXMoKTtcbiAgICAgICAgLy8gPT09IGZvcm1hdGluZyBjZW50cmlwZXRhbE9wdGlvbnMgPT09PT1cbiAgICAgICAgY29uc3QgYmFzaWNDZW50cmlwZXRhbCA9IGNlbnRyaXBldGFsT3B0aW9ucyB8fCB7XG4gICAgICAgICAgICBsZWFmOiAyLFxuICAgICAgICAgICAgc2luZ2xlOiAyLFxuICAgICAgICAgICAgb3RoZXJzOiAxLFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICAgICAgICBjZW50ZXI6IChuKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgeDogY2VudGVyWzBdLFxuICAgICAgICAgICAgICAgICAgICB5OiBjZW50ZXJbMV0sXG4gICAgICAgICAgICAgICAgICAgIHo6IGRpbWVuc2lvbnMgPT09IDMgPyBjZW50ZXJbMl0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgY2x1c3Rlck5vZGVTdHJlbmd0aCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3B0aW9ucy5jbHVzdGVyTm9kZVN0cmVuZ3RoID0gKG5vZGUpID0+IGNsdXN0ZXJOb2RlU3RyZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNhbWVUeXBlTGVhZk1hcDtcbiAgICAgICAgbGV0IGNsdXN0ZXJzO1xuICAgICAgICBpZiAobGVhZkNsdXN0ZXIgJiYgbm9kZUNsdXN0ZXJCeSkge1xuICAgICAgICAgICAgc2FtZVR5cGVMZWFmTWFwID0gZ2V0U2FtZVR5cGVMZWFmTWFwKGNhbGNHcmFwaCwgbm9kZUNsdXN0ZXJCeSk7XG4gICAgICAgICAgICBjbHVzdGVycyA9XG4gICAgICAgICAgICAgICAgQXJyYXkuZnJvbShuZXcgU2V0KGNhbGNOb2RlcyA9PT0gbnVsbCB8fCBjYWxjTm9kZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGNOb2Rlcy5tYXAoKG5vZGUpID0+IG5vZGUuZGF0YVtub2RlQ2x1c3RlckJ5XSkpKSB8fCBbXTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIG9wdGlvbnMuY2VudHJpcGV0YWxPcHRpb25zID0gT2JqZWN0LmFzc2lnbihiYXNpY0NlbnRyaXBldGFsLCB7XG4gICAgICAgICAgICAgICAgc2luZ2xlOiAxMDAsXG4gICAgICAgICAgICAgICAgbGVhZjogKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5om+5Ye65LiO5a6D5YWz6IGU55qE6L6555qE6LW354K55oiW57uI54K55Ye65Y+R55qE5omA5pyJ5LiA5bqm6IqC54K55Lit5ZCM57G75Z6L55qE5Y+25a2Q6IqC54K5XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2libGluZ0xlYXZlcywgc2FtZVR5cGVMZWF2ZXMgfSA9IHNhbWVUeXBlTGVhZk1hcFtub2RlLmlkXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgLy8g5aaC5p6c6YO95piv5ZCM5LiA57G75Z6L5oiW6ICF5q+P56eN57G75Z6L5Y+q5pyJMeS4qu+8jOWImeaWveWKoOm7mOiupOWQkeW/g+WKm1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHNhbWVUeXBlTGVhdmVzID09PSBudWxsIHx8IHNhbWVUeXBlTGVhdmVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzYW1lVHlwZUxlYXZlcy5sZW5ndGgpID09PSAoc2libGluZ0xlYXZlcyA9PT0gbnVsbCB8fCBzaWJsaW5nTGVhdmVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzaWJsaW5nTGVhdmVzLmxlbmd0aCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChjbHVzdGVycyA9PT0gbnVsbCB8fCBjbHVzdGVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2x1c3RlcnMubGVuZ3RoKSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY2x1c3Rlck5vZGVTdHJlbmd0aChub2RlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG90aGVyczogMSxcbiAgICAgICAgICAgICAgICBjZW50ZXI6IChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZ3JlZSA9IGNhbGNHcmFwaC5nZXREZWdyZWUobm9kZS5pZCwgJ2JvdGgnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8g5a2k54K56buY6K6k57uZMeS4qui/nOemu+eahOS4reW/g+eCuVxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRlZ3JlZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiAxMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogMTAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHo6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCBjZW50ZXJQb3M7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWdyZWUgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIOWmguaenOS4uuWPtuWtkOiKgueCuVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8g5om+5Ye65LiO5a6D5YWz6IGU55qE6L6555qE6LW354K55Ye65Y+R55qE5omA5pyJ5LiA5bqm6IqC54K55Lit5ZCM57G75Z6L55qE5Y+25a2Q6IqC54K5XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNhbWVUeXBlTGVhdmVzID0gW10gfSA9IHNhbWVUeXBlTGVhZk1hcFtub2RlLmlkXSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzYW1lVHlwZUxlYXZlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyDlpoLmnpzlkIznsbvlnovnmoTlj7blrZDoioLngrnlj6rmnIkx5Liq77yM5Lit5b+D5L2N572u5Li6dW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyUG9zID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc2FtZVR5cGVMZWF2ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIOaJvuWHuuWQjOexu+Wei+iKgueCueW5s+Wdh+S9jee9ruS9nOS4uuS4reW/g1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlclBvcyA9IGdldEF2Z05vZGVQb3NpdGlvbihzYW1lVHlwZUxlYXZlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXJQb3MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNlbnRlclBvcyA9PT0gbnVsbCB8fCBjZW50ZXJQb3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNlbnRlclBvcy54LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogY2VudGVyUG9zID09PSBudWxsIHx8IGNlbnRlclBvcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2VudGVyUG9zLnksXG4gICAgICAgICAgICAgICAgICAgICAgICB6OiBjZW50ZXJQb3MgPT09IG51bGwgfHwgY2VudGVyUG9zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjZW50ZXJQb3MueixcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsdXN0ZXJpbmcgJiYgbm9kZUNsdXN0ZXJCeSkge1xuICAgICAgICAgICAgaWYgKCFzYW1lVHlwZUxlYWZNYXApIHtcbiAgICAgICAgICAgICAgICBzYW1lVHlwZUxlYWZNYXAgPSBnZXRTYW1lVHlwZUxlYWZNYXAoY2FsY0dyYXBoLCBub2RlQ2x1c3RlckJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghY2x1c3RlcnMpIHtcbiAgICAgICAgICAgICAgICBjbHVzdGVycyA9IEFycmF5LmZyb20obmV3IFNldChjYWxjTm9kZXMubWFwKChub2RlKSA9PiBub2RlLmRhdGFbbm9kZUNsdXN0ZXJCeV0pKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbHVzdGVycyA9IGNsdXN0ZXJzLmZpbHRlcigoaXRlbSkgPT4gaXRlbSAhPT0gdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGNvbnN0IGNlbnRlckluZm8gPSB7fTtcbiAgICAgICAgICAgIGNsdXN0ZXJzLmZvckVhY2goKGNsdXN0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzYW1lVHlwZU5vZGVzID0gY2FsY05vZGVzXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKG5vZGUpID0+IG5vZGUuZGF0YVtub2RlQ2x1c3RlckJ5XSA9PT0gY2x1c3RlcilcbiAgICAgICAgICAgICAgICAgICAgLm1hcCgobm9kZSkgPT4gY2FsY0dyYXBoLmdldE5vZGUobm9kZS5pZCkpO1xuICAgICAgICAgICAgICAgIC8vIOaJvuWHuuWQjOexu+Wei+iKgueCueW5s+Wdh+S9jee9ruiKgueCueeahOi3neemu+acgOi/keeahOiKgueCueS9nOS4uuS4reW/g+iKgueCuVxuICAgICAgICAgICAgICAgIGNlbnRlckluZm9bY2x1c3Rlcl0gPSBnZXRBdmdOb2RlUG9zaXRpb24oc2FtZVR5cGVOb2Rlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9wdGlvbnMuY2VudHJpcGV0YWxPcHRpb25zID0gT2JqZWN0LmFzc2lnbihiYXNpY0NlbnRyaXBldGFsLCB7XG4gICAgICAgICAgICAgICAgc2luZ2xlOiAobm9kZSkgPT4gb3B0aW9ucy5jbHVzdGVyTm9kZVN0cmVuZ3RoKG5vZGUpLFxuICAgICAgICAgICAgICAgIGxlYWY6IChub2RlKSA9PiBvcHRpb25zLmNsdXN0ZXJOb2RlU3RyZW5ndGgobm9kZSksXG4gICAgICAgICAgICAgICAgb3RoZXJzOiAobm9kZSkgPT4gb3B0aW9ucy5jbHVzdGVyTm9kZVN0cmVuZ3RoKG5vZGUpLFxuICAgICAgICAgICAgICAgIGNlbnRlcjogKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8g5om+5Ye65ZCM57G75Z6L6IqC54K55bmz5Z2H5L2N572u6IqC54K555qE6Led56a75pyA6L+R55qE6IqC54K55L2c5Li65Lit5b+D6IqC54K5XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbnRlclBvcyA9IGNlbnRlckluZm9bbm9kZS5kYXRhW25vZGVDbHVzdGVyQnldXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNlbnRlclBvcyA9PT0gbnVsbCB8fCBjZW50ZXJQb3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNlbnRlclBvcy54LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogY2VudGVyUG9zID09PSBudWxsIHx8IGNlbnRlclBvcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2VudGVyUG9zLnksXG4gICAgICAgICAgICAgICAgICAgICAgICB6OiBjZW50ZXJQb3MgPT09IG51bGwgfHwgY2VudGVyUG9zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjZW50ZXJQb3MueixcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBsZWFmLCBzaW5nbGUsIG90aGVycyB9ID0gb3B0aW9ucy5jZW50cmlwZXRhbE9wdGlvbnMgfHwge307XG4gICAgICAgIGlmIChsZWFmICYmIHR5cGVvZiBsZWFmICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNlbnRyaXBldGFsT3B0aW9ucy5sZWFmID0gKCkgPT4gbGVhZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2luZ2xlICYmIHR5cGVvZiBzaW5nbGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2VudHJpcGV0YWxPcHRpb25zLnNpbmdsZSA9ICgpID0+IHNpbmdsZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXJzICYmIHR5cGVvZiBvdGhlcnMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2VudHJpcGV0YWxPcHRpb25zLm90aGVycyA9ICgpID0+IG90aGVycztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbmUgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSBjYWxjR3JhcGggY2FsY3VsYXRpb24gZ3JhcGhcbiAgICAgKiBAcGFyYW0gZ3JhcGggb3JpZ2luIGdyYXBoXG4gICAgICogQHBhcmFtIGl0ZXIgY3VycmVudCBpdGVyYXRpb24gaW5kZXhcbiAgICAgKiBAcGFyYW0gdmVsTWFwIG5vZGVzJyB2ZWxvY2l0eSBtYXBcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBmb3JtYXR0ZWQgbGF5b3V0IG9wdGlvbnNcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqL1xuICAgIHJ1bk9uZVN0ZXAoY2FsY0dyYXBoLCBncmFwaCwgaXRlciwgdmVsTWFwLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGFjY01hcCA9IHt9O1xuICAgICAgICBjb25zdCBjYWxjTm9kZXMgPSBjYWxjR3JhcGguZ2V0QWxsTm9kZXMoKTtcbiAgICAgICAgY29uc3QgY2FsY0VkZ2VzID0gY2FsY0dyYXBoLmdldEFsbEVkZ2VzKCk7XG4gICAgICAgIGlmICghKGNhbGNOb2RlcyA9PT0gbnVsbCB8fCBjYWxjTm9kZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGNOb2Rlcy5sZW5ndGgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IG1vbml0b3IgfSA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuY2FsUmVwdWxzaXZlKGNhbGNHcmFwaCwgYWNjTWFwLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKGNhbGNFZGdlcylcbiAgICAgICAgICAgIHRoaXMuY2FsQXR0cmFjdGl2ZShjYWxjR3JhcGgsIGFjY01hcCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY2FsR3Jhdml0eShjYWxjR3JhcGgsIGdyYXBoLCBhY2NNYXAsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnVwZGF0ZVZlbG9jaXR5KGNhbGNHcmFwaCwgYWNjTWFwLCB2ZWxNYXAsIG9wdGlvbnMpO1xuICAgICAgICAvKiog5aaC5p6c6ZyA6KaB55uR5o6n5L+h5oGv77yM5YiZ5o+Q5L6b57uZ55So5oi3ICovXG4gICAgICAgIGlmIChtb25pdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBlbmVyZ3kgPSB0aGlzLmNhbFRvdGFsRW5lcmd5KGFjY01hcCwgY2FsY05vZGVzKTtcbiAgICAgICAgICAgIG1vbml0b3Ioe1xuICAgICAgICAgICAgICAgIGVuZXJneSxcbiAgICAgICAgICAgICAgICBub2RlczogZ3JhcGguZ2V0QWxsTm9kZXMoKSxcbiAgICAgICAgICAgICAgICBlZGdlczogZ3JhcGguZ2V0QWxsRWRnZXMoKSxcbiAgICAgICAgICAgICAgICBpdGVyYXRpb25zOiBpdGVyLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIGdyYXBoIGVuZXJneSBmb3IgbW9uaXRvcmluZyBjb252ZXJnZW5jZS5cbiAgICAgKiBAcGFyYW0gYWNjTWFwIGFjY2VsZXJhdGlvbiBtYXBcbiAgICAgKiBAcGFyYW0gbm9kZXMgY2FsY3VsYXRpb24gbm9kZXNcbiAgICAgKiBAcmV0dXJucyBlbmVyZ3lcbiAgICAgKi9cbiAgICBjYWxUb3RhbEVuZXJneShhY2NNYXAsIG5vZGVzKSB7XG4gICAgICAgIGlmICghKG5vZGVzID09PSBudWxsIHx8IG5vZGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2Rlcy5sZW5ndGgpKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGxldCBlbmVyZ3kgPSAwLjA7XG4gICAgICAgIG5vZGVzLmZvckVhY2goKG5vZGUsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZ4ID0gYWNjTWFwW25vZGUuaWRdLng7XG4gICAgICAgICAgICBjb25zdCB2eSA9IGFjY01hcFtub2RlLmlkXS55O1xuICAgICAgICAgICAgY29uc3QgdnogPSB0aGlzLm9wdGlvbnMuZGltZW5zaW9ucyA9PT0gMyA/IGFjY01hcFtub2RlLmlkXS56IDogMDtcbiAgICAgICAgICAgIGNvbnN0IHNwZWVkMiA9IHZ4ICogdnggKyB2eSAqIHZ5ICsgdnogKiB2ejtcbiAgICAgICAgICAgIGNvbnN0IHsgbWFzcyA9IDEgfSA9IG5vZGUuZGF0YTtcbiAgICAgICAgICAgIGVuZXJneSArPSBtYXNzICogc3BlZWQyICogMC41OyAvLyBwID0gMS8yKihtdl4yKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVuZXJneTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSByZXB1bHNpdmUgZm9yY2VzIGFjY29yZGluZyB0byBjb3Vsb21icyBsYXcuXG4gICAgICogQHBhcmFtIGNhbGNHcmFwaCBjYWxjdWxhdGlvbiBncmFwaFxuICAgICAqIEBwYXJhbSBhY2NNYXAgYWNjZWxlcmF0aW9uIG1hcFxuICAgICAqIEBwYXJhbSBvcHRpb25zIGZvcm1hdHRlZCBsYXlvdXQgb3B0aW9uc1xuICAgICAqL1xuICAgIGNhbFJlcHVsc2l2ZShjYWxjR3JhcGgsIGFjY01hcCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGRpbWVuc2lvbnMsIGZhY3RvciwgY291bG9tYkRpc1NjYWxlIH0gPSBvcHRpb25zO1xuICAgICAgICBmb3JjZU5Cb2R5KGNhbGNHcmFwaCwgZmFjdG9yLCBjb3Vsb21iRGlzU2NhbGUgKiBjb3Vsb21iRGlzU2NhbGUsIGFjY01hcCwgZGltZW5zaW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZSB0aGUgYXR0cmFjdGl2ZSBmb3JjZXMgYWNjb3JkaW5nIHRvIGhvb2tzIGxhdy5cbiAgICAgKiBAcGFyYW0gY2FsY0dyYXBoIGNhbGN1bGF0aW9uIGdyYXBoXG4gICAgICogQHBhcmFtIGFjY01hcCBhY2NlbGVyYXRpb24gbWFwXG4gICAgICovXG4gICAgY2FsQXR0cmFjdGl2ZShjYWxjR3JhcGgsIGFjY01hcCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGRpbWVuc2lvbnMsIG5vZGVTaXplIH0gPSBvcHRpb25zO1xuICAgICAgICBjYWxjR3JhcGguZ2V0QWxsRWRnZXMoKS5mb3JFYWNoKChlZGdlLCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHNvdXJjZSwgdGFyZ2V0IH0gPSBlZGdlO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlTm9kZSA9IGNhbGNHcmFwaC5nZXROb2RlKHNvdXJjZSk7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXROb2RlID0gY2FsY0dyYXBoLmdldE5vZGUodGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICghc291cmNlTm9kZSB8fCAhdGFyZ2V0Tm9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgdmVjWCA9IHRhcmdldE5vZGUuZGF0YS54IC0gc291cmNlTm9kZS5kYXRhLng7XG4gICAgICAgICAgICBsZXQgdmVjWSA9IHRhcmdldE5vZGUuZGF0YS55IC0gc291cmNlTm9kZS5kYXRhLnk7XG4gICAgICAgICAgICBsZXQgdmVjWiA9IGRpbWVuc2lvbnMgPT09IDMgPyB0YXJnZXROb2RlLmRhdGEueiAtIHNvdXJjZU5vZGUuZGF0YS56IDogMDtcbiAgICAgICAgICAgIGlmICghdmVjWCAmJiAhdmVjWSkge1xuICAgICAgICAgICAgICAgIHZlY1ggPSBNYXRoLnJhbmRvbSgpICogMC4wMTtcbiAgICAgICAgICAgICAgICB2ZWNZID0gTWF0aC5yYW5kb20oKSAqIDAuMDE7XG4gICAgICAgICAgICAgICAgaWYgKGRpbWVuc2lvbnMgPT09IDMgJiYgIXZlY1opIHtcbiAgICAgICAgICAgICAgICAgICAgdmVjWiA9IE1hdGgucmFuZG9tKCkgKiAwLjAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZlY0xlbmd0aCA9IE1hdGguc3FydCh2ZWNYICogdmVjWCArIHZlY1kgKiB2ZWNZICsgdmVjWiAqIHZlY1opO1xuICAgICAgICAgICAgaWYgKHZlY0xlbmd0aCA8IG5vZGVTaXplKHNvdXJjZU5vZGUpICsgbm9kZVNpemUodGFyZ2V0Tm9kZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgZGlyZVggPSB2ZWNYIC8gdmVjTGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgZGlyZVkgPSB2ZWNZIC8gdmVjTGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgZGlyZVogPSB2ZWNaIC8gdmVjTGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgeyBsaW5rRGlzdGFuY2UgPSAyMDAsIGVkZ2VTdHJlbmd0aCA9IDIwMCB9ID0gZWRnZS5kYXRhIHx8IHt9O1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGxpbmtEaXN0YW5jZSAtIHZlY0xlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtID0gZGlmZiAqIGVkZ2VTdHJlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IG1hc3NTb3VyY2UgPSBzb3VyY2VOb2RlLmRhdGEubWFzcyB8fCAxO1xuICAgICAgICAgICAgY29uc3QgbWFzc1RhcmdldCA9IHRhcmdldE5vZGUuZGF0YS5tYXNzIHx8IDE7XG4gICAgICAgICAgICAvLyDotKjph4/ljaDmr5TotorlpKfvvIzlr7nlj6bkuIDnq6/lvbHlk43nqIvluqbotorlpKdcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZU1hc3NSYXRpbyA9IDEgLyBtYXNzU291cmNlO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0TWFzc1JhdGlvID0gMSAvIG1hc3NUYXJnZXQ7XG4gICAgICAgICAgICBjb25zdCBkaXNYID0gZGlyZVggKiBwYXJhbTtcbiAgICAgICAgICAgIGNvbnN0IGRpc1kgPSBkaXJlWSAqIHBhcmFtO1xuICAgICAgICAgICAgY29uc3QgZGlzWiA9IGRpcmVaICogcGFyYW07XG4gICAgICAgICAgICBhY2NNYXBbc291cmNlXS54IC09IGRpc1ggKiBzb3VyY2VNYXNzUmF0aW87XG4gICAgICAgICAgICBhY2NNYXBbc291cmNlXS55IC09IGRpc1kgKiBzb3VyY2VNYXNzUmF0aW87XG4gICAgICAgICAgICBhY2NNYXBbc291cmNlXS56IC09IGRpc1ogKiBzb3VyY2VNYXNzUmF0aW87XG4gICAgICAgICAgICBhY2NNYXBbdGFyZ2V0XS54ICs9IGRpc1ggKiB0YXJnZXRNYXNzUmF0aW87XG4gICAgICAgICAgICBhY2NNYXBbdGFyZ2V0XS55ICs9IGRpc1kgKiB0YXJnZXRNYXNzUmF0aW87XG4gICAgICAgICAgICBhY2NNYXBbdGFyZ2V0XS56ICs9IGRpc1ogKiB0YXJnZXRNYXNzUmF0aW87XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIGdyYXZpdHkgZm9yY2VzIHRvd2FyZCBjZW50ZXIuXG4gICAgICogQHBhcmFtIGNhbGNHcmFwaCBjYWxjdWxhdGlvbiBncmFwaFxuICAgICAqIEBwYXJhbSBncmFwaCBvcmlnaW4gZ3JhcGhcbiAgICAgKiBAcGFyYW0gYWNjTWFwIGFjY2VsZXJhdGlvbiBtYXBcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBmb3JtYXR0ZWQgbGF5b3V0IG9wdGlvbnNcbiAgICAgKi9cbiAgICBjYWxHcmF2aXR5KGNhbGNHcmFwaCwgZ3JhcGgsIGFjY01hcCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IGdldENlbnRlciB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgY2FsY05vZGVzID0gY2FsY0dyYXBoLmdldEFsbE5vZGVzKCk7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gZ3JhcGguZ2V0QWxsTm9kZXMoKTtcbiAgICAgICAgY29uc3QgZWRnZXMgPSBncmFwaC5nZXRBbGxFZGdlcygpO1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIGNlbnRlciwgZ3Jhdml0eTogZGVmYXVsdEdyYXZpdHksIGNlbnRyaXBldGFsT3B0aW9ucywgfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmICghY2FsY05vZGVzKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYWxjTm9kZXMuZm9yRWFjaCgoY2FsY05vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgaWQsIGRhdGEgfSA9IGNhbGNOb2RlO1xuICAgICAgICAgICAgY29uc3QgeyBtYXNzLCB4LCB5LCB6IH0gPSBkYXRhO1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGdyYXBoLmdldE5vZGUoaWQpO1xuICAgICAgICAgICAgbGV0IHZlY1ggPSAwO1xuICAgICAgICAgICAgbGV0IHZlY1kgPSAwO1xuICAgICAgICAgICAgbGV0IHZlY1ogPSAwO1xuICAgICAgICAgICAgbGV0IGdyYXZpdHkgPSBkZWZhdWx0R3Jhdml0eTtcbiAgICAgICAgICAgIGNvbnN0IGluRGVncmVlID0gY2FsY0dyYXBoLmdldERlZ3JlZShpZCwgJ2luJyk7XG4gICAgICAgICAgICBjb25zdCBvdXREZWdyZWUgPSBjYWxjR3JhcGguZ2V0RGVncmVlKGlkLCAnb3V0Jyk7XG4gICAgICAgICAgICBjb25zdCBkZWdyZWUgPSBjYWxjR3JhcGguZ2V0RGVncmVlKGlkLCAnYm90aCcpO1xuICAgICAgICAgICAgY29uc3QgZm9yY2VDZW50ZXIgPSBnZXRDZW50ZXIgPT09IG51bGwgfHwgZ2V0Q2VudGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZXRDZW50ZXIobm9kZSwgZGVncmVlKTtcbiAgICAgICAgICAgIGlmIChmb3JjZUNlbnRlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtjZW50ZXJYLCBjZW50ZXJZLCBzdHJlbmd0aF0gPSBmb3JjZUNlbnRlcjtcbiAgICAgICAgICAgICAgICB2ZWNYID0geCAtIGNlbnRlclg7XG4gICAgICAgICAgICAgICAgdmVjWSA9IHkgLSBjZW50ZXJZO1xuICAgICAgICAgICAgICAgIGdyYXZpdHkgPSBzdHJlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZlY1ggPSB4IC0gY2VudGVyWzBdO1xuICAgICAgICAgICAgICAgIHZlY1kgPSB5IC0gY2VudGVyWzFdO1xuICAgICAgICAgICAgICAgIHZlY1ogPSB6IC0gY2VudGVyWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyYXZpdHkpIHtcbiAgICAgICAgICAgICAgICBhY2NNYXBbaWRdLnggLT0gKGdyYXZpdHkgKiB2ZWNYKSAvIG1hc3M7XG4gICAgICAgICAgICAgICAgYWNjTWFwW2lkXS55IC09IChncmF2aXR5ICogdmVjWSkgLyBtYXNzO1xuICAgICAgICAgICAgICAgIGFjY01hcFtpZF0ueiAtPSAoZ3Jhdml0eSAqIHZlY1opIC8gbWFzcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjZW50cmlwZXRhbE9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGxlYWYsIHNpbmdsZSwgb3RoZXJzLCBjZW50ZXI6IGNlbnRyaUNlbnRlciwgfSA9IGNlbnRyaXBldGFsT3B0aW9ucztcbiAgICAgICAgICAgICAgICBjb25zdCB7IHg6IGNlbnRyaVgsIHk6IGNlbnRyaVksIHo6IGNlbnRyaVosIGNlbnRlclN0cmVuZ3RoLCB9ID0gKGNlbnRyaUNlbnRlciA9PT0gbnVsbCB8fCBjZW50cmlDZW50ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNlbnRyaUNlbnRlcihub2RlLCBub2RlcywgZWRnZXMsIHdpZHRoLCBoZWlnaHQpKSB8fCB7XG4gICAgICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICAgICAgICAgIHo6IDAsXG4gICAgICAgICAgICAgICAgICAgIGNlbnRlclN0cmVuZ3RoOiAwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKCFpc051bWJlcihjZW50cmlYKSB8fCAhaXNOdW1iZXIoY2VudHJpWSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBjb25zdCB2eCA9ICh4IC0gY2VudHJpWCkgLyBtYXNzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZ5ID0gKHkgLSBjZW50cmlZKSAvIG1hc3M7XG4gICAgICAgICAgICAgICAgY29uc3QgdnogPSAoeiAtIGNlbnRyaVopIC8gbWFzcztcbiAgICAgICAgICAgICAgICBpZiAoY2VudGVyU3RyZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgYWNjTWFwW2lkXS54IC09IGNlbnRlclN0cmVuZ3RoICogdng7XG4gICAgICAgICAgICAgICAgICAgIGFjY01hcFtpZF0ueSAtPSBjZW50ZXJTdHJlbmd0aCAqIHZ5O1xuICAgICAgICAgICAgICAgICAgICBhY2NNYXBbaWRdLnogLT0gY2VudGVyU3RyZW5ndGggKiB2ejtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8g5a2k54K5XG4gICAgICAgICAgICAgICAgaWYgKGRlZ3JlZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaW5nbGVTdHJlbmd0aCA9IHNpbmdsZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzaW5nbGVTdHJlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgYWNjTWFwW2lkXS54IC09IHNpbmdsZVN0cmVuZ3RoICogdng7XG4gICAgICAgICAgICAgICAgICAgIGFjY01hcFtpZF0ueSAtPSBzaW5nbGVTdHJlbmd0aCAqIHZ5O1xuICAgICAgICAgICAgICAgICAgICBhY2NNYXBbaWRdLnogLT0gc2luZ2xlU3RyZW5ndGggKiB2ejtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyDmsqHmnInlh7rluqbmiJbmsqHmnInlhaXluqbvvIzpg73orqTkuLrmmK/lj7blrZDoioLngrlcbiAgICAgICAgICAgICAgICBpZiAoaW5EZWdyZWUgPT09IDAgfHwgb3V0RGVncmVlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlYWZTdHJlbmd0aCA9IGxlYWYobm9kZSwgbm9kZXMsIGVkZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsZWFmU3RyZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGFjY01hcFtpZF0ueCAtPSBsZWFmU3RyZW5ndGggKiB2eDtcbiAgICAgICAgICAgICAgICAgICAgYWNjTWFwW2lkXS55IC09IGxlYWZTdHJlbmd0aCAqIHZ5O1xuICAgICAgICAgICAgICAgICAgICBhY2NNYXBbaWRdLnogLT0gbGVhZlN0cmVuZ3RoICogdno7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyoqIG90aGVycyAqL1xuICAgICAgICAgICAgICAgIGNvbnN0IG90aGVyc1N0cmVuZ3RoID0gb3RoZXJzKG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmICghb3RoZXJzU3RyZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBhY2NNYXBbaWRdLnggLT0gb3RoZXJzU3RyZW5ndGggKiB2eDtcbiAgICAgICAgICAgICAgICBhY2NNYXBbaWRdLnkgLT0gb3RoZXJzU3RyZW5ndGggKiB2eTtcbiAgICAgICAgICAgICAgICBhY2NNYXBbaWRdLnogLT0gb3RoZXJzU3RyZW5ndGggKiB2ejtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgdmVsb2NpdGllcyBmb3Igbm9kZXMuXG4gICAgICogQHBhcmFtIGNhbGNHcmFwaCBjYWxjdWxhdGlvbiBncmFwaFxuICAgICAqIEBwYXJhbSBhY2NNYXAgYWNjZWxlcmF0aW9uIG1hcFxuICAgICAqIEBwYXJhbSB2ZWxNYXAgdmVsb2NpdHkgbWFwXG4gICAgICogQHBhcmFtIG9wdGlvbnMgZm9ybWF0dGVkIGxheW91dCBvcHRpb25zXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICB1cGRhdGVWZWxvY2l0eShjYWxjR3JhcGgsIGFjY01hcCwgdmVsTWFwLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgZGFtcGluZywgbWF4U3BlZWQsIGludGVydmFsLCBkaW1lbnNpb25zIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBjYWxjTm9kZXMgPSBjYWxjR3JhcGguZ2V0QWxsTm9kZXMoKTtcbiAgICAgICAgaWYgKCEoY2FsY05vZGVzID09PSBudWxsIHx8IGNhbGNOb2RlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsY05vZGVzLmxlbmd0aCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhbGNOb2Rlcy5mb3JFYWNoKChjYWxjTm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBpZCB9ID0gY2FsY05vZGU7XG4gICAgICAgICAgICBsZXQgdnggPSAodmVsTWFwW2lkXS54ICsgYWNjTWFwW2lkXS54ICogaW50ZXJ2YWwpICogZGFtcGluZyB8fCAwLjAxO1xuICAgICAgICAgICAgbGV0IHZ5ID0gKHZlbE1hcFtpZF0ueSArIGFjY01hcFtpZF0ueSAqIGludGVydmFsKSAqIGRhbXBpbmcgfHwgMC4wMTtcbiAgICAgICAgICAgIGxldCB2eiA9IGRpbWVuc2lvbnMgPT09IDNcbiAgICAgICAgICAgICAgICA/ICh2ZWxNYXBbaWRdLnogKyBhY2NNYXBbaWRdLnogKiBpbnRlcnZhbCkgKiBkYW1waW5nIHx8IDAuMDFcbiAgICAgICAgICAgICAgICA6IDAuMDtcbiAgICAgICAgICAgIGNvbnN0IHZMZW5ndGggPSBNYXRoLnNxcnQodnggKiB2eCArIHZ5ICogdnkgKyB2eiAqIHZ6KTtcbiAgICAgICAgICAgIGlmICh2TGVuZ3RoID4gbWF4U3BlZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbTIgPSBtYXhTcGVlZCAvIHZMZW5ndGg7XG4gICAgICAgICAgICAgICAgdnggPSBwYXJhbTIgKiB2eDtcbiAgICAgICAgICAgICAgICB2eSA9IHBhcmFtMiAqIHZ5O1xuICAgICAgICAgICAgICAgIHZ6ID0gcGFyYW0yICogdno7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2ZWxNYXBbaWRdID0ge1xuICAgICAgICAgICAgICAgIHg6IHZ4LFxuICAgICAgICAgICAgICAgIHk6IHZ5LFxuICAgICAgICAgICAgICAgIHo6IHZ6LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBub2RlcycgcG9zaXRpb25zLlxuICAgICAqIEBwYXJhbSBncmFwaCBvcmlnaW4gZ3JhcGhcbiAgICAgKiBAcGFyYW0gY2FsY0dyYXBoIGNhbGN1bGF0aXRpb24gZ3JhcGhcbiAgICAgKiBAcGFyYW0gdmVsTWFwIHZlbG9jaXR5IG1hcFxuICAgICAqIEBwYXJhbSBvcHRpb25zIGZvcm1hdHRlZCBsYXlvdSBvcHRpb25zXG4gICAgICogQHJldHVybnNcbiAgICAgKi9cbiAgICB1cGRhdGVQb3NpdGlvbihncmFwaCwgY2FsY0dyYXBoLCB2ZWxNYXAsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBkaXN0YW5jZVRocmVzaG9sZE1vZGUsIGludGVydmFsLCBkaW1lbnNpb25zIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBjYWxjTm9kZXMgPSBjYWxjR3JhcGguZ2V0QWxsTm9kZXMoKTtcbiAgICAgICAgaWYgKCEoY2FsY05vZGVzID09PSBudWxsIHx8IGNhbGNOb2RlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsY05vZGVzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRoaXMuanVkZ2luZ0Rpc3RhbmNlID0gMDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgaWYgKGRpc3RhbmNlVGhyZXNob2xkTW9kZSA9PT0gJ21heCcpXG4gICAgICAgICAgICB0aGlzLmp1ZGdpbmdEaXN0YW5jZSA9IC1JbmZpbml0eTtcbiAgICAgICAgZWxzZSBpZiAoZGlzdGFuY2VUaHJlc2hvbGRNb2RlID09PSAnbWluJylcbiAgICAgICAgICAgIHRoaXMuanVkZ2luZ0Rpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIGNhbGNOb2Rlcy5mb3JFYWNoKChjYWxjTm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBpZCB9ID0gY2FsY05vZGU7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gZ3JhcGguZ2V0Tm9kZShpZCk7XG4gICAgICAgICAgICBpZiAoaXNOdW1iZXIobm9kZS5kYXRhLmZ4KSAmJiBpc051bWJlcihub2RlLmRhdGEuZnkpKSB7XG4gICAgICAgICAgICAgICAgY2FsY0dyYXBoLm1lcmdlTm9kZURhdGEoaWQsIHtcbiAgICAgICAgICAgICAgICAgICAgeDogbm9kZS5kYXRhLmZ4LFxuICAgICAgICAgICAgICAgICAgICB5OiBub2RlLmRhdGEuZnksXG4gICAgICAgICAgICAgICAgICAgIHo6IGRpbWVuc2lvbnMgPT09IDMgPyBub2RlLmRhdGEuZnogOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGlzdFggPSB2ZWxNYXBbaWRdLnggKiBpbnRlcnZhbDtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RZID0gdmVsTWFwW2lkXS55ICogaW50ZXJ2YWw7XG4gICAgICAgICAgICBjb25zdCBkaXN0WiA9IGRpbWVuc2lvbnMgPT09IDMgPyB2ZWxNYXBbaWRdLnogKiBpbnRlcnZhbCA6IDAuMDtcbiAgICAgICAgICAgIGNhbGNHcmFwaC5tZXJnZU5vZGVEYXRhKGlkLCB7XG4gICAgICAgICAgICAgICAgeDogY2FsY05vZGUuZGF0YS54ICsgZGlzdFgsXG4gICAgICAgICAgICAgICAgeTogY2FsY05vZGUuZGF0YS55ICsgZGlzdFksXG4gICAgICAgICAgICAgICAgejogY2FsY05vZGUuZGF0YS56ICsgZGlzdFosXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlTWFnbml0dWRlID0gTWF0aC5zcXJ0KGRpc3RYICogZGlzdFggKyBkaXN0WSAqIGRpc3RZICsgZGlzdFogKiBkaXN0Wik7XG4gICAgICAgICAgICBzd2l0Y2ggKGRpc3RhbmNlVGhyZXNob2xkTW9kZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ21heCc6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmp1ZGdpbmdEaXN0YW5jZSA8IGRpc3RhbmNlTWFnbml0dWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmp1ZGdpbmdEaXN0YW5jZSA9IGRpc3RhbmNlTWFnbml0dWRlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ21pbic6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmp1ZGdpbmdEaXN0YW5jZSA+IGRpc3RhbmNlTWFnbml0dWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmp1ZGdpbmdEaXN0YW5jZSA9IGRpc3RhbmNlTWFnbml0dWRlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHN1bSA9IHN1bSArIGRpc3RhbmNlTWFnbml0dWRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghZGlzdGFuY2VUaHJlc2hvbGRNb2RlIHx8IGRpc3RhbmNlVGhyZXNob2xkTW9kZSA9PT0gJ21lYW4nKSB7XG4gICAgICAgICAgICB0aGlzLmp1ZGdpbmdEaXN0YW5jZSA9IHN1bSAvIGNhbGNOb2Rlcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEdyb3VwIHRoZSBsZWFmIG5vZGVzIGFjY29yZGluZyB0byBub2RlQ2x1c3RlckJ5IGZpZWxkLlxuICogQHBhcmFtIGNhbGNHcmFwaCBjYWxjdWxhdGlvbiBncmFwaFxuICogQHBhcmFtIG5vZGVDbHVzdGVyQnkgdGhlIGZpZWxkIG5hbWUgaW4gbm9kZS5kYXRhIHRvIGRpdGluZ3Vpc2ggZGlmZmVyZW50IG5vZGUgY2x1c3RlcnNcbiAqIEByZXR1cm5zIHJlbGF0ZWQgc2FtZSBncm91cCBsZWFmIG5vZGVzIGZvciBlYWNoIGxlYWYgbm9kZVxuICovXG5jb25zdCBnZXRTYW1lVHlwZUxlYWZNYXAgPSAoY2FsY0dyYXBoLCBub2RlQ2x1c3RlckJ5KSA9PiB7XG4gICAgY29uc3QgY2FsY05vZGVzID0gY2FsY0dyYXBoLmdldEFsbE5vZGVzKCk7XG4gICAgaWYgKCEoY2FsY05vZGVzID09PSBudWxsIHx8IGNhbGNOb2RlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsY05vZGVzLmxlbmd0aCkpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICBjb25zdCBzYW1lVHlwZUxlYWZNYXAgPSB7fTtcbiAgICBjYWxjTm9kZXMuZm9yRWFjaCgobm9kZSwgaSkgPT4ge1xuICAgICAgICBjb25zdCBkZWdyZWUgPSBjYWxjR3JhcGguZ2V0RGVncmVlKG5vZGUuaWQsICdib3RoJyk7XG4gICAgICAgIGlmIChkZWdyZWUgPT09IDEpIHtcbiAgICAgICAgICAgIHNhbWVUeXBlTGVhZk1hcFtub2RlLmlkXSA9IGdldENvcmVOb2RlQW5kU2libGluZ0xlYXZlcyhjYWxjR3JhcGgsICdsZWFmJywgbm9kZSwgbm9kZUNsdXN0ZXJCeSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gc2FtZVR5cGVMZWFmTWFwO1xufTtcbi8qKlxuICogRmluZCB0aGUgc3VjY2Vzc29yIG9yIHByZWRlY2Vzc29yIG9mIG5vZGUgYXMgY29yZU5vZGUsIHRoZSBzaWJsaW5nIGxlYWYgbm9kZXNcbiAqIEBwYXJhbSBjYWxjR3JhcGggY2FsY3VsYXRpb24gZ3JhcGhcbiAqIEBwYXJhbSB0eXBlICgnYWxsJykgZmlsdGVyIG91dCB0aGUgbm90LXNhbWUtY2x1c3RlciBub2RlcywgKCdsZWFmJykgb3IgZmlsdGVyIG91dCB0aGUgbm90LWxlYWYgbm9kZXMgaW4gdGhlIHNhbWUgdGltZVxuICogQHBhcmFtIG5vZGUgdGhlIHRhcmdldCBub2RlXG4gKiBAcGFyYW0gbm9kZUNsdXN0ZXJCeSB0aGUgZmllbGQgbmFtZSBpbiBub2RlLmRhdGEgdG8gZGl0aW5ndWlzaCBkaWZmZXJlbnQgbm9kZSBjbHVzdGVyc1xuICogQHJldHVybnMgY29yZU5vZGUsIHNpYmxpbmcgbGVhZiBub2RlcywgYW5kIGdyb3VwZWQgc2libGluZyBsZWFmIG5vZGVzXG4gKi9cbmNvbnN0IGdldENvcmVOb2RlQW5kU2libGluZ0xlYXZlcyA9IChjYWxjR3JhcGgsIHR5cGUsIG5vZGUsIG5vZGVDbHVzdGVyQnkpID0+IHtcbiAgICBjb25zdCBpbkRlZ3JlZSA9IGNhbGNHcmFwaC5nZXREZWdyZWUobm9kZS5pZCwgJ2luJyk7XG4gICAgY29uc3Qgb3V0RGVncmVlID0gY2FsY0dyYXBoLmdldERlZ3JlZShub2RlLmlkLCAnb3V0Jyk7XG4gICAgLy8gbm9kZSBpcyBub3QgYSBsZWFmLCBjb3JlTm9kZSBpcyBpdHNlbGYsIHNpYmxpbmdMZWF2ZXMgaXMgZW1wdHlcbiAgICBsZXQgY29yZU5vZGUgPSBub2RlO1xuICAgIGxldCBzaWJsaW5nTGVhdmVzID0gW107XG4gICAgaWYgKGluRGVncmVlID09PSAwKSB7XG4gICAgICAgIC8vIG5vZGUgaXMgYSBsZWFmIG5vZGUgd2l0aG91dCBvdXQgZWRnZXMsIGl0cyByZWxhdGVkKHN1Y2Nlc3Nvcikgbm9kZSBpcyBjb3JlTm9kZSwgc2libGluZ0xlYXZlcyBpcyB0aGUgbmVpZ2hib3JzIG9mIGl0cyByZWxhdGVkIG5vZGVcbiAgICAgICAgY29yZU5vZGUgPSBjYWxjR3JhcGguZ2V0U3VjY2Vzc29ycyhub2RlLmlkKVswXTtcbiAgICAgICAgc2libGluZ0xlYXZlcyA9IGNhbGNHcmFwaC5nZXROZWlnaGJvcnMoY29yZU5vZGUuaWQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChvdXREZWdyZWUgPT09IDApIHtcbiAgICAgICAgLy8gbm9kZSBpcyBhIGxlYWYgbm9kZSB3aXRob3V0IGluIGVkZ2VzLCBpdHMgcmVsYXRlZChwcmVkZWNlc3Nvcikgbm9kZSBpcyBjb3JlTm9kZSwgc2libGluZ0xlYXZlcyBpcyB0aGUgbmVpZ2hib3JzIG9mIGl0cyByZWxhdGVkIG5vZGVcbiAgICAgICAgY29yZU5vZGUgPSBjYWxjR3JhcGguZ2V0UHJlZGVjZXNzb3JzKG5vZGUuaWQpWzBdO1xuICAgICAgICBzaWJsaW5nTGVhdmVzID0gY2FsY0dyYXBoLmdldE5laWdoYm9ycyhjb3JlTm9kZS5pZCk7XG4gICAgfVxuICAgIC8vIHNpYmxpbmdMZWF2ZXMgYXJlIGxlYWYgbm9kZXNcbiAgICBzaWJsaW5nTGVhdmVzID0gc2libGluZ0xlYXZlcy5maWx0ZXIoKG5vZGUpID0+IGNhbGNHcmFwaC5nZXREZWdyZWUobm9kZS5pZCwgJ2luJykgPT09IDAgfHxcbiAgICAgICAgY2FsY0dyYXBoLmdldERlZ3JlZShub2RlLmlkLCAnb3V0JykgPT09IDApO1xuICAgIGNvbnN0IHNhbWVUeXBlTGVhdmVzID0gZ2V0U2FtZVR5cGVOb2RlcyhjYWxjR3JhcGgsIHR5cGUsIG5vZGVDbHVzdGVyQnksIG5vZGUsIHNpYmxpbmdMZWF2ZXMpO1xuICAgIHJldHVybiB7IGNvcmVOb2RlLCBzaWJsaW5nTGVhdmVzLCBzYW1lVHlwZUxlYXZlcyB9O1xufTtcbi8qKlxuICogRmluZCB0aGUgc2FtZSB0eXBlIChhY2NvcmRpbmcgdG8gbm9kZUNsdXN0ZXJCeSBmaWVsZCkgb2Ygbm9kZSBpbiByZWxhdGl2ZU5vZGVzLlxuICogQHBhcmFtIGNhbGNHcmFwaCBjYWxjdWxhdGlvbiBncmFwaFxuICogQHBhcmFtIHR5cGUgKCdhbGwnKSBmaWx0ZXIgb3V0IHRoZSBub3Qtc2FtZS1jbHVzdGVyIG5vZGVzLCAoJ2xlYWYnKSBvciBmaWx0ZXIgb3V0IHRoZSBub3QtbGVhZiBub2RlcyBpbiB0aGUgc2FtZSB0aW1lXG4gKiBAcGFyYW0gbm9kZUNsdXN0ZXJCeSB0aGUgZmllbGQgbmFtZSBpbiBub2RlLmRhdGEgdG8gZGl0aW5ndWlzaCBkaWZmZXJlbnQgbm9kZSBjbHVzdGVyc1xuICogQHBhcmFtIG5vZGUgdGhlIHRhcmdldCBub2RlXG4gKiBAcGFyYW0gcmVsYXRpdmVOb2RlcyBub2RlJ3MgcmVsYXRlZCBuZG9lcyB0byBiZSBmaWx0ZXJlZFxuICogQHJldHVybnMgcmVsYXRlZCBub2RlcyB0aGF0IG1lZXQgdGhlIGZpbHRlcmluZyBjb25kaXRpb25zXG4gKi9cbmNvbnN0IGdldFNhbWVUeXBlTm9kZXMgPSAoY2FsY0dyYXBoLCB0eXBlLCBub2RlQ2x1c3RlckJ5LCBub2RlLCByZWxhdGl2ZU5vZGVzKSA9PiB7XG4gICAgY29uc3QgdHlwZU5hbWUgPSBub2RlLmRhdGFbbm9kZUNsdXN0ZXJCeV0gfHwgJyc7XG4gICAgbGV0IHNhbWVUeXBlTm9kZXMgPSAocmVsYXRpdmVOb2RlcyA9PT0gbnVsbCB8fCByZWxhdGl2ZU5vZGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWxhdGl2ZU5vZGVzLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5kYXRhW25vZGVDbHVzdGVyQnldID09PSB0eXBlTmFtZSkpIHx8XG4gICAgICAgIFtdO1xuICAgIGlmICh0eXBlID09PSAnbGVhZicpIHtcbiAgICAgICAgc2FtZVR5cGVOb2RlcyA9IHNhbWVUeXBlTm9kZXMuZmlsdGVyKChpdGVtKSA9PiBjYWxjR3JhcGguZ2V0RGVncmVlKGl0ZW0uaWQsICdpbicpID09PSAwIHx8XG4gICAgICAgICAgICBjYWxjR3JhcGguZ2V0RGVncmVlKGl0ZW0uaWQsICdvdXQnKSA9PT0gMCk7XG4gICAgfVxuICAgIHJldHVybiBzYW1lVHlwZU5vZGVzO1xufTtcbi8qKlxuICogR2V0IHRoZSBhdmVyYWdlIHBvc2l0aW9uIG9mIG5vZGVzLlxuICogQHBhcmFtIG5vZGVzIG5vZGVzIHNldFxuICogQHJldHVybnMgYXZlcmFnZSBwcHNpdGlvblxuICovXG5jb25zdCBnZXRBdmdOb2RlUG9zaXRpb24gPSAobm9kZXMpID0+IHtcbiAgICBjb25zdCB0b3RhbE5vZGVzID0geyB4OiAwLCB5OiAwIH07XG4gICAgbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IG5vZGUuZGF0YTtcbiAgICAgICAgdG90YWxOb2Rlcy54ICs9IHggfHwgMDtcbiAgICAgICAgdG90YWxOb2Rlcy55ICs9IHkgfHwgMDtcbiAgICB9KTtcbiAgICAvLyDojrflj5blnYflgLzlkJHph49cbiAgICBjb25zdCBsZW5ndGggPSBub2Rlcy5sZW5ndGggfHwgMTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB0b3RhbE5vZGVzLnggLyBsZW5ndGgsXG4gICAgICAgIHk6IHRvdGFsTm9kZXMueSAvIGxlbmd0aCxcbiAgICB9O1xufTtcbi8qKlxuICogRm9ybWF0IHRoZSBvdXRwdXQgbm9kZXMgZnJvbSBDYWxjTm9kZVtdLlxuICogQHBhcmFtIGdyYXBoIG9yaWdpbiBncmFwaFxuICogQHBhcmFtIGxheW91dE5vZGVzIGNhbGN1bGF0aW9uIG5vZGVzXG4gKiBAcmV0dXJucyBvdXRwdXQgbm9kZXNcbiAqL1xuY29uc3QgZm9ybWF0T3V0Tm9kZXMgPSAoZ3JhcGgsIGxheW91dE5vZGVzKSA9PiBsYXlvdXROb2Rlcy5tYXAoKGNhbGNOb2RlKSA9PiB7XG4gICAgY29uc3QgeyBpZCwgZGF0YSB9ID0gY2FsY05vZGU7XG4gICAgY29uc3Qgbm9kZSA9IGdyYXBoLmdldE5vZGUoaWQpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG5vZGUpLCB7IGRhdGE6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbm9kZS5kYXRhKSwgeyB4OiBkYXRhLngsIHk6IGRhdGEueSwgejogZGF0YS56IH0pIH0pO1xufSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IEdyYXBoIGFzIElHcmFwaCB9IGZyb20gJ0BhbnR2L2dyYXBobGliJztcbmltcG9ydCB7IGlzTnVtYmVyIH0gZnJvbSAnQGFudHYvdXRpbCc7XG5pbXBvcnQgeyBjbG9uZUZvcm1hdERhdGEgfSBmcm9tICcuL3V0aWwnO1xuY29uc3QgREVGQVVMVFNfTEFZT1VUX09QVElPTlMgPSB7XG4gICAgbWF4SXRlcmF0aW9uOiAxMDAwLFxuICAgIGdyYXZpdHk6IDEwLFxuICAgIHNwZWVkOiA1LFxuICAgIGNsdXN0ZXJpbmc6IGZhbHNlLFxuICAgIGNsdXN0ZXJHcmF2aXR5OiAxMCxcbiAgICB3aWR0aDogMzAwLFxuICAgIGhlaWdodDogMzAwLFxuICAgIG5vZGVDbHVzdGVyQnk6ICdjbHVzdGVyJyxcbn07XG5jb25zdCBTUEVFRF9ESVZJU09SID0gODAwO1xuLyoqXG4gKiA8emgvPiBGcnVjaHRlcm1hbiDlipvlr7zlkJHluIPlsYBcbiAqXG4gKiA8ZW4vPiBGcnVjaHRlcm1hbiBmb3JjZS1kaXJlY3RlZCBsYXlvdXRcbiAqL1xuZXhwb3J0IGNsYXNzIEZydWNodGVybWFuTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5pZCA9ICdmcnVjaHRlcm1hbic7XG4gICAgICAgIHRoaXMudGltZUludGVydmFsID0gMDtcbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVFNfTEFZT1VUX09QVElPTlMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBwb3NpdGlvbnMgb2Ygbm9kZXMgYW5kIGVkZ2VzKGlmIG5lZWRlZCkuXG4gICAgICovXG4gICAgZXhlY3V0ZShncmFwaCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJpY0ZydWNodGVybWFuTGF5b3V0KGZhbHNlLCBncmFwaCwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUbyBkaXJlY3RseSBhc3NpZ24gdGhlIHBvc2l0aW9ucyB0byB0aGUgbm9kZXMuXG4gICAgICovXG4gICAgYXNzaWduKGdyYXBoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdlbmVyaWNGcnVjaHRlcm1hbkxheW91dCh0cnVlLCBncmFwaCwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wIHNpbXVsYXRpb24gaW1tZWRpYXRlbHkuXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMudGltZUludGVydmFsICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVJbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hbnVhbGx5IHN0ZXBzIHRoZSBzaW11bGF0aW9uIGJ5IHRoZSBzcGVjaWZpZWQgbnVtYmVyIG9mIGl0ZXJhdGlvbnMuXG4gICAgICogQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZDMvZDMtZm9yY2Ujc2ltdWxhdGlvbl90aWNrXG4gICAgICovXG4gICAgdGljayhpdGVyYXRpb25zID0gdGhpcy5vcHRpb25zLm1heEl0ZXJhdGlvbiB8fCAxKSB7XG4gICAgICAgIGlmICh0aGlzLmxhc3RSZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhc3RSZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMucnVuT25lU3RlcCh0aGlzLmxhc3RHcmFwaCwgdGhpcy5sYXN0Q2x1c3Rlck1hcCwgdGhpcy5sYXN0T3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgbm9kZXM6IHRoaXMubGFzdExheW91dE5vZGVzLFxuICAgICAgICAgICAgZWRnZXM6IHRoaXMubGFzdExheW91dEVkZ2VzLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5sYXN0QXNzaWduKSB7XG4gICAgICAgICAgICByZXN1bHQubm9kZXMuZm9yRWFjaCgobm9kZSkgPT4gdGhpcy5sYXN0R3JhcGgubWVyZ2VOb2RlRGF0YShub2RlLmlkLCB7XG4gICAgICAgICAgICAgICAgeDogbm9kZS5kYXRhLngsXG4gICAgICAgICAgICAgICAgeTogbm9kZS5kYXRhLnksXG4gICAgICAgICAgICAgICAgejogdGhpcy5vcHRpb25zLmRpbWVuc2lvbnMgPT09IDMgPyBub2RlLmRhdGEueiA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBnZW5lcmljRnJ1Y2h0ZXJtYW5MYXlvdXQoYXNzaWduLCBncmFwaCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucnVubmluZylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBmb3JtYXR0ZWRPcHRpb25zID0gdGhpcy5mb3JtYXRPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgeyBkaW1lbnNpb25zLCB3aWR0aCwgaGVpZ2h0LCBjZW50ZXIsIGNsdXN0ZXJpbmcsIG5vZGVDbHVzdGVyQnksIG1heEl0ZXJhdGlvbiwgb25UaWNrLCB9ID0gZm9ybWF0dGVkT3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gZ3JhcGguZ2V0QWxsTm9kZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGVkZ2VzID0gZ3JhcGguZ2V0QWxsRWRnZXMoKTtcbiAgICAgICAgICAgIGlmICghKG5vZGVzID09PSBudWxsIHx8IG5vZGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2Rlcy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geyBub2RlczogW10sIGVkZ2VzIH07XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0UmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFzc2lnbikge1xuICAgICAgICAgICAgICAgICAgICBncmFwaC5tZXJnZU5vZGVEYXRhKG5vZGVzWzBdLmlkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBjZW50ZXJbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBjZW50ZXJbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB6OiBkaW1lbnNpb25zID09PSAzID8gY2VudGVyWzJdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgICAgICBub2RlczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBub2Rlc1swXSksIHsgZGF0YTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBub2Rlc1swXS5kYXRhKSwgeyB4OiBjZW50ZXJbMF0sIHk6IGNlbnRlclsxXSwgejogZGltZW5zaW9ucyA9PT0gMyA/IGNlbnRlclsyXSA6IHVuZGVmaW5lZCB9KSB9KSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgZWRnZXMsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RSZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxheW91dE5vZGVzID0gbm9kZXMubWFwKChub2RlKSA9PiBjbG9uZUZvcm1hdERhdGEobm9kZSwgW3dpZHRoLCBoZWlnaHRdKSk7XG4gICAgICAgICAgICBjb25zdCBjYWxjR3JhcGggPSBuZXcgSUdyYXBoKHtcbiAgICAgICAgICAgICAgICBub2RlczogbGF5b3V0Tm9kZXMsXG4gICAgICAgICAgICAgICAgZWRnZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGNsdXN0ZXJpbmcgaW5mb1xuICAgICAgICAgICAgY29uc3QgY2x1c3Rlck1hcCA9IHt9O1xuICAgICAgICAgICAgaWYgKGNsdXN0ZXJpbmcpIHtcbiAgICAgICAgICAgICAgICBsYXlvdXROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNsdXN0ZXJWYWx1ZSA9IG5vZGUuZGF0YVtub2RlQ2x1c3RlckJ5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjbHVzdGVyTWFwW2NsdXN0ZXJWYWx1ZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJNYXBbY2x1c3RlclZhbHVlXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBjbHVzdGVyVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3g6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3k6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVc2UgdGhlbSBsYXRlciBpbiBgdGlja2AuXG4gICAgICAgICAgICB0aGlzLmxhc3RMYXlvdXROb2RlcyA9IGxheW91dE5vZGVzO1xuICAgICAgICAgICAgdGhpcy5sYXN0TGF5b3V0RWRnZXMgPSBlZGdlcztcbiAgICAgICAgICAgIHRoaXMubGFzdEFzc2lnbiA9IGFzc2lnbjtcbiAgICAgICAgICAgIHRoaXMubGFzdEdyYXBoID0gY2FsY0dyYXBoO1xuICAgICAgICAgICAgdGhpcy5sYXN0T3B0aW9ucyA9IGZvcm1hdHRlZE9wdGlvbnM7XG4gICAgICAgICAgICB0aGlzLmxhc3RDbHVzdGVyTWFwID0gY2x1c3Rlck1hcDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsZXQgaXRlciA9IDA7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBpbnRlcnZhbCBmb3IgcmVuZGVyIHRoZSByZXN1bHQgYWZ0ZXIgZWFjaCBpdGVyYXRpb25cbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVJbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5ydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgbm9kZXM6IGxheW91dE5vZGVzLCBlZGdlcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJ1bk9uZVN0ZXAoY2FsY0dyYXBoLCBjbHVzdGVyTWFwLCBmb3JtYXR0ZWRPcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFzc2lnbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5b3V0Tm9kZXMuZm9yRWFjaCgoeyBpZCwgZGF0YSB9KSA9PiBncmFwaC5tZXJnZU5vZGVEYXRhKGlkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogZGF0YS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGRhdGEueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB6OiBkaW1lbnNpb25zID09PSAzID8gZGF0YS56IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9uVGljayA9PT0gbnVsbCB8fCBvblRpY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uVGljayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlczogbGF5b3V0Tm9kZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBlZGdlcyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXIrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZXIgPj0gbWF4SXRlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLnRpbWVJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHsgbm9kZXM6IGxheW91dE5vZGVzLCBlZGdlcyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZvcm1hdE9wdGlvbnMob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCB7IGNsdXN0ZXJpbmcsIG5vZGVDbHVzdGVyQnkgfSA9IG1lcmdlZE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IHsgY2VudGVyOiBwcm9wc0NlbnRlciwgd2lkdGg6IHByb3BzV2lkdGgsIGhlaWdodDogcHJvcHNIZWlnaHQsIH0gPSBtZXJnZWRPcHRpb25zO1xuICAgICAgICBtZXJnZWRPcHRpb25zLndpZHRoID1cbiAgICAgICAgICAgICFwcm9wc1dpZHRoICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgPyB3aW5kb3cuaW5uZXJXaWR0aFxuICAgICAgICAgICAgICAgIDogcHJvcHNXaWR0aDtcbiAgICAgICAgbWVyZ2VkT3B0aW9ucy5oZWlnaHQgPVxuICAgICAgICAgICAgIXByb3BzSGVpZ2h0ICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgPyB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICAgICAgICAgICAgICA6IHByb3BzSGVpZ2h0O1xuICAgICAgICBtZXJnZWRPcHRpb25zLmNlbnRlciA9ICFwcm9wc0NlbnRlclxuICAgICAgICAgICAgPyBbbWVyZ2VkT3B0aW9ucy53aWR0aCAvIDIsIG1lcmdlZE9wdGlvbnMuaGVpZ2h0IC8gMl1cbiAgICAgICAgICAgIDogcHJvcHNDZW50ZXI7XG4gICAgICAgIG1lcmdlZE9wdGlvbnMuY2x1c3RlcmluZyA9IGNsdXN0ZXJpbmcgJiYgISFub2RlQ2x1c3RlckJ5O1xuICAgICAgICByZXR1cm4gbWVyZ2VkT3B0aW9ucztcbiAgICB9XG4gICAgcnVuT25lU3RlcChjYWxjR3JhcGgsIGNsdXN0ZXJNYXAsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBkaW1lbnNpb25zLCBoZWlnaHQsIHdpZHRoLCBncmF2aXR5LCBjZW50ZXIsIHNwZWVkLCBjbHVzdGVyaW5nLCBub2RlQ2x1c3RlckJ5LCBjbHVzdGVyR3Jhdml0eTogcHJvcHNDbHVzdGVyR3Jhdml0eSwgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGFyZWEgPSBoZWlnaHQgKiB3aWR0aDtcbiAgICAgICAgY29uc3QgbWF4RGlzcGxhY2UgPSBNYXRoLnNxcnQoYXJlYSkgLyAxMDtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBjYWxjR3JhcGguZ2V0QWxsTm9kZXMoKTtcbiAgICAgICAgY29uc3QgazIgPSBhcmVhIC8gKG5vZGVzLmxlbmd0aCArIDEpO1xuICAgICAgICBjb25zdCBrID0gTWF0aC5zcXJ0KGsyKTtcbiAgICAgICAgY29uc3QgZGlzcGxhY2VtZW50cyA9IHt9O1xuICAgICAgICB0aGlzLmFwcGx5Q2FsY3VsYXRlKGNhbGNHcmFwaCwgZGlzcGxhY2VtZW50cywgaywgazIpO1xuICAgICAgICAvLyBncmF2aXR5IGZvciBjbHVzdGVyc1xuICAgICAgICBpZiAoY2x1c3RlcmluZykge1xuICAgICAgICAgICAgLy8gcmVzZXQgdGhlIGNsdXN0ZXJpbmcgY2VudGVyc1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY2x1c3Rlck1hcCkge1xuICAgICAgICAgICAgICAgIGNsdXN0ZXJNYXBba2V5XS5jeCA9IDA7XG4gICAgICAgICAgICAgICAgY2x1c3Rlck1hcFtrZXldLmN5ID0gMDtcbiAgICAgICAgICAgICAgICBjbHVzdGVyTWFwW2tleV0uY291bnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmUtY29tcHV0ZSBjbHVzdGVyaW5nIGNlbnRlcnNcbiAgICAgICAgICAgIG5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGRhdGEgfSA9IG5vZGU7IC8vIG5vZGUgaXMgb25lIG9mIGxheW91dE5vZGVzLCB3aGljaCBpcyBmb3JtYXR0ZWQgYW5kIGRhdGEgZmllbGQgZXhpc3RzXG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IGNsdXN0ZXJNYXBbZGF0YVtub2RlQ2x1c3RlckJ5XV07XG4gICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGRhdGEueCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYy5jeCArPSBkYXRhLng7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc051bWJlcihkYXRhLnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGMuY3kgKz0gZGF0YS55O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjLmNvdW50Kys7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGNsdXN0ZXJNYXApIHtcbiAgICAgICAgICAgICAgICBjbHVzdGVyTWFwW2tleV0uY3ggLz0gY2x1c3Rlck1hcFtrZXldLmNvdW50O1xuICAgICAgICAgICAgICAgIGNsdXN0ZXJNYXBba2V5XS5jeSAvPSBjbHVzdGVyTWFwW2tleV0uY291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjb21wdXRlIHRoZSBjbHVzdGVyIGdyYXZpdHkgZm9yY2VzXG4gICAgICAgICAgICBjb25zdCBjbHVzdGVyR3Jhdml0eSA9IChwcm9wc0NsdXN0ZXJHcmF2aXR5IHx8IGdyYXZpdHkpO1xuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaCgobm9kZSwgaikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaWQsIGRhdGEgfSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKCFpc051bWJlcihkYXRhLngpIHx8ICFpc051bWJlcihkYXRhLnkpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IGNsdXN0ZXJNYXBbZGF0YVtub2RlQ2x1c3RlckJ5XV07XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzdExlbmd0aCA9IE1hdGguc3FydCgoZGF0YS54IC0gYy5jeCkgKiAoZGF0YS54IC0gYy5jeCkgKyAoZGF0YS55IC0gYy5jeSkgKiAoZGF0YS55IC0gYy5jeSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGdyYXZpdHlGb3JjZSA9IGsgKiBjbHVzdGVyR3Jhdml0eTtcbiAgICAgICAgICAgICAgICBkaXNwbGFjZW1lbnRzW2lkXS54IC09IChncmF2aXR5Rm9yY2UgKiAoZGF0YS54IC0gYy5jeCkpIC8gZGlzdExlbmd0aDtcbiAgICAgICAgICAgICAgICBkaXNwbGFjZW1lbnRzW2lkXS55IC09IChncmF2aXR5Rm9yY2UgKiAoZGF0YS55IC0gYy5jeSkpIC8gZGlzdExlbmd0aDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdyYXZpdHlcbiAgICAgICAgbm9kZXMuZm9yRWFjaCgobm9kZSwgaikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBpZCwgZGF0YSB9ID0gbm9kZTtcbiAgICAgICAgICAgIGlmICghaXNOdW1iZXIoZGF0YS54KSB8fCAhaXNOdW1iZXIoZGF0YS55KSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBncmF2aXR5Rm9yY2UgPSAwLjAxICogayAqIGdyYXZpdHk7XG4gICAgICAgICAgICBkaXNwbGFjZW1lbnRzW2lkXS54IC09IGdyYXZpdHlGb3JjZSAqIChkYXRhLnggLSBjZW50ZXJbMF0pO1xuICAgICAgICAgICAgZGlzcGxhY2VtZW50c1tpZF0ueSAtPSBncmF2aXR5Rm9yY2UgKiAoZGF0YS55IC0gY2VudGVyWzFdKTtcbiAgICAgICAgICAgIGlmIChkaW1lbnNpb25zID09PSAzKSB7XG4gICAgICAgICAgICAgICAgZGlzcGxhY2VtZW50c1tpZF0ueiAtPSBncmF2aXR5Rm9yY2UgKiAoZGF0YS56IC0gY2VudGVyWzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIG1vdmVcbiAgICAgICAgbm9kZXMuZm9yRWFjaCgobm9kZSwgaikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBpZCwgZGF0YSB9ID0gbm9kZTtcbiAgICAgICAgICAgIGlmIChpc051bWJlcihkYXRhLmZ4KSAmJiBpc051bWJlcihkYXRhLmZ5KSkge1xuICAgICAgICAgICAgICAgIGRhdGEueCA9IGRhdGEuZng7XG4gICAgICAgICAgICAgICAgZGF0YS55ID0gZGF0YS5meTtcbiAgICAgICAgICAgICAgICBpZiAoZGltZW5zaW9ucyA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnogPSBkYXRhLmZ6O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzTnVtYmVyKGRhdGEueCkgfHwgIWlzTnVtYmVyKGRhdGEueSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgZGlzdExlbmd0aCA9IE1hdGguc3FydChkaXNwbGFjZW1lbnRzW2lkXS54ICogZGlzcGxhY2VtZW50c1tpZF0ueCArXG4gICAgICAgICAgICAgICAgZGlzcGxhY2VtZW50c1tpZF0ueSAqIGRpc3BsYWNlbWVudHNbaWRdLnkgK1xuICAgICAgICAgICAgICAgIChkaW1lbnNpb25zID09PSAzID8gZGlzcGxhY2VtZW50c1tpZF0ueiAqIGRpc3BsYWNlbWVudHNbaWRdLnogOiAwKSk7XG4gICAgICAgICAgICBpZiAoZGlzdExlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAvLyAmJiAhbi5pc0ZpeGVkKClcbiAgICAgICAgICAgICAgICBjb25zdCBsaW1pdGVkRGlzdCA9IE1hdGgubWluKG1heERpc3BsYWNlICogKHNwZWVkIC8gU1BFRURfRElWSVNPUiksIGRpc3RMZW5ndGgpO1xuICAgICAgICAgICAgICAgIGNhbGNHcmFwaC5tZXJnZU5vZGVEYXRhKGlkLCB7XG4gICAgICAgICAgICAgICAgICAgIHg6IGRhdGEueCArIChkaXNwbGFjZW1lbnRzW2lkXS54IC8gZGlzdExlbmd0aCkgKiBsaW1pdGVkRGlzdCxcbiAgICAgICAgICAgICAgICAgICAgeTogZGF0YS55ICsgKGRpc3BsYWNlbWVudHNbaWRdLnkgLyBkaXN0TGVuZ3RoKSAqIGxpbWl0ZWREaXN0LFxuICAgICAgICAgICAgICAgICAgICB6OiBkaW1lbnNpb25zID09PSAzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGRhdGEueiArIChkaXNwbGFjZW1lbnRzW2lkXS56IC8gZGlzdExlbmd0aCkgKiBsaW1pdGVkRGlzdFxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhcHBseUNhbGN1bGF0ZShjYWxjR3JhcGgsIGRpc3BsYWNlbWVudHMsIGssIGsyKSB7XG4gICAgICAgIHRoaXMuY2FsUmVwdWxzaXZlKGNhbGNHcmFwaCwgZGlzcGxhY2VtZW50cywgazIpO1xuICAgICAgICB0aGlzLmNhbEF0dHJhY3RpdmUoY2FsY0dyYXBoLCBkaXNwbGFjZW1lbnRzLCBrKTtcbiAgICB9XG4gICAgY2FsUmVwdWxzaXZlKGNhbGNHcmFwaCwgZGlzcGxhY2VtZW50cywgazIpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBjYWxjR3JhcGguZ2V0QWxsTm9kZXMoKTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaCgoeyBkYXRhOiB2LCBpZDogdmlkIH0sIGkpID0+IHtcbiAgICAgICAgICAgIGRpc3BsYWNlbWVudHNbdmlkXSA9IHsgeDogMCwgeTogMCwgejogMCB9O1xuICAgICAgICAgICAgbm9kZXMuZm9yRWFjaCgoeyBkYXRhOiB1LCBpZDogdWlkIH0sIGopID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaSA8PSBqIHx8XG4gICAgICAgICAgICAgICAgICAgICFpc051bWJlcih2LngpIHx8XG4gICAgICAgICAgICAgICAgICAgICFpc051bWJlcih1LngpIHx8XG4gICAgICAgICAgICAgICAgICAgICFpc051bWJlcih2LnkpIHx8XG4gICAgICAgICAgICAgICAgICAgICFpc051bWJlcih1LnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHZlY1ggPSB2LnggLSB1Lng7XG4gICAgICAgICAgICAgICAgbGV0IHZlY1kgPSB2LnkgLSB1Lnk7XG4gICAgICAgICAgICAgICAgbGV0IHZlY1ogPSB0aGlzLm9wdGlvbnMuZGltZW5zaW9ucyA9PT0gMyA/IHYueiAtIHUueiA6IDA7XG4gICAgICAgICAgICAgICAgbGV0IGxlbmd0aFNxciA9IHZlY1ggKiB2ZWNYICsgdmVjWSAqIHZlY1kgKyB2ZWNaICogdmVjWjtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoU3FyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aFNxciA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHZlY1ggPSAwLjAxO1xuICAgICAgICAgICAgICAgICAgICB2ZWNZID0gMC4wMTtcbiAgICAgICAgICAgICAgICAgICAgdmVjWiA9IDAuMDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1vbiA9IGsyIC8gbGVuZ3RoU3FyO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpc3BYID0gdmVjWCAqIGNvbW1vbjtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXNwWSA9IHZlY1kgKiBjb21tb247XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzcFogPSB2ZWNaICogY29tbW9uO1xuICAgICAgICAgICAgICAgIGRpc3BsYWNlbWVudHNbdmlkXS54ICs9IGRpc3BYO1xuICAgICAgICAgICAgICAgIGRpc3BsYWNlbWVudHNbdmlkXS55ICs9IGRpc3BZO1xuICAgICAgICAgICAgICAgIGRpc3BsYWNlbWVudHNbdWlkXS54IC09IGRpc3BYO1xuICAgICAgICAgICAgICAgIGRpc3BsYWNlbWVudHNbdWlkXS55IC09IGRpc3BZO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGltZW5zaW9ucyA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICBkaXNwbGFjZW1lbnRzW3ZpZF0ueiArPSBkaXNwWjtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxhY2VtZW50c1t1aWRdLnogLT0gZGlzcFo7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYWxBdHRyYWN0aXZlKGNhbGNHcmFwaCwgZGlzcGxhY2VtZW50cywgaykge1xuICAgICAgICBjb25zdCBlZGdlcyA9IGNhbGNHcmFwaC5nZXRBbGxFZGdlcygpO1xuICAgICAgICBlZGdlcy5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHNvdXJjZSwgdGFyZ2V0IH0gPSBlO1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UgfHwgIXRhcmdldCB8fCBzb3VyY2UgPT09IHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogdSB9ID0gY2FsY0dyYXBoLmdldE5vZGUoc291cmNlKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YTogdiB9ID0gY2FsY0dyYXBoLmdldE5vZGUodGFyZ2V0KTtcbiAgICAgICAgICAgIGlmICghaXNOdW1iZXIodi54KSB8fFxuICAgICAgICAgICAgICAgICFpc051bWJlcih1LngpIHx8XG4gICAgICAgICAgICAgICAgIWlzTnVtYmVyKHYueSkgfHxcbiAgICAgICAgICAgICAgICAhaXNOdW1iZXIodS55KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHZlY1ggPSB2LnggLSB1Lng7XG4gICAgICAgICAgICBjb25zdCB2ZWNZID0gdi55IC0gdS55O1xuICAgICAgICAgICAgY29uc3QgdmVjWiA9IHRoaXMub3B0aW9ucy5kaW1lbnNpb25zID09PSAzID8gdi56IC0gdS56IDogMDtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1vbiA9IE1hdGguc3FydCh2ZWNYICogdmVjWCArIHZlY1kgKiB2ZWNZICsgdmVjWiAqIHZlY1opIC8gaztcbiAgICAgICAgICAgIGNvbnN0IGRpc3BYID0gdmVjWCAqIGNvbW1vbjtcbiAgICAgICAgICAgIGNvbnN0IGRpc3BZID0gdmVjWSAqIGNvbW1vbjtcbiAgICAgICAgICAgIGNvbnN0IGRpc3BaID0gdmVjWiAqIGNvbW1vbjtcbiAgICAgICAgICAgIGRpc3BsYWNlbWVudHNbc291cmNlXS54ICs9IGRpc3BYO1xuICAgICAgICAgICAgZGlzcGxhY2VtZW50c1tzb3VyY2VdLnkgKz0gZGlzcFk7XG4gICAgICAgICAgICBkaXNwbGFjZW1lbnRzW3RhcmdldF0ueCAtPSBkaXNwWDtcbiAgICAgICAgICAgIGRpc3BsYWNlbWVudHNbdGFyZ2V0XS55IC09IGRpc3BZO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaW1lbnNpb25zID09PSAzKSB7XG4gICAgICAgICAgICAgICAgZGlzcGxhY2VtZW50c1tzb3VyY2VdLnogKz0gZGlzcFo7XG4gICAgICAgICAgICAgICAgZGlzcGxhY2VtZW50c1t0YXJnZXRdLnogLT0gZGlzcFo7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZydWNodGVybWFuLmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgaXNOdW1iZXIsIGlzU3RyaW5nIH0gZnJvbSAnQGFudHYvdXRpbCc7XG5pbXBvcnQgeyBjbG9uZUZvcm1hdERhdGEsIGZvcm1hdE51bWJlckZuLCBmb3JtYXRTaXplRm4gfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgaGFuZGxlU2luZ2xlTm9kZUdyYXBoIH0gZnJvbSAnLi91dGlsL2NvbW1vbic7XG5pbXBvcnQgeyBwYXJzZVNpemUgfSBmcm9tICcuL3V0aWwvc2l6ZSc7XG5jb25zdCBERUZBVUxUU19MQVlPVVRfT1BUSU9OUyA9IHtcbiAgICBiZWdpbjogWzAsIDBdLFxuICAgIHByZXZlbnRPdmVybGFwOiB0cnVlLFxuICAgIHByZXZlbnRPdmVybGFwUGFkZGluZzogMTAsXG4gICAgY29uZGVuc2U6IGZhbHNlLFxuICAgIHJvd3M6IHVuZGVmaW5lZCxcbiAgICBjb2xzOiB1bmRlZmluZWQsXG4gICAgcG9zaXRpb246IHVuZGVmaW5lZCxcbiAgICBzb3J0Qnk6ICdkZWdyZWUnLFxuICAgIG5vZGVTaXplOiAzMCxcbiAgICB3aWR0aDogMzAwLFxuICAgIGhlaWdodDogMzAwLFxufTtcbi8qKlxuICogPHpoLz4g572R5qC85biD5bGAXG4gKlxuICogPGVuLz4gR3JpZCBsYXlvdXRcbiAqL1xuZXhwb3J0IGNsYXNzIEdyaWRMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmlkID0gJ2dyaWQnO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIERFRkFVTFRTX0xBWU9VVF9PUFRJT05TKSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgcG9zaXRpb25zIG9mIG5vZGVzIGFuZCBlZGdlcyhpZiBuZWVkZWQpLlxuICAgICAqL1xuICAgIGV4ZWN1dGUoZ3JhcGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyaWNHcmlkTGF5b3V0KGZhbHNlLCBncmFwaCwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUbyBkaXJlY3RseSBhc3NpZ24gdGhlIHBvc2l0aW9ucyB0byB0aGUgbm9kZXMuXG4gICAgICovXG4gICAgYXNzaWduKGdyYXBoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdlbmVyaWNHcmlkTGF5b3V0KHRydWUsIGdyYXBoLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdlbmVyaWNHcmlkTGF5b3V0KGFzc2lnbiwgZ3JhcGgsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucyksIG9wdGlvbnMpO1xuICAgICAgICAgICAgY29uc3QgeyBiZWdpbiA9IFswLCAwXSwgY29uZGVuc2UsIHByZXZlbnRPdmVybGFwUGFkZGluZywgcHJldmVudE92ZXJsYXAsIHJvd3M6IHByb3BzUm93cywgY29sczogcHJvcHNDb2xzLCBub2RlU3BhY2luZzogcGFyYW1Ob2RlU3BhY2luZywgbm9kZVNpemU6IHBhcmFtTm9kZVNpemUsIHdpZHRoOiBwcm9wc1dpZHRoLCBoZWlnaHQ6IHByb3BzSGVpZ2h0LCBwb3NpdGlvbiwgfSA9IG1lcmdlZE9wdGlvbnM7XG4gICAgICAgICAgICBsZXQgeyBzb3J0QnkgfSA9IG1lcmdlZE9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBub2RlcyA9IGdyYXBoLmdldEFsbE5vZGVzKCk7XG4gICAgICAgICAgICBjb25zdCBlZGdlcyA9IGdyYXBoLmdldEFsbEVkZ2VzKCk7XG4gICAgICAgICAgICBjb25zdCBuID0gbm9kZXMgPT09IG51bGwgfHwgbm9kZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgIC8vIE5lZWQgbm8gbGF5b3V0IGlmIHRoZXJlIGlzIG5vIG5vZGUuXG4gICAgICAgICAgICBpZiAoIW4gfHwgbiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVTaW5nbGVOb2RlR3JhcGgoZ3JhcGgsIGFzc2lnbiwgYmVnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGF5b3V0Tm9kZXMgPSBub2Rlcy5tYXAoKG5vZGUpID0+IGNsb25lRm9ybWF0RGF0YShub2RlKSk7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBgaWRgIHNob3VsZCBiZSByZXNlcnZlZCBrZXl3b3JkXG4gICAgICAgICAgICBzb3J0QnkgIT09ICdpZCcgJiZcbiAgICAgICAgICAgICAgICAoIWlzU3RyaW5nKHNvcnRCeSkgfHwgbGF5b3V0Tm9kZXNbMF0uZGF0YVtzb3J0QnldID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgc29ydEJ5ID0gJ2RlZ3JlZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc29ydEJ5ID09PSAnZGVncmVlJykge1xuICAgICAgICAgICAgICAgIGxheW91dE5vZGVzLnNvcnQoKG4xLCBuMikgPT4gZ3JhcGguZ2V0RGVncmVlKG4yLmlkLCAnYm90aCcpIC0gZ3JhcGguZ2V0RGVncmVlKG4xLmlkLCAnYm90aCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNvcnRCeSA9PT0gJ2lkJykge1xuICAgICAgICAgICAgICAgIC8vIHNvcnQgbm9kZXMgYnkgSURcbiAgICAgICAgICAgICAgICBsYXlvdXROb2Rlcy5zb3J0KChuMSwgbjIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTnVtYmVyKG4yLmlkKSAmJiBpc051bWJlcihuMS5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuMi5pZCAtIG4xLmlkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHtuMS5pZH1gLmxvY2FsZUNvbXBhcmUoYCR7bjIuaWR9YCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBzb3J0IG5vZGVzIGJ5IHZhbHVlXG4gICAgICAgICAgICAgICAgbGF5b3V0Tm9kZXMuc29ydCgobjEsIG4yKSA9PiBuMi5kYXRhW3NvcnRCeV0gLSBuMS5kYXRhW3NvcnRCeV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSAhcHJvcHNXaWR0aCAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgID8gd2luZG93LmlubmVyV2lkdGhcbiAgICAgICAgICAgICAgICA6IHByb3BzV2lkdGg7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSAhcHJvcHNIZWlnaHQgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/IHdpbmRvdy5pbm5lckhlaWdodFxuICAgICAgICAgICAgICAgIDogcHJvcHNIZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBjZWxscyA9IG47XG4gICAgICAgICAgICBjb25zdCByY3MgPSB7IHJvd3M6IHByb3BzUm93cywgY29sczogcHJvcHNDb2xzIH07XG4gICAgICAgICAgICAvLyBpZiByb3dzIG9yIGNvbHVtbnMgd2VyZSBzZXQgaW4gc2VsZiwgdXNlIHRob3NlIHZhbHVlc1xuICAgICAgICAgICAgaWYgKHByb3BzUm93cyAhPSBudWxsICYmIHByb3BzQ29scyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmNzLnJvd3MgPSBwcm9wc1Jvd3M7XG4gICAgICAgICAgICAgICAgcmNzLmNvbHMgPSBwcm9wc0NvbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9wc1Jvd3MgIT0gbnVsbCAmJiBwcm9wc0NvbHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJjcy5yb3dzID0gcHJvcHNSb3dzO1xuICAgICAgICAgICAgICAgIHJjcy5jb2xzID0gTWF0aC5jZWlsKGNlbGxzIC8gcmNzLnJvd3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvcHNSb3dzID09IG51bGwgJiYgcHJvcHNDb2xzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByY3MuY29scyA9IHByb3BzQ29scztcbiAgICAgICAgICAgICAgICByY3Mucm93cyA9IE1hdGguY2VpbChjZWxscyAvIHJjcy5jb2xzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSB1c2UgdGhlIGF1dG9tYXRpYyB2YWx1ZXMgYW5kIGFkanVzdCBhY2NvcmRpbmdseVx0ICAgICAgLy8gb3RoZXJ3aXNlIHVzZSB0aGUgYXV0b21hdGljIHZhbHVlcyBhbmQgYWRqdXN0IGFjY29yZGluZ2x5XG4gICAgICAgICAgICAgICAgLy8gd2lkdGgvaGVpZ2h0ICogc3BsaXRzXjIgPSBjZWxscyB3aGVyZSBzcGxpdHMgaXMgbnVtYmVyIG9mIHRpbWVzIHRvIHNwbGl0IHdpZHRoXG4gICAgICAgICAgICAgICAgY29uc3Qgc3BsaXRzID0gTWF0aC5zcXJ0KChjZWxscyAqIGhlaWdodCkgLyB3aWR0aCk7XG4gICAgICAgICAgICAgICAgcmNzLnJvd3MgPSBNYXRoLnJvdW5kKHNwbGl0cyk7XG4gICAgICAgICAgICAgICAgcmNzLmNvbHMgPSBNYXRoLnJvdW5kKCh3aWR0aCAvIGhlaWdodCkgKiBzcGxpdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmNzLnJvd3MgPSBNYXRoLm1heChyY3Mucm93cywgMSk7XG4gICAgICAgICAgICByY3MuY29scyA9IE1hdGgubWF4KHJjcy5jb2xzLCAxKTtcbiAgICAgICAgICAgIGlmIChyY3MuY29scyAqIHJjcy5yb3dzID4gY2VsbHMpIHtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgdXNlIHRoZSBhdXRvbWF0aWMgdmFsdWVzIGFuZCBhZGp1c3QgYWNjb3JkaW5nbHlcbiAgICAgICAgICAgICAgICAvLyBpZiByb3VuZGluZyB3YXMgdXAsIHNlZSBpZiB3ZSBjYW4gcmVkdWNlIHJvd3Mgb3IgY29sdW1uc1xuICAgICAgICAgICAgICAgIGNvbnN0IHNtID0gc21hbGwocmNzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsZyA9IGxhcmdlKHJjcyk7XG4gICAgICAgICAgICAgICAgLy8gcmVkdWNpbmcgdGhlIHNtYWxsIHNpZGUgdGFrZXMgYXdheSB0aGUgbW9zdCBjZWxscywgc28gdHJ5IGl0IGZpcnN0XG4gICAgICAgICAgICAgICAgaWYgKChzbSAtIDEpICogbGcgPj0gY2VsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgc21hbGwocmNzLCBzbSAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgobGcgLSAxKSAqIHNtID49IGNlbGxzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhcmdlKHJjcywgbGcgLSAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBpZiByb3VuZGluZyB3YXMgdG9vIGxvdywgYWRkIHJvd3Mgb3IgY29sdW1uc1xuICAgICAgICAgICAgICAgIHdoaWxlIChyY3MuY29scyAqIHJjcy5yb3dzIDwgY2VsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc20gPSBzbWFsbChyY3MpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZyA9IGxhcmdlKHJjcyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0byBhZGQgdG8gbGFyZ2VyIHNpZGUgZmlyc3QgKGFkZHMgbGVzcyBpbiBtdWx0aXBsaWNhdGlvbilcbiAgICAgICAgICAgICAgICAgICAgaWYgKChsZyArIDEpICogc20gPj0gY2VsbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhcmdlKHJjcywgbGcgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNtYWxsKHJjcywgc20gKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjZWxsV2lkdGggPSBjb25kZW5zZSA/IDAgOiB3aWR0aCAvIHJjcy5jb2xzO1xuICAgICAgICAgICAgbGV0IGNlbGxIZWlnaHQgPSBjb25kZW5zZSA/IDAgOiBoZWlnaHQgLyByY3Mucm93cztcbiAgICAgICAgICAgIGlmIChwcmV2ZW50T3ZlcmxhcCB8fCBwYXJhbU5vZGVTcGFjaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVNwYWNpbmcgPSBmb3JtYXROdW1iZXJGbigxMCwgcGFyYW1Ob2RlU3BhY2luZyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVNpemUgPSBmb3JtYXRTaXplRm4oMzAsIHBhcmFtTm9kZVNpemUsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBsYXlvdXROb2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbm9kZS5kYXRhLnggfHwgIW5vZGUuZGF0YS55KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgYmJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGF0YS54ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuZGF0YS55ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBvTm9kZSA9IGdyYXBoLmdldE5vZGUobm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IFtub2RlVywgbm9kZUhdID0gcGFyc2VTaXplKG5vZGVTaXplKG9Ob2RlKSB8fCAzMCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBub2RlU3BhY2luZyAhPT0gdW5kZWZpbmVkID8gbm9kZVNwYWNpbmcobm9kZSkgOiBwcmV2ZW50T3ZlcmxhcFBhZGRpbmc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHcgPSBub2RlVyArIHA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGggPSBub2RlSCArIHA7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxXaWR0aCA9IE1hdGgubWF4KGNlbGxXaWR0aCwgdyk7XG4gICAgICAgICAgICAgICAgICAgIGNlbGxIZWlnaHQgPSBNYXRoLm1heChjZWxsSGVpZ2h0LCBoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNlbGxVc2VkID0ge307IC8vIGUuZy4gJ2MtMC0yJyA9PiB0cnVlXG4gICAgICAgICAgICAvLyB0byBrZWVwIHRyYWNrIG9mIGN1cnJlbnQgY2VsbCBwb3NpdGlvblxuICAgICAgICAgICAgY29uc3QgcmMgPSB7IHJvdzogMCwgY29sOiAwIH07XG4gICAgICAgICAgICAvLyBnZXQgYSBjYWNoZSBvZiBhbGwgdGhlIG1hbnVhbCBwb3NpdGlvbnNcbiAgICAgICAgICAgIGNvbnN0IGlkMm1hblBvcyA9IHt9O1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXlvdXROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBsYXlvdXROb2Rlc1tpXTtcbiAgICAgICAgICAgICAgICBsZXQgcmNQb3M7XG4gICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IG5vdCBzdXJlIHRoZSBhcGkgbmFtZVxuICAgICAgICAgICAgICAgICAgICByY1BvcyA9IHBvc2l0aW9uKGdyYXBoLmdldE5vZGUobm9kZS5pZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmNQb3MgJiYgKHJjUG9zLnJvdyAhPT0gdW5kZWZpbmVkIHx8IHJjUG9zLmNvbCAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBtdXN0IGhhdmUgYXQgbGVhc3Qgcm93IG9yIGNvbCBkZWYnZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3MgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3c6IHJjUG9zLnJvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbDogcmNQb3MuY29sLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zLmNvbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHVudXNlZCBjb2xcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcy5jb2wgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHVzZWQoY2VsbFVzZWQsIHBvcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MuY29sKys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocG9zLnJvdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmaW5kIHVudXNlZCByb3dcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcy5yb3cgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHVzZWQoY2VsbFVzZWQsIHBvcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3Mucm93Kys7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWQybWFuUG9zW25vZGUuaWRdID0gcG9zO1xuICAgICAgICAgICAgICAgICAgICB1c2UoY2VsbFVzZWQsIHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGdldFBvcyhub2RlLCBiZWdpbiwgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0LCBpZDJtYW5Qb3MsIHJjcywgcmMsIGNlbGxVc2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICBub2RlczogbGF5b3V0Tm9kZXMsXG4gICAgICAgICAgICAgICAgZWRnZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGFzc2lnbikge1xuICAgICAgICAgICAgICAgIGxheW91dE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhcGgubWVyZ2VOb2RlRGF0YShub2RlLmlkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBub2RlLmRhdGEueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IG5vZGUuZGF0YS55LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNvbnN0IHNtYWxsID0gKHJjcywgdmFsKSA9PiB7XG4gICAgbGV0IHJlcztcbiAgICBjb25zdCByb3dzID0gcmNzLnJvd3MgfHwgNTtcbiAgICBjb25zdCBjb2xzID0gcmNzLmNvbHMgfHwgNTtcbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgcmVzID0gTWF0aC5taW4ocm93cywgY29scyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBtaW4gPSBNYXRoLm1pbihyb3dzLCBjb2xzKTtcbiAgICAgICAgaWYgKG1pbiA9PT0gcmNzLnJvd3MpIHtcbiAgICAgICAgICAgIHJjcy5yb3dzID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmNzLmNvbHMgPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5jb25zdCBsYXJnZSA9IChyY3MsIHZhbCkgPT4ge1xuICAgIGxldCByZXN1bHQ7XG4gICAgY29uc3QgdXNlZFJvd3MgPSByY3Mucm93cyB8fCA1O1xuICAgIGNvbnN0IHVzZWRDb2xzID0gcmNzLmNvbHMgfHwgNTtcbiAgICBpZiAodmFsID09IG51bGwpIHtcbiAgICAgICAgcmVzdWx0ID0gTWF0aC5tYXgodXNlZFJvd3MsIHVzZWRDb2xzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG1heCA9IE1hdGgubWF4KHVzZWRSb3dzLCB1c2VkQ29scyk7XG4gICAgICAgIGlmIChtYXggPT09IHJjcy5yb3dzKSB7XG4gICAgICAgICAgICByY3Mucm93cyA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJjcy5jb2xzID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuY29uc3QgdXNlZCA9IChjZWxsVXNlZCwgcmMpID0+IGNlbGxVc2VkW2BjLSR7cmMucm93fS0ke3JjLmNvbH1gXSB8fCBmYWxzZTtcbmNvbnN0IHVzZSA9IChjZWxsVXNlZCwgcmMpID0+IChjZWxsVXNlZFtgYy0ke3JjLnJvd30tJHtyYy5jb2x9YF0gPSB0cnVlKTtcbmNvbnN0IG1vdmVUb05leHRDZWxsID0gKHJjcywgcmMpID0+IHtcbiAgICBjb25zdCBjb2xzID0gcmNzLmNvbHMgfHwgNTtcbiAgICByYy5jb2wrKztcbiAgICBpZiAocmMuY29sID49IGNvbHMpIHtcbiAgICAgICAgcmMuY29sID0gMDtcbiAgICAgICAgcmMucm93Kys7XG4gICAgfVxufTtcbmNvbnN0IGdldFBvcyA9IChub2RlLCBiZWdpbiwgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0LCBpZDJtYW5Qb3MsIHJjcywgcmMsIGNlbGxVc2VkKSA9PiB7XG4gICAgbGV0IHg7XG4gICAgbGV0IHk7XG4gICAgLy8gc2VlIGlmIHdlIGhhdmUgYSBtYW51YWwgcG9zaXRpb24gc2V0XG4gICAgY29uc3QgcmNQb3MgPSBpZDJtYW5Qb3Nbbm9kZS5pZF07XG4gICAgaWYgKHJjUG9zKSB7XG4gICAgICAgIHggPSByY1Bvcy5jb2wgKiBjZWxsV2lkdGggKyBjZWxsV2lkdGggLyAyICsgYmVnaW5bMF07XG4gICAgICAgIHkgPSByY1Bvcy5yb3cgKiBjZWxsSGVpZ2h0ICsgY2VsbEhlaWdodCAvIDIgKyBiZWdpblsxXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSBzZXQgYXV0b21hdGljYWxseVxuICAgICAgICB3aGlsZSAodXNlZChjZWxsVXNlZCwgcmMpKSB7XG4gICAgICAgICAgICBtb3ZlVG9OZXh0Q2VsbChyY3MsIHJjKTtcbiAgICAgICAgfVxuICAgICAgICB4ID0gcmMuY29sICogY2VsbFdpZHRoICsgY2VsbFdpZHRoIC8gMiArIGJlZ2luWzBdO1xuICAgICAgICB5ID0gcmMucm93ICogY2VsbEhlaWdodCArIGNlbGxIZWlnaHQgLyAyICsgYmVnaW5bMV07XG4gICAgICAgIHVzZShjZWxsVXNlZCwgcmMpO1xuICAgICAgICBtb3ZlVG9OZXh0Q2VsbChyY3MsIHJjKTtcbiAgICB9XG4gICAgbm9kZS5kYXRhLnggPSB4O1xuICAgIG5vZGUuZGF0YS55ID0geTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncmlkLmpzLm1hcCIsImltcG9ydCB7IF9fYXdhaXRlciB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgTWF0cml4IGFzIE1MTWF0cml4LCBTaW5ndWxhclZhbHVlRGVjb21wb3NpdGlvbiB9IGZyb20gJ21sLW1hdHJpeCc7XG5pbXBvcnQgeyBjbG9uZUZvcm1hdERhdGEsIGZsb3lkV2Fyc2hhbGwsIGdldEFkak1hdHJpeCwgc2NhbGVNYXRyaXgsIH0gZnJvbSAnLi91dGlsJztcbmltcG9ydCB7IGhhbmRsZVNpbmdsZU5vZGVHcmFwaCB9IGZyb20gJy4vdXRpbC9jb21tb24nO1xuY29uc3QgREVGQVVMVFNfTEFZT1VUX09QVElPTlMgPSB7XG4gICAgY2VudGVyOiBbMCwgMF0sXG4gICAgbGlua0Rpc3RhbmNlOiA1MCxcbn07XG4vKipcbiAqIDx6aC8+IOWkmue7tOe8qeaUvueul+azleW4g+WxgFxuICpcbiAqIDxlbi8+IE11bHRpZGltZW5zaW9uYWwgc2NhbGluZyBsYXlvdXRcbiAqL1xuZXhwb3J0IGNsYXNzIE1EU0xheW91dCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuaWQgPSAnbWRzJztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUU19MQVlPVVRfT1BUSU9OUyksIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHBvc2l0aW9ucyBvZiBub2RlcyBhbmQgZWRnZXMoaWYgbmVlZGVkKS5cbiAgICAgKi9cbiAgICBleGVjdXRlKGdyYXBoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmljTURTTGF5b3V0KGZhbHNlLCBncmFwaCwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUbyBkaXJlY3RseSBhc3NpZ24gdGhlIHBvc2l0aW9ucyB0byB0aGUgbm9kZXMuXG4gICAgICovXG4gICAgYXNzaWduKGdyYXBoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdlbmVyaWNNRFNMYXlvdXQodHJ1ZSwgZ3JhcGgsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2VuZXJpY01EU0xheW91dChhc3NpZ24sIGdyYXBoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWRPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHsgY2VudGVyID0gWzAsIDBdLCBsaW5rRGlzdGFuY2UgPSA1MCB9ID0gbWVyZ2VkT3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gZ3JhcGguZ2V0QWxsTm9kZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGVkZ2VzID0gZ3JhcGguZ2V0QWxsRWRnZXMoKTtcbiAgICAgICAgICAgIGlmICghKG5vZGVzID09PSBudWxsIHx8IG5vZGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2Rlcy5sZW5ndGgpIHx8IG5vZGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVTaW5nbGVOb2RlR3JhcGgoZ3JhcGgsIGFzc2lnbiwgY2VudGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoZSBncmFwaC10aGVvcmV0aWMgZGlzdGFuY2UgKHNob3J0ZXN0IHBhdGggZGlzdGFuY2UpIG1hdHJpeFxuICAgICAgICAgICAgY29uc3QgYWRqTWF0cml4ID0gZ2V0QWRqTWF0cml4KHsgbm9kZXMsIGVkZ2VzIH0sIGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlcyA9IGZsb3lkV2Fyc2hhbGwoYWRqTWF0cml4KTtcbiAgICAgICAgICAgIGhhbmRsZUluZmluaXR5KGRpc3RhbmNlcyk7XG4gICAgICAgICAgICAvLyBzY2FsZSB0aGUgaWRlYWwgZWRnZSBsZW5ndGggYWNvb3JkaW5nIHRvIGxpbmtEaXN0YW5jZVxuICAgICAgICAgICAgY29uc3Qgc2NhbGVkRCA9IHNjYWxlTWF0cml4KGRpc3RhbmNlcywgbGlua0Rpc3RhbmNlKTtcbiAgICAgICAgICAgIC8vIGdldCBwb3NpdGlvbnMgYnkgTURTXG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSBydW5NRFMoc2NhbGVkRCk7XG4gICAgICAgICAgICBjb25zdCBsYXlvdXROb2RlcyA9IFtdO1xuICAgICAgICAgICAgcG9zaXRpb25zLmZvckVhY2goKHAsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbm9kZSA9IGNsb25lRm9ybWF0RGF0YShub2Rlc1tpXSk7XG4gICAgICAgICAgICAgICAgY25vZGUuZGF0YS54ID0gcFswXSArIGNlbnRlclswXTtcbiAgICAgICAgICAgICAgICBjbm9kZS5kYXRhLnkgPSBwWzFdICsgY2VudGVyWzFdO1xuICAgICAgICAgICAgICAgIGxheW91dE5vZGVzLnB1c2goY25vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoYXNzaWduKSB7XG4gICAgICAgICAgICAgICAgbGF5b3V0Tm9kZXMuZm9yRWFjaCgobm9kZSkgPT4gZ3JhcGgubWVyZ2VOb2RlRGF0YShub2RlLmlkLCB7XG4gICAgICAgICAgICAgICAgICAgIHg6IG5vZGUuZGF0YS54LFxuICAgICAgICAgICAgICAgICAgICB5OiBub2RlLmRhdGEueSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgbm9kZXM6IGxheW91dE5vZGVzLFxuICAgICAgICAgICAgICAgIGVkZ2VzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNvbnN0IGhhbmRsZUluZmluaXR5ID0gKGRpc3RhbmNlcykgPT4ge1xuICAgIGxldCBtYXhEaXN0YW5jZSA9IC05OTk5OTk7XG4gICAgZGlzdGFuY2VzLmZvckVhY2goKHJvdykgPT4ge1xuICAgICAgICByb3cuZm9yRWFjaCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF4RGlzdGFuY2UgPCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIG1heERpc3RhbmNlID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGRpc3RhbmNlcy5mb3JFYWNoKChyb3csIGkpID0+IHtcbiAgICAgICAgcm93LmZvckVhY2goKHZhbHVlLCBqKSA9PiB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICAgICAgZGlzdGFuY2VzW2ldW2pdID0gbWF4RGlzdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbi8qKlxuICogbWRzIOeul+azlVxuICogQHJldHVybiB7YXJyYXl9IHBvc2l0aW9ucyDorqHnrpflkI7nmoToioLngrnkvY3nva7mlbDnu4RcbiAqL1xuY29uc3QgcnVuTURTID0gKGRpc3RhbmNlcykgPT4ge1xuICAgIGNvbnN0IGRpbWVuc2lvbiA9IDI7XG4gICAgLy8gc3F1YXJlIGRpc3RhbmNlc1xuICAgIGNvbnN0IE0gPSBNTE1hdHJpeC5tdWwoTUxNYXRyaXgucG93KGRpc3RhbmNlcywgMiksIC0wLjUpO1xuICAgIC8vIGRvdWJsZSBjZW50cmUgdGhlIHJvd3MvY29sdW1uc1xuICAgIGNvbnN0IHJvd01lYW5zID0gTS5tZWFuKCdyb3cnKTtcbiAgICBjb25zdCBjb2xNZWFucyA9IE0ubWVhbignY29sdW1uJyk7XG4gICAgY29uc3QgdG90YWxNZWFuID0gTS5tZWFuKCk7XG4gICAgTS5hZGQodG90YWxNZWFuKS5zdWJSb3dWZWN0b3Iocm93TWVhbnMpLnN1YkNvbHVtblZlY3Rvcihjb2xNZWFucyk7XG4gICAgLy8gdGFrZSB0aGUgU1ZEIG9mIHRoZSBkb3VibGUgY2VudHJlZCBtYXRyaXgsIGFuZCByZXR1cm4gdGhlXG4gICAgLy8gcG9pbnRzIGZyb20gaXRcbiAgICBjb25zdCByZXQgPSBuZXcgU2luZ3VsYXJWYWx1ZURlY29tcG9zaXRpb24oTSk7XG4gICAgY29uc3QgZWlnZW5WYWx1ZXMgPSBNTE1hdHJpeC5zcXJ0KHJldC5kaWFnb25hbE1hdHJpeCkuZGlhZ29uYWwoKTtcbiAgICByZXR1cm4gcmV0LmxlZnRTaW5ndWxhclZlY3RvcnMudG9KU09OKCkubWFwKChyb3cpID0+IHtcbiAgICAgICAgcmV0dXJuIE1MTWF0cml4Lm11bChbcm93XSwgW2VpZ2VuVmFsdWVzXSlcbiAgICAgICAgICAgIC50b0pTT04oKVswXVxuICAgICAgICAgICAgLnNwbGljZSgwLCBkaW1lbnNpb24pO1xuICAgIH0pO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1kcy5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIgfSBmcm9tIFwidHNsaWJcIjtcbmltcG9ydCB7IGlzU3RyaW5nIH0gZnJvbSAnQGFudHYvdXRpbCc7XG5pbXBvcnQgeyBjbG9uZUZvcm1hdERhdGEsIGZsb3lkV2Fyc2hhbGwsIGZvcm1hdE5vZGVTaXplVG9OdW1iZXIsIGdldEFkak1hdHJpeCwgZ2V0RXVjbGlkZWFuRGlzdGFuY2UsIH0gZnJvbSAnLi4vdXRpbCc7XG5pbXBvcnQgeyBoYW5kbGVTaW5nbGVOb2RlR3JhcGggfSBmcm9tICcuLi91dGlsL2NvbW1vbic7XG5pbXBvcnQgeyBtZHMgfSBmcm9tICcuL21kcyc7XG5pbXBvcnQgeyByYWRpYWxOb25vdmVybGFwRm9yY2UsIH0gZnJvbSAnLi9yYWRpYWwtbm9ub3ZlcmxhcC1mb3JjZSc7XG5jb25zdCBERUZBVUxUU19MQVlPVVRfT1BUSU9OUyA9IHtcbiAgICBtYXhJdGVyYXRpb246IDEwMDAsXG4gICAgZm9jdXNOb2RlOiBudWxsLFxuICAgIHVuaXRSYWRpdXM6IG51bGwsXG4gICAgbGlua0Rpc3RhbmNlOiA1MCxcbiAgICBwcmV2ZW50T3ZlcmxhcDogZmFsc2UsXG4gICAgc3RyaWN0UmFkaWFsOiB0cnVlLFxuICAgIG1heFByZXZlbnRPdmVybGFwSXRlcmF0aW9uOiAyMDAsXG4gICAgc29ydFN0cmVuZ3RoOiAxMCxcbn07XG4vKipcbiAqIDx6aC8+IOW+hOWQkeW4g+WxgFxuICpcbiAqIDxlbi8+IFJhZGlhbCBsYXlvdXRcbiAqL1xuZXhwb3J0IGNsYXNzIFJhZGlhbExheW91dCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuaWQgPSAncmFkaWFsJztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUU19MQVlPVVRfT1BUSU9OUyksIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIHBvc2l0aW9ucyBvZiBub2RlcyBhbmQgZWRnZXMoaWYgbmVlZGVkKS5cbiAgICAgKi9cbiAgICBleGVjdXRlKGdyYXBoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZW5lcmljUmFkaWFsTGF5b3V0KGZhbHNlLCBncmFwaCwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUbyBkaXJlY3RseSBhc3NpZ24gdGhlIHBvc2l0aW9ucyB0byB0aGUgbm9kZXMuXG4gICAgICovXG4gICAgYXNzaWduKGdyYXBoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdlbmVyaWNSYWRpYWxMYXlvdXQodHJ1ZSwgZ3JhcGgsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2VuZXJpY1JhZGlhbExheW91dChhc3NpZ24sIGdyYXBoLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWRPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHsgd2lkdGg6IHByb3BzV2lkdGgsIGhlaWdodDogcHJvcHNIZWlnaHQsIGNlbnRlcjogcHJvcHNDZW50ZXIsIGZvY3VzTm9kZTogcHJvcHNGb2N1c05vZGUsIHVuaXRSYWRpdXM6IHByb3BzVW5pdFJhZGl1cywgbm9kZVNpemUsIG5vZGVTcGFjaW5nLCBzdHJpY3RSYWRpYWwsIHByZXZlbnRPdmVybGFwLCBtYXhQcmV2ZW50T3ZlcmxhcEl0ZXJhdGlvbiwgc29ydEJ5LCBsaW5rRGlzdGFuY2UgPSA1MCwgc29ydFN0cmVuZ3RoID0gMTAsIG1heEl0ZXJhdGlvbiA9IDEwMDAsIH0gPSBtZXJnZWRPcHRpb25zO1xuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBncmFwaC5nZXRBbGxOb2RlcygpO1xuICAgICAgICAgICAgY29uc3QgZWRnZXMgPSBncmFwaC5nZXRBbGxFZGdlcygpO1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSAhcHJvcHNXaWR0aCAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgID8gd2luZG93LmlubmVyV2lkdGhcbiAgICAgICAgICAgICAgICA6IHByb3BzV2lkdGg7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSAhcHJvcHNIZWlnaHQgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/IHdpbmRvdy5pbm5lckhlaWdodFxuICAgICAgICAgICAgICAgIDogcHJvcHNIZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBjZW50ZXIgPSAoIXByb3BzQ2VudGVyID8gW3dpZHRoIC8gMiwgaGVpZ2h0IC8gMl0gOiBwcm9wc0NlbnRlcik7XG4gICAgICAgICAgICBpZiAoIShub2RlcyA9PT0gbnVsbCB8fCBub2RlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZXMubGVuZ3RoKSB8fCBub2Rlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlU2luZ2xlTm9kZUdyYXBoKGdyYXBoLCBhc3NpZ24sIGNlbnRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm9jdXNOb2RlID0gbm9kZXNbMF07XG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcocHJvcHNGb2N1c05vZGUpKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZXNbaV0uaWQgPT09IHByb3BzRm9jdXNOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1c05vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9jdXNOb2RlID0gcHJvcHNGb2N1c05vZGUgfHwgbm9kZXNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGUgaW5kZXggb2YgdGhlIGZvY3VzTm9kZSBpbiBkYXRhXG4gICAgICAgICAgICBjb25zdCBmb2N1c0luZGV4ID0gZ2V0SW5kZXhCeUlkKG5vZGVzLCBmb2N1c05vZGUuaWQpO1xuICAgICAgICAgICAgLy8gdGhlIGdyYXBoLXRoZW9yZXRpYyBkaXN0YW5jZSAoc2hvcnRlc3QgcGF0aCBkaXN0YW5jZSkgbWF0cml4XG4gICAgICAgICAgICBjb25zdCBhZGpNYXRyaXggPSBnZXRBZGpNYXRyaXgoeyBub2RlcywgZWRnZXMgfSwgZmFsc2UpO1xuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2VzID0gZmxveWRXYXJzaGFsbChhZGpNYXRyaXgpO1xuICAgICAgICAgICAgY29uc3QgbWF4RGlzdGFuY2UgPSBtYXhUb0ZvY3VzKGRpc3RhbmNlcywgZm9jdXNJbmRleCk7XG4gICAgICAgICAgICAvLyByZXBsYWNlIGZpcnN0IG5vZGUgaW4gdW5jb25uZWN0ZWQgY29tcG9uZW50IHRvIHRoZSBjaXJjbGUgYXQgKG1heERpc3RhbmNlICsgMSlcbiAgICAgICAgICAgIGhhbmRsZUluZmluaXR5KGRpc3RhbmNlcywgZm9jdXNJbmRleCwgbWF4RGlzdGFuY2UgKyAxKTtcbiAgICAgICAgICAgIC8vIHRoZSBzaG9ydGVzdCBwYXRoIGRpc3RhbmNlIGZyb20gZWFjaCBub2RlIHRvIGZvY3VzTm9kZVxuICAgICAgICAgICAgY29uc3QgZm9jdXNOb2RlRCA9IGRpc3RhbmNlc1tmb2N1c0luZGV4XTtcbiAgICAgICAgICAgIGxldCBzZW1pV2lkdGggPSB3aWR0aCAtIGNlbnRlclswXSA+IGNlbnRlclswXSA/IGNlbnRlclswXSA6IHdpZHRoIC0gY2VudGVyWzBdO1xuICAgICAgICAgICAgbGV0IHNlbWlIZWlnaHQgPSBoZWlnaHQgLSBjZW50ZXJbMV0gPiBjZW50ZXJbMV0gPyBjZW50ZXJbMV0gOiBoZWlnaHQgLSBjZW50ZXJbMV07XG4gICAgICAgICAgICBpZiAoc2VtaVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc2VtaVdpZHRoID0gd2lkdGggLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbWlIZWlnaHQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzZW1pSGVpZ2h0ID0gaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoZSBtYXhSYWRpdXMgb2YgdGhlIGdyYXBoXG4gICAgICAgICAgICBjb25zdCBtYXhSYWRpdXMgPSBNYXRoLm1pbihzZW1pV2lkdGgsIHNlbWlIZWlnaHQpO1xuICAgICAgICAgICAgY29uc3QgbWF4RCA9IE1hdGgubWF4KC4uLmZvY3VzTm9kZUQpO1xuICAgICAgICAgICAgLy8gdGhlIHJhZGl1cyBmb3IgZWFjaCBub2RlcyBhd2F5IGZyb20gZm9jdXNOb2RlXG4gICAgICAgICAgICBjb25zdCByYWRpaSA9IFtdO1xuICAgICAgICAgICAgY29uc3QgdW5pdFJhZGl1cyA9ICFwcm9wc1VuaXRSYWRpdXMgPyBtYXhSYWRpdXMgLyBtYXhEIDogcHJvcHNVbml0UmFkaXVzO1xuICAgICAgICAgICAgZm9jdXNOb2RlRC5mb3JFYWNoKCh2YWx1ZSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHJhZGlpW2ldID0gdmFsdWUgKiB1bml0UmFkaXVzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBpZGVhbERpc3RhbmNlcyA9IGVJZGVhbERpc01hdHJpeChub2RlcywgZGlzdGFuY2VzLCBsaW5rRGlzdGFuY2UsIHJhZGlpLCB1bml0UmFkaXVzLCBzb3J0QnksIHNvcnRTdHJlbmd0aCk7XG4gICAgICAgICAgICAvLyB0aGUgd2VpZ2h0IG1hdHJpeCwgV2lqID0gMSAvIGRpal4oLTIpXG4gICAgICAgICAgICBjb25zdCB3ZWlnaHRzID0gZ2V0V2VpZ2h0TWF0cml4KGlkZWFsRGlzdGFuY2VzKTtcbiAgICAgICAgICAgIC8vIHRoZSBpbml0aWFsIHBvc2l0aW9ucyBmcm9tIG1kcywgbW92ZSB0aGUgZ3JhcGggdG8gb3JpZ2luLCBjZW50ZXJlZCBhdCBmb2N1c05vZGVcbiAgICAgICAgICAgIGNvbnN0IG1kc1Jlc3VsdCA9IG1kcyhsaW5rRGlzdGFuY2UsIGlkZWFsRGlzdGFuY2VzLCBsaW5rRGlzdGFuY2UpO1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9ucyA9IG1kc1Jlc3VsdC5tYXAoKFt4LCB5XSkgPT4gKHtcbiAgICAgICAgICAgICAgICB4OiAoaXNOYU4oeCkgPyBNYXRoLnJhbmRvbSgpICogbGlua0Rpc3RhbmNlIDogeCkgLVxuICAgICAgICAgICAgICAgICAgICBtZHNSZXN1bHRbZm9jdXNJbmRleF1bMF0sXG4gICAgICAgICAgICAgICAgeTogKGlzTmFOKHkpID8gTWF0aC5yYW5kb20oKSAqIGxpbmtEaXN0YW5jZSA6IHkpIC1cbiAgICAgICAgICAgICAgICAgICAgbWRzUmVzdWx0W2ZvY3VzSW5kZXhdWzFdLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgdGhpcy5ydW4obWF4SXRlcmF0aW9uLCBwb3NpdGlvbnMsIHdlaWdodHMsIGlkZWFsRGlzdGFuY2VzLCByYWRpaSwgZm9jdXNJbmRleCk7XG4gICAgICAgICAgICBsZXQgbm9kZVNpemVGdW5jO1xuICAgICAgICAgICAgLy8gc3RhZ2dlciB0aGUgb3ZlcmxhcHBlZCBub2Rlc1xuICAgICAgICAgICAgaWYgKHByZXZlbnRPdmVybGFwKSB7XG4gICAgICAgICAgICAgICAgbm9kZVNpemVGdW5jID0gZm9ybWF0Tm9kZVNpemVUb051bWJlcihub2RlU2l6ZSwgbm9kZVNwYWNpbmcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vbm92ZXJsYXBGb3JjZVBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVTaXplRnVuYyxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25zLFxuICAgICAgICAgICAgICAgICAgICByYWRpaSxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgc3RyaWN0UmFkaWFsOiBCb29sZWFuKHN0cmljdFJhZGlhbCksXG4gICAgICAgICAgICAgICAgICAgIGZvY3VzSWR4OiBmb2N1c0luZGV4LFxuICAgICAgICAgICAgICAgICAgICBpdGVyYXRpb25zOiBtYXhQcmV2ZW50T3ZlcmxhcEl0ZXJhdGlvbiB8fCAyMDAsXG4gICAgICAgICAgICAgICAgICAgIGs6IHBvc2l0aW9ucy5sZW5ndGggLyA0LjUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnMgPSByYWRpYWxOb25vdmVybGFwRm9yY2UoZ3JhcGgsIG5vbm92ZXJsYXBGb3JjZVBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBtb3ZlIHRoZSBncmFwaCB0byBjZW50ZXJcbiAgICAgICAgICAgIGNvbnN0IGxheW91dE5vZGVzID0gW107XG4gICAgICAgICAgICBwb3NpdGlvbnMuZm9yRWFjaCgocCwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNub2RlID0gY2xvbmVGb3JtYXREYXRhKG5vZGVzW2ldKTtcbiAgICAgICAgICAgICAgICBjbm9kZS5kYXRhLnggPSBwLnggKyBjZW50ZXJbMF07XG4gICAgICAgICAgICAgICAgY25vZGUuZGF0YS55ID0gcC55ICsgY2VudGVyWzFdO1xuICAgICAgICAgICAgICAgIGxheW91dE5vZGVzLnB1c2goY25vZGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoYXNzaWduKSB7XG4gICAgICAgICAgICAgICAgbGF5b3V0Tm9kZXMuZm9yRWFjaCgobm9kZSkgPT4gZ3JhcGgubWVyZ2VOb2RlRGF0YShub2RlLmlkLCB7XG4gICAgICAgICAgICAgICAgICAgIHg6IG5vZGUuZGF0YS54LFxuICAgICAgICAgICAgICAgICAgICB5OiBub2RlLmRhdGEueSxcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgbm9kZXM6IGxheW91dE5vZGVzLFxuICAgICAgICAgICAgICAgIGVkZ2VzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBydW4obWF4SXRlcmF0aW9uLCBwb3NpdGlvbnMsIHdlaWdodHMsIGlkZWFsRGlzdGFuY2VzLCByYWRpaSwgZm9jdXNJbmRleCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBtYXhJdGVyYXRpb247IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcGFyYW0gPSBpIC8gbWF4SXRlcmF0aW9uO1xuICAgICAgICAgICAgdGhpcy5vbmVJdGVyYXRpb24ocGFyYW0sIHBvc2l0aW9ucywgcmFkaWksIGlkZWFsRGlzdGFuY2VzLCB3ZWlnaHRzLCBmb2N1c0luZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbmVJdGVyYXRpb24ocGFyYW0sIHBvc2l0aW9ucywgcmFkaWksIGRpc3RhbmNlcywgd2VpZ2h0cywgZm9jdXNJbmRleCkge1xuICAgICAgICBjb25zdCB2cGFyYW0gPSAxIC0gcGFyYW07XG4gICAgICAgIHBvc2l0aW9ucy5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgICAgICAgICAvLyB2XG4gICAgICAgICAgICBjb25zdCBvcmlnaW5EaXMgPSBnZXRFdWNsaWRlYW5EaXN0YW5jZSh2LCB7IHg6IDAsIHk6IDAgfSk7XG4gICAgICAgICAgICBjb25zdCByZWNpT0RpcyA9IG9yaWdpbkRpcyA9PT0gMCA/IDAgOiAxIC8gb3JpZ2luRGlzO1xuICAgICAgICAgICAgaWYgKGkgPT09IGZvY3VzSW5kZXgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgeE1vbGVjdWxlID0gMDtcbiAgICAgICAgICAgIGxldCB5TW9sZWN1bGUgPSAwO1xuICAgICAgICAgICAgbGV0IGRlbm9taW5hdG9yID0gMDtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5mb3JFYWNoKCh1LCBqKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gdVxuICAgICAgICAgICAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdGhlIGV1Y2xpZGVhbiBkaXN0YW5jZSBiZXR3ZWVuIHYgYW5kIHVcbiAgICAgICAgICAgICAgICBjb25zdCBlZGlzID0gZ2V0RXVjbGlkZWFuRGlzdGFuY2UodiwgdSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjaUVkaXMgPSBlZGlzID09PSAwID8gMCA6IDEgLyBlZGlzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkZWFsRGlzID0gZGlzdGFuY2VzW2pdW2ldO1xuICAgICAgICAgICAgICAgIC8vIHNhbWUgZm9yIHggYW5kIHlcbiAgICAgICAgICAgICAgICBkZW5vbWluYXRvciArPSB3ZWlnaHRzW2ldW2pdO1xuICAgICAgICAgICAgICAgIC8vIHhcbiAgICAgICAgICAgICAgICB4TW9sZWN1bGUgKz0gd2VpZ2h0c1tpXVtqXSAqICh1LnggKyBpZGVhbERpcyAqICh2LnggLSB1LngpICogcmVjaUVkaXMpO1xuICAgICAgICAgICAgICAgIC8vIHlcbiAgICAgICAgICAgICAgICB5TW9sZWN1bGUgKz0gd2VpZ2h0c1tpXVtqXSAqICh1LnkgKyBpZGVhbERpcyAqICh2LnkgLSB1LnkpICogcmVjaUVkaXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZWNpUiA9IHJhZGlpW2ldID09PSAwID8gMCA6IDEgLyByYWRpaVtpXTtcbiAgICAgICAgICAgIGRlbm9taW5hdG9yICo9IHZwYXJhbTtcbiAgICAgICAgICAgIGRlbm9taW5hdG9yICs9IHBhcmFtICogcmVjaVIgKiByZWNpUjtcbiAgICAgICAgICAgIC8vIHhcbiAgICAgICAgICAgIHhNb2xlY3VsZSAqPSB2cGFyYW07XG4gICAgICAgICAgICB4TW9sZWN1bGUgKz0gcGFyYW0gKiByZWNpUiAqIHYueCAqIHJlY2lPRGlzO1xuICAgICAgICAgICAgdi54ID0geE1vbGVjdWxlIC8gZGVub21pbmF0b3I7XG4gICAgICAgICAgICAvLyB5XG4gICAgICAgICAgICB5TW9sZWN1bGUgKj0gdnBhcmFtO1xuICAgICAgICAgICAgeU1vbGVjdWxlICs9IHBhcmFtICogcmVjaVIgKiB2LnkgKiByZWNpT0RpcztcbiAgICAgICAgICAgIHYueSA9IHlNb2xlY3VsZSAvIGRlbm9taW5hdG9yO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jb25zdCBlSWRlYWxEaXNNYXRyaXggPSAobm9kZXMsIGRpc3RhbmNlcywgbGlua0Rpc3RhbmNlLCByYWRpaSwgdW5pdFJhZGl1cywgc29ydEJ5LCBzb3J0U3RyZW5ndGgpID0+IHtcbiAgICBpZiAoIW5vZGVzKVxuICAgICAgICByZXR1cm4gW107XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgaWYgKGRpc3RhbmNlcykge1xuICAgICAgICAvLyBjYWNoZSB0aGUgdmFsdWUgb2YgZmllbGQgc29ydEJ5IGZvciBub2RlcyB0byBhdm9pZCBkdXBsaWF0ZSBjYWxjdWxhdGlvblxuICAgICAgICBjb25zdCBzb3J0VmFsdWVDYWNoZSA9IHt9O1xuICAgICAgICBkaXN0YW5jZXMuZm9yRWFjaCgocm93LCBpKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdSb3cgPSBbXTtcbiAgICAgICAgICAgIHJvdy5mb3JFYWNoKCh2LCBqKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gaikge1xuICAgICAgICAgICAgICAgICAgICBuZXdSb3cucHVzaCgwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmFkaWlbaV0gPT09IHJhZGlpW2pdKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGkgYW5kIGogYXJlIG9uIHRoZSBzYW1lIGNpcmNsZVxuICAgICAgICAgICAgICAgICAgICBpZiAoc29ydEJ5ID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvcnQgdGhlIG5vZGVzIG9uIHRoZSBzYW1lIGNpcmNsZSBhY2NvcmRpbmcgdG8gdGhlIG9yZGVyaW5nIG9mIHRoZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdSb3cucHVzaCgodiAqIChNYXRoLmFicyhpIC0gaikgKiBzb3J0U3RyZW5ndGgpKSAvIChyYWRpaVtpXSAvIHVuaXRSYWRpdXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzb3J0QnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvcnQgdGhlIG5vZGVzIG9uIHRoZSBzYW1lIGNpcmNsZSBhY2NvcmRpbmcgdG8gdGhlIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBpVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgalZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvcnRWYWx1ZUNhY2hlW25vZGVzW2ldLmlkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlWYWx1ZSA9IHNvcnRWYWx1ZUNhY2hlW25vZGVzW2ldLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gKHNvcnRCeSA9PT0gJ2lkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG5vZGVzW2ldLmlkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKF9hID0gbm9kZXNbaV0uZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW3NvcnRCeV0pIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpVmFsdWUgPSB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaVZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRWYWx1ZUNhY2hlW25vZGVzW2ldLmlkXSA9IGlWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3J0VmFsdWVDYWNoZVtub2Rlc1tqXS5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqVmFsdWUgPSBzb3J0VmFsdWVDYWNoZVtub2Rlc1tqXS5pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IChzb3J0QnkgPT09ICdpZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBub2Rlc1tqXS5pZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IChfYiA9IG5vZGVzW2pdLmRhdGEpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltzb3J0QnldKSB8fCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalZhbHVlID0gdmFsdWUuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3J0VmFsdWVDYWNoZVtub2Rlc1tqXS5pZF0gPSBqVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdSb3cucHVzaCgodiAqIChNYXRoLmFicyhpVmFsdWUgLSBqVmFsdWUpICogc29ydFN0cmVuZ3RoKSkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChyYWRpaVtpXSAvIHVuaXRSYWRpdXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1Jvdy5wdXNoKCh2ICogbGlua0Rpc3RhbmNlKSAvIChyYWRpaVtpXSAvIHVuaXRSYWRpdXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaSBhbmQgaiBhcmUgb24gZGlmZmVyZW50IGNpcmNsZXNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluayA9IChsaW5rRGlzdGFuY2UgKyB1bml0UmFkaXVzKSAvIDI7XG4gICAgICAgICAgICAgICAgICAgIG5ld1Jvdy5wdXNoKHYgKiBsaW5rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ld1Jvdyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmNvbnN0IGdldFdlaWdodE1hdHJpeCA9IChpZGVhbERpc3RhbmNlcykgPT4ge1xuICAgIGNvbnN0IHJvd3MgPSBpZGVhbERpc3RhbmNlcy5sZW5ndGg7XG4gICAgY29uc3QgY29scyA9IGlkZWFsRGlzdGFuY2VzWzBdLmxlbmd0aDtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICBjb25zdCByb3cgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xzOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChpZGVhbERpc3RhbmNlc1tpXVtqXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHJvdy5wdXNoKDEgLyAoaWRlYWxEaXN0YW5jZXNbaV1bal0gKiBpZGVhbERpc3RhbmNlc1tpXVtqXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcm93LnB1c2goMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2gocm93KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5jb25zdCBnZXRJbmRleEJ5SWQgPSAoYXJyYXksIGlkKSA9PiB7XG4gICAgbGV0IGluZGV4ID0gLTE7XG4gICAgYXJyYXkuZm9yRWFjaCgoYSwgaSkgPT4ge1xuICAgICAgICBpZiAoYS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBNYXRoLm1heChpbmRleCwgMCk7XG59O1xuY29uc3QgaGFuZGxlSW5maW5pdHkgPSAobWF0cml4LCBmb2N1c0luZGV4LCBzdGVwKSA9PiB7XG4gICAgY29uc3QgbGVuZ3RoID0gbWF0cml4Lmxlbmd0aDtcbiAgICAvLyDpgY3ljoYgbWF0cml4IOS4remBjeWOhiBmb2N1cyDlr7nlupTooYxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIG1hdHJpeCDlhbPms6jngrnlr7nlupTooYznmoQgSW5mIOmhuVxuICAgICAgICBpZiAobWF0cml4W2ZvY3VzSW5kZXhdW2ldID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgbWF0cml4W2ZvY3VzSW5kZXhdW2ldID0gc3RlcDtcbiAgICAgICAgICAgIG1hdHJpeFtpXVtmb2N1c0luZGV4XSA9IHN0ZXA7XG4gICAgICAgICAgICAvLyDpgY3ljoYgbWF0cml4IOS4reeahCBpIOihjO+8jGkg6KGM5Lit6Z2eIEluZiDpobnoi6XlnKggZm9jdXMg6KGM5Li6IEluZu+8jOWImeabv+aNoiBmb2N1cyDooYznmoTpgqPkuKogSW5mXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hdHJpeFtpXVtqXSAhPT0gSW5maW5pdHkgJiYgbWF0cml4W2ZvY3VzSW5kZXhdW2pdID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXhbZm9jdXNJbmRleF1bal0gPSBzdGVwICsgbWF0cml4W2ldW2pdO1xuICAgICAgICAgICAgICAgICAgICBtYXRyaXhbal1bZm9jdXNJbmRleF0gPSBzdGVwICsgbWF0cml4W2ldW2pdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyDlpITnkIblhbbku5booYznmoQgSW5m44CC5qC55o2u6K+l6KGM5a+55bqU54K55LiOIGZvY3VzIOi3neemu+S7peWPiiBJbmYg6aG554K5IOS4jiBmb2N1cyDot53nprvvvIzlhrPlrprmm7/mjaLlgLxcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpID09PSBmb2N1c0luZGV4KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAobWF0cml4W2ldW2pdID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgICAgIGxldCBtaW51cyA9IE1hdGguYWJzKG1hdHJpeFtmb2N1c0luZGV4XVtpXSAtIG1hdHJpeFtmb2N1c0luZGV4XVtqXSk7XG4gICAgICAgICAgICAgICAgbWludXMgPSBtaW51cyA9PT0gMCA/IDEgOiBtaW51cztcbiAgICAgICAgICAgICAgICBtYXRyaXhbaV1bal0gPSBtaW51cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBtYXhUb0ZvY3VzID0gKG1hdHJpeCwgZm9jdXNJbmRleCkgPT4ge1xuICAgIGxldCBtYXggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0cml4W2ZvY3VzSW5kZXhdLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChtYXRyaXhbZm9jdXNJbmRleF1baV0gPT09IEluZmluaXR5KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtYXggPSBtYXRyaXhbZm9jdXNJbmRleF1baV0gPiBtYXggPyBtYXRyaXhbZm9jdXNJbmRleF1baV0gOiBtYXg7XG4gICAgfVxuICAgIHJldHVybiBtYXg7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHsgTWF0cml4IGFzIE1MTWF0cml4LCBTaW5ndWxhclZhbHVlRGVjb21wb3NpdGlvbiB9IGZyb20gJ21sLW1hdHJpeCc7XG5leHBvcnQgY29uc3QgbWRzID0gKGRpbWVuc2lvbiwgZGlzdGFuY2VzLCBsaW5rRGlzdGFuY2UpID0+IHtcbiAgICB0cnkge1xuICAgICAgICAvLyBzcXVhcmUgZGlzdGFuY2VzXG4gICAgICAgIGNvbnN0IE0gPSBNTE1hdHJpeC5tdWwoTUxNYXRyaXgucG93KGRpc3RhbmNlcywgMiksIC0wLjUpO1xuICAgICAgICAvLyBkb3VibGUgY2VudHJlIHRoZSByb3dzL2NvbHVtbnNcbiAgICAgICAgY29uc3Qgcm93TWVhbnMgPSBNLm1lYW4oJ3JvdycpO1xuICAgICAgICBjb25zdCBjb2xNZWFucyA9IE0ubWVhbignY29sdW1uJyk7XG4gICAgICAgIGNvbnN0IHRvdGFsTWVhbiA9IE0ubWVhbigpO1xuICAgICAgICBNLmFkZCh0b3RhbE1lYW4pLnN1YlJvd1ZlY3Rvcihyb3dNZWFucykuc3ViQ29sdW1uVmVjdG9yKGNvbE1lYW5zKTtcbiAgICAgICAgLy8gdGFrZSB0aGUgU1ZEIG9mIHRoZSBkb3VibGUgY2VudHJlZCBtYXRyaXgsIGFuZCByZXR1cm4gdGhlXG4gICAgICAgIC8vIHBvaW50cyBmcm9tIGl0XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBTaW5ndWxhclZhbHVlRGVjb21wb3NpdGlvbihNKTtcbiAgICAgICAgY29uc3QgZWlnZW5WYWx1ZXMgPSBNTE1hdHJpeC5zcXJ0KHJldC5kaWFnb25hbE1hdHJpeCkuZGlhZ29uYWwoKTtcbiAgICAgICAgcmV0dXJuIHJldC5sZWZ0U2luZ3VsYXJWZWN0b3JzLnRvSlNPTigpLm1hcCgocm93KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gTUxNYXRyaXgubXVsKFtyb3ddLCBbZWlnZW5WYWx1ZXNdKVxuICAgICAgICAgICAgICAgIC50b0pTT04oKVswXVxuICAgICAgICAgICAgICAgIC5zcGxpY2UoMCwgZGltZW5zaW9uKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaXN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLnJhbmRvbSgpICogbGlua0Rpc3RhbmNlO1xuICAgICAgICAgICAgY29uc3QgeSA9IE1hdGgucmFuZG9tKCkgKiBsaW5rRGlzdGFuY2U7XG4gICAgICAgICAgICByZXMucHVzaChbeCwgeV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1kcy5qcy5tYXAiLCJjb25zdCBTUEVFRF9ESVZJU09SID0gODAwO1xuY29uc3QgREVGQVVMVFNfTEFZT1VUX09QVElPTlMgPSB7XG4gICAgaXRlcmF0aW9uczogMTAsXG4gICAgaGVpZ2h0OiAxMCxcbiAgICB3aWR0aDogMTAsXG4gICAgc3BlZWQ6IDEwMCxcbiAgICBncmF2aXR5OiAxMCxcbiAgICBrOiA1LFxufTtcbmV4cG9ydCBjb25zdCByYWRpYWxOb25vdmVybGFwRm9yY2UgPSAoZ3JhcGgsIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBtZXJnZWRPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUU19MQVlPVVRfT1BUSU9OUyksIG9wdGlvbnMpO1xuICAgIGNvbnN0IHsgcG9zaXRpb25zLCBpdGVyYXRpb25zLCB3aWR0aCwgaywgc3BlZWQgPSAxMDAsIHN0cmljdFJhZGlhbCwgZm9jdXNJZHgsIHJhZGlpID0gW10sIG5vZGVTaXplRnVuYywgfSA9IG1lcmdlZE9wdGlvbnM7XG4gICAgY29uc3Qgbm9kZXMgPSBncmFwaC5nZXRBbGxOb2RlcygpO1xuICAgIGNvbnN0IGRpc3AgPSBbXTtcbiAgICBjb25zdCBtYXhEaXNwbGFjZSA9IHdpZHRoIC8gMTA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcbiAgICAgICAgcG9zaXRpb25zLmZvckVhY2goKF8sIGspID0+IHtcbiAgICAgICAgICAgIGRpc3Bba10gPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIOe7memHjeWPoOeahOiKgueCueWinuWKoOaWpeWKm1xuICAgICAgICBnZXRSZXB1bHNpb24obm9kZXMsIHBvc2l0aW9ucywgZGlzcCwgaywgcmFkaWksIG5vZGVTaXplRnVuYyk7XG4gICAgICAgIHVwZGF0ZVBvc2l0aW9ucyhwb3NpdGlvbnMsIGRpc3AsIHNwZWVkLCBzdHJpY3RSYWRpYWwsIGZvY3VzSWR4LCBtYXhEaXNwbGFjZSwgd2lkdGgsIHJhZGlpKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvc2l0aW9ucztcbn07XG5jb25zdCBnZXRSZXB1bHNpb24gPSAobm9kZXMsIHBvc2l0aW9ucywgZGlzcCwgaywgcmFkaWksIG5vZGVTaXplRnVuYykgPT4ge1xuICAgIHBvc2l0aW9ucy5mb3JFYWNoKCh2LCBpKSA9PiB7XG4gICAgICAgIGRpc3BbaV0gPSB7IHg6IDAsIHk6IDAgfTtcbiAgICAgICAgcG9zaXRpb25zLmZvckVhY2goKHUsIGopID0+IHtcbiAgICAgICAgICAgIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdiBhbmQgdSBhcmUgbm90IG9uIHRoZSBzYW1lIGNpcmNsZSwgcmV0dXJuXG4gICAgICAgICAgICBpZiAocmFkaWlbaV0gIT09IHJhZGlpW2pdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHZlY3ggPSB2LnggLSB1Lng7XG4gICAgICAgICAgICBsZXQgdmVjeSA9IHYueSAtIHUueTtcbiAgICAgICAgICAgIGxldCB2ZWNMZW5ndGggPSBNYXRoLnNxcnQodmVjeCAqIHZlY3ggKyB2ZWN5ICogdmVjeSk7XG4gICAgICAgICAgICBpZiAodmVjTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmVjTGVuZ3RoID0gMTtcbiAgICAgICAgICAgICAgICBjb25zdCBzaWduID0gaSA+IGogPyAxIDogLTE7XG4gICAgICAgICAgICAgICAgdmVjeCA9IDAuMDEgKiBzaWduO1xuICAgICAgICAgICAgICAgIHZlY3kgPSAwLjAxICogc2lnbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHRoZXNlIHR3byBub2RlcyBvdmVybGFwXG4gICAgICAgICAgICBpZiAodmVjTGVuZ3RoIDwgbm9kZVNpemVGdW5jKG5vZGVzW2ldKSAvIDIgKyBub2RlU2l6ZUZ1bmMobm9kZXNbal0pIC8gMikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbW1vbiA9IChrICogaykgLyB2ZWNMZW5ndGg7XG4gICAgICAgICAgICAgICAgZGlzcFtpXS54ICs9ICh2ZWN4IC8gdmVjTGVuZ3RoKSAqIGNvbW1vbjtcbiAgICAgICAgICAgICAgICBkaXNwW2ldLnkgKz0gKHZlY3kgLyB2ZWNMZW5ndGgpICogY29tbW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5jb25zdCB1cGRhdGVQb3NpdGlvbnMgPSAocG9zaXRpb25zLCBkaXNwLCBzcGVlZCwgc3RyaWN0UmFkaWFsLCBmb2N1c0lkeCwgbWF4RGlzcGxhY2UsIHdpZHRoLCByYWRpaSkgPT4ge1xuICAgIGNvbnN0IG1heERpc3AgPSBtYXhEaXNwbGFjZSB8fCB3aWR0aCAvIDEwO1xuICAgIGlmIChzdHJpY3RSYWRpYWwpIHtcbiAgICAgICAgZGlzcC5mb3JFYWNoKChkaSwgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdnggPSBwb3NpdGlvbnNbaV0ueCAtIHBvc2l0aW9uc1tmb2N1c0lkeF0ueDtcbiAgICAgICAgICAgIGNvbnN0IHZ5ID0gcG9zaXRpb25zW2ldLnkgLSBwb3NpdGlvbnNbZm9jdXNJZHhdLnk7XG4gICAgICAgICAgICBjb25zdCB2TGVuZ3RoID0gTWF0aC5zcXJ0KHZ4ICogdnggKyB2eSAqIHZ5KTtcbiAgICAgICAgICAgIGxldCB2cHggPSB2eSAvIHZMZW5ndGg7XG4gICAgICAgICAgICBsZXQgdnB5ID0gLXZ4IC8gdkxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGRpTGVuZ3RoID0gTWF0aC5zcXJ0KGRpLnggKiBkaS54ICsgZGkueSAqIGRpLnkpO1xuICAgICAgICAgICAgbGV0IGFscGhhID0gTWF0aC5hY29zKCh2cHggKiBkaS54ICsgdnB5ICogZGkueSkgLyBkaUxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoYWxwaGEgPiBNYXRoLlBJIC8gMikge1xuICAgICAgICAgICAgICAgIGFscGhhIC09IE1hdGguUEkgLyAyO1xuICAgICAgICAgICAgICAgIHZweCAqPSAtMTtcbiAgICAgICAgICAgICAgICB2cHkgKj0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ZGlzcExlbmd0aCA9IE1hdGguY29zKGFscGhhKSAqIGRpTGVuZ3RoO1xuICAgICAgICAgICAgZGkueCA9IHZweCAqIHRkaXNwTGVuZ3RoO1xuICAgICAgICAgICAgZGkueSA9IHZweSAqIHRkaXNwTGVuZ3RoO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gbW92ZVxuICAgIHBvc2l0aW9ucy5mb3JFYWNoKChuLCBpKSA9PiB7XG4gICAgICAgIGlmIChpID09PSBmb2N1c0lkeCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpc3RMZW5ndGggPSBNYXRoLnNxcnQoZGlzcFtpXS54ICogZGlzcFtpXS54ICsgZGlzcFtpXS55ICogZGlzcFtpXS55KTtcbiAgICAgICAgaWYgKGRpc3RMZW5ndGggPiAwICYmIGkgIT09IGZvY3VzSWR4KSB7XG4gICAgICAgICAgICBjb25zdCBsaW1pdGVkRGlzdCA9IE1hdGgubWluKG1heERpc3AgKiAoc3BlZWQgLyBTUEVFRF9ESVZJU09SKSwgZGlzdExlbmd0aCk7XG4gICAgICAgICAgICBuLnggKz0gKGRpc3BbaV0ueCAvIGRpc3RMZW5ndGgpICogbGltaXRlZERpc3Q7XG4gICAgICAgICAgICBuLnkgKz0gKGRpc3BbaV0ueSAvIGRpc3RMZW5ndGgpICogbGltaXRlZERpc3Q7XG4gICAgICAgICAgICBpZiAoc3RyaWN0UmFkaWFsKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZ4ID0gbi54IC0gcG9zaXRpb25zW2ZvY3VzSWR4XS54O1xuICAgICAgICAgICAgICAgIGxldCB2eSA9IG4ueSAtIHBvc2l0aW9uc1tmb2N1c0lkeF0ueTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZkRpcyA9IE1hdGguc3FydCh2eCAqIHZ4ICsgdnkgKiB2eSk7XG4gICAgICAgICAgICAgICAgdnggPSAodnggLyBuZkRpcykgKiByYWRpaVtpXTtcbiAgICAgICAgICAgICAgICB2eSA9ICh2eSAvIG5mRGlzKSAqIHJhZGlpW2ldO1xuICAgICAgICAgICAgICAgIG4ueCA9IHBvc2l0aW9uc1tmb2N1c0lkeF0ueCArIHZ4O1xuICAgICAgICAgICAgICAgIG4ueSA9IHBvc2l0aW9uc1tmb2N1c0lkeF0ueSArIHZ5O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHBvc2l0aW9ucztcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYWRpYWwtbm9ub3ZlcmxhcC1mb3JjZS5qcy5tYXAiLCJpbXBvcnQgeyBfX2F3YWl0ZXIgfSBmcm9tIFwidHNsaWJcIjtcbmNvbnN0IERFRkFVTFRTX0xBWU9VVF9PUFRJT05TID0ge1xuICAgIGNlbnRlcjogWzAsIDBdLFxuICAgIHdpZHRoOiAzMDAsXG4gICAgaGVpZ2h0OiAzMDAsXG59O1xuLyoqXG4gKiA8emgvPiDpmo/mnLrluIPlsYBcbiAqXG4gKiA8ZW4vPiBSYW5kb20gbGF5b3V0XG4gKi9cbmV4cG9ydCBjbGFzcyBSYW5kb21MYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmlkID0gJ3JhbmRvbSc7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVFNfTEFZT1VUX09QVElPTlMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBwb3NpdGlvbnMgb2Ygbm9kZXMgYW5kIGVkZ2VzKGlmIG5lZWRlZCkuXG4gICAgICovXG4gICAgZXhlY3V0ZShncmFwaCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJpY1JhbmRvbUxheW91dChmYWxzZSwgZ3JhcGgsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG8gZGlyZWN0bHkgYXNzaWduIHRoZSBwb3NpdGlvbnMgdG8gdGhlIG5vZGVzLlxuICAgICAqL1xuICAgIGFzc2lnbihncmFwaCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZW5lcmljUmFuZG9tTGF5b3V0KHRydWUsIGdyYXBoLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdlbmVyaWNSYW5kb21MYXlvdXQoYXNzaWduLCBncmFwaCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICBjb25zdCB7IGNlbnRlcjogcHJvcHNDZW50ZXIsIHdpZHRoOiBwcm9wc1dpZHRoLCBoZWlnaHQ6IHByb3BzSGVpZ2h0LCB9ID0gbWVyZ2VkT3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gZ3JhcGguZ2V0QWxsTm9kZXMoKTtcbiAgICAgICAgICAgIGNvbnN0IGxheW91dFNjYWxlID0gMC45O1xuICAgICAgICAgICAgY29uc3Qgd2lkdGggPSAhcHJvcHNXaWR0aCAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAgID8gd2luZG93LmlubmVyV2lkdGhcbiAgICAgICAgICAgICAgICA6IHByb3BzV2lkdGg7XG4gICAgICAgICAgICBjb25zdCBoZWlnaHQgPSAhcHJvcHNIZWlnaHQgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/IHdpbmRvdy5pbm5lckhlaWdodFxuICAgICAgICAgICAgICAgIDogcHJvcHNIZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBjZW50ZXIgPSAhcHJvcHNDZW50ZXJcbiAgICAgICAgICAgICAgICA/IFt3aWR0aCAvIDIsIGhlaWdodCAvIDJdXG4gICAgICAgICAgICAgICAgOiBwcm9wc0NlbnRlcjtcbiAgICAgICAgICAgIGNvbnN0IGxheW91dE5vZGVzID0gW107XG4gICAgICAgICAgICBpZiAobm9kZXMpIHtcbiAgICAgICAgICAgICAgICBub2Rlcy5mb3JFYWNoKChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxheW91dE5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogKE1hdGgucmFuZG9tKCkgLSAwLjUpICogbGF5b3V0U2NhbGUgKiB3aWR0aCArIGNlbnRlclswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiAoTWF0aC5yYW5kb20oKSAtIDAuNSkgKiBsYXlvdXRTY2FsZSAqIGhlaWdodCArIGNlbnRlclsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFzc2lnbikge1xuICAgICAgICAgICAgICAgIGxheW91dE5vZGVzLmZvckVhY2goKG5vZGUpID0+IGdyYXBoLm1lcmdlTm9kZURhdGEobm9kZS5pZCwge1xuICAgICAgICAgICAgICAgICAgICB4OiBub2RlLmRhdGEueCxcbiAgICAgICAgICAgICAgICAgICAgeTogbm9kZS5kYXRhLnksXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgICAgIG5vZGVzOiBsYXlvdXROb2RlcyxcbiAgICAgICAgICAgICAgICBlZGdlczogZ3JhcGguZ2V0QWxsRWRnZXMoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYW5kb20uanMubWFwIiwiaW1wb3J0IHsgQW50VkRhZ3JlTGF5b3V0IH0gZnJvbSAnLi9hbnR2LWRhZ3JlJztcbmltcG9ydCB7IENpcmN1bGFyTGF5b3V0IH0gZnJvbSAnLi9jaXJjdWxhcic7XG5pbXBvcnQgeyBDb21ib0NvbWJpbmVkTGF5b3V0IH0gZnJvbSAnLi9jb21iby1jb21iaW5lZCc7XG5pbXBvcnQgeyBDb25jZW50cmljTGF5b3V0IH0gZnJvbSAnLi9jb25jZW50cmljJztcbmltcG9ydCB7IEQzRm9yY2VMYXlvdXQgfSBmcm9tICcuL2QzLWZvcmNlJztcbmltcG9ydCB7IEQzRm9yY2UzRExheW91dCB9IGZyb20gJy4vZDMtZm9yY2UtM2QnO1xuaW1wb3J0IHsgRGFncmVMYXlvdXQgfSBmcm9tICcuL2RhZ3JlJztcbmltcG9ydCB7IEZvcmNlTGF5b3V0IH0gZnJvbSAnLi9mb3JjZSc7XG5pbXBvcnQgeyBGb3JjZUF0bGFzMkxheW91dCB9IGZyb20gJy4vZm9yY2UtYXRsYXMyJztcbmltcG9ydCB7IEZydWNodGVybWFuTGF5b3V0IH0gZnJvbSAnLi9mcnVjaHRlcm1hbic7XG5pbXBvcnQgeyBHcmlkTGF5b3V0IH0gZnJvbSAnLi9ncmlkJztcbmltcG9ydCB7IE1EU0xheW91dCB9IGZyb20gJy4vbWRzJztcbmltcG9ydCB7IFJhZGlhbExheW91dCB9IGZyb20gJy4vcmFkaWFsJztcbmltcG9ydCB7IFJhbmRvbUxheW91dCB9IGZyb20gJy4vcmFuZG9tJztcbmV4cG9ydCBjb25zdCByZWdpc3RyeSA9IHtcbiAgICBjaXJjdWxhcjogQ2lyY3VsYXJMYXlvdXQsXG4gICAgY29uY2VudHJpYzogQ29uY2VudHJpY0xheW91dCxcbiAgICBtZHM6IE1EU0xheW91dCxcbiAgICByYW5kb206IFJhbmRvbUxheW91dCxcbiAgICBncmlkOiBHcmlkTGF5b3V0LFxuICAgIHJhZGlhbDogUmFkaWFsTGF5b3V0LFxuICAgIGZvcmNlOiBGb3JjZUxheW91dCxcbiAgICBkM2ZvcmNlOiBEM0ZvcmNlTGF5b3V0LFxuICAgICdkMy1mb3JjZS0zZCc6IEQzRm9yY2UzRExheW91dCxcbiAgICBmcnVjaHRlcm1hbjogRnJ1Y2h0ZXJtYW5MYXlvdXQsXG4gICAgZm9yY2VBdGxhczI6IEZvcmNlQXRsYXMyTGF5b3V0LFxuICAgIGRhZ3JlOiBEYWdyZUxheW91dCxcbiAgICBhbnR2RGFncmU6IEFudFZEYWdyZUxheW91dCxcbiAgICBjb21ib0NvbWJpbmVkOiBDb21ib0NvbWJpbmVkTGF5b3V0LFxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZ2lzdHJ5LmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBpc0xheW91dFdpdGhJdGVyYXRpb25zKGxheW91dCkge1xuICAgIHJldHVybiAhIWxheW91dC50aWNrICYmICEhbGF5b3V0LnN0b3A7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlcy5qcy5tYXAiLCJleHBvcnQgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS5qcy5tYXAiLCIvKipcbiAqIEFzc2lnbiBvciBvbmx5IHJldHVybiB0aGUgcmVzdWx0IGZvciB0aGUgZ3JhcGggd2hvIGhhcyBubyBub2RlcyBvciBvbmx5IG9uZSBub2RlLlxuICogQHBhcmFtIGdyYXBoIG9yaWdpbmFsIGdyYXBoXG4gKiBAcGFyYW0gYXNzaWduIHdoZXRoZXIgYXNzaWduIHJlc3VsdCB0byBvcmlnaW5hbCBncmFwaFxuICogQHBhcmFtIGNlbnRlciB0aGUgbGF5b3V0IGNlbnRlclxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGNvbnN0IGhhbmRsZVNpbmdsZU5vZGVHcmFwaCA9IChncmFwaCwgYXNzaWduLCBjZW50ZXIpID0+IHtcbiAgICBjb25zdCBub2RlcyA9IGdyYXBoLmdldEFsbE5vZGVzKCk7XG4gICAgY29uc3QgZWRnZXMgPSBncmFwaC5nZXRBbGxFZGdlcygpO1xuICAgIGlmICghKG5vZGVzID09PSBudWxsIHx8IG5vZGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2Rlcy5sZW5ndGgpKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgbm9kZXM6IFtdLCBlZGdlcyB9O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBpZiAobm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChhc3NpZ24pIHtcbiAgICAgICAgICAgIGdyYXBoLm1lcmdlTm9kZURhdGEobm9kZXNbMF0uaWQsIHtcbiAgICAgICAgICAgICAgICB4OiBjZW50ZXJbMF0sXG4gICAgICAgICAgICAgICAgeTogY2VudGVyWzFdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgbm9kZXM6IFtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG5vZGVzWzBdKSwgeyBkYXRhOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG5vZGVzWzBdLmRhdGEpLCB7IHg6IGNlbnRlclswXSwgeTogY2VudGVyWzFdIH0pIH0pLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGVkZ2VzLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tb24uanMubWFwIiwiaW1wb3J0IHsgaXNGdW5jdGlvbiwgaXNOdW1iZXIsIGlzT2JqZWN0IH0gZnJvbSAnQGFudHYvdXRpbCc7XG5pbXBvcnQgeyBwYXJzZVNpemUgfSBmcm9tICcuL3NpemUnO1xuLyoqXG4gKiBGb3JtYXQgdmFsdWUgd2l0aCBtdWx0aXBsZSB0eXBlcyBpbnRvIGEgZnVuY3Rpb24gcmV0dXJucyBudW1iZXIuXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIGRlZmF1bHQgdmFsdWUgd2hlbiB2YWx1ZSBpcyBpbnZhbGlkXG4gKiBAcGFyYW0gdmFsdWUgdmFsdWUgdG8gYmUgZm9ybWF0dGVkXG4gKiBAcmV0dXJucyBmb3JtYXR0ZWQgcmVzdWx0LCBhIGZ1bmN0aW9uIHJldHVybnMgbnVtYmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXROdW1iZXJGbihkZWZhdWx0VmFsdWUsIHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdEZ1bmM7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdEZ1bmMgPSB2YWx1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNOdW1iZXIodmFsdWUpKSB7XG4gICAgICAgIC8vIHZhbHVlIGlzIG51bWJlclxuICAgICAgICByZXN1bHRGdW5jID0gKCkgPT4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyB2YWx1ZSBpcyBub3QgbnVtYmVyIGFuZCBmdW5jdGlvblxuICAgICAgICByZXN1bHRGdW5jID0gKCkgPT4gZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0RnVuYztcbn1cbi8qKlxuICogRm9ybWF0IHNpemUgY29uZmlnIHdpdGggbXVsdGlwbGUgdHlwZXMgaW50byBhIGZ1bmN0aW9uIHJldHVybnMgbnVtYmVyXG4gKiBAcGFyYW0gZGVmYXVsdFZhbHVlIGRlZmF1bHQgdmFsdWUgd2hlbiB2YWx1ZSBpcyBpbnZhbGlkXG4gKiBAcGFyYW0gdmFsdWUgdmFsdWUgdG8gYmUgZm9ybWF0dGVkXG4gKiBAcGFyYW0gcmVzdWx0SXNOdW1iZXIgd2hldGhlciByZXR1cm5zIG51bWJlclxuICogQHJldHVybnMgZm9ybWF0dGVkIHJlc3VsdCwgYSBmdW5jdGlvbiByZXR1cm5zIG51bWJlclxuICovXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0U2l6ZUZuKGRlZmF1bHRWYWx1ZSwgdmFsdWUsIHJlc3VsdElzTnVtYmVyID0gdHJ1ZSkge1xuICAgIGlmICghdmFsdWUgJiYgdmFsdWUgIT09IDApIHtcbiAgICAgICAgcmV0dXJuIChkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHNpemUgfSA9IGQuZGF0YSB8fCB7fTtcbiAgICAgICAgICAgIGlmIChzaXplKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2l6ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRJc051bWJlciA/IE1hdGgubWF4KC4uLnNpemUpIHx8IGRlZmF1bHRWYWx1ZSA6IHNpemU7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHNpemUpICYmXG4gICAgICAgICAgICAgICAgICAgIHNpemUud2lkdGggJiZcbiAgICAgICAgICAgICAgICAgICAgc2l6ZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdElzTnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IE1hdGgubWF4KHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KSB8fCBkZWZhdWx0VmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogW3NpemUud2lkdGgsIHNpemUuaGVpZ2h0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBpZiAoaXNOdW1iZXIodmFsdWUpKVxuICAgICAgICByZXR1cm4gKCkgPT4gdmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzdWx0SXNOdW1iZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KC4uLnZhbHVlKSB8fCBkZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChpc09iamVjdCh2YWx1ZSkgJiYgdmFsdWUud2lkdGggJiYgdmFsdWUuaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzdWx0SXNOdW1iZXIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHZhbHVlLndpZHRoLCB2YWx1ZS5oZWlnaHQpIHx8IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBbdmFsdWUud2lkdGgsIHZhbHVlLmhlaWdodF07XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiBkZWZhdWx0VmFsdWU7XG59XG4vKipcbiAqIGZvcm1hdCB0aGUgcHJvcHMgbm9kZVNpemUgYW5kIG5vZGVTcGFjaW5nIHRvIGEgZnVuY3Rpb25cbiAqIEBwYXJhbSBub2RlU2l6ZVxuICogQHBhcmFtIG5vZGVTcGFjaW5nXG4gKiBAcmV0dXJuc1xuICovXG5leHBvcnQgY29uc3QgZm9ybWF0Tm9kZVNpemVUb051bWJlciA9IChub2RlU2l6ZSwgbm9kZVNwYWNpbmcsIGRlZmF1bHROb2RlU2l6ZSA9IDEwKSA9PiB7XG4gICAgbGV0IG5vZGVTaXplRnVuYztcbiAgICBjb25zdCBub2RlU3BhY2luZ0Z1bmMgPSB0eXBlb2Ygbm9kZVNwYWNpbmcgPT09ICdmdW5jdGlvbicgPyBub2RlU3BhY2luZyA6ICgpID0+IG5vZGVTcGFjaW5nIHx8IDA7XG4gICAgaWYgKCFub2RlU2l6ZSkge1xuICAgICAgICBub2RlU2l6ZUZ1bmMgPSAoZCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBpZiAoKF9hID0gZC5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYmJveFNpemUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIChfYiA9IGQuZGF0YSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmJib3hTaXplO1xuICAgICAgICAgICAgaWYgKChfYyA9IGQuZGF0YSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNpemUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhU2l6ZSA9IGQuZGF0YS5zaXplO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFTaXplKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFTaXplO1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChkYXRhU2l6ZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbZGF0YVNpemUud2lkdGgsIGRhdGFTaXplLmhlaWdodF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGFTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHROb2RlU2l6ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShub2RlU2l6ZSkpIHtcbiAgICAgICAgbm9kZVNpemVGdW5jID0gKGQpID0+IG5vZGVTaXplO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Z1bmN0aW9uKG5vZGVTaXplKSkge1xuICAgICAgICBub2RlU2l6ZUZ1bmMgPSBub2RlU2l6ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vZGVTaXplRnVuYyA9IChkKSA9PiBub2RlU2l6ZTtcbiAgICB9XG4gICAgY29uc3QgZnVuYyA9IChkKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGVTaXplID0gbm9kZVNpemVGdW5jKGQpO1xuICAgICAgICBjb25zdCBub2RlU3BhY2luZyA9IG5vZGVTcGFjaW5nRnVuYyhkKTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KC4uLnBhcnNlU2l6ZShub2RlU2l6ZSkpICsgbm9kZVNwYWNpbmc7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuYztcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mdW5jdGlvbi5qcy5tYXAiLCJpbXBvcnQgeyBpc051bWJlciB9IGZyb20gJ0BhbnR2L3V0aWwnO1xuaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJy4vYXJyYXknO1xuZXhwb3J0IGNvbnN0IGZsb3lkV2Fyc2hhbGwgPSAoYWRqTWF0cml4KSA9PiB7XG4gICAgLy8gaW5pdGlhbGl6ZVxuICAgIGNvbnN0IGRpc3QgPSBbXTtcbiAgICBjb25zdCBzaXplID0gYWRqTWF0cml4Lmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNpemU7IGkgKz0gMSkge1xuICAgICAgICBkaXN0W2ldID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2l6ZTsgaiArPSAxKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gaikge1xuICAgICAgICAgICAgICAgIGRpc3RbaV1bal0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYWRqTWF0cml4W2ldW2pdID09PSAwIHx8ICFhZGpNYXRyaXhbaV1bal0pIHtcbiAgICAgICAgICAgICAgICBkaXN0W2ldW2pdID0gSW5maW5pdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXN0W2ldW2pdID0gYWRqTWF0cml4W2ldW2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGZsb3lkXG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBzaXplOyBrICs9IDEpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2l6ZTsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRpc3RbaV1bal0gPiBkaXN0W2ldW2tdICsgZGlzdFtrXVtqXSkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0W2ldW2pdID0gZGlzdFtpXVtrXSArIGRpc3Rba11bal07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaXN0O1xufTtcbmV4cG9ydCBjb25zdCBnZXRBZGpNYXRyaXggPSAoZGF0YSwgZGlyZWN0ZWQpID0+IHtcbiAgICBjb25zdCB7IG5vZGVzLCBlZGdlcyB9ID0gZGF0YTtcbiAgICBjb25zdCBtYXRyaXggPSBbXTtcbiAgICAvLyBtYXAgbm9kZSB3aXRoIGluZGV4IGluIGRhdGEubm9kZXNcbiAgICBjb25zdCBub2RlTWFwID0ge307XG4gICAgaWYgKCFub2Rlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbm9kZXMgZGF0YSEnKTtcbiAgICB9XG4gICAgaWYgKG5vZGVzKSB7XG4gICAgICAgIG5vZGVzLmZvckVhY2goKG5vZGUsIGkpID0+IHtcbiAgICAgICAgICAgIG5vZGVNYXBbbm9kZS5pZF0gPSBpO1xuICAgICAgICAgICAgY29uc3Qgcm93ID0gW107XG4gICAgICAgICAgICBtYXRyaXgucHVzaChyb3cpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWRnZXMgPT09IG51bGwgfHwgZWRnZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVkZ2VzLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgY29uc3QgeyBzb3VyY2UsIHRhcmdldCB9ID0gZTtcbiAgICAgICAgY29uc3Qgc0luZGV4ID0gbm9kZU1hcFtzb3VyY2VdO1xuICAgICAgICBjb25zdCB0SW5kZXggPSBub2RlTWFwW3RhcmdldF07XG4gICAgICAgIGlmIChzSW5kZXggPT09IHVuZGVmaW5lZCB8fCB0SW5kZXggPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbWF0cml4W3NJbmRleF1bdEluZGV4XSA9IDE7XG4gICAgICAgIGlmICghZGlyZWN0ZWQpIHtcbiAgICAgICAgICAgIG1hdHJpeFt0SW5kZXhdW3NJbmRleF0gPSAxO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hdHJpeDtcbn07XG4vKipcbiAqIHNjYWxlIG1hdHJpeFxuICogQHBhcmFtIG1hdHJpeCBbIFtdLCBbXSwgW10gXVxuICogQHBhcmFtIHJhdGlvXG4gKi9cbmV4cG9ydCBjb25zdCBzY2FsZU1hdHJpeCA9IChtYXRyaXgsIHJhdGlvKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgbWF0cml4LmZvckVhY2goKHJvdykgPT4ge1xuICAgICAgICBjb25zdCBuZXdSb3cgPSBbXTtcbiAgICAgICAgcm93LmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgICAgIG5ld1Jvdy5wdXNoKHYgKiByYXRpbyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHQucHVzaChuZXdSb3cpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIGJvdW5kaW5nIGJveCBmb3IgdGhlIG5vZGVzIGFjY29yZGluZyB0byB0aGVpciB4LCB5LCBhbmQgc2l6ZVxuICogQHBhcmFtIG5vZGVzIG5vZGVzIGluIHRoZSBsYXlvdXRcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRMYXlvdXRCQm94ID0gKG5vZGVzKSA9PiB7XG4gICAgbGV0IG1pblggPSBJbmZpbml0eTtcbiAgICBsZXQgbWluWSA9IEluZmluaXR5O1xuICAgIGxldCBtYXhYID0gLUluZmluaXR5O1xuICAgIGxldCBtYXhZID0gLUluZmluaXR5O1xuICAgIG5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgbGV0IHNpemUgPSBub2RlLmRhdGEuc2l6ZTtcbiAgICAgICAgaWYgKGlzQXJyYXkoc2l6ZSkpIHtcbiAgICAgICAgICAgIGlmIChzaXplLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICBzaXplID0gW3NpemVbMF0sIHNpemVbMF1dO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTnVtYmVyKHNpemUpKSB7XG4gICAgICAgICAgICBzaXplID0gW3NpemUsIHNpemVdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNpemUgPT09IHVuZGVmaW5lZCB8fCBpc05hTihzaXplKSkge1xuICAgICAgICAgICAgc2l6ZSA9IFszMCwgMzBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhbGZTaXplID0gW3NpemVbMF0gLyAyLCBzaXplWzFdIC8gMl07XG4gICAgICAgIGNvbnN0IGxlZnQgPSBub2RlLmRhdGEueCAtIGhhbGZTaXplWzBdO1xuICAgICAgICBjb25zdCByaWdodCA9IG5vZGUuZGF0YS54ICsgaGFsZlNpemVbMF07XG4gICAgICAgIGNvbnN0IHRvcCA9IG5vZGUuZGF0YS55IC0gaGFsZlNpemVbMV07XG4gICAgICAgIGNvbnN0IGJvdHRvbSA9IG5vZGUuZGF0YS55ICsgaGFsZlNpemVbMV07XG4gICAgICAgIGlmIChtaW5YID4gbGVmdClcbiAgICAgICAgICAgIG1pblggPSBsZWZ0O1xuICAgICAgICBpZiAobWluWSA+IHRvcClcbiAgICAgICAgICAgIG1pblkgPSB0b3A7XG4gICAgICAgIGlmIChtYXhYIDwgcmlnaHQpXG4gICAgICAgICAgICBtYXhYID0gcmlnaHQ7XG4gICAgICAgIGlmIChtYXhZIDwgYm90dG9tKVxuICAgICAgICAgICAgbWF4WSA9IGJvdHRvbTtcbiAgICB9KTtcbiAgICByZXR1cm4geyBtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZIH07XG59O1xuLyoqXG4gKiBjYWxjdWxhdGUgdGhlIGV1Y2xpZGVhbiBkaXN0YW5jZSBmb3JtIHAxIHRvIHAyXG4gKiBAcGFyYW0gcDFcbiAqIEBwYXJhbSBwMlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGNvbnN0IGdldEV1Y2xpZGVhbkRpc3RhbmNlID0gKHAxLCBwMikgPT4gTWF0aC5zcXJ0KChwMS54IC0gcDIueCkgKiAocDEueCAtIHAyLngpICsgKHAxLnkgLSBwMi55KSAqIChwMS55IC0gcDIueSkpO1xuLyoqXG4gKiBEZXB0aCBmaXJzdCBzZWFyY2ggYmVnaW4gZnJvbSBub2RlcyBpbiBncmFwaENvcmUgZGF0YS5cbiAqIEBwYXJhbSBncmFwaENvcmUgZ3JhcGhsaWIgZGF0YSBzdHJ1Y3R1cmVcbiAqIEBwYXJhbSBub2RlcyBiZWdpbiBub2Rlc1xuICogQHBhcmFtIGZuIHdpbGwgYmUgY2FsbGVkIHdoaWxlIHZpc2l0aW5nIGVhY2ggbm9kZVxuICogQHBhcmFtIG1vZGUgJ1RCJyAtIHZpc2l0IGZyb20gdG9wIHRvIGJvdHRvbTsgJ0JUJyAtIHZpc2l0IGZyb20gYm90dG9tIHRvIHRvcDtcbiAqIEByZXR1cm5zXG4gKi9cbmV4cG9ydCBjb25zdCBncmFwaFRyZWVEZnMgPSAoZ3JhcGgsIG5vZGVzLCBmbiwgbW9kZSA9ICdUQicsIHRyZWVLZXksIHN0b3BGbnMgPSB7fSkgPT4ge1xuICAgIGlmICghKG5vZGVzID09PSBudWxsIHx8IG5vZGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2Rlcy5sZW5ndGgpKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgeyBzdG9wQnJhbmNoRm4sIHN0b3BBbGxGbiB9ID0gc3RvcEZucztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKCFncmFwaC5oYXNOb2RlKG5vZGUuaWQpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChzdG9wQnJhbmNoRm4gPT09IG51bGwgfHwgc3RvcEJyYW5jaEZuID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdG9wQnJhbmNoRm4obm9kZSkpXG4gICAgICAgICAgICBjb250aW51ZTsgLy8gU3RvcCB0aGlzIGJyYW5jaFxuICAgICAgICBpZiAoc3RvcEFsbEZuID09PSBudWxsIHx8IHN0b3BBbGxGbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RvcEFsbEZuKG5vZGUpKVxuICAgICAgICAgICAgcmV0dXJuOyAvLyBTdG9wIGFsbFxuICAgICAgICBpZiAobW9kZSA9PT0gJ1RCJylcbiAgICAgICAgICAgIGZuKG5vZGUpOyAvLyBUcmF2ZXJzZSBmcm9tIHRvcCB0byBib3R0b21cbiAgICAgICAgZ3JhcGhUcmVlRGZzKGdyYXBoLCBncmFwaC5nZXRDaGlsZHJlbihub2RlLmlkLCB0cmVlS2V5KSwgZm4sIG1vZGUsIHRyZWVLZXksIHN0b3BGbnMpO1xuICAgICAgICBpZiAobW9kZSAhPT0gJ1RCJylcbiAgICAgICAgICAgIGZuKG5vZGUpOyAvLyBUcmF2ZXJzZSBmcm9tIGJvdHRvbSB0byB0b3BcbiAgICB9XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0aC5qcy5tYXAiLCJpbXBvcnQgeyBpc051bWJlciB9IGZyb20gJ0BhbnR2L3V0aWwnO1xuZXhwb3J0IGNvbnN0IGNsb25lID0gKHRhcmdldCkgPT4ge1xuICAgIGlmICh0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG4gICAgaWYgKHRhcmdldCBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRhcmdldC5nZXRUaW1lKCkpO1xuICAgIH1cbiAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgY29uc3QgY3AgPSBbXTtcbiAgICAgICAgdGFyZ2V0LmZvckVhY2goKHYpID0+IHtcbiAgICAgICAgICAgIGNwLnB1c2godik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY3AubWFwKChuKSA9PiBjbG9uZShuKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICBjb25zdCBjcCA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyh0YXJnZXQpLmZvckVhY2goKGspID0+IHtcbiAgICAgICAgICAgIGNwW2tdID0gY2xvbmUodGFyZ2V0W2tdKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjcDtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn07XG4vKipcbiAqIENsb25lIG5vZGUgb3IgZWRnZSBkYXRhIGFuZCBmb3JtYXQgaXRcbiAqIEBwYXJhbSB0YXJnZXQgbm9kZS9lZGdlIHRvIGJlIGNsb25lZFxuICogQHBhcmFtIGluaXRSYW5nZSB3aGV0aGVyIGluaXQgdGhlIHggYW5kIHkgaW4gZGF0YSB3aXRoIHRoZSByYW5nZSwgd2hpY2ggbWVhbnMgW3hSYW5nZSwgeVJhbmdlXVxuICogQHJldHVybnMgY2xvbmVkIG5vZGUvZWRnZVxuICovXG5leHBvcnQgY29uc3QgY2xvbmVGb3JtYXREYXRhID0gKHRhcmdldCwgaW5pdFJhbmdlKSA9PiB7XG4gICAgY29uc3QgY2xvbmVkID0gY2xvbmUodGFyZ2V0KTtcbiAgICBjbG9uZWQuZGF0YSA9IGNsb25lZC5kYXRhIHx8IHt9O1xuICAgIGlmIChpbml0UmFuZ2UpIHtcbiAgICAgICAgaWYgKCFpc051bWJlcihjbG9uZWQuZGF0YS54KSlcbiAgICAgICAgICAgIGNsb25lZC5kYXRhLnggPSBNYXRoLnJhbmRvbSgpICogaW5pdFJhbmdlWzBdO1xuICAgICAgICBpZiAoIWlzTnVtYmVyKGNsb25lZC5kYXRhLnkpKVxuICAgICAgICAgICAgY2xvbmVkLmRhdGEueSA9IE1hdGgucmFuZG9tKCkgKiBpbml0UmFuZ2VbMV07XG4gICAgfVxuICAgIHJldHVybiBjbG9uZWQ7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JqZWN0LmpzLm1hcCIsImltcG9ydCB7IGlzTnVtYmVyIH0gZnJvbSAnQGFudHYvdXRpbCc7XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTaXplKHNpemUpIHtcbiAgICBpZiAoIXNpemUpXG4gICAgICAgIHJldHVybiBbMCwgMCwgMF07XG4gICAgaWYgKGlzTnVtYmVyKHNpemUpKVxuICAgICAgICByZXR1cm4gW3NpemUsIHNpemUsIHNpemVdO1xuICAgIGVsc2UgaWYgKHNpemUubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gWzAsIDAsIDBdO1xuICAgIGNvbnN0IFt4LCB5ID0geCwgeiA9IHhdID0gc2l6ZTtcbiAgICByZXR1cm4gW3gsIHksIHpdO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2l6ZS5qcy5tYXAiLCJpbXBvcnQgaXNBcnJheSBmcm9tICcuL2lzLWFycmF5JztcbnZhciBjbG9uZSA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHZhciByc3Q7XG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xuICAgICAgICByc3QgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9ialtpXSA9PT0gJ29iamVjdCcgJiYgb2JqW2ldICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByc3RbaV0gPSBjbG9uZShvYmpbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcnN0W2ldID0gb2JqW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByc3QgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqW2tdID09PSAnb2JqZWN0JyAmJiBvYmpba10gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJzdFtrXSA9IGNsb25lKG9ialtrXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByc3Rba10gPSBvYmpba107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJzdDtcbn07XG5leHBvcnQgZGVmYXVsdCBjbG9uZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsb25lLmpzLm1hcCIsImltcG9ydCBpc0FycmF5IGZyb20gJy4vaXMtYXJyYXknO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnLi9pcy1wbGFpbi1vYmplY3QnO1xudmFyIE1BWF9NSVhfTEVWRUwgPSA1O1xuZnVuY3Rpb24gaGFzT3duKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICBpZiAoT2JqZWN0Lmhhc093bikge1xuICAgICAgICByZXR1cm4gT2JqZWN0Lmhhc093bihvYmplY3QsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjb252ZXJ0IHVuZGVmaW5lZCBvciBudWxsIHRvIG9iamVjdCcpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKE9iamVjdChvYmplY3QpLCBwcm9wZXJ0eSk7XG59XG5mdW5jdGlvbiBfZGVlcE1peChkaXN0LCBzcmMsIGxldmVsLCBtYXhMZXZlbCkge1xuICAgIGxldmVsID0gbGV2ZWwgfHwgMDtcbiAgICBtYXhMZXZlbCA9IG1heExldmVsIHx8IE1BWF9NSVhfTEVWRUw7XG4gICAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgICAgICBpZiAoaGFzT3duKHNyYywga2V5KSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gc3JjW2tleV07XG4gICAgICAgICAgICBpZiAodmFsdWUgIT09IG51bGwgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUGxhaW5PYmplY3QoZGlzdFtrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0W2tleV0gPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxldmVsIDwgbWF4TGV2ZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgX2RlZXBNaXgoZGlzdFtrZXldLCB2YWx1ZSwgbGV2ZWwgKyAxLCBtYXhMZXZlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkaXN0W2tleV0gPSBzcmNba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGRpc3Rba2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgIGRpc3Rba2V5XSA9IGRpc3Rba2V5XS5jb25jYXQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGRpc3Rba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8gdG9kbyDph43lhplcbnZhciBkZWVwTWl4ID0gZnVuY3Rpb24gKHJzdCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIF9kZWVwTWl4KHJzdCwgYXJnc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByc3Q7XG59O1xuZXhwb3J0IGRlZmF1bHQgZGVlcE1peDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlZXAtbWl4LmpzLm1hcCIsImltcG9ydCBpc0FycmF5IGZyb20gJy4vaXMtYXJyYXknO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJy4vaXMtb2JqZWN0JztcbmZ1bmN0aW9uIGVhY2goZWxlbWVudHMsIGZ1bmMpIHtcbiAgICBpZiAoIWVsZW1lbnRzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJzdDtcbiAgICBpZiAoaXNBcnJheShlbGVtZW50cykpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICByc3QgPSBmdW5jKGVsZW1lbnRzW2ldLCBpKTtcbiAgICAgICAgICAgIGlmIChyc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNPYmplY3QoZWxlbWVudHMpKSB7XG4gICAgICAgIGZvciAodmFyIGsgaW4gZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50cy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgIHJzdCA9IGZ1bmMoZWxlbWVudHNba10sIGspO1xuICAgICAgICAgICAgICAgIGlmIChyc3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IGVhY2g7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lYWNoLmpzLm1hcCIsIi8qKlxuICog5Yik5pat5YC85piv5ZCm5Li65pWw57uEXG4gKiBAcmV0dXJuIOaYr+WQpuS4uuaVsOe7hFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc0FycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtYXJyYXkuanMubWFwIiwiLyoqXG4gKiDliKTmlq3lgLzmmK/lkKbkuLrlh73mlbBcbiAqIEByZXR1cm4g5piv5ZCm5Li65Ye95pWwXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtZnVuY3Rpb24uanMubWFwIiwiLyoqXG4gKiDliKTmlq3lgLzmmK/lkKbkuLogbnVsbCDmiJYgdW5kZWZpbmVkXG4gKiBAcmV0dXJuIOaYr+WQpuS4uiBudWxsIOaIliB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNOaWwodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLW5pbC5qcy5tYXAiLCIvKipcbiAqIOWIpOaWreWAvOaYr+WQpuS4uuaVsOWtl1xuICogQHJldHVybiDmmK/lkKbkuLrmlbDlrZdcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlzLW51bWJlci5qcy5tYXAiLCJ2YXIgaXNPYmplY3RMaWtlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLyoqXG4gICAgICogaXNPYmplY3RMaWtlKHt9KSA9PiB0cnVlXG4gICAgICogaXNPYmplY3RMaWtlKFsxLCAyLCAzXSkgPT4gdHJ1ZVxuICAgICAqIGlzT2JqZWN0TGlrZShGdW5jdGlvbikgPT4gZmFsc2VcbiAgICAgKiBpc09iamVjdExpa2UobnVsbCkgPT4gZmFsc2VcbiAgICAgKi9cbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbDtcbn07XG5leHBvcnQgZGVmYXVsdCBpc09iamVjdExpa2U7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1vYmplY3QtbGlrZS5qcy5tYXAiLCJleHBvcnQgZGVmYXVsdCAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLyoqXG4gICAgICogaXNPYmplY3Qoe30pID0+IHRydWVcbiAgICAgKiBpc09iamVjdChbMSwgMiwgM10pID0+IHRydWVcbiAgICAgKiBpc09iamVjdChGdW5jdGlvbikgPT4gdHJ1ZVxuICAgICAqIGlzT2JqZWN0KG51bGwpID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgcmV0dXJuICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlID09PSAnb2JqZWN0JykgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJztcbn0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aXMtb2JqZWN0LmpzLm1hcCIsImltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pcy1vYmplY3QtbGlrZSc7XG5pbXBvcnQgaXNUeXBlIGZyb20gJy4vaXMtdHlwZSc7XG52YXIgaXNQbGFpbk9iamVjdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8qKlxuICAgICAqIGlzT2JqZWN0TGlrZShuZXcgRm9vKSA9PiBmYWxzZVxuICAgICAqIGlzT2JqZWN0TGlrZShbMSwgMiwgM10pID0+IGZhbHNlXG4gICAgICogaXNPYmplY3RMaWtlKHsgeDogMCwgeTogMCB9KSA9PiB0cnVlXG4gICAgICogaXNPYmplY3RMaWtlKE9iamVjdC5jcmVhdGUobnVsbCkpID0+IHRydWVcbiAgICAgKi9cbiAgICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHwgIWlzVHlwZSh2YWx1ZSwgJ09iamVjdCcpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHZhciBwcm90byA9IHZhbHVlO1xuICAgIHdoaWxlIChPYmplY3QuZ2V0UHJvdG90eXBlT2YocHJvdG8pICE9PSBudWxsKSB7XG4gICAgICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWx1ZSkgPT09IHByb3RvO1xufTtcbmV4cG9ydCBkZWZhdWx0IGlzUGxhaW5PYmplY3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1wbGFpbi1vYmplY3QuanMubWFwIiwiLyoqXG4gKiDliKTmlq3lgLzmmK/lkKbkuLrlrZfnrKbkuLJcbiAqIEByZXR1cm4g5piv5ZCm5Li65a2X56ym5LiyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy1zdHJpbmcuanMubWFwIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG52YXIgaXNUeXBlID0gZnVuY3Rpb24gKHZhbHVlLCB0eXBlKSB7IHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgJyArIHR5cGUgKyAnXSc7IH07XG5leHBvcnQgZGVmYXVsdCBpc1R5cGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pcy10eXBlLmpzLm1hcCIsImltcG9ydCBlYWNoIGZyb20gJy4vZWFjaCc7XG5pbXBvcnQgaXNQbGFpbk9iamVjdCBmcm9tICcuL2lzLXBsYWluLW9iamVjdCc7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZXhwb3J0IGRlZmF1bHQgKGZ1bmN0aW9uIChvYmplY3QsIGtleXMpIHtcbiAgICBpZiAob2JqZWN0ID09PSBudWxsIHx8ICFpc1BsYWluT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZWFjaChrZXlzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBpY2suanMubWFwIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICogU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbiAqL1xuY29uc3QgcHJveHlNYXJrZXIgPSBTeW1ib2woXCJDb21saW5rLnByb3h5XCIpO1xuY29uc3QgY3JlYXRlRW5kcG9pbnQgPSBTeW1ib2woXCJDb21saW5rLmVuZHBvaW50XCIpO1xuY29uc3QgcmVsZWFzZVByb3h5ID0gU3ltYm9sKFwiQ29tbGluay5yZWxlYXNlUHJveHlcIik7XG5jb25zdCBmaW5hbGl6ZXIgPSBTeW1ib2woXCJDb21saW5rLmZpbmFsaXplclwiKTtcbmNvbnN0IHRocm93TWFya2VyID0gU3ltYm9sKFwiQ29tbGluay50aHJvd25cIik7XG5jb25zdCBpc09iamVjdCA9ICh2YWwpID0+ICh0eXBlb2YgdmFsID09PSBcIm9iamVjdFwiICYmIHZhbCAhPT0gbnVsbCkgfHwgdHlwZW9mIHZhbCA9PT0gXCJmdW5jdGlvblwiO1xuLyoqXG4gKiBJbnRlcm5hbCB0cmFuc2ZlciBoYW5kbGUgdG8gaGFuZGxlIG9iamVjdHMgbWFya2VkIHRvIHByb3h5LlxuICovXG5jb25zdCBwcm94eVRyYW5zZmVySGFuZGxlciA9IHtcbiAgICBjYW5IYW5kbGU6ICh2YWwpID0+IGlzT2JqZWN0KHZhbCkgJiYgdmFsW3Byb3h5TWFya2VyXSxcbiAgICBzZXJpYWxpemUob2JqKSB7XG4gICAgICAgIGNvbnN0IHsgcG9ydDEsIHBvcnQyIH0gPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgZXhwb3NlKG9iaiwgcG9ydDEpO1xuICAgICAgICByZXR1cm4gW3BvcnQyLCBbcG9ydDJdXTtcbiAgICB9LFxuICAgIGRlc2VyaWFsaXplKHBvcnQpIHtcbiAgICAgICAgcG9ydC5zdGFydCgpO1xuICAgICAgICByZXR1cm4gd3JhcChwb3J0KTtcbiAgICB9LFxufTtcbi8qKlxuICogSW50ZXJuYWwgdHJhbnNmZXIgaGFuZGxlciB0byBoYW5kbGUgdGhyb3duIGV4Y2VwdGlvbnMuXG4gKi9cbmNvbnN0IHRocm93VHJhbnNmZXJIYW5kbGVyID0ge1xuICAgIGNhbkhhbmRsZTogKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgdGhyb3dNYXJrZXIgaW4gdmFsdWUsXG4gICAgc2VyaWFsaXplKHsgdmFsdWUgfSkge1xuICAgICAgICBsZXQgc2VyaWFsaXplZDtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWQgPSB7XG4gICAgICAgICAgICAgICAgaXNFcnJvcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiB2YWx1ZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiB2YWx1ZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogdmFsdWUuc3RhY2ssXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXJpYWxpemVkID0geyBpc0Vycm9yOiBmYWxzZSwgdmFsdWUgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3NlcmlhbGl6ZWQsIFtdXTtcbiAgICB9LFxuICAgIGRlc2VyaWFsaXplKHNlcmlhbGl6ZWQpIHtcbiAgICAgICAgaWYgKHNlcmlhbGl6ZWQuaXNFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3Ioc2VyaWFsaXplZC52YWx1ZS5tZXNzYWdlKSwgc2VyaWFsaXplZC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgc2VyaWFsaXplZC52YWx1ZTtcbiAgICB9LFxufTtcbi8qKlxuICogQWxsb3dzIGN1c3RvbWl6aW5nIHRoZSBzZXJpYWxpemF0aW9uIG9mIGNlcnRhaW4gdmFsdWVzLlxuICovXG5jb25zdCB0cmFuc2ZlckhhbmRsZXJzID0gbmV3IE1hcChbXG4gICAgW1wicHJveHlcIiwgcHJveHlUcmFuc2ZlckhhbmRsZXJdLFxuICAgIFtcInRocm93XCIsIHRocm93VHJhbnNmZXJIYW5kbGVyXSxcbl0pO1xuZnVuY3Rpb24gaXNBbGxvd2VkT3JpZ2luKGFsbG93ZWRPcmlnaW5zLCBvcmlnaW4pIHtcbiAgICBmb3IgKGNvbnN0IGFsbG93ZWRPcmlnaW4gb2YgYWxsb3dlZE9yaWdpbnMpIHtcbiAgICAgICAgaWYgKG9yaWdpbiA9PT0gYWxsb3dlZE9yaWdpbiB8fCBhbGxvd2VkT3JpZ2luID09PSBcIipcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFsbG93ZWRPcmlnaW4gaW5zdGFuY2VvZiBSZWdFeHAgJiYgYWxsb3dlZE9yaWdpbi50ZXN0KG9yaWdpbikpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGV4cG9zZShvYmosIGVwID0gZ2xvYmFsVGhpcywgYWxsb3dlZE9yaWdpbnMgPSBbXCIqXCJdKSB7XG4gICAgZXAuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgZnVuY3Rpb24gY2FsbGJhY2soZXYpIHtcbiAgICAgICAgaWYgKCFldiB8fCAhZXYuZGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNBbGxvd2VkT3JpZ2luKGFsbG93ZWRPcmlnaW5zLCBldi5vcmlnaW4pKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgb3JpZ2luICcke2V2Lm9yaWdpbn0nIGZvciBjb21saW5rIHByb3h5YCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBpZCwgdHlwZSwgcGF0aCB9ID0gT2JqZWN0LmFzc2lnbih7IHBhdGg6IFtdIH0sIGV2LmRhdGEpO1xuICAgICAgICBjb25zdCBhcmd1bWVudExpc3QgPSAoZXYuZGF0YS5hcmd1bWVudExpc3QgfHwgW10pLm1hcChmcm9tV2lyZVZhbHVlKTtcbiAgICAgICAgbGV0IHJldHVyblZhbHVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gcGF0aC5zbGljZSgwLCAtMSkucmVkdWNlKChvYmosIHByb3ApID0+IG9ialtwcm9wXSwgb2JqKTtcbiAgICAgICAgICAgIGNvbnN0IHJhd1ZhbHVlID0gcGF0aC5yZWR1Y2UoKG9iaiwgcHJvcCkgPT4gb2JqW3Byb3BdLCBvYmopO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkdFVFwiIC8qIE1lc3NhZ2VUeXBlLkdFVCAqLzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSByYXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiU0VUXCIgLyogTWVzc2FnZVR5cGUuU0VUICovOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRbcGF0aC5zbGljZSgtMSlbMF1dID0gZnJvbVdpcmVWYWx1ZShldi5kYXRhLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiQVBQTFlcIiAvKiBNZXNzYWdlVHlwZS5BUFBMWSAqLzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSByYXdWYWx1ZS5hcHBseShwYXJlbnQsIGFyZ3VtZW50TGlzdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkNPTlNUUlVDVFwiIC8qIE1lc3NhZ2VUeXBlLkNPTlNUUlVDVCAqLzpcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBuZXcgcmF3VmFsdWUoLi4uYXJndW1lbnRMaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gcHJveHkodmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJFTkRQT0lOVFwiIC8qIE1lc3NhZ2VUeXBlLkVORFBPSU5UICovOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHBvcnQxLCBwb3J0MiB9ID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleHBvc2Uob2JqLCBwb3J0Mik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5WYWx1ZSA9IHRyYW5zZmVyKHBvcnQxLCBbcG9ydDFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiUkVMRUFTRVwiIC8qIE1lc3NhZ2VUeXBlLlJFTEVBU0UgKi86XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0geyB2YWx1ZSwgW3Rocm93TWFya2VyXTogMCB9O1xuICAgICAgICB9XG4gICAgICAgIFByb21pc2UucmVzb2x2ZShyZXR1cm5WYWx1ZSlcbiAgICAgICAgICAgIC5jYXRjaCgodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlLCBbdGhyb3dNYXJrZXJdOiAwIH07XG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigocmV0dXJuVmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFt3aXJlVmFsdWUsIHRyYW5zZmVyYWJsZXNdID0gdG9XaXJlVmFsdWUocmV0dXJuVmFsdWUpO1xuICAgICAgICAgICAgZXAucG9zdE1lc3NhZ2UoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB3aXJlVmFsdWUpLCB7IGlkIH0pLCB0cmFuc2ZlcmFibGVzKTtcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIlJFTEVBU0VcIiAvKiBNZXNzYWdlVHlwZS5SRUxFQVNFICovKSB7XG4gICAgICAgICAgICAgICAgLy8gZGV0YWNoIGFuZCBkZWFjdGl2ZSBhZnRlciBzZW5kaW5nIHJlbGVhc2UgcmVzcG9uc2UgYWJvdmUuXG4gICAgICAgICAgICAgICAgZXAucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGNsb3NlRW5kUG9pbnQoZXApO1xuICAgICAgICAgICAgICAgIGlmIChmaW5hbGl6ZXIgaW4gb2JqICYmIHR5cGVvZiBvYmpbZmluYWxpemVyXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG9ialtmaW5hbGl6ZXJdKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgLy8gU2VuZCBTZXJpYWxpemF0aW9uIEVycm9yIFRvIENhbGxlclxuICAgICAgICAgICAgY29uc3QgW3dpcmVWYWx1ZSwgdHJhbnNmZXJhYmxlc10gPSB0b1dpcmVWYWx1ZSh7XG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ldyBUeXBlRXJyb3IoXCJVbnNlcmlhbGl6YWJsZSByZXR1cm4gdmFsdWVcIiksXG4gICAgICAgICAgICAgICAgW3Rocm93TWFya2VyXTogMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZXAucG9zdE1lc3NhZ2UoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB3aXJlVmFsdWUpLCB7IGlkIH0pLCB0cmFuc2ZlcmFibGVzKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKGVwLnN0YXJ0KSB7XG4gICAgICAgIGVwLnN0YXJ0KCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNNZXNzYWdlUG9ydChlbmRwb2ludCkge1xuICAgIHJldHVybiBlbmRwb2ludC5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIk1lc3NhZ2VQb3J0XCI7XG59XG5mdW5jdGlvbiBjbG9zZUVuZFBvaW50KGVuZHBvaW50KSB7XG4gICAgaWYgKGlzTWVzc2FnZVBvcnQoZW5kcG9pbnQpKVxuICAgICAgICBlbmRwb2ludC5jbG9zZSgpO1xufVxuZnVuY3Rpb24gd3JhcChlcCwgdGFyZ2V0KSB7XG4gICAgY29uc3QgcGVuZGluZ0xpc3RlbmVycyA9IG5ldyBNYXAoKTtcbiAgICBlcC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBmdW5jdGlvbiBoYW5kbGVNZXNzYWdlKGV2KSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YSB9ID0gZXY7XG4gICAgICAgIGlmICghZGF0YSB8fCAhZGF0YS5pZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc29sdmVyID0gcGVuZGluZ0xpc3RlbmVycy5nZXQoZGF0YS5pZCk7XG4gICAgICAgIGlmICghcmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzb2x2ZXIoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBwZW5kaW5nTGlzdGVuZXJzLmRlbGV0ZShkYXRhLmlkKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjcmVhdGVQcm94eShlcCwgcGVuZGluZ0xpc3RlbmVycywgW10sIHRhcmdldCk7XG59XG5mdW5jdGlvbiB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1JlbGVhc2VkKSB7XG4gICAgaWYgKGlzUmVsZWFzZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUHJveHkgaGFzIGJlZW4gcmVsZWFzZWQgYW5kIGlzIG5vdCB1c2VhYmxlXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlbGVhc2VFbmRwb2ludChlcCkge1xuICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBuZXcgTWFwKCksIHtcbiAgICAgICAgdHlwZTogXCJSRUxFQVNFXCIgLyogTWVzc2FnZVR5cGUuUkVMRUFTRSAqLyxcbiAgICB9KS50aGVuKCgpID0+IHtcbiAgICAgICAgY2xvc2VFbmRQb2ludChlcCk7XG4gICAgfSk7XG59XG5jb25zdCBwcm94eUNvdW50ZXIgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgcHJveHlGaW5hbGl6ZXJzID0gXCJGaW5hbGl6YXRpb25SZWdpc3RyeVwiIGluIGdsb2JhbFRoaXMgJiZcbiAgICBuZXcgRmluYWxpemF0aW9uUmVnaXN0cnkoKGVwKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld0NvdW50ID0gKHByb3h5Q291bnRlci5nZXQoZXApIHx8IDApIC0gMTtcbiAgICAgICAgcHJveHlDb3VudGVyLnNldChlcCwgbmV3Q291bnQpO1xuICAgICAgICBpZiAobmV3Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHJlbGVhc2VFbmRwb2ludChlcCk7XG4gICAgICAgIH1cbiAgICB9KTtcbmZ1bmN0aW9uIHJlZ2lzdGVyUHJveHkocHJveHksIGVwKSB7XG4gICAgY29uc3QgbmV3Q291bnQgPSAocHJveHlDb3VudGVyLmdldChlcCkgfHwgMCkgKyAxO1xuICAgIHByb3h5Q291bnRlci5zZXQoZXAsIG5ld0NvdW50KTtcbiAgICBpZiAocHJveHlGaW5hbGl6ZXJzKSB7XG4gICAgICAgIHByb3h5RmluYWxpemVycy5yZWdpc3Rlcihwcm94eSwgZXAsIHByb3h5KTtcbiAgICB9XG59XG5mdW5jdGlvbiB1bnJlZ2lzdGVyUHJveHkocHJveHkpIHtcbiAgICBpZiAocHJveHlGaW5hbGl6ZXJzKSB7XG4gICAgICAgIHByb3h5RmluYWxpemVycy51bnJlZ2lzdGVyKHByb3h5KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVQcm94eShlcCwgcGVuZGluZ0xpc3RlbmVycywgcGF0aCA9IFtdLCB0YXJnZXQgPSBmdW5jdGlvbiAoKSB7IH0pIHtcbiAgICBsZXQgaXNQcm94eVJlbGVhc2VkID0gZmFsc2U7XG4gICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkodGFyZ2V0LCB7XG4gICAgICAgIGdldChfdGFyZ2V0LCBwcm9wKSB7XG4gICAgICAgICAgICB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1Byb3h5UmVsZWFzZWQpO1xuICAgICAgICAgICAgaWYgKHByb3AgPT09IHJlbGVhc2VQcm94eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHVucmVnaXN0ZXJQcm94eShwcm94eSk7XG4gICAgICAgICAgICAgICAgICAgIHJlbGVhc2VFbmRwb2ludChlcCk7XG4gICAgICAgICAgICAgICAgICAgIHBlbmRpbmdMaXN0ZW5lcnMuY2xlYXIoKTtcbiAgICAgICAgICAgICAgICAgICAgaXNQcm94eVJlbGVhc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByb3AgPT09IFwidGhlblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHRoZW46ICgpID0+IHByb3h5IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIgLyogTWVzc2FnZVR5cGUuR0VUICovLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLm1hcCgocCkgPT4gcC50b1N0cmluZygpKSxcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZyb21XaXJlVmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByLnRoZW4uYmluZChyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVQcm94eShlcCwgcGVuZGluZ0xpc3RlbmVycywgWy4uLnBhdGgsIHByb3BdKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KF90YXJnZXQsIHByb3AsIHJhd1ZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1Byb3h5UmVsZWFzZWQpO1xuICAgICAgICAgICAgLy8gRklYTUU6IEVTNiBQcm94eSBIYW5kbGVyIGBzZXRgIG1ldGhvZHMgYXJlIHN1cHBvc2VkIHRvIHJldHVybiBhXG4gICAgICAgICAgICAvLyBib29sZWFuLiBUbyBzaG93IGdvb2Qgd2lsbCwgd2UgcmV0dXJuIHRydWUgYXN5bmNocm9ub3VzbHkgwq9cXF8o44OEKV8vwq9cbiAgICAgICAgICAgIGNvbnN0IFt2YWx1ZSwgdHJhbnNmZXJhYmxlc10gPSB0b1dpcmVWYWx1ZShyYXdWYWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVxdWVzdFJlc3BvbnNlTWVzc2FnZShlcCwgcGVuZGluZ0xpc3RlbmVycywge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiU0VUXCIgLyogTWVzc2FnZVR5cGUuU0VUICovLFxuICAgICAgICAgICAgICAgIHBhdGg6IFsuLi5wYXRoLCBwcm9wXS5tYXAoKHApID0+IHAudG9TdHJpbmcoKSksXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB9LCB0cmFuc2ZlcmFibGVzKS50aGVuKGZyb21XaXJlVmFsdWUpO1xuICAgICAgICB9LFxuICAgICAgICBhcHBseShfdGFyZ2V0LCBfdGhpc0FyZywgcmF3QXJndW1lbnRMaXN0KSB7XG4gICAgICAgICAgICB0aHJvd0lmUHJveHlSZWxlYXNlZChpc1Byb3h5UmVsZWFzZWQpO1xuICAgICAgICAgICAgY29uc3QgbGFzdCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIGlmIChsYXN0ID09PSBjcmVhdGVFbmRwb2ludCkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiRU5EUE9JTlRcIiAvKiBNZXNzYWdlVHlwZS5FTkRQT0lOVCAqLyxcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZyb21XaXJlVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UganVzdCBwcmV0ZW5kIHRoYXQgYGJpbmQoKWAgZGlkbuKAmXQgaGFwcGVuLlxuICAgICAgICAgICAgaWYgKGxhc3QgPT09IFwiYmluZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVByb3h5KGVwLCBwZW5kaW5nTGlzdGVuZXJzLCBwYXRoLnNsaWNlKDAsIC0xKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBbYXJndW1lbnRMaXN0LCB0cmFuc2ZlcmFibGVzXSA9IHByb2Nlc3NBcmd1bWVudHMocmF3QXJndW1lbnRMaXN0KTtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJBUFBMWVwiIC8qIE1lc3NhZ2VUeXBlLkFQUExZICovLFxuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgubWFwKChwKSA9PiBwLnRvU3RyaW5nKCkpLFxuICAgICAgICAgICAgICAgIGFyZ3VtZW50TGlzdCxcbiAgICAgICAgICAgIH0sIHRyYW5zZmVyYWJsZXMpLnRoZW4oZnJvbVdpcmVWYWx1ZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbnN0cnVjdChfdGFyZ2V0LCByYXdBcmd1bWVudExpc3QpIHtcbiAgICAgICAgICAgIHRocm93SWZQcm94eVJlbGVhc2VkKGlzUHJveHlSZWxlYXNlZCk7XG4gICAgICAgICAgICBjb25zdCBbYXJndW1lbnRMaXN0LCB0cmFuc2ZlcmFibGVzXSA9IHByb2Nlc3NBcmd1bWVudHMocmF3QXJndW1lbnRMaXN0KTtcbiAgICAgICAgICAgIHJldHVybiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJDT05TVFJVQ1RcIiAvKiBNZXNzYWdlVHlwZS5DT05TVFJVQ1QgKi8sXG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aC5tYXAoKHApID0+IHAudG9TdHJpbmcoKSksXG4gICAgICAgICAgICAgICAgYXJndW1lbnRMaXN0LFxuICAgICAgICAgICAgfSwgdHJhbnNmZXJhYmxlcykudGhlbihmcm9tV2lyZVZhbHVlKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZWdpc3RlclByb3h5KHByb3h5LCBlcCk7XG4gICAgcmV0dXJuIHByb3h5O1xufVxuZnVuY3Rpb24gbXlGbGF0KGFycikge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBhcnIpO1xufVxuZnVuY3Rpb24gcHJvY2Vzc0FyZ3VtZW50cyhhcmd1bWVudExpc3QpIHtcbiAgICBjb25zdCBwcm9jZXNzZWQgPSBhcmd1bWVudExpc3QubWFwKHRvV2lyZVZhbHVlKTtcbiAgICByZXR1cm4gW3Byb2Nlc3NlZC5tYXAoKHYpID0+IHZbMF0pLCBteUZsYXQocHJvY2Vzc2VkLm1hcCgodikgPT4gdlsxXSkpXTtcbn1cbmNvbnN0IHRyYW5zZmVyQ2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gdHJhbnNmZXIob2JqLCB0cmFuc2ZlcnMpIHtcbiAgICB0cmFuc2ZlckNhY2hlLnNldChvYmosIHRyYW5zZmVycyk7XG4gICAgcmV0dXJuIG9iajtcbn1cbmZ1bmN0aW9uIHByb3h5KG9iaikge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKG9iaiwgeyBbcHJveHlNYXJrZXJdOiB0cnVlIH0pO1xufVxuZnVuY3Rpb24gd2luZG93RW5kcG9pbnQodywgY29udGV4dCA9IGdsb2JhbFRoaXMsIHRhcmdldE9yaWdpbiA9IFwiKlwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zdE1lc3NhZ2U6IChtc2csIHRyYW5zZmVyYWJsZXMpID0+IHcucG9zdE1lc3NhZ2UobXNnLCB0YXJnZXRPcmlnaW4sIHRyYW5zZmVyYWJsZXMpLFxuICAgICAgICBhZGRFdmVudExpc3RlbmVyOiBjb250ZXh0LmFkZEV2ZW50TGlzdGVuZXIuYmluZChjb250ZXh0KSxcbiAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogY29udGV4dC5yZW1vdmVFdmVudExpc3RlbmVyLmJpbmQoY29udGV4dCksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRvV2lyZVZhbHVlKHZhbHVlKSB7XG4gICAgZm9yIChjb25zdCBbbmFtZSwgaGFuZGxlcl0gb2YgdHJhbnNmZXJIYW5kbGVycykge1xuICAgICAgICBpZiAoaGFuZGxlci5jYW5IYW5kbGUodmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBbc2VyaWFsaXplZFZhbHVlLCB0cmFuc2ZlcmFibGVzXSA9IGhhbmRsZXIuc2VyaWFsaXplKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkhBTkRMRVJcIiAvKiBXaXJlVmFsdWVUeXBlLkhBTkRMRVIgKi8sXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBzZXJpYWxpemVkVmFsdWUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB0cmFuc2ZlcmFibGVzLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcIlJBV1wiIC8qIFdpcmVWYWx1ZVR5cGUuUkFXICovLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zZmVyQ2FjaGUuZ2V0KHZhbHVlKSB8fCBbXSxcbiAgICBdO1xufVxuZnVuY3Rpb24gZnJvbVdpcmVWYWx1ZSh2YWx1ZSkge1xuICAgIHN3aXRjaCAodmFsdWUudHlwZSkge1xuICAgICAgICBjYXNlIFwiSEFORExFUlwiIC8qIFdpcmVWYWx1ZVR5cGUuSEFORExFUiAqLzpcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2ZlckhhbmRsZXJzLmdldCh2YWx1ZS5uYW1lKS5kZXNlcmlhbGl6ZSh2YWx1ZS52YWx1ZSk7XG4gICAgICAgIGNhc2UgXCJSQVdcIiAvKiBXaXJlVmFsdWVUeXBlLlJBVyAqLzpcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS52YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXF1ZXN0UmVzcG9uc2VNZXNzYWdlKGVwLCBwZW5kaW5nTGlzdGVuZXJzLCBtc2csIHRyYW5zZmVycykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IGdlbmVyYXRlVVVJRCgpO1xuICAgICAgICBwZW5kaW5nTGlzdGVuZXJzLnNldChpZCwgcmVzb2x2ZSk7XG4gICAgICAgIGlmIChlcC5zdGFydCkge1xuICAgICAgICAgICAgZXAuc3RhcnQoKTtcbiAgICAgICAgfVxuICAgICAgICBlcC5wb3N0TWVzc2FnZShPYmplY3QuYXNzaWduKHsgaWQgfSwgbXNnKSwgdHJhbnNmZXJzKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdlbmVyYXRlVVVJRCgpIHtcbiAgICByZXR1cm4gbmV3IEFycmF5KDQpXG4gICAgICAgIC5maWxsKDApXG4gICAgICAgIC5tYXAoKCkgPT4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIpLnRvU3RyaW5nKDE2KSlcbiAgICAgICAgLmpvaW4oXCItXCIpO1xufVxuXG5leHBvcnQgeyBjcmVhdGVFbmRwb2ludCwgZXhwb3NlLCBmaW5hbGl6ZXIsIHByb3h5LCBwcm94eU1hcmtlciwgcmVsZWFzZVByb3h5LCB0cmFuc2ZlciwgdHJhbnNmZXJIYW5kbGVycywgd2luZG93RW5kcG9pbnQsIHdyYXAgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbWxpbmsubWpzLm1hcFxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZCkge1xuICBjb25zdCB4ID0gK3RoaXMuX3guY2FsbChudWxsLCBkKTtcbiAgcmV0dXJuIGFkZCh0aGlzLmNvdmVyKHgpLCB4LCBkKTtcbn1cblxuZnVuY3Rpb24gYWRkKHRyZWUsIHgsIGQpIHtcbiAgaWYgKGlzTmFOKHgpKSByZXR1cm4gdHJlZTsgLy8gaWdub3JlIGludmFsaWQgcG9pbnRzXG5cbiAgdmFyIHBhcmVudCxcbiAgICAgIG5vZGUgPSB0cmVlLl9yb290LFxuICAgICAgbGVhZiA9IHtkYXRhOiBkfSxcbiAgICAgIHgwID0gdHJlZS5feDAsXG4gICAgICB4MSA9IHRyZWUuX3gxLFxuICAgICAgeG0sXG4gICAgICB4cCxcbiAgICAgIHJpZ2h0LFxuICAgICAgaSxcbiAgICAgIGo7XG5cbiAgLy8gSWYgdGhlIHRyZWUgaXMgZW1wdHksIGluaXRpYWxpemUgdGhlIHJvb3QgYXMgYSBsZWFmLlxuICBpZiAoIW5vZGUpIHJldHVybiB0cmVlLl9yb290ID0gbGVhZiwgdHJlZTtcblxuICAvLyBGaW5kIHRoZSBleGlzdGluZyBsZWFmIGZvciB0aGUgbmV3IHBvaW50LCBvciBhZGQgaXQuXG4gIHdoaWxlIChub2RlLmxlbmd0aCkge1xuICAgIGlmIChyaWdodCA9IHggPj0gKHhtID0gKHgwICsgeDEpIC8gMikpIHgwID0geG07IGVsc2UgeDEgPSB4bTtcbiAgICBpZiAocGFyZW50ID0gbm9kZSwgIShub2RlID0gbm9kZVtpID0gK3JpZ2h0XSkpIHJldHVybiBwYXJlbnRbaV0gPSBsZWFmLCB0cmVlO1xuICB9XG5cbiAgLy8gSXMgdGhlIG5ldyBwb2ludCBpcyBleGFjdGx5IGNvaW5jaWRlbnQgd2l0aCB0aGUgZXhpc3RpbmcgcG9pbnQ/XG4gIHhwID0gK3RyZWUuX3guY2FsbChudWxsLCBub2RlLmRhdGEpO1xuICBpZiAoeCA9PT0geHApIHJldHVybiBsZWFmLm5leHQgPSBub2RlLCBwYXJlbnQgPyBwYXJlbnRbaV0gPSBsZWFmIDogdHJlZS5fcm9vdCA9IGxlYWYsIHRyZWU7XG5cbiAgLy8gT3RoZXJ3aXNlLCBzcGxpdCB0aGUgbGVhZiBub2RlIHVudGlsIHRoZSBvbGQgYW5kIG5ldyBwb2ludCBhcmUgc2VwYXJhdGVkLlxuICBkbyB7XG4gICAgcGFyZW50ID0gcGFyZW50ID8gcGFyZW50W2ldID0gbmV3IEFycmF5KDIpIDogdHJlZS5fcm9vdCA9IG5ldyBBcnJheSgyKTtcbiAgICBpZiAocmlnaHQgPSB4ID49ICh4bSA9ICh4MCArIHgxKSAvIDIpKSB4MCA9IHhtOyBlbHNlIHgxID0geG07XG4gIH0gd2hpbGUgKChpID0gK3JpZ2h0KSA9PT0gKGogPSArKHhwID49IHhtKSkpO1xuICByZXR1cm4gcGFyZW50W2pdID0gbm9kZSwgcGFyZW50W2ldID0gbGVhZiwgdHJlZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEFsbChkYXRhKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShkYXRhKSkgZGF0YSA9IEFycmF5LmZyb20oZGF0YSk7XG4gIGNvbnN0IG4gPSBkYXRhLmxlbmd0aDtcbiAgY29uc3QgeHogPSBuZXcgRmxvYXQ2NEFycmF5KG4pO1xuICBsZXQgeDAgPSBJbmZpbml0eSxcbiAgICAgIHgxID0gLUluZmluaXR5O1xuXG4gIC8vIENvbXB1dGUgdGhlIHBvaW50cyBhbmQgdGhlaXIgZXh0ZW50LlxuICBmb3IgKGxldCBpID0gMCwgeDsgaSA8IG47ICsraSkge1xuICAgIGlmIChpc05hTih4ID0gK3RoaXMuX3guY2FsbChudWxsLCBkYXRhW2ldKSkpIGNvbnRpbnVlO1xuICAgIHh6W2ldID0geDtcbiAgICBpZiAoeCA8IHgwKSB4MCA9IHg7XG4gICAgaWYgKHggPiB4MSkgeDEgPSB4O1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgd2VyZSBubyAodmFsaWQpIHBvaW50cywgYWJvcnQuXG4gIGlmICh4MCA+IHgxKSByZXR1cm4gdGhpcztcblxuICAvLyBFeHBhbmQgdGhlIHRyZWUgdG8gY292ZXIgdGhlIG5ldyBwb2ludHMuXG4gIHRoaXMuY292ZXIoeDApLmNvdmVyKHgxKTtcblxuICAvLyBBZGQgdGhlIG5ldyBwb2ludHMuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgYWRkKHRoaXMsIHh6W2ldLCBkYXRhW2ldKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuIiwiaW1wb3J0IHRyZWVfYWRkLCB7YWRkQWxsIGFzIHRyZWVfYWRkQWxsfSBmcm9tIFwiLi9hZGQuanNcIjtcbmltcG9ydCB0cmVlX2NvdmVyIGZyb20gXCIuL2NvdmVyLmpzXCI7XG5pbXBvcnQgdHJlZV9kYXRhIGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCB0cmVlX2V4dGVudCBmcm9tIFwiLi9leHRlbnQuanNcIjtcbmltcG9ydCB0cmVlX2ZpbmQgZnJvbSBcIi4vZmluZC5qc1wiO1xuaW1wb3J0IHRyZWVfcmVtb3ZlLCB7cmVtb3ZlQWxsIGFzIHRyZWVfcmVtb3ZlQWxsfSBmcm9tIFwiLi9yZW1vdmUuanNcIjtcbmltcG9ydCB0cmVlX3Jvb3QgZnJvbSBcIi4vcm9vdC5qc1wiO1xuaW1wb3J0IHRyZWVfc2l6ZSBmcm9tIFwiLi9zaXplLmpzXCI7XG5pbXBvcnQgdHJlZV92aXNpdCBmcm9tIFwiLi92aXNpdC5qc1wiO1xuaW1wb3J0IHRyZWVfdmlzaXRBZnRlciBmcm9tIFwiLi92aXNpdEFmdGVyLmpzXCI7XG5pbXBvcnQgdHJlZV94LCB7ZGVmYXVsdFh9IGZyb20gXCIuL3guanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYmluYXJ5dHJlZShub2RlcywgeCkge1xuICB2YXIgdHJlZSA9IG5ldyBCaW5hcnl0cmVlKHggPT0gbnVsbCA/IGRlZmF1bHRYIDogeCwgTmFOLCBOYU4pO1xuICByZXR1cm4gbm9kZXMgPT0gbnVsbCA/IHRyZWUgOiB0cmVlLmFkZEFsbChub2Rlcyk7XG59XG5cbmZ1bmN0aW9uIEJpbmFyeXRyZWUoeCwgeDAsIHgxKSB7XG4gIHRoaXMuX3ggPSB4O1xuICB0aGlzLl94MCA9IHgwO1xuICB0aGlzLl94MSA9IHgxO1xuICB0aGlzLl9yb290ID0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBsZWFmX2NvcHkobGVhZikge1xuICB2YXIgY29weSA9IHtkYXRhOiBsZWFmLmRhdGF9LCBuZXh0ID0gY29weTtcbiAgd2hpbGUgKGxlYWYgPSBsZWFmLm5leHQpIG5leHQgPSBuZXh0Lm5leHQgPSB7ZGF0YTogbGVhZi5kYXRhfTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbnZhciB0cmVlUHJvdG8gPSBiaW5hcnl0cmVlLnByb3RvdHlwZSA9IEJpbmFyeXRyZWUucHJvdG90eXBlO1xuXG50cmVlUHJvdG8uY29weSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29weSA9IG5ldyBCaW5hcnl0cmVlKHRoaXMuX3gsIHRoaXMuX3gwLCB0aGlzLl94MSksXG4gICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgIG5vZGVzLFxuICAgICAgY2hpbGQ7XG5cbiAgaWYgKCFub2RlKSByZXR1cm4gY29weTtcblxuICBpZiAoIW5vZGUubGVuZ3RoKSByZXR1cm4gY29weS5fcm9vdCA9IGxlYWZfY29weShub2RlKSwgY29weTtcblxuICBub2RlcyA9IFt7c291cmNlOiBub2RlLCB0YXJnZXQ6IGNvcHkuX3Jvb3QgPSBuZXcgQXJyYXkoMil9XTtcbiAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgKytpKSB7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlLnNvdXJjZVtpXSkge1xuICAgICAgICBpZiAoY2hpbGQubGVuZ3RoKSBub2Rlcy5wdXNoKHtzb3VyY2U6IGNoaWxkLCB0YXJnZXQ6IG5vZGUudGFyZ2V0W2ldID0gbmV3IEFycmF5KDIpfSk7XG4gICAgICAgIGVsc2Ugbm9kZS50YXJnZXRbaV0gPSBsZWFmX2NvcHkoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufTtcblxudHJlZVByb3RvLmFkZCA9IHRyZWVfYWRkO1xudHJlZVByb3RvLmFkZEFsbCA9IHRyZWVfYWRkQWxsO1xudHJlZVByb3RvLmNvdmVyID0gdHJlZV9jb3ZlcjtcbnRyZWVQcm90by5kYXRhID0gdHJlZV9kYXRhO1xudHJlZVByb3RvLmV4dGVudCA9IHRyZWVfZXh0ZW50O1xudHJlZVByb3RvLmZpbmQgPSB0cmVlX2ZpbmQ7XG50cmVlUHJvdG8ucmVtb3ZlID0gdHJlZV9yZW1vdmU7XG50cmVlUHJvdG8ucmVtb3ZlQWxsID0gdHJlZV9yZW1vdmVBbGw7XG50cmVlUHJvdG8ucm9vdCA9IHRyZWVfcm9vdDtcbnRyZWVQcm90by5zaXplID0gdHJlZV9zaXplO1xudHJlZVByb3RvLnZpc2l0ID0gdHJlZV92aXNpdDtcbnRyZWVQcm90by52aXNpdEFmdGVyID0gdHJlZV92aXNpdEFmdGVyO1xudHJlZVByb3RvLnggPSB0cmVlX3g7IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICBpZiAoaXNOYU4oeCA9ICt4KSkgcmV0dXJuIHRoaXM7IC8vIGlnbm9yZSBpbnZhbGlkIHBvaW50c1xuXG4gIHZhciB4MCA9IHRoaXMuX3gwLFxuICAgICAgeDEgPSB0aGlzLl94MTtcblxuICAvLyBJZiB0aGUgYmluYXJ5dHJlZSBoYXMgbm8gZXh0ZW50LCBpbml0aWFsaXplIHRoZW0uXG4gIC8vIEludGVnZXIgZXh0ZW50IGFyZSBuZWNlc3Nhcnkgc28gdGhhdCBpZiB3ZSBsYXRlciBkb3VibGUgdGhlIGV4dGVudCxcbiAgLy8gdGhlIGV4aXN0aW5nIGhhbGYgYm91bmRhcmllcyBkb27igJl0IGNoYW5nZSBkdWUgdG8gZmxvYXRpbmcgcG9pbnQgZXJyb3IhXG4gIGlmIChpc05hTih4MCkpIHtcbiAgICB4MSA9ICh4MCA9IE1hdGguZmxvb3IoeCkpICsgMTtcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgZG91YmxlIHJlcGVhdGVkbHkgdG8gY292ZXIuXG4gIGVsc2Uge1xuICAgIHZhciB6ID0geDEgLSB4MCB8fCAxLFxuICAgICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgICAgcGFyZW50LFxuICAgICAgICBpO1xuXG4gICAgd2hpbGUgKHgwID4geCB8fCB4ID49IHgxKSB7XG4gICAgICBpID0gKyh4IDwgeDApO1xuICAgICAgcGFyZW50ID0gbmV3IEFycmF5KDIpLCBwYXJlbnRbaV0gPSBub2RlLCBub2RlID0gcGFyZW50LCB6ICo9IDI7XG4gICAgICBzd2l0Y2ggKGkpIHtcbiAgICAgICAgY2FzZSAwOiB4MSA9IHgwICsgejsgYnJlYWs7XG4gICAgICAgIGNhc2UgMTogeDAgPSB4MSAtIHo7IGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9yb290ICYmIHRoaXMuX3Jvb3QubGVuZ3RoKSB0aGlzLl9yb290ID0gbm9kZTtcbiAgfVxuXG4gIHRoaXMuX3gwID0geDA7XG4gIHRoaXMuX3gxID0geDE7XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBkYXRhID0gW107XG4gIHRoaXMudmlzaXQoZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICghbm9kZS5sZW5ndGgpIGRvIGRhdGEucHVzaChub2RlLmRhdGEpOyB3aGlsZSAobm9kZSA9IG5vZGUubmV4dClcbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oXykge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmNvdmVyKCtfWzBdWzBdKS5jb3ZlcigrX1sxXVswXSlcbiAgICAgIDogaXNOYU4odGhpcy5feDApID8gdW5kZWZpbmVkIDogW1t0aGlzLl94MF0sIFt0aGlzLl94MV1dO1xufVxuIiwiaW1wb3J0IEhhbGYgZnJvbSBcIi4vaGFsZi5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4LCByYWRpdXMpIHtcbiAgdmFyIGRhdGEsXG4gICAgICB4MCA9IHRoaXMuX3gwLFxuICAgICAgeDEsXG4gICAgICB4MixcbiAgICAgIHgzID0gdGhpcy5feDEsXG4gICAgICBoYWx2ZXMgPSBbXSxcbiAgICAgIG5vZGUgPSB0aGlzLl9yb290LFxuICAgICAgcSxcbiAgICAgIGk7XG5cbiAgaWYgKG5vZGUpIGhhbHZlcy5wdXNoKG5ldyBIYWxmKG5vZGUsIHgwLCB4MykpO1xuICBpZiAocmFkaXVzID09IG51bGwpIHJhZGl1cyA9IEluZmluaXR5O1xuICBlbHNlIHtcbiAgICB4MCA9IHggLSByYWRpdXM7XG4gICAgeDMgPSB4ICsgcmFkaXVzO1xuICB9XG5cbiAgd2hpbGUgKHEgPSBoYWx2ZXMucG9wKCkpIHtcblxuICAgIC8vIFN0b3Agc2VhcmNoaW5nIGlmIHRoaXMgaGFsZiBjYW7igJl0IGNvbnRhaW4gYSBjbG9zZXIgbm9kZS5cbiAgICBpZiAoIShub2RlID0gcS5ub2RlKVxuICAgICAgICB8fCAoeDEgPSBxLngwKSA+IHgzXG4gICAgICAgIHx8ICh4MiA9IHEueDEpIDwgeDApIGNvbnRpbnVlO1xuXG4gICAgLy8gQmlzZWN0IHRoZSBjdXJyZW50IGhhbGYuXG4gICAgaWYgKG5vZGUubGVuZ3RoKSB7XG4gICAgICB2YXIgeG0gPSAoeDEgKyB4MikgLyAyO1xuXG4gICAgICBoYWx2ZXMucHVzaChcbiAgICAgICAgbmV3IEhhbGYobm9kZVsxXSwgeG0sIHgyKSxcbiAgICAgICAgbmV3IEhhbGYobm9kZVswXSwgeDEsIHhtKVxuICAgICAgKTtcblxuICAgICAgLy8gVmlzaXQgdGhlIGNsb3Nlc3QgaGFsZiBmaXJzdC5cbiAgICAgIGlmIChpID0gKyh4ID49IHhtKSkge1xuICAgICAgICBxID0gaGFsdmVzW2hhbHZlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaGFsdmVzW2hhbHZlcy5sZW5ndGggLSAxXSA9IGhhbHZlc1toYWx2ZXMubGVuZ3RoIC0gMSAtIGldO1xuICAgICAgICBoYWx2ZXNbaGFsdmVzLmxlbmd0aCAtIDEgLSBpXSA9IHE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmlzaXQgdGhpcyBwb2ludC4gKFZpc2l0aW5nIGNvaW5jaWRlbnQgcG9pbnRzIGlzbuKAmXQgbmVjZXNzYXJ5ISlcbiAgICBlbHNlIHtcbiAgICAgIHZhciBkID0gTWF0aC5hYnMoeCAtICt0aGlzLl94LmNhbGwobnVsbCwgbm9kZS5kYXRhKSk7XG4gICAgICBpZiAoZCA8IHJhZGl1cykge1xuICAgICAgICByYWRpdXMgPSBkO1xuICAgICAgICB4MCA9IHggLSBkO1xuICAgICAgICB4MyA9IHggKyBkO1xuICAgICAgICBkYXRhID0gbm9kZS5kYXRhO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZSwgeDAsIHgxKSB7XG4gIHRoaXMubm9kZSA9IG5vZGU7XG4gIHRoaXMueDAgPSB4MDtcbiAgdGhpcy54MSA9IHgxO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oZCkge1xuICBpZiAoaXNOYU4oeCA9ICt0aGlzLl94LmNhbGwobnVsbCwgZCkpKSByZXR1cm4gdGhpczsgLy8gaWdub3JlIGludmFsaWQgcG9pbnRzXG5cbiAgdmFyIHBhcmVudCxcbiAgICAgIG5vZGUgPSB0aGlzLl9yb290LFxuICAgICAgcmV0YWluZXIsXG4gICAgICBwcmV2aW91cyxcbiAgICAgIG5leHQsXG4gICAgICB4MCA9IHRoaXMuX3gwLFxuICAgICAgeDEgPSB0aGlzLl94MSxcbiAgICAgIHgsXG4gICAgICB4bSxcbiAgICAgIHJpZ2h0LFxuICAgICAgaSxcbiAgICAgIGo7XG5cbiAgLy8gSWYgdGhlIHRyZWUgaXMgZW1wdHksIGluaXRpYWxpemUgdGhlIHJvb3QgYXMgYSBsZWFmLlxuICBpZiAoIW5vZGUpIHJldHVybiB0aGlzO1xuXG4gIC8vIEZpbmQgdGhlIGxlYWYgbm9kZSBmb3IgdGhlIHBvaW50LlxuICAvLyBXaGlsZSBkZXNjZW5kaW5nLCBhbHNvIHJldGFpbiB0aGUgZGVlcGVzdCBwYXJlbnQgd2l0aCBhIG5vbi1yZW1vdmVkIHNpYmxpbmcuXG4gIGlmIChub2RlLmxlbmd0aCkgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAocmlnaHQgPSB4ID49ICh4bSA9ICh4MCArIHgxKSAvIDIpKSB4MCA9IHhtOyBlbHNlIHgxID0geG07XG4gICAgaWYgKCEocGFyZW50ID0gbm9kZSwgbm9kZSA9IG5vZGVbaSA9ICtyaWdodF0pKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIW5vZGUubGVuZ3RoKSBicmVhaztcbiAgICBpZiAocGFyZW50WyhpICsgMSkgJiAxXSkgcmV0YWluZXIgPSBwYXJlbnQsIGogPSBpO1xuICB9XG5cbiAgLy8gRmluZCB0aGUgcG9pbnQgdG8gcmVtb3ZlLlxuICB3aGlsZSAobm9kZS5kYXRhICE9PSBkKSBpZiAoIShwcmV2aW91cyA9IG5vZGUsIG5vZGUgPSBub2RlLm5leHQpKSByZXR1cm4gdGhpcztcbiAgaWYgKG5leHQgPSBub2RlLm5leHQpIGRlbGV0ZSBub2RlLm5leHQ7XG5cbiAgLy8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNvaW5jaWRlbnQgcG9pbnRzLCByZW1vdmUganVzdCB0aGUgcG9pbnQuXG4gIGlmIChwcmV2aW91cykgcmV0dXJuIChuZXh0ID8gcHJldmlvdXMubmV4dCA9IG5leHQgOiBkZWxldGUgcHJldmlvdXMubmV4dCksIHRoaXM7XG5cbiAgLy8gSWYgdGhpcyBpcyB0aGUgcm9vdCBwb2ludCwgcmVtb3ZlIGl0LlxuICBpZiAoIXBhcmVudCkgcmV0dXJuIHRoaXMuX3Jvb3QgPSBuZXh0LCB0aGlzO1xuXG4gIC8vIFJlbW92ZSB0aGlzIGxlYWYuXG4gIG5leHQgPyBwYXJlbnRbaV0gPSBuZXh0IDogZGVsZXRlIHBhcmVudFtpXTtcblxuICAvLyBJZiB0aGUgcGFyZW50IG5vdyBjb250YWlucyBleGFjdGx5IG9uZSBsZWFmLCBjb2xsYXBzZSBzdXBlcmZsdW91cyBwYXJlbnRzLlxuICBpZiAoKG5vZGUgPSBwYXJlbnRbMF0gfHwgcGFyZW50WzFdKVxuICAgICAgJiYgbm9kZSA9PT0gKHBhcmVudFsxXSB8fCBwYXJlbnRbMF0pXG4gICAgICAmJiAhbm9kZS5sZW5ndGgpIHtcbiAgICBpZiAocmV0YWluZXIpIHJldGFpbmVyW2pdID0gbm9kZTtcbiAgICBlbHNlIHRoaXMuX3Jvb3QgPSBub2RlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVBbGwoZGF0YSkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGRhdGEubGVuZ3RoOyBpIDwgbjsgKytpKSB0aGlzLnJlbW92ZShkYXRhW2ldKTtcbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3Jvb3Q7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIHNpemUgPSAwO1xuICB0aGlzLnZpc2l0KGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUubGVuZ3RoKSBkbyArK3NpemU7IHdoaWxlIChub2RlID0gbm9kZS5uZXh0KVxuICB9KTtcbiAgcmV0dXJuIHNpemU7XG59XG4iLCJpbXBvcnQgSGFsZiBmcm9tIFwiLi9oYWxmLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBoYWx2ZXMgPSBbXSwgcSwgbm9kZSA9IHRoaXMuX3Jvb3QsIGNoaWxkLCB4MCwgeDE7XG4gIGlmIChub2RlKSBoYWx2ZXMucHVzaChuZXcgSGFsZihub2RlLCB0aGlzLl94MCwgdGhpcy5feDEpKTtcbiAgd2hpbGUgKHEgPSBoYWx2ZXMucG9wKCkpIHtcbiAgICBpZiAoIWNhbGxiYWNrKG5vZGUgPSBxLm5vZGUsIHgwID0gcS54MCwgeDEgPSBxLngxKSAmJiBub2RlLmxlbmd0aCkge1xuICAgICAgdmFyIHhtID0gKHgwICsgeDEpIC8gMjtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMV0pIGhhbHZlcy5wdXNoKG5ldyBIYWxmKGNoaWxkLCB4bSwgeDEpKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMF0pIGhhbHZlcy5wdXNoKG5ldyBIYWxmKGNoaWxkLCB4MCwgeG0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJpbXBvcnQgSGFsZiBmcm9tIFwiLi9oYWxmLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBoYWx2ZXMgPSBbXSwgbmV4dCA9IFtdLCBxO1xuICBpZiAodGhpcy5fcm9vdCkgaGFsdmVzLnB1c2gobmV3IEhhbGYodGhpcy5fcm9vdCwgdGhpcy5feDAsIHRoaXMuX3gxKSk7XG4gIHdoaWxlIChxID0gaGFsdmVzLnBvcCgpKSB7XG4gICAgdmFyIG5vZGUgPSBxLm5vZGU7XG4gICAgaWYgKG5vZGUubGVuZ3RoKSB7XG4gICAgICB2YXIgY2hpbGQsIHgwID0gcS54MCwgeDEgPSBxLngxLCB4bSA9ICh4MCArIHgxKSAvIDI7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzBdKSBoYWx2ZXMucHVzaChuZXcgSGFsZihjaGlsZCwgeDAsIHhtKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzFdKSBoYWx2ZXMucHVzaChuZXcgSGFsZihjaGlsZCwgeG0sIHgxKSk7XG4gICAgfVxuICAgIG5leHQucHVzaChxKTtcbiAgfVxuICB3aGlsZSAocSA9IG5leHQucG9wKCkpIHtcbiAgICBjYWxsYmFjayhxLm5vZGUsIHEueDAsIHEueDEpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRYKGQpIHtcbiAgcmV0dXJuIGRbMF07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKF8pIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGhpcy5feCA9IF8sIHRoaXMpIDogdGhpcy5feDtcbn1cbiIsInZhciBub29wID0ge3ZhbHVlOiAoKSA9PiB7fX07XG5cbmZ1bmN0aW9uIGRpc3BhdGNoKCkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGFyZ3VtZW50cy5sZW5ndGgsIF8gPSB7fSwgdDsgaSA8IG47ICsraSkge1xuICAgIGlmICghKHQgPSBhcmd1bWVudHNbaV0gKyBcIlwiKSB8fCAodCBpbiBfKSB8fCAvW1xccy5dLy50ZXN0KHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIHR5cGU6IFwiICsgdCk7XG4gICAgX1t0XSA9IFtdO1xuICB9XG4gIHJldHVybiBuZXcgRGlzcGF0Y2goXyk7XG59XG5cbmZ1bmN0aW9uIERpc3BhdGNoKF8pIHtcbiAgdGhpcy5fID0gXztcbn1cblxuZnVuY3Rpb24gcGFyc2VUeXBlbmFtZXModHlwZW5hbWVzLCB0eXBlcykge1xuICByZXR1cm4gdHlwZW5hbWVzLnRyaW0oKS5zcGxpdCgvXnxcXHMrLykubWFwKGZ1bmN0aW9uKHQpIHtcbiAgICB2YXIgbmFtZSA9IFwiXCIsIGkgPSB0LmluZGV4T2YoXCIuXCIpO1xuICAgIGlmIChpID49IDApIG5hbWUgPSB0LnNsaWNlKGkgKyAxKSwgdCA9IHQuc2xpY2UoMCwgaSk7XG4gICAgaWYgKHQgJiYgIXR5cGVzLmhhc093blByb3BlcnR5KHQpKSB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHR5cGU6IFwiICsgdCk7XG4gICAgcmV0dXJuIHt0eXBlOiB0LCBuYW1lOiBuYW1lfTtcbiAgfSk7XG59XG5cbkRpc3BhdGNoLnByb3RvdHlwZSA9IGRpc3BhdGNoLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IERpc3BhdGNoLFxuICBvbjogZnVuY3Rpb24odHlwZW5hbWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIF8gPSB0aGlzLl8sXG4gICAgICAgIFQgPSBwYXJzZVR5cGVuYW1lcyh0eXBlbmFtZSArIFwiXCIsIF8pLFxuICAgICAgICB0LFxuICAgICAgICBpID0gLTEsXG4gICAgICAgIG4gPSBULmxlbmd0aDtcblxuICAgIC8vIElmIG5vIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIHJldHVybiB0aGUgY2FsbGJhY2sgb2YgdGhlIGdpdmVuIHR5cGUgYW5kIG5hbWUuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICB3aGlsZSAoKytpIDwgbikgaWYgKCh0ID0gKHR5cGVuYW1lID0gVFtpXSkudHlwZSkgJiYgKHQgPSBnZXQoX1t0XSwgdHlwZW5hbWUubmFtZSkpKSByZXR1cm4gdDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiBhIHR5cGUgd2FzIHNwZWNpZmllZCwgc2V0IHRoZSBjYWxsYmFjayBmb3IgdGhlIGdpdmVuIHR5cGUgYW5kIG5hbWUuXG4gICAgLy8gT3RoZXJ3aXNlLCBpZiBhIG51bGwgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgcmVtb3ZlIGNhbGxiYWNrcyBvZiB0aGUgZ2l2ZW4gbmFtZS5cbiAgICBpZiAoY2FsbGJhY2sgIT0gbnVsbCAmJiB0eXBlb2YgY2FsbGJhY2sgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjYWxsYmFjazogXCIgKyBjYWxsYmFjayk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIGlmICh0ID0gKHR5cGVuYW1lID0gVFtpXSkudHlwZSkgX1t0XSA9IHNldChfW3RdLCB0eXBlbmFtZS5uYW1lLCBjYWxsYmFjayk7XG4gICAgICBlbHNlIGlmIChjYWxsYmFjayA9PSBudWxsKSBmb3IgKHQgaW4gXykgX1t0XSA9IHNldChfW3RdLCB0eXBlbmFtZS5uYW1lLCBudWxsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgY29weTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNvcHkgPSB7fSwgXyA9IHRoaXMuXztcbiAgICBmb3IgKHZhciB0IGluIF8pIGNvcHlbdF0gPSBfW3RdLnNsaWNlKCk7XG4gICAgcmV0dXJuIG5ldyBEaXNwYXRjaChjb3B5KTtcbiAgfSxcbiAgY2FsbDogZnVuY3Rpb24odHlwZSwgdGhhdCkge1xuICAgIGlmICgobiA9IGFyZ3VtZW50cy5sZW5ndGggLSAyKSA+IDApIGZvciAodmFyIGFyZ3MgPSBuZXcgQXJyYXkobiksIGkgPSAwLCBuLCB0OyBpIDwgbjsgKytpKSBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICBpZiAoIXRoaXMuXy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgIGZvciAodCA9IHRoaXMuX1t0eXBlXSwgaSA9IDAsIG4gPSB0Lmxlbmd0aDsgaSA8IG47ICsraSkgdFtpXS52YWx1ZS5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfSxcbiAgYXBwbHk6IGZ1bmN0aW9uKHR5cGUsIHRoYXQsIGFyZ3MpIHtcbiAgICBpZiAoIXRoaXMuXy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIiArIHR5cGUpO1xuICAgIGZvciAodmFyIHQgPSB0aGlzLl9bdHlwZV0sIGkgPSAwLCBuID0gdC5sZW5ndGg7IGkgPCBuOyArK2kpIHRbaV0udmFsdWUuYXBwbHkodGhhdCwgYXJncyk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGdldCh0eXBlLCBuYW1lKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gdHlwZS5sZW5ndGgsIGM7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoKGMgPSB0eXBlW2ldKS5uYW1lID09PSBuYW1lKSB7XG4gICAgICByZXR1cm4gYy52YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0KHR5cGUsIG5hbWUsIGNhbGxiYWNrKSB7XG4gIGZvciAodmFyIGkgPSAwLCBuID0gdHlwZS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAodHlwZVtpXS5uYW1lID09PSBuYW1lKSB7XG4gICAgICB0eXBlW2ldID0gbm9vcCwgdHlwZSA9IHR5cGUuc2xpY2UoMCwgaSkuY29uY2F0KHR5cGUuc2xpY2UoaSArIDEpKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBpZiAoY2FsbGJhY2sgIT0gbnVsbCkgdHlwZS5wdXNoKHtuYW1lOiBuYW1lLCB2YWx1ZTogY2FsbGJhY2t9KTtcbiAgcmV0dXJuIHR5cGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRpc3BhdGNoO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCwgeSwgeikge1xuICB2YXIgbm9kZXMsIHN0cmVuZ3RoID0gMTtcblxuICBpZiAoeCA9PSBudWxsKSB4ID0gMDtcbiAgaWYgKHkgPT0gbnVsbCkgeSA9IDA7XG4gIGlmICh6ID09IG51bGwpIHogPSAwO1xuXG4gIGZ1bmN0aW9uIGZvcmNlKCkge1xuICAgIHZhciBpLFxuICAgICAgICBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICBub2RlLFxuICAgICAgICBzeCA9IDAsXG4gICAgICAgIHN5ID0gMCxcbiAgICAgICAgc3ogPSAwO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldLCBzeCArPSBub2RlLnggfHwgMCwgc3kgKz0gbm9kZS55IHx8IDAsIHN6ICs9IG5vZGUueiB8fCAwO1xuICAgIH1cblxuICAgIGZvciAoc3ggPSAoc3ggLyBuIC0geCkgKiBzdHJlbmd0aCwgc3kgPSAoc3kgLyBuIC0geSkgKiBzdHJlbmd0aCwgc3ogPSAoc3ogLyBuIC0geikgKiBzdHJlbmd0aCwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgIGlmIChzeCkgeyBub2RlLnggLT0gc3ggfVxuICAgICAgaWYgKHN5KSB7IG5vZGUueSAtPSBzeTsgfVxuICAgICAgaWYgKHN6KSB7IG5vZGUueiAtPSBzejsgfVxuICAgIH1cbiAgfVxuXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgbm9kZXMgPSBfO1xuICB9O1xuXG4gIGZvcmNlLnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9ICtfLCBmb3JjZSkgOiB4O1xuICB9O1xuXG4gIGZvcmNlLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9ICtfLCBmb3JjZSkgOiB5O1xuICB9O1xuXG4gIGZvcmNlLnogPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeiA9ICtfLCBmb3JjZSkgOiB6O1xuICB9O1xuXG4gIGZvcmNlLnN0cmVuZ3RoID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0cmVuZ3RoID0gK18sIGZvcmNlKSA6IHN0cmVuZ3RoO1xuICB9O1xuXG4gIHJldHVybiBmb3JjZTtcbn1cbiIsImltcG9ydCB7YmluYXJ5dHJlZX0gZnJvbSBcImQzLWJpbmFyeXRyZWVcIjtcbmltcG9ydCB7cXVhZHRyZWV9IGZyb20gXCJkMy1xdWFkdHJlZVwiO1xuaW1wb3J0IHtvY3RyZWV9IGZyb20gXCJkMy1vY3RyZWVcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IGppZ2dsZSBmcm9tIFwiLi9qaWdnbGUuanNcIjtcblxuZnVuY3Rpb24geChkKSB7XG4gIHJldHVybiBkLnggKyBkLnZ4O1xufVxuXG5mdW5jdGlvbiB5KGQpIHtcbiAgcmV0dXJuIGQueSArIGQudnk7XG59XG5cbmZ1bmN0aW9uIHooZCkge1xuICByZXR1cm4gZC56ICsgZC52ejtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocmFkaXVzKSB7XG4gIHZhciBub2RlcyxcbiAgICAgIG5EaW0sXG4gICAgICByYWRpaSxcbiAgICAgIHJhbmRvbSxcbiAgICAgIHN0cmVuZ3RoID0gMSxcbiAgICAgIGl0ZXJhdGlvbnMgPSAxO1xuXG4gIGlmICh0eXBlb2YgcmFkaXVzICE9PSBcImZ1bmN0aW9uXCIpIHJhZGl1cyA9IGNvbnN0YW50KHJhZGl1cyA9PSBudWxsID8gMSA6ICtyYWRpdXMpO1xuXG4gIGZ1bmN0aW9uIGZvcmNlKCkge1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICB0cmVlLFxuICAgICAgICBub2RlLFxuICAgICAgICB4aSxcbiAgICAgICAgeWksXG4gICAgICAgIHppLFxuICAgICAgICByaSxcbiAgICAgICAgcmkyO1xuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBpdGVyYXRpb25zOyArK2spIHtcbiAgICAgIHRyZWUgPVxuICAgICAgICAgIChuRGltID09PSAxID8gYmluYXJ5dHJlZShub2RlcywgeClcbiAgICAgICAgICA6KG5EaW0gPT09IDIgPyBxdWFkdHJlZShub2RlcywgeCwgeSlcbiAgICAgICAgICA6KG5EaW0gPT09IDMgPyBvY3RyZWUobm9kZXMsIHgsIHksIHopXG4gICAgICAgICAgOm51bGxcbiAgICAgICkpKS52aXNpdEFmdGVyKHByZXBhcmUpO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgcmkgPSByYWRpaVtub2RlLmluZGV4XSwgcmkyID0gcmkgKiByaTtcbiAgICAgICAgeGkgPSBub2RlLnggKyBub2RlLnZ4O1xuICAgICAgICBpZiAobkRpbSA+IDEpIHsgeWkgPSBub2RlLnkgKyBub2RlLnZ5OyB9XG4gICAgICAgIGlmIChuRGltID4gMikgeyB6aSA9IG5vZGUueiArIG5vZGUudno7IH1cbiAgICAgICAgdHJlZS52aXNpdChhcHBseSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHkodHJlZU5vZGUsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUsIGFyZzYpIHtcbiAgICAgIHZhciBhcmdzID0gW2FyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUsIGFyZzZdO1xuICAgICAgdmFyIHgwID0gYXJnc1swXSxcbiAgICAgICAgICB5MCA9IGFyZ3NbMV0sXG4gICAgICAgICAgejAgPSBhcmdzWzJdLFxuICAgICAgICAgIHgxID0gYXJnc1tuRGltXSxcbiAgICAgICAgICB5MSA9IGFyZ3NbbkRpbSsxXSxcbiAgICAgICAgICB6MSA9IGFyZ3NbbkRpbSsyXTtcblxuICAgICAgdmFyIGRhdGEgPSB0cmVlTm9kZS5kYXRhLCByaiA9IHRyZWVOb2RlLnIsIHIgPSByaSArIHJqO1xuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEuaW5kZXggPiBub2RlLmluZGV4KSB7XG4gICAgICAgICAgdmFyIHggPSB4aSAtIGRhdGEueCAtIGRhdGEudngsXG4gICAgICAgICAgICAgIHkgPSAobkRpbSA+IDEgPyB5aSAtIGRhdGEueSAtIGRhdGEudnkgOiAwKSxcbiAgICAgICAgICAgICAgeiA9IChuRGltID4gMiA/IHppIC0gZGF0YS56IC0gZGF0YS52eiA6IDApLFxuICAgICAgICAgICAgICBsID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuICAgICAgICAgIGlmIChsIDwgciAqIHIpIHtcbiAgICAgICAgICAgIGlmICh4ID09PSAwKSB4ID0gamlnZ2xlKHJhbmRvbSksIGwgKz0geCAqIHg7XG4gICAgICAgICAgICBpZiAobkRpbSA+IDEgJiYgeSA9PT0gMCkgeSA9IGppZ2dsZShyYW5kb20pLCBsICs9IHkgKiB5O1xuICAgICAgICAgICAgaWYgKG5EaW0gPiAyICYmIHogPT09IDApIHogPSBqaWdnbGUocmFuZG9tKSwgbCArPSB6ICogejtcbiAgICAgICAgICAgIGwgPSAociAtIChsID0gTWF0aC5zcXJ0KGwpKSkgLyBsICogc3RyZW5ndGg7XG5cbiAgICAgICAgICAgIG5vZGUudnggKz0gKHggKj0gbCkgKiAociA9IChyaiAqPSByaikgLyAocmkyICsgcmopKTtcbiAgICAgICAgICAgIGlmIChuRGltID4gMSkgeyBub2RlLnZ5ICs9ICh5ICo9IGwpICogcjsgfVxuICAgICAgICAgICAgaWYgKG5EaW0gPiAyKSB7IG5vZGUudnogKz0gKHogKj0gbCkgKiByOyB9XG5cbiAgICAgICAgICAgIGRhdGEudnggLT0geCAqIChyID0gMSAtIHIpO1xuICAgICAgICAgICAgaWYgKG5EaW0gPiAxKSB7IGRhdGEudnkgLT0geSAqIHI7IH1cbiAgICAgICAgICAgIGlmIChuRGltID4gMikgeyBkYXRhLnZ6IC09IHogKiByOyB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4MCA+IHhpICsgciB8fCB4MSA8IHhpIC0gclxuICAgICAgICAgIHx8IChuRGltID4gMSAmJiAoeTAgPiB5aSArIHIgfHwgeTEgPCB5aSAtIHIpKVxuICAgICAgICAgIHx8IChuRGltID4gMiAmJiAoejAgPiB6aSArIHIgfHwgejEgPCB6aSAtIHIpKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlKHRyZWVOb2RlKSB7XG4gICAgaWYgKHRyZWVOb2RlLmRhdGEpIHJldHVybiB0cmVlTm9kZS5yID0gcmFkaWlbdHJlZU5vZGUuZGF0YS5pbmRleF07XG4gICAgZm9yICh2YXIgaSA9IHRyZWVOb2RlLnIgPSAwOyBpIDwgTWF0aC5wb3coMiwgbkRpbSk7ICsraSkge1xuICAgICAgaWYgKHRyZWVOb2RlW2ldICYmIHRyZWVOb2RlW2ldLnIgPiB0cmVlTm9kZS5yKSB7XG4gICAgICAgIHRyZWVOb2RlLnIgPSB0cmVlTm9kZVtpXS5yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoLCBub2RlO1xuICAgIHJhZGlpID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIG5vZGUgPSBub2Rlc1tpXSwgcmFkaWlbbm9kZS5pbmRleF0gPSArcmFkaXVzKG5vZGUsIGksIG5vZGVzKTtcbiAgfVxuXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfbm9kZXMsIC4uLmFyZ3MpIHtcbiAgICBub2RlcyA9IF9ub2RlcztcbiAgICByYW5kb20gPSBhcmdzLmZpbmQoYXJnID0+IHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicpIHx8IE1hdGgucmFuZG9tO1xuICAgIG5EaW0gPSBhcmdzLmZpbmQoYXJnID0+IFsxLCAyLCAzXS5pbmNsdWRlcyhhcmcpKSB8fCAyO1xuICAgIGluaXRpYWxpemUoKTtcbiAgfTtcblxuICBmb3JjZS5pdGVyYXRpb25zID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGl0ZXJhdGlvbnMgPSArXywgZm9yY2UpIDogaXRlcmF0aW9ucztcbiAgfTtcblxuICBmb3JjZS5zdHJlbmd0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9ICtfLCBmb3JjZSkgOiBzdHJlbmd0aDtcbiAgfTtcblxuICBmb3JjZS5yYWRpdXMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAocmFkaXVzID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogcmFkaXVzO1xuICB9O1xuXG4gIHJldHVybiBmb3JjZTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB4O1xuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24ocmFuZG9tKSB7XG4gIHJldHVybiAocmFuZG9tKCkgLSAwLjUpICogMWUtNjtcbn1cbiIsIi8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpbmVhcl9jb25ncnVlbnRpYWxfZ2VuZXJhdG9yI1BhcmFtZXRlcnNfaW5fY29tbW9uX3VzZVxuY29uc3QgYSA9IDE2NjQ1MjU7XG5jb25zdCBjID0gMTAxMzkwNDIyMztcbmNvbnN0IG0gPSA0Mjk0OTY3Mjk2OyAvLyAyXjMyXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICBsZXQgcyA9IDE7XG4gIHJldHVybiAoKSA9PiAocyA9IChhICogcyArIGMpICUgbSkgLyBtO1xufVxuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5pbXBvcnQgamlnZ2xlIGZyb20gXCIuL2ppZ2dsZS5qc1wiO1xuXG5mdW5jdGlvbiBpbmRleChkKSB7XG4gIHJldHVybiBkLmluZGV4O1xufVxuXG5mdW5jdGlvbiBmaW5kKG5vZGVCeUlkLCBub2RlSWQpIHtcbiAgdmFyIG5vZGUgPSBub2RlQnlJZC5nZXQobm9kZUlkKTtcbiAgaWYgKCFub2RlKSB0aHJvdyBuZXcgRXJyb3IoXCJub2RlIG5vdCBmb3VuZDogXCIgKyBub2RlSWQpO1xuICByZXR1cm4gbm9kZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obGlua3MpIHtcbiAgdmFyIGlkID0gaW5kZXgsXG4gICAgICBzdHJlbmd0aCA9IGRlZmF1bHRTdHJlbmd0aCxcbiAgICAgIHN0cmVuZ3RocyxcbiAgICAgIGRpc3RhbmNlID0gY29uc3RhbnQoMzApLFxuICAgICAgZGlzdGFuY2VzLFxuICAgICAgbm9kZXMsXG4gICAgICBuRGltLFxuICAgICAgY291bnQsXG4gICAgICBiaWFzLFxuICAgICAgcmFuZG9tLFxuICAgICAgaXRlcmF0aW9ucyA9IDE7XG5cbiAgaWYgKGxpbmtzID09IG51bGwpIGxpbmtzID0gW107XG5cbiAgZnVuY3Rpb24gZGVmYXVsdFN0cmVuZ3RoKGxpbmspIHtcbiAgICByZXR1cm4gMSAvIE1hdGgubWluKGNvdW50W2xpbmsuc291cmNlLmluZGV4XSwgY291bnRbbGluay50YXJnZXQuaW5kZXhdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcmNlKGFscGhhKSB7XG4gICAgZm9yICh2YXIgayA9IDAsIG4gPSBsaW5rcy5sZW5ndGg7IGsgPCBpdGVyYXRpb25zOyArK2spIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsaW5rLCBzb3VyY2UsIHRhcmdldCwgeCA9IDAsIHkgPSAwLCB6ID0gMCwgbCwgYjsgaSA8IG47ICsraSkge1xuICAgICAgICBsaW5rID0gbGlua3NbaV0sIHNvdXJjZSA9IGxpbmsuc291cmNlLCB0YXJnZXQgPSBsaW5rLnRhcmdldDtcbiAgICAgICAgeCA9IHRhcmdldC54ICsgdGFyZ2V0LnZ4IC0gc291cmNlLnggLSBzb3VyY2UudnggfHwgamlnZ2xlKHJhbmRvbSk7XG4gICAgICAgIGlmIChuRGltID4gMSkgeyB5ID0gdGFyZ2V0LnkgKyB0YXJnZXQudnkgLSBzb3VyY2UueSAtIHNvdXJjZS52eSB8fCBqaWdnbGUocmFuZG9tKTsgfVxuICAgICAgICBpZiAobkRpbSA+IDIpIHsgeiA9IHRhcmdldC56ICsgdGFyZ2V0LnZ6IC0gc291cmNlLnogLSBzb3VyY2UudnogfHwgamlnZ2xlKHJhbmRvbSk7IH1cbiAgICAgICAgbCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xuICAgICAgICBsID0gKGwgLSBkaXN0YW5jZXNbaV0pIC8gbCAqIGFscGhhICogc3RyZW5ndGhzW2ldO1xuICAgICAgICB4ICo9IGwsIHkgKj0gbCwgeiAqPSBsO1xuXG4gICAgICAgIHRhcmdldC52eCAtPSB4ICogKGIgPSBiaWFzW2ldKTtcbiAgICAgICAgaWYgKG5EaW0gPiAxKSB7IHRhcmdldC52eSAtPSB5ICogYjsgfVxuICAgICAgICBpZiAobkRpbSA+IDIpIHsgdGFyZ2V0LnZ6IC09IHogKiBiOyB9XG5cbiAgICAgICAgc291cmNlLnZ4ICs9IHggKiAoYiA9IDEgLSBiKTtcbiAgICAgICAgaWYgKG5EaW0gPiAxKSB7IHNvdXJjZS52eSArPSB5ICogYjsgfVxuICAgICAgICBpZiAobkRpbSA+IDIpIHsgc291cmNlLnZ6ICs9IHogKiBiOyB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAoIW5vZGVzKSByZXR1cm47XG5cbiAgICB2YXIgaSxcbiAgICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgbSA9IGxpbmtzLmxlbmd0aCxcbiAgICAgICAgbm9kZUJ5SWQgPSBuZXcgTWFwKG5vZGVzLm1hcCgoZCwgaSkgPT4gW2lkKGQsIGksIG5vZGVzKSwgZF0pKSxcbiAgICAgICAgbGluaztcblxuICAgIGZvciAoaSA9IDAsIGNvdW50ID0gbmV3IEFycmF5KG4pOyBpIDwgbTsgKytpKSB7XG4gICAgICBsaW5rID0gbGlua3NbaV0sIGxpbmsuaW5kZXggPSBpO1xuICAgICAgaWYgKHR5cGVvZiBsaW5rLnNvdXJjZSAhPT0gXCJvYmplY3RcIikgbGluay5zb3VyY2UgPSBmaW5kKG5vZGVCeUlkLCBsaW5rLnNvdXJjZSk7XG4gICAgICBpZiAodHlwZW9mIGxpbmsudGFyZ2V0ICE9PSBcIm9iamVjdFwiKSBsaW5rLnRhcmdldCA9IGZpbmQobm9kZUJ5SWQsIGxpbmsudGFyZ2V0KTtcbiAgICAgIGNvdW50W2xpbmsuc291cmNlLmluZGV4XSA9IChjb3VudFtsaW5rLnNvdXJjZS5pbmRleF0gfHwgMCkgKyAxO1xuICAgICAgY291bnRbbGluay50YXJnZXQuaW5kZXhdID0gKGNvdW50W2xpbmsudGFyZ2V0LmluZGV4XSB8fCAwKSArIDE7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMCwgYmlhcyA9IG5ldyBBcnJheShtKTsgaSA8IG07ICsraSkge1xuICAgICAgbGluayA9IGxpbmtzW2ldLCBiaWFzW2ldID0gY291bnRbbGluay5zb3VyY2UuaW5kZXhdIC8gKGNvdW50W2xpbmsuc291cmNlLmluZGV4XSArIGNvdW50W2xpbmsudGFyZ2V0LmluZGV4XSk7XG4gICAgfVxuXG4gICAgc3RyZW5ndGhzID0gbmV3IEFycmF5KG0pLCBpbml0aWFsaXplU3RyZW5ndGgoKTtcbiAgICBkaXN0YW5jZXMgPSBuZXcgQXJyYXkobSksIGluaXRpYWxpemVEaXN0YW5jZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZVN0cmVuZ3RoKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcblxuICAgIGZvciAodmFyIGkgPSAwLCBuID0gbGlua3MubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBzdHJlbmd0aHNbaV0gPSArc3RyZW5ndGgobGlua3NbaV0sIGksIGxpbmtzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplRGlzdGFuY2UoKSB7XG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBsaW5rcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGRpc3RhbmNlc1tpXSA9ICtkaXN0YW5jZShsaW5rc1tpXSwgaSwgbGlua3MpO1xuICAgIH1cbiAgfVxuXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfbm9kZXMsIC4uLmFyZ3MpIHtcbiAgICBub2RlcyA9IF9ub2RlcztcbiAgICByYW5kb20gPSBhcmdzLmZpbmQoYXJnID0+IHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbicpIHx8IE1hdGgucmFuZG9tO1xuICAgIG5EaW0gPSBhcmdzLmZpbmQoYXJnID0+IFsxLCAyLCAzXS5pbmNsdWRlcyhhcmcpKSB8fCAyO1xuICAgIGluaXRpYWxpemUoKTtcbiAgfTtcblxuICBmb3JjZS5saW5rcyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChsaW5rcyA9IF8sIGluaXRpYWxpemUoKSwgZm9yY2UpIDogbGlua3M7XG4gIH07XG5cbiAgZm9yY2UuaWQgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaWQgPSBfLCBmb3JjZSkgOiBpZDtcbiAgfTtcblxuICBmb3JjZS5pdGVyYXRpb25zID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGl0ZXJhdGlvbnMgPSArXywgZm9yY2UpIDogaXRlcmF0aW9ucztcbiAgfTtcblxuICBmb3JjZS5zdHJlbmd0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplU3RyZW5ndGgoKSwgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgZm9yY2UuZGlzdGFuY2UgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGlzdGFuY2UgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZURpc3RhbmNlKCksIGZvcmNlKSA6IGRpc3RhbmNlO1xuICB9O1xuXG4gIHJldHVybiBmb3JjZTtcbn1cbiIsImltcG9ydCB7YmluYXJ5dHJlZX0gZnJvbSBcImQzLWJpbmFyeXRyZWVcIjtcbmltcG9ydCB7cXVhZHRyZWV9IGZyb20gXCJkMy1xdWFkdHJlZVwiO1xuaW1wb3J0IHtvY3RyZWV9IGZyb20gXCJkMy1vY3RyZWVcIjtcbmltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IGppZ2dsZSBmcm9tIFwiLi9qaWdnbGUuanNcIjtcbmltcG9ydCB7eCwgeSwgen0gZnJvbSBcIi4vc2ltdWxhdGlvbi5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIG5vZGVzLFxuICAgICAgbkRpbSxcbiAgICAgIG5vZGUsXG4gICAgICByYW5kb20sXG4gICAgICBhbHBoYSxcbiAgICAgIHN0cmVuZ3RoID0gY29uc3RhbnQoLTMwKSxcbiAgICAgIHN0cmVuZ3RocyxcbiAgICAgIGRpc3RhbmNlTWluMiA9IDEsXG4gICAgICBkaXN0YW5jZU1heDIgPSBJbmZpbml0eSxcbiAgICAgIHRoZXRhMiA9IDAuODE7XG5cbiAgZnVuY3Rpb24gZm9yY2UoXykge1xuICAgIHZhciBpLFxuICAgICAgICBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICB0cmVlID1cbiAgICAgICAgICAgIChuRGltID09PSAxID8gYmluYXJ5dHJlZShub2RlcywgeClcbiAgICAgICAgICAgIDoobkRpbSA9PT0gMiA/IHF1YWR0cmVlKG5vZGVzLCB4LCB5KVxuICAgICAgICAgICAgOihuRGltID09PSAzID8gb2N0cmVlKG5vZGVzLCB4LCB5LCB6KVxuICAgICAgICAgICAgOm51bGxcbiAgICAgICAgKSkpLnZpc2l0QWZ0ZXIoYWNjdW11bGF0ZSk7XG5cbiAgICBmb3IgKGFscGhhID0gXywgaSA9IDA7IGkgPCBuOyArK2kpIG5vZGUgPSBub2Rlc1tpXSwgdHJlZS52aXNpdChhcHBseSk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTtcbiAgICBzdHJlbmd0aHMgPSBuZXcgQXJyYXkobik7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgbm9kZSA9IG5vZGVzW2ldLCBzdHJlbmd0aHNbbm9kZS5pbmRleF0gPSArc3RyZW5ndGgobm9kZSwgaSwgbm9kZXMpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWNjdW11bGF0ZSh0cmVlTm9kZSkge1xuICAgIHZhciBzdHJlbmd0aCA9IDAsIHEsIGMsIHdlaWdodCA9IDAsIHgsIHksIHosIGk7XG4gICAgdmFyIG51bUNoaWxkcmVuID0gdHJlZU5vZGUubGVuZ3RoO1xuXG4gICAgLy8gRm9yIGludGVybmFsIG5vZGVzLCBhY2N1bXVsYXRlIGZvcmNlcyBmcm9tIGNoaWxkcmVuLlxuICAgIGlmIChudW1DaGlsZHJlbikge1xuICAgICAgZm9yICh4ID0geSA9IHogPSBpID0gMDsgaSA8IG51bUNoaWxkcmVuOyArK2kpIHtcbiAgICAgICAgaWYgKChxID0gdHJlZU5vZGVbaV0pICYmIChjID0gTWF0aC5hYnMocS52YWx1ZSkpKSB7XG4gICAgICAgICAgc3RyZW5ndGggKz0gcS52YWx1ZSwgd2VpZ2h0ICs9IGMsIHggKz0gYyAqIChxLnggfHwgMCksIHkgKz0gYyAqIChxLnkgfHwgMCksIHogKz0gYyAqIChxLnogfHwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0cmVuZ3RoICo9IE1hdGguc3FydCg0IC8gbnVtQ2hpbGRyZW4pOyAvLyBzY2FsZSBhY2N1bXVsYXRlZCBzdHJlbmd0aCBhY2NvcmRpbmcgdG8gbnVtYmVyIG9mIGRpbWVuc2lvbnNcblxuICAgICAgdHJlZU5vZGUueCA9IHggLyB3ZWlnaHQ7XG4gICAgICBpZiAobkRpbSA+IDEpIHsgdHJlZU5vZGUueSA9IHkgLyB3ZWlnaHQ7IH1cbiAgICAgIGlmIChuRGltID4gMikgeyB0cmVlTm9kZS56ID0geiAvIHdlaWdodDsgfVxuICAgIH1cblxuICAgIC8vIEZvciBsZWFmIG5vZGVzLCBhY2N1bXVsYXRlIGZvcmNlcyBmcm9tIGNvaW5jaWRlbnQgbm9kZXMuXG4gICAgZWxzZSB7XG4gICAgICBxID0gdHJlZU5vZGU7XG4gICAgICBxLnggPSBxLmRhdGEueDtcbiAgICAgIGlmIChuRGltID4gMSkgeyBxLnkgPSBxLmRhdGEueTsgfVxuICAgICAgaWYgKG5EaW0gPiAyKSB7IHEueiA9IHEuZGF0YS56OyB9XG4gICAgICBkbyBzdHJlbmd0aCArPSBzdHJlbmd0aHNbcS5kYXRhLmluZGV4XTtcbiAgICAgIHdoaWxlIChxID0gcS5uZXh0KTtcbiAgICB9XG5cbiAgICB0cmVlTm9kZS52YWx1ZSA9IHN0cmVuZ3RoO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwbHkodHJlZU5vZGUsIHgxLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgaWYgKCF0cmVlTm9kZS52YWx1ZSkgcmV0dXJuIHRydWU7XG4gICAgdmFyIHgyID0gW2FyZzEsIGFyZzIsIGFyZzNdW25EaW0tMV07XG5cbiAgICB2YXIgeCA9IHRyZWVOb2RlLnggLSBub2RlLngsXG4gICAgICAgIHkgPSAobkRpbSA+IDEgPyB0cmVlTm9kZS55IC0gbm9kZS55IDogMCksXG4gICAgICAgIHogPSAobkRpbSA+IDIgPyB0cmVlTm9kZS56IC0gbm9kZS56IDogMCksXG4gICAgICAgIHcgPSB4MiAtIHgxLFxuICAgICAgICBsID0geCAqIHggKyB5ICogeSArIHogKiB6O1xuXG4gICAgLy8gQXBwbHkgdGhlIEJhcm5lcy1IdXQgYXBwcm94aW1hdGlvbiBpZiBwb3NzaWJsZS5cbiAgICAvLyBMaW1pdCBmb3JjZXMgZm9yIHZlcnkgY2xvc2Ugbm9kZXM7IHJhbmRvbWl6ZSBkaXJlY3Rpb24gaWYgY29pbmNpZGVudC5cbiAgICBpZiAodyAqIHcgLyB0aGV0YTIgPCBsKSB7XG4gICAgICBpZiAobCA8IGRpc3RhbmNlTWF4Mikge1xuICAgICAgICBpZiAoeCA9PT0gMCkgeCA9IGppZ2dsZShyYW5kb20pLCBsICs9IHggKiB4O1xuICAgICAgICBpZiAobkRpbSA+IDEgJiYgeSA9PT0gMCkgeSA9IGppZ2dsZShyYW5kb20pLCBsICs9IHkgKiB5O1xuICAgICAgICBpZiAobkRpbSA+IDIgJiYgeiA9PT0gMCkgeiA9IGppZ2dsZShyYW5kb20pLCBsICs9IHogKiB6O1xuICAgICAgICBpZiAobCA8IGRpc3RhbmNlTWluMikgbCA9IE1hdGguc3FydChkaXN0YW5jZU1pbjIgKiBsKTtcbiAgICAgICAgbm9kZS52eCArPSB4ICogdHJlZU5vZGUudmFsdWUgKiBhbHBoYSAvIGw7XG4gICAgICAgIGlmIChuRGltID4gMSkgeyBub2RlLnZ5ICs9IHkgKiB0cmVlTm9kZS52YWx1ZSAqIGFscGhhIC8gbDsgfVxuICAgICAgICBpZiAobkRpbSA+IDIpIHsgbm9kZS52eiArPSB6ICogdHJlZU5vZGUudmFsdWUgKiBhbHBoYSAvIGw7IH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSwgcHJvY2VzcyBwb2ludHMgZGlyZWN0bHkuXG4gICAgZWxzZSBpZiAodHJlZU5vZGUubGVuZ3RoIHx8IGwgPj0gZGlzdGFuY2VNYXgyKSByZXR1cm47XG5cbiAgICAvLyBMaW1pdCBmb3JjZXMgZm9yIHZlcnkgY2xvc2Ugbm9kZXM7IHJhbmRvbWl6ZSBkaXJlY3Rpb24gaWYgY29pbmNpZGVudC5cbiAgICBpZiAodHJlZU5vZGUuZGF0YSAhPT0gbm9kZSB8fCB0cmVlTm9kZS5uZXh0KSB7XG4gICAgICBpZiAoeCA9PT0gMCkgeCA9IGppZ2dsZShyYW5kb20pLCBsICs9IHggKiB4O1xuICAgICAgaWYgKG5EaW0gPiAxICYmIHkgPT09IDApIHkgPSBqaWdnbGUocmFuZG9tKSwgbCArPSB5ICogeTtcbiAgICAgIGlmIChuRGltID4gMiAmJiB6ID09PSAwKSB6ID0gamlnZ2xlKHJhbmRvbSksIGwgKz0geiAqIHo7XG4gICAgICBpZiAobCA8IGRpc3RhbmNlTWluMikgbCA9IE1hdGguc3FydChkaXN0YW5jZU1pbjIgKiBsKTtcbiAgICB9XG5cbiAgICBkbyBpZiAodHJlZU5vZGUuZGF0YSAhPT0gbm9kZSkge1xuICAgICAgdyA9IHN0cmVuZ3Roc1t0cmVlTm9kZS5kYXRhLmluZGV4XSAqIGFscGhhIC8gbDtcbiAgICAgIG5vZGUudnggKz0geCAqIHc7XG4gICAgICBpZiAobkRpbSA+IDEpIHsgbm9kZS52eSArPSB5ICogdzsgfVxuICAgICAgaWYgKG5EaW0gPiAyKSB7IG5vZGUudnogKz0geiAqIHc7IH1cbiAgICB9IHdoaWxlICh0cmVlTm9kZSA9IHRyZWVOb2RlLm5leHQpO1xuICB9XG5cbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKF9ub2RlcywgLi4uYXJncykge1xuICAgIG5vZGVzID0gX25vZGVzO1xuICAgIHJhbmRvbSA9IGFyZ3MuZmluZChhcmcgPT4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJykgfHwgTWF0aC5yYW5kb207XG4gICAgbkRpbSA9IGFyZ3MuZmluZChhcmcgPT4gWzEsIDIsIDNdLmluY2x1ZGVzKGFyZykpIHx8IDI7XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9O1xuXG4gIGZvcmNlLnN0cmVuZ3RoID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0cmVuZ3RoID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgZm9yY2UuZGlzdGFuY2VNaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGlzdGFuY2VNaW4yID0gXyAqIF8sIGZvcmNlKSA6IE1hdGguc3FydChkaXN0YW5jZU1pbjIpO1xuICB9O1xuXG4gIGZvcmNlLmRpc3RhbmNlTWF4ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRpc3RhbmNlTWF4MiA9IF8gKiBfLCBmb3JjZSkgOiBNYXRoLnNxcnQoZGlzdGFuY2VNYXgyKTtcbiAgfTtcblxuICBmb3JjZS50aGV0YSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aGV0YTIgPSBfICogXywgZm9yY2UpIDogTWF0aC5zcXJ0KHRoZXRhMik7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufVxuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHJhZGl1cywgeCwgeSwgeikge1xuICB2YXIgbm9kZXMsXG4gICAgICBuRGltLFxuICAgICAgc3RyZW5ndGggPSBjb25zdGFudCgwLjEpLFxuICAgICAgc3RyZW5ndGhzLFxuICAgICAgcmFkaXVzZXM7XG5cbiAgaWYgKHR5cGVvZiByYWRpdXMgIT09IFwiZnVuY3Rpb25cIikgcmFkaXVzID0gY29uc3RhbnQoK3JhZGl1cyk7XG4gIGlmICh4ID09IG51bGwpIHggPSAwO1xuICBpZiAoeSA9PSBudWxsKSB5ID0gMDtcbiAgaWYgKHogPT0gbnVsbCkgeiA9IDA7XG5cbiAgZnVuY3Rpb24gZm9yY2UoYWxwaGEpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IG5vZGVzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXSxcbiAgICAgICAgICBkeCA9IG5vZGUueCAtIHggfHwgMWUtNixcbiAgICAgICAgICBkeSA9IChub2RlLnkgfHwgMCkgLSB5IHx8IDFlLTYsXG4gICAgICAgICAgZHogPSAobm9kZS56IHx8IDApIC0geiB8fCAxZS02LFxuICAgICAgICAgIHIgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6KSxcbiAgICAgICAgICBrID0gKHJhZGl1c2VzW2ldIC0gcikgKiBzdHJlbmd0aHNbaV0gKiBhbHBoYSAvIHI7XG4gICAgICBub2RlLnZ4ICs9IGR4ICogaztcbiAgICAgIGlmIChuRGltPjEpIHsgbm9kZS52eSArPSBkeSAqIGs7IH1cbiAgICAgIGlmIChuRGltPjIpIHsgbm9kZS52eiArPSBkeiAqIGs7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aDtcbiAgICBzdHJlbmd0aHMgPSBuZXcgQXJyYXkobik7XG4gICAgcmFkaXVzZXMgPSBuZXcgQXJyYXkobik7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgcmFkaXVzZXNbaV0gPSArcmFkaXVzKG5vZGVzW2ldLCBpLCBub2Rlcyk7XG4gICAgICBzdHJlbmd0aHNbaV0gPSBpc05hTihyYWRpdXNlc1tpXSkgPyAwIDogK3N0cmVuZ3RoKG5vZGVzW2ldLCBpLCBub2Rlcyk7XG4gICAgfVxuICB9XG5cbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGluaXROb2RlcywgLi4uYXJncykge1xuICAgIG5vZGVzID0gaW5pdE5vZGVzO1xuICAgIG5EaW0gPSBhcmdzLmZpbmQoYXJnID0+IFsxLCAyLCAzXS5pbmNsdWRlcyhhcmcpKSB8fCAyO1xuICAgIGluaXRpYWxpemUoKTtcbiAgfTtcblxuICBmb3JjZS5zdHJlbmd0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHN0cmVuZ3RoO1xuICB9O1xuXG4gIGZvcmNlLnJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiByYWRpdXM7XG4gIH07XG5cbiAgZm9yY2UueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gK18sIGZvcmNlKSA6IHg7XG4gIH07XG5cbiAgZm9yY2UueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5ID0gK18sIGZvcmNlKSA6IHk7XG4gIH07XG5cbiAgZm9yY2UueiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh6ID0gK18sIGZvcmNlKSA6IHo7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufVxuIiwiaW1wb3J0IHtkaXNwYXRjaH0gZnJvbSBcImQzLWRpc3BhdGNoXCI7XG5pbXBvcnQge3RpbWVyfSBmcm9tIFwiZDMtdGltZXJcIjtcbmltcG9ydCBsY2cgZnJvbSBcIi4vbGNnLmpzXCI7XG5cbnZhciBNQVhfRElNRU5TSU9OUyA9IDM7XG5cbmV4cG9ydCBmdW5jdGlvbiB4KGQpIHtcbiAgcmV0dXJuIGQueDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHkoZCkge1xuICByZXR1cm4gZC55O1xufVxuXG5leHBvcnQgZnVuY3Rpb24geihkKSB7XG4gIHJldHVybiBkLno7XG59XG5cbnZhciBpbml0aWFsUmFkaXVzID0gMTAsXG4gICAgaW5pdGlhbEFuZ2xlUm9sbCA9IE1hdGguUEkgKiAoMyAtIE1hdGguc3FydCg1KSksIC8vIEdvbGRlbiByYXRpbyBhbmdsZVxuICAgIGluaXRpYWxBbmdsZVlhdyA9IE1hdGguUEkgKiAyMCAvICg5ICsgTWF0aC5zcXJ0KDIyMSkpOyAvLyBNYXJrb3YgaXJyYXRpb25hbCBudW1iZXJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZXMsIG51bURpbWVuc2lvbnMpIHtcbiAgbnVtRGltZW5zaW9ucyA9IG51bURpbWVuc2lvbnMgfHwgMjtcblxuICB2YXIgbkRpbSA9IE1hdGgubWluKE1BWF9ESU1FTlNJT05TLCBNYXRoLm1heCgxLCBNYXRoLnJvdW5kKG51bURpbWVuc2lvbnMpKSksXG4gICAgICBzaW11bGF0aW9uLFxuICAgICAgYWxwaGEgPSAxLFxuICAgICAgYWxwaGFNaW4gPSAwLjAwMSxcbiAgICAgIGFscGhhRGVjYXkgPSAxIC0gTWF0aC5wb3coYWxwaGFNaW4sIDEgLyAzMDApLFxuICAgICAgYWxwaGFUYXJnZXQgPSAwLFxuICAgICAgdmVsb2NpdHlEZWNheSA9IDAuNixcbiAgICAgIGZvcmNlcyA9IG5ldyBNYXAoKSxcbiAgICAgIHN0ZXBwZXIgPSB0aW1lcihzdGVwKSxcbiAgICAgIGV2ZW50ID0gZGlzcGF0Y2goXCJ0aWNrXCIsIFwiZW5kXCIpLFxuICAgICAgcmFuZG9tID0gbGNnKCk7XG5cbiAgaWYgKG5vZGVzID09IG51bGwpIG5vZGVzID0gW107XG5cbiAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICB0aWNrKCk7XG4gICAgZXZlbnQuY2FsbChcInRpY2tcIiwgc2ltdWxhdGlvbik7XG4gICAgaWYgKGFscGhhIDwgYWxwaGFNaW4pIHtcbiAgICAgIHN0ZXBwZXIuc3RvcCgpO1xuICAgICAgZXZlbnQuY2FsbChcImVuZFwiLCBzaW11bGF0aW9uKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0aWNrKGl0ZXJhdGlvbnMpIHtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTtcblxuICAgIGlmIChpdGVyYXRpb25zID09PSB1bmRlZmluZWQpIGl0ZXJhdGlvbnMgPSAxO1xuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBpdGVyYXRpb25zOyArK2spIHtcbiAgICAgIGFscGhhICs9IChhbHBoYVRhcmdldCAtIGFscGhhKSAqIGFscGhhRGVjYXk7XG5cbiAgICAgIGZvcmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChmb3JjZSkge1xuICAgICAgICBmb3JjZShhbHBoYSk7XG4gICAgICB9KTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIGlmIChub2RlLmZ4ID09IG51bGwpIG5vZGUueCArPSBub2RlLnZ4ICo9IHZlbG9jaXR5RGVjYXk7XG4gICAgICAgIGVsc2Ugbm9kZS54ID0gbm9kZS5meCwgbm9kZS52eCA9IDA7XG4gICAgICAgIGlmIChuRGltID4gMSkge1xuICAgICAgICAgIGlmIChub2RlLmZ5ID09IG51bGwpIG5vZGUueSArPSBub2RlLnZ5ICo9IHZlbG9jaXR5RGVjYXk7XG4gICAgICAgICAgZWxzZSBub2RlLnkgPSBub2RlLmZ5LCBub2RlLnZ5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobkRpbSA+IDIpIHtcbiAgICAgICAgICBpZiAobm9kZS5meiA9PSBudWxsKSBub2RlLnogKz0gbm9kZS52eiAqPSB2ZWxvY2l0eURlY2F5O1xuICAgICAgICAgIGVsc2Ugbm9kZS56ID0gbm9kZS5meiwgbm9kZS52eiA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2ltdWxhdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVOb2RlcygpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldLCBub2RlLmluZGV4ID0gaTtcbiAgICAgIGlmIChub2RlLmZ4ICE9IG51bGwpIG5vZGUueCA9IG5vZGUuZng7XG4gICAgICBpZiAobm9kZS5meSAhPSBudWxsKSBub2RlLnkgPSBub2RlLmZ5O1xuICAgICAgaWYgKG5vZGUuZnogIT0gbnVsbCkgbm9kZS56ID0gbm9kZS5mejtcbiAgICAgIGlmIChpc05hTihub2RlLngpIHx8IChuRGltID4gMSAmJiBpc05hTihub2RlLnkpKSB8fCAobkRpbSA+IDIgJiYgaXNOYU4obm9kZS56KSkpIHtcbiAgICAgICAgdmFyIHJhZGl1cyA9IGluaXRpYWxSYWRpdXMgKiAobkRpbSA+IDIgPyBNYXRoLmNicnQoMC41ICsgaSkgOiAobkRpbSA+IDEgPyBNYXRoLnNxcnQoMC41ICsgaSkgOiBpKSksXG4gICAgICAgICAgcm9sbEFuZ2xlID0gaSAqIGluaXRpYWxBbmdsZVJvbGwsXG4gICAgICAgICAgeWF3QW5nbGUgPSBpICogaW5pdGlhbEFuZ2xlWWF3O1xuXG4gICAgICAgIGlmIChuRGltID09PSAxKSB7XG4gICAgICAgICAgbm9kZS54ID0gcmFkaXVzO1xuICAgICAgICB9IGVsc2UgaWYgKG5EaW0gPT09IDIpIHtcbiAgICAgICAgICBub2RlLnggPSByYWRpdXMgKiBNYXRoLmNvcyhyb2xsQW5nbGUpO1xuICAgICAgICAgIG5vZGUueSA9IHJhZGl1cyAqIE1hdGguc2luKHJvbGxBbmdsZSk7XG4gICAgICAgIH0gZWxzZSB7IC8vIDMgZGltZW5zaW9uczogdXNlIHNwaGVyaWNhbCBkaXN0cmlidXRpb24gYWxvbmcgMiBpcnJhdGlvbmFsIG51bWJlciBhbmdsZXNcbiAgICAgICAgICBub2RlLnggPSByYWRpdXMgKiBNYXRoLnNpbihyb2xsQW5nbGUpICogTWF0aC5jb3MoeWF3QW5nbGUpO1xuICAgICAgICAgIG5vZGUueSA9IHJhZGl1cyAqIE1hdGguY29zKHJvbGxBbmdsZSk7XG4gICAgICAgICAgbm9kZS56ID0gcmFkaXVzICogTWF0aC5zaW4ocm9sbEFuZ2xlKSAqIE1hdGguc2luKHlhd0FuZ2xlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzTmFOKG5vZGUudngpIHx8IChuRGltID4gMSAmJiBpc05hTihub2RlLnZ5KSkgfHwgKG5EaW0gPiAyICYmIGlzTmFOKG5vZGUudnopKSkge1xuICAgICAgICBub2RlLnZ4ID0gMDtcbiAgICAgICAgaWYgKG5EaW0gPiAxKSB7IG5vZGUudnkgPSAwOyB9XG4gICAgICAgIGlmIChuRGltID4gMikgeyBub2RlLnZ6ID0gMDsgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVGb3JjZShmb3JjZSkge1xuICAgIGlmIChmb3JjZS5pbml0aWFsaXplKSBmb3JjZS5pbml0aWFsaXplKG5vZGVzLCByYW5kb20sIG5EaW0pO1xuICAgIHJldHVybiBmb3JjZTtcbiAgfVxuXG4gIGluaXRpYWxpemVOb2RlcygpO1xuXG4gIHJldHVybiBzaW11bGF0aW9uID0ge1xuICAgIHRpY2s6IHRpY2ssXG5cbiAgICByZXN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBzdGVwcGVyLnJlc3RhcnQoc3RlcCksIHNpbXVsYXRpb247XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0ZXBwZXIuc3RvcCgpLCBzaW11bGF0aW9uO1xuICAgIH0sXG5cbiAgICBudW1EaW1lbnNpb25zOiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgICAgID8gKG5EaW0gPSBNYXRoLm1pbihNQVhfRElNRU5TSU9OUywgTWF0aC5tYXgoMSwgTWF0aC5yb3VuZChfKSkpLCBmb3JjZXMuZm9yRWFjaChpbml0aWFsaXplRm9yY2UpLCBzaW11bGF0aW9uKVxuICAgICAgICAgIDogbkRpbTtcbiAgICB9LFxuXG4gICAgbm9kZXM6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKG5vZGVzID0gXywgaW5pdGlhbGl6ZU5vZGVzKCksIGZvcmNlcy5mb3JFYWNoKGluaXRpYWxpemVGb3JjZSksIHNpbXVsYXRpb24pIDogbm9kZXM7XG4gICAgfSxcblxuICAgIGFscGhhOiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChhbHBoYSA9ICtfLCBzaW11bGF0aW9uKSA6IGFscGhhO1xuICAgIH0sXG5cbiAgICBhbHBoYU1pbjogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGFNaW4gPSArXywgc2ltdWxhdGlvbikgOiBhbHBoYU1pbjtcbiAgICB9LFxuXG4gICAgYWxwaGFEZWNheTogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGFEZWNheSA9ICtfLCBzaW11bGF0aW9uKSA6ICthbHBoYURlY2F5O1xuICAgIH0sXG5cbiAgICBhbHBoYVRhcmdldDogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGFUYXJnZXQgPSArXywgc2ltdWxhdGlvbikgOiBhbHBoYVRhcmdldDtcbiAgICB9LFxuXG4gICAgdmVsb2NpdHlEZWNheTogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodmVsb2NpdHlEZWNheSA9IDEgLSBfLCBzaW11bGF0aW9uKSA6IDEgLSB2ZWxvY2l0eURlY2F5O1xuICAgIH0sXG5cbiAgICByYW5kb21Tb3VyY2U6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhbmRvbSA9IF8sIGZvcmNlcy5mb3JFYWNoKGluaXRpYWxpemVGb3JjZSksIHNpbXVsYXRpb24pIDogcmFuZG9tO1xuICAgIH0sXG5cbiAgICBmb3JjZTogZnVuY3Rpb24obmFtZSwgXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gKChfID09IG51bGwgPyBmb3JjZXMuZGVsZXRlKG5hbWUpIDogZm9yY2VzLnNldChuYW1lLCBpbml0aWFsaXplRm9yY2UoXykpKSwgc2ltdWxhdGlvbikgOiBmb3JjZXMuZ2V0KG5hbWUpO1xuICAgIH0sXG5cbiAgICBmaW5kOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIHZhciB4ID0gYXJncy5zaGlmdCgpIHx8IDAsXG4gICAgICAgICAgeSA9IChuRGltID4gMSA/IGFyZ3Muc2hpZnQoKSA6IG51bGwpIHx8IDAsXG4gICAgICAgICAgeiA9IChuRGltID4gMiA/IGFyZ3Muc2hpZnQoKSA6IG51bGwpIHx8IDAsXG4gICAgICAgICAgcmFkaXVzID0gYXJncy5zaGlmdCgpIHx8IEluZmluaXR5O1xuXG4gICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgICBkeCxcbiAgICAgICAgICBkeSxcbiAgICAgICAgICBkeixcbiAgICAgICAgICBkMixcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIGNsb3Nlc3Q7XG5cbiAgICAgIHJhZGl1cyAqPSByYWRpdXM7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBkeCA9IHggLSBub2RlLng7XG4gICAgICAgIGR5ID0geSAtIChub2RlLnkgfHwgMCk7XG4gICAgICAgIGR6ID0geiAtIChub2RlLnogfHwwKTtcbiAgICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeSArIGR6ICogZHo7XG4gICAgICAgIGlmIChkMiA8IHJhZGl1cykgY2xvc2VzdCA9IG5vZGUsIHJhZGl1cyA9IGQyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xvc2VzdDtcbiAgICB9LFxuXG4gICAgb246IGZ1bmN0aW9uKG5hbWUsIF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMSA/IChldmVudC5vbihuYW1lLCBfKSwgc2ltdWxhdGlvbikgOiBldmVudC5vbihuYW1lKTtcbiAgICB9XG4gIH07XG59XG4iLCJpbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oeCkge1xuICB2YXIgc3RyZW5ndGggPSBjb25zdGFudCgwLjEpLFxuICAgICAgbm9kZXMsXG4gICAgICBzdHJlbmd0aHMsXG4gICAgICB4ejtcblxuICBpZiAodHlwZW9mIHggIT09IFwiZnVuY3Rpb25cIikgeCA9IGNvbnN0YW50KHggPT0gbnVsbCA/IDAgOiAreCk7XG5cbiAgZnVuY3Rpb24gZm9yY2UoYWxwaGEpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldLCBub2RlLnZ4ICs9ICh4eltpXSAtIG5vZGUueCkgKiBzdHJlbmd0aHNbaV0gKiBhbHBoYTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aDtcbiAgICBzdHJlbmd0aHMgPSBuZXcgQXJyYXkobik7XG4gICAgeHogPSBuZXcgQXJyYXkobik7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgc3RyZW5ndGhzW2ldID0gaXNOYU4oeHpbaV0gPSAreChub2Rlc1tpXSwgaSwgbm9kZXMpKSA/IDAgOiArc3RyZW5ndGgobm9kZXNbaV0sIGksIG5vZGVzKTtcbiAgICB9XG4gIH1cblxuICBmb3JjZS5pbml0aWFsaXplID0gZnVuY3Rpb24oXykge1xuICAgIG5vZGVzID0gXztcbiAgICBpbml0aWFsaXplKCk7XG4gIH07XG5cbiAgZm9yY2Uuc3RyZW5ndGggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RyZW5ndGggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiBzdHJlbmd0aDtcbiAgfTtcblxuICBmb3JjZS54ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHggPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiB4O1xuICB9O1xuXG4gIHJldHVybiBmb3JjZTtcbn1cbiIsImltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih5KSB7XG4gIHZhciBzdHJlbmd0aCA9IGNvbnN0YW50KDAuMSksXG4gICAgICBub2RlcyxcbiAgICAgIHN0cmVuZ3RocyxcbiAgICAgIHl6O1xuXG4gIGlmICh0eXBlb2YgeSAhPT0gXCJmdW5jdGlvblwiKSB5ID0gY29uc3RhbnQoeSA9PSBudWxsID8gMCA6ICt5KTtcblxuICBmdW5jdGlvbiBmb3JjZShhbHBoYSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gbm9kZXMubGVuZ3RoLCBub2RlOyBpIDwgbjsgKytpKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV0sIG5vZGUudnkgKz0gKHl6W2ldIC0gbm9kZS55KSAqIHN0cmVuZ3Roc1tpXSAqIGFscGhhO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoO1xuICAgIHN0cmVuZ3RocyA9IG5ldyBBcnJheShuKTtcbiAgICB5eiA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBzdHJlbmd0aHNbaV0gPSBpc05hTih5eltpXSA9ICt5KG5vZGVzW2ldLCBpLCBub2RlcykpID8gMCA6ICtzdHJlbmd0aChub2Rlc1tpXSwgaSwgbm9kZXMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgbm9kZXMgPSBfO1xuICAgIGluaXRpYWxpemUoKTtcbiAgfTtcblxuICBmb3JjZS5zdHJlbmd0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHN0cmVuZ3RoO1xuICB9O1xuXG4gIGZvcmNlLnkgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHk7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufVxuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHopIHtcbiAgdmFyIHN0cmVuZ3RoID0gY29uc3RhbnQoMC4xKSxcbiAgICAgIG5vZGVzLFxuICAgICAgc3RyZW5ndGhzLFxuICAgICAgeno7XG5cbiAgaWYgKHR5cGVvZiB6ICE9PSBcImZ1bmN0aW9uXCIpIHogPSBjb25zdGFudCh6ID09IG51bGwgPyAwIDogK3opO1xuXG4gIGZ1bmN0aW9uIGZvcmNlKGFscGhhKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBub2Rlcy5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS52eiArPSAoenpbaV0gLSBub2RlLnopICogc3RyZW5ndGhzW2ldICogYWxwaGE7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAoIW5vZGVzKSByZXR1cm47XG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGg7XG4gICAgc3RyZW5ndGhzID0gbmV3IEFycmF5KG4pO1xuICAgIHp6ID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHN0cmVuZ3Roc1tpXSA9IGlzTmFOKHp6W2ldID0gK3oobm9kZXNbaV0sIGksIG5vZGVzKSkgPyAwIDogK3N0cmVuZ3RoKG5vZGVzW2ldLCBpLCBub2Rlcyk7XG4gICAgfVxuICB9XG5cbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBub2RlcyA9IF87XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9O1xuXG4gIGZvcmNlLnN0cmVuZ3RoID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0cmVuZ3RoID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgZm9yY2UueiA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh6ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogejtcbiAgfTtcblxuICByZXR1cm4gZm9yY2U7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4LCB5KSB7XG4gIHZhciBub2Rlcywgc3RyZW5ndGggPSAxO1xuXG4gIGlmICh4ID09IG51bGwpIHggPSAwO1xuICBpZiAoeSA9PSBudWxsKSB5ID0gMDtcblxuICBmdW5jdGlvbiBmb3JjZSgpIHtcbiAgICB2YXIgaSxcbiAgICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgc3ggPSAwLFxuICAgICAgICBzeSA9IDA7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV0sIHN4ICs9IG5vZGUueCwgc3kgKz0gbm9kZS55O1xuICAgIH1cblxuICAgIGZvciAoc3ggPSAoc3ggLyBuIC0geCkgKiBzdHJlbmd0aCwgc3kgPSAoc3kgLyBuIC0geSkgKiBzdHJlbmd0aCwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS54IC09IHN4LCBub2RlLnkgLT0gc3k7XG4gICAgfVxuICB9XG5cbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBub2RlcyA9IF87XG4gIH07XG5cbiAgZm9yY2UueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gK18sIGZvcmNlKSA6IHg7XG4gIH07XG5cbiAgZm9yY2UueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5ID0gK18sIGZvcmNlKSA6IHk7XG4gIH07XG5cbiAgZm9yY2Uuc3RyZW5ndGggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RyZW5ndGggPSArXywgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufVxuIiwiaW1wb3J0IHtxdWFkdHJlZX0gZnJvbSBcImQzLXF1YWR0cmVlXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBqaWdnbGUgZnJvbSBcIi4vamlnZ2xlLmpzXCI7XG5cbmZ1bmN0aW9uIHgoZCkge1xuICByZXR1cm4gZC54ICsgZC52eDtcbn1cblxuZnVuY3Rpb24geShkKSB7XG4gIHJldHVybiBkLnkgKyBkLnZ5O1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihyYWRpdXMpIHtcbiAgdmFyIG5vZGVzLFxuICAgICAgcmFkaWksXG4gICAgICByYW5kb20sXG4gICAgICBzdHJlbmd0aCA9IDEsXG4gICAgICBpdGVyYXRpb25zID0gMTtcblxuICBpZiAodHlwZW9mIHJhZGl1cyAhPT0gXCJmdW5jdGlvblwiKSByYWRpdXMgPSBjb25zdGFudChyYWRpdXMgPT0gbnVsbCA/IDEgOiArcmFkaXVzKTtcblxuICBmdW5jdGlvbiBmb3JjZSgpIHtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgdHJlZSxcbiAgICAgICAgbm9kZSxcbiAgICAgICAgeGksXG4gICAgICAgIHlpLFxuICAgICAgICByaSxcbiAgICAgICAgcmkyO1xuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBpdGVyYXRpb25zOyArK2spIHtcbiAgICAgIHRyZWUgPSBxdWFkdHJlZShub2RlcywgeCwgeSkudmlzaXRBZnRlcihwcmVwYXJlKTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICByaSA9IHJhZGlpW25vZGUuaW5kZXhdLCByaTIgPSByaSAqIHJpO1xuICAgICAgICB4aSA9IG5vZGUueCArIG5vZGUudng7XG4gICAgICAgIHlpID0gbm9kZS55ICsgbm9kZS52eTtcbiAgICAgICAgdHJlZS52aXNpdChhcHBseSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHkocXVhZCwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgICAgIHZhciBkYXRhID0gcXVhZC5kYXRhLCByaiA9IHF1YWQuciwgciA9IHJpICsgcmo7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5pbmRleCA+IG5vZGUuaW5kZXgpIHtcbiAgICAgICAgICB2YXIgeCA9IHhpIC0gZGF0YS54IC0gZGF0YS52eCxcbiAgICAgICAgICAgICAgeSA9IHlpIC0gZGF0YS55IC0gZGF0YS52eSxcbiAgICAgICAgICAgICAgbCA9IHggKiB4ICsgeSAqIHk7XG4gICAgICAgICAgaWYgKGwgPCByICogcikge1xuICAgICAgICAgICAgaWYgKHggPT09IDApIHggPSBqaWdnbGUocmFuZG9tKSwgbCArPSB4ICogeDtcbiAgICAgICAgICAgIGlmICh5ID09PSAwKSB5ID0gamlnZ2xlKHJhbmRvbSksIGwgKz0geSAqIHk7XG4gICAgICAgICAgICBsID0gKHIgLSAobCA9IE1hdGguc3FydChsKSkpIC8gbCAqIHN0cmVuZ3RoO1xuICAgICAgICAgICAgbm9kZS52eCArPSAoeCAqPSBsKSAqIChyID0gKHJqICo9IHJqKSAvIChyaTIgKyByaikpO1xuICAgICAgICAgICAgbm9kZS52eSArPSAoeSAqPSBsKSAqIHI7XG4gICAgICAgICAgICBkYXRhLnZ4IC09IHggKiAociA9IDEgLSByKTtcbiAgICAgICAgICAgIGRhdGEudnkgLT0geSAqIHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB4MCA+IHhpICsgciB8fCB4MSA8IHhpIC0gciB8fCB5MCA+IHlpICsgciB8fCB5MSA8IHlpIC0gcjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlKHF1YWQpIHtcbiAgICBpZiAocXVhZC5kYXRhKSByZXR1cm4gcXVhZC5yID0gcmFkaWlbcXVhZC5kYXRhLmluZGV4XTtcbiAgICBmb3IgKHZhciBpID0gcXVhZC5yID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgaWYgKHF1YWRbaV0gJiYgcXVhZFtpXS5yID4gcXVhZC5yKSB7XG4gICAgICAgIHF1YWQuciA9IHF1YWRbaV0ucjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTtcbiAgICByYWRpaSA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSBub2RlID0gbm9kZXNbaV0sIHJhZGlpW25vZGUuaW5kZXhdID0gK3JhZGl1cyhub2RlLCBpLCBub2Rlcyk7XG4gIH1cblxuICBmb3JjZS5pbml0aWFsaXplID0gZnVuY3Rpb24oX25vZGVzLCBfcmFuZG9tKSB7XG4gICAgbm9kZXMgPSBfbm9kZXM7XG4gICAgcmFuZG9tID0gX3JhbmRvbTtcbiAgICBpbml0aWFsaXplKCk7XG4gIH07XG5cbiAgZm9yY2UuaXRlcmF0aW9ucyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpdGVyYXRpb25zID0gK18sIGZvcmNlKSA6IGl0ZXJhdGlvbnM7XG4gIH07XG5cbiAgZm9yY2Uuc3RyZW5ndGggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc3RyZW5ndGggPSArXywgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgZm9yY2UucmFkaXVzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHJhZGl1cyA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHJhZGl1cztcbiAgfTtcblxuICByZXR1cm4gZm9yY2U7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4geDtcbiAgfTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHJhbmRvbSkge1xuICByZXR1cm4gKHJhbmRvbSgpIC0gMC41KSAqIDFlLTY7XG59XG4iLCIvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaW5lYXJfY29uZ3J1ZW50aWFsX2dlbmVyYXRvciNQYXJhbWV0ZXJzX2luX2NvbW1vbl91c2VcbmNvbnN0IGEgPSAxNjY0NTI1O1xuY29uc3QgYyA9IDEwMTM5MDQyMjM7XG5jb25zdCBtID0gNDI5NDk2NzI5NjsgLy8gMl4zMlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgbGV0IHMgPSAxO1xuICByZXR1cm4gKCkgPT4gKHMgPSAoYSAqIHMgKyBjKSAlIG0pIC8gbTtcbn1cbiIsImltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuaW1wb3J0IGppZ2dsZSBmcm9tIFwiLi9qaWdnbGUuanNcIjtcblxuZnVuY3Rpb24gaW5kZXgoZCkge1xuICByZXR1cm4gZC5pbmRleDtcbn1cblxuZnVuY3Rpb24gZmluZChub2RlQnlJZCwgbm9kZUlkKSB7XG4gIHZhciBub2RlID0gbm9kZUJ5SWQuZ2V0KG5vZGVJZCk7XG4gIGlmICghbm9kZSkgdGhyb3cgbmV3IEVycm9yKFwibm9kZSBub3QgZm91bmQ6IFwiICsgbm9kZUlkKTtcbiAgcmV0dXJuIG5vZGU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGxpbmtzKSB7XG4gIHZhciBpZCA9IGluZGV4LFxuICAgICAgc3RyZW5ndGggPSBkZWZhdWx0U3RyZW5ndGgsXG4gICAgICBzdHJlbmd0aHMsXG4gICAgICBkaXN0YW5jZSA9IGNvbnN0YW50KDMwKSxcbiAgICAgIGRpc3RhbmNlcyxcbiAgICAgIG5vZGVzLFxuICAgICAgY291bnQsXG4gICAgICBiaWFzLFxuICAgICAgcmFuZG9tLFxuICAgICAgaXRlcmF0aW9ucyA9IDE7XG5cbiAgaWYgKGxpbmtzID09IG51bGwpIGxpbmtzID0gW107XG5cbiAgZnVuY3Rpb24gZGVmYXVsdFN0cmVuZ3RoKGxpbmspIHtcbiAgICByZXR1cm4gMSAvIE1hdGgubWluKGNvdW50W2xpbmsuc291cmNlLmluZGV4XSwgY291bnRbbGluay50YXJnZXQuaW5kZXhdKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZvcmNlKGFscGhhKSB7XG4gICAgZm9yICh2YXIgayA9IDAsIG4gPSBsaW5rcy5sZW5ndGg7IGsgPCBpdGVyYXRpb25zOyArK2spIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsaW5rLCBzb3VyY2UsIHRhcmdldCwgeCwgeSwgbCwgYjsgaSA8IG47ICsraSkge1xuICAgICAgICBsaW5rID0gbGlua3NbaV0sIHNvdXJjZSA9IGxpbmsuc291cmNlLCB0YXJnZXQgPSBsaW5rLnRhcmdldDtcbiAgICAgICAgeCA9IHRhcmdldC54ICsgdGFyZ2V0LnZ4IC0gc291cmNlLnggLSBzb3VyY2UudnggfHwgamlnZ2xlKHJhbmRvbSk7XG4gICAgICAgIHkgPSB0YXJnZXQueSArIHRhcmdldC52eSAtIHNvdXJjZS55IC0gc291cmNlLnZ5IHx8IGppZ2dsZShyYW5kb20pO1xuICAgICAgICBsID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgICAgICBsID0gKGwgLSBkaXN0YW5jZXNbaV0pIC8gbCAqIGFscGhhICogc3RyZW5ndGhzW2ldO1xuICAgICAgICB4ICo9IGwsIHkgKj0gbDtcbiAgICAgICAgdGFyZ2V0LnZ4IC09IHggKiAoYiA9IGJpYXNbaV0pO1xuICAgICAgICB0YXJnZXQudnkgLT0geSAqIGI7XG4gICAgICAgIHNvdXJjZS52eCArPSB4ICogKGIgPSAxIC0gYik7XG4gICAgICAgIHNvdXJjZS52eSArPSB5ICogYjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcblxuICAgIHZhciBpLFxuICAgICAgICBuID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICBtID0gbGlua3MubGVuZ3RoLFxuICAgICAgICBub2RlQnlJZCA9IG5ldyBNYXAobm9kZXMubWFwKChkLCBpKSA9PiBbaWQoZCwgaSwgbm9kZXMpLCBkXSkpLFxuICAgICAgICBsaW5rO1xuXG4gICAgZm9yIChpID0gMCwgY291bnQgPSBuZXcgQXJyYXkobik7IGkgPCBtOyArK2kpIHtcbiAgICAgIGxpbmsgPSBsaW5rc1tpXSwgbGluay5pbmRleCA9IGk7XG4gICAgICBpZiAodHlwZW9mIGxpbmsuc291cmNlICE9PSBcIm9iamVjdFwiKSBsaW5rLnNvdXJjZSA9IGZpbmQobm9kZUJ5SWQsIGxpbmsuc291cmNlKTtcbiAgICAgIGlmICh0eXBlb2YgbGluay50YXJnZXQgIT09IFwib2JqZWN0XCIpIGxpbmsudGFyZ2V0ID0gZmluZChub2RlQnlJZCwgbGluay50YXJnZXQpO1xuICAgICAgY291bnRbbGluay5zb3VyY2UuaW5kZXhdID0gKGNvdW50W2xpbmsuc291cmNlLmluZGV4XSB8fCAwKSArIDE7XG4gICAgICBjb3VudFtsaW5rLnRhcmdldC5pbmRleF0gPSAoY291bnRbbGluay50YXJnZXQuaW5kZXhdIHx8IDApICsgMTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBiaWFzID0gbmV3IEFycmF5KG0pOyBpIDwgbTsgKytpKSB7XG4gICAgICBsaW5rID0gbGlua3NbaV0sIGJpYXNbaV0gPSBjb3VudFtsaW5rLnNvdXJjZS5pbmRleF0gLyAoY291bnRbbGluay5zb3VyY2UuaW5kZXhdICsgY291bnRbbGluay50YXJnZXQuaW5kZXhdKTtcbiAgICB9XG5cbiAgICBzdHJlbmd0aHMgPSBuZXcgQXJyYXkobSksIGluaXRpYWxpemVTdHJlbmd0aCgpO1xuICAgIGRpc3RhbmNlcyA9IG5ldyBBcnJheShtKSwgaW5pdGlhbGl6ZURpc3RhbmNlKCk7XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplU3RyZW5ndGgoKSB7XG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBsaW5rcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHN0cmVuZ3Roc1tpXSA9ICtzdHJlbmd0aChsaW5rc1tpXSwgaSwgbGlua3MpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVEaXN0YW5jZSgpIHtcbiAgICBpZiAoIW5vZGVzKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGxpbmtzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgZGlzdGFuY2VzW2ldID0gK2Rpc3RhbmNlKGxpbmtzW2ldLCBpLCBsaW5rcyk7XG4gICAgfVxuICB9XG5cbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKF9ub2RlcywgX3JhbmRvbSkge1xuICAgIG5vZGVzID0gX25vZGVzO1xuICAgIHJhbmRvbSA9IF9yYW5kb207XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9O1xuXG4gIGZvcmNlLmxpbmtzID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGxpbmtzID0gXywgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiBsaW5rcztcbiAgfTtcblxuICBmb3JjZS5pZCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChpZCA9IF8sIGZvcmNlKSA6IGlkO1xuICB9O1xuXG4gIGZvcmNlLml0ZXJhdGlvbnMgPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoaXRlcmF0aW9ucyA9ICtfLCBmb3JjZSkgOiBpdGVyYXRpb25zO1xuICB9O1xuXG4gIGZvcmNlLnN0cmVuZ3RoID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0cmVuZ3RoID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemVTdHJlbmd0aCgpLCBmb3JjZSkgOiBzdHJlbmd0aDtcbiAgfTtcblxuICBmb3JjZS5kaXN0YW5jZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChkaXN0YW5jZSA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplRGlzdGFuY2UoKSwgZm9yY2UpIDogZGlzdGFuY2U7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufVxuIiwiaW1wb3J0IHtxdWFkdHJlZX0gZnJvbSBcImQzLXF1YWR0cmVlXCI7XG5pbXBvcnQgY29uc3RhbnQgZnJvbSBcIi4vY29uc3RhbnQuanNcIjtcbmltcG9ydCBqaWdnbGUgZnJvbSBcIi4vamlnZ2xlLmpzXCI7XG5pbXBvcnQge3gsIHl9IGZyb20gXCIuL3NpbXVsYXRpb24uanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBub2RlcyxcbiAgICAgIG5vZGUsXG4gICAgICByYW5kb20sXG4gICAgICBhbHBoYSxcbiAgICAgIHN0cmVuZ3RoID0gY29uc3RhbnQoLTMwKSxcbiAgICAgIHN0cmVuZ3RocyxcbiAgICAgIGRpc3RhbmNlTWluMiA9IDEsXG4gICAgICBkaXN0YW5jZU1heDIgPSBJbmZpbml0eSxcbiAgICAgIHRoZXRhMiA9IDAuODE7XG5cbiAgZnVuY3Rpb24gZm9yY2UoXykge1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoLCB0cmVlID0gcXVhZHRyZWUobm9kZXMsIHgsIHkpLnZpc2l0QWZ0ZXIoYWNjdW11bGF0ZSk7XG4gICAgZm9yIChhbHBoYSA9IF8sIGkgPSAwOyBpIDwgbjsgKytpKSBub2RlID0gbm9kZXNbaV0sIHRyZWUudmlzaXQoYXBwbHkpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAoIW5vZGVzKSByZXR1cm47XG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGgsIG5vZGU7XG4gICAgc3RyZW5ndGhzID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIG5vZGUgPSBub2Rlc1tpXSwgc3RyZW5ndGhzW25vZGUuaW5kZXhdID0gK3N0cmVuZ3RoKG5vZGUsIGksIG5vZGVzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFjY3VtdWxhdGUocXVhZCkge1xuICAgIHZhciBzdHJlbmd0aCA9IDAsIHEsIGMsIHdlaWdodCA9IDAsIHgsIHksIGk7XG5cbiAgICAvLyBGb3IgaW50ZXJuYWwgbm9kZXMsIGFjY3VtdWxhdGUgZm9yY2VzIGZyb20gY2hpbGQgcXVhZHJhbnRzLlxuICAgIGlmIChxdWFkLmxlbmd0aCkge1xuICAgICAgZm9yICh4ID0geSA9IGkgPSAwOyBpIDwgNDsgKytpKSB7XG4gICAgICAgIGlmICgocSA9IHF1YWRbaV0pICYmIChjID0gTWF0aC5hYnMocS52YWx1ZSkpKSB7XG4gICAgICAgICAgc3RyZW5ndGggKz0gcS52YWx1ZSwgd2VpZ2h0ICs9IGMsIHggKz0gYyAqIHEueCwgeSArPSBjICogcS55O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBxdWFkLnggPSB4IC8gd2VpZ2h0O1xuICAgICAgcXVhZC55ID0geSAvIHdlaWdodDtcbiAgICB9XG5cbiAgICAvLyBGb3IgbGVhZiBub2RlcywgYWNjdW11bGF0ZSBmb3JjZXMgZnJvbSBjb2luY2lkZW50IHF1YWRyYW50cy5cbiAgICBlbHNlIHtcbiAgICAgIHEgPSBxdWFkO1xuICAgICAgcS54ID0gcS5kYXRhLng7XG4gICAgICBxLnkgPSBxLmRhdGEueTtcbiAgICAgIGRvIHN0cmVuZ3RoICs9IHN0cmVuZ3Roc1txLmRhdGEuaW5kZXhdO1xuICAgICAgd2hpbGUgKHEgPSBxLm5leHQpO1xuICAgIH1cblxuICAgIHF1YWQudmFsdWUgPSBzdHJlbmd0aDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5KHF1YWQsIHgxLCBfLCB4Mikge1xuICAgIGlmICghcXVhZC52YWx1ZSkgcmV0dXJuIHRydWU7XG5cbiAgICB2YXIgeCA9IHF1YWQueCAtIG5vZGUueCxcbiAgICAgICAgeSA9IHF1YWQueSAtIG5vZGUueSxcbiAgICAgICAgdyA9IHgyIC0geDEsXG4gICAgICAgIGwgPSB4ICogeCArIHkgKiB5O1xuXG4gICAgLy8gQXBwbHkgdGhlIEJhcm5lcy1IdXQgYXBwcm94aW1hdGlvbiBpZiBwb3NzaWJsZS5cbiAgICAvLyBMaW1pdCBmb3JjZXMgZm9yIHZlcnkgY2xvc2Ugbm9kZXM7IHJhbmRvbWl6ZSBkaXJlY3Rpb24gaWYgY29pbmNpZGVudC5cbiAgICBpZiAodyAqIHcgLyB0aGV0YTIgPCBsKSB7XG4gICAgICBpZiAobCA8IGRpc3RhbmNlTWF4Mikge1xuICAgICAgICBpZiAoeCA9PT0gMCkgeCA9IGppZ2dsZShyYW5kb20pLCBsICs9IHggKiB4O1xuICAgICAgICBpZiAoeSA9PT0gMCkgeSA9IGppZ2dsZShyYW5kb20pLCBsICs9IHkgKiB5O1xuICAgICAgICBpZiAobCA8IGRpc3RhbmNlTWluMikgbCA9IE1hdGguc3FydChkaXN0YW5jZU1pbjIgKiBsKTtcbiAgICAgICAgbm9kZS52eCArPSB4ICogcXVhZC52YWx1ZSAqIGFscGhhIC8gbDtcbiAgICAgICAgbm9kZS52eSArPSB5ICogcXVhZC52YWx1ZSAqIGFscGhhIC8gbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIE90aGVyd2lzZSwgcHJvY2VzcyBwb2ludHMgZGlyZWN0bHkuXG4gICAgZWxzZSBpZiAocXVhZC5sZW5ndGggfHwgbCA+PSBkaXN0YW5jZU1heDIpIHJldHVybjtcblxuICAgIC8vIExpbWl0IGZvcmNlcyBmb3IgdmVyeSBjbG9zZSBub2RlczsgcmFuZG9taXplIGRpcmVjdGlvbiBpZiBjb2luY2lkZW50LlxuICAgIGlmIChxdWFkLmRhdGEgIT09IG5vZGUgfHwgcXVhZC5uZXh0KSB7XG4gICAgICBpZiAoeCA9PT0gMCkgeCA9IGppZ2dsZShyYW5kb20pLCBsICs9IHggKiB4O1xuICAgICAgaWYgKHkgPT09IDApIHkgPSBqaWdnbGUocmFuZG9tKSwgbCArPSB5ICogeTtcbiAgICAgIGlmIChsIDwgZGlzdGFuY2VNaW4yKSBsID0gTWF0aC5zcXJ0KGRpc3RhbmNlTWluMiAqIGwpO1xuICAgIH1cblxuICAgIGRvIGlmIChxdWFkLmRhdGEgIT09IG5vZGUpIHtcbiAgICAgIHcgPSBzdHJlbmd0aHNbcXVhZC5kYXRhLmluZGV4XSAqIGFscGhhIC8gbDtcbiAgICAgIG5vZGUudnggKz0geCAqIHc7XG4gICAgICBub2RlLnZ5ICs9IHkgKiB3O1xuICAgIH0gd2hpbGUgKHF1YWQgPSBxdWFkLm5leHQpO1xuICB9XG5cbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKF9ub2RlcywgX3JhbmRvbSkge1xuICAgIG5vZGVzID0gX25vZGVzO1xuICAgIHJhbmRvbSA9IF9yYW5kb207XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9O1xuXG4gIGZvcmNlLnN0cmVuZ3RoID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0cmVuZ3RoID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgZm9yY2UuZGlzdGFuY2VNaW4gPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoZGlzdGFuY2VNaW4yID0gXyAqIF8sIGZvcmNlKSA6IE1hdGguc3FydChkaXN0YW5jZU1pbjIpO1xuICB9O1xuXG4gIGZvcmNlLmRpc3RhbmNlTWF4ID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGRpc3RhbmNlTWF4MiA9IF8gKiBfLCBmb3JjZSkgOiBNYXRoLnNxcnQoZGlzdGFuY2VNYXgyKTtcbiAgfTtcblxuICBmb3JjZS50aGV0YSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aGV0YTIgPSBfICogXywgZm9yY2UpIDogTWF0aC5zcXJ0KHRoZXRhMik7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufVxuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHJhZGl1cywgeCwgeSkge1xuICB2YXIgbm9kZXMsXG4gICAgICBzdHJlbmd0aCA9IGNvbnN0YW50KDAuMSksXG4gICAgICBzdHJlbmd0aHMsXG4gICAgICByYWRpdXNlcztcblxuICBpZiAodHlwZW9mIHJhZGl1cyAhPT0gXCJmdW5jdGlvblwiKSByYWRpdXMgPSBjb25zdGFudCgrcmFkaXVzKTtcbiAgaWYgKHggPT0gbnVsbCkgeCA9IDA7XG4gIGlmICh5ID09IG51bGwpIHkgPSAwO1xuXG4gIGZ1bmN0aW9uIGZvcmNlKGFscGhhKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBub2Rlcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIHZhciBub2RlID0gbm9kZXNbaV0sXG4gICAgICAgICAgZHggPSBub2RlLnggLSB4IHx8IDFlLTYsXG4gICAgICAgICAgZHkgPSBub2RlLnkgLSB5IHx8IDFlLTYsXG4gICAgICAgICAgciA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSksXG4gICAgICAgICAgayA9IChyYWRpdXNlc1tpXSAtIHIpICogc3RyZW5ndGhzW2ldICogYWxwaGEgLyByO1xuICAgICAgbm9kZS52eCArPSBkeCAqIGs7XG4gICAgICBub2RlLnZ5ICs9IGR5ICogaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGlmICghbm9kZXMpIHJldHVybjtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aDtcbiAgICBzdHJlbmd0aHMgPSBuZXcgQXJyYXkobik7XG4gICAgcmFkaXVzZXMgPSBuZXcgQXJyYXkobik7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgcmFkaXVzZXNbaV0gPSArcmFkaXVzKG5vZGVzW2ldLCBpLCBub2Rlcyk7XG4gICAgICBzdHJlbmd0aHNbaV0gPSBpc05hTihyYWRpdXNlc1tpXSkgPyAwIDogK3N0cmVuZ3RoKG5vZGVzW2ldLCBpLCBub2Rlcyk7XG4gICAgfVxuICB9XG5cbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBub2RlcyA9IF8sIGluaXRpYWxpemUoKTtcbiAgfTtcblxuICBmb3JjZS5zdHJlbmd0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHN0cmVuZ3RoO1xuICB9O1xuXG4gIGZvcmNlLnJhZGl1cyA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYWRpdXMgPSB0eXBlb2YgXyA9PT0gXCJmdW5jdGlvblwiID8gXyA6IGNvbnN0YW50KCtfKSwgaW5pdGlhbGl6ZSgpLCBmb3JjZSkgOiByYWRpdXM7XG4gIH07XG5cbiAgZm9yY2UueCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gK18sIGZvcmNlKSA6IHg7XG4gIH07XG5cbiAgZm9yY2UueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5ID0gK18sIGZvcmNlKSA6IHk7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufVxuIiwiaW1wb3J0IHtkaXNwYXRjaH0gZnJvbSBcImQzLWRpc3BhdGNoXCI7XG5pbXBvcnQge3RpbWVyfSBmcm9tIFwiZDMtdGltZXJcIjtcbmltcG9ydCBsY2cgZnJvbSBcIi4vbGNnLmpzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB4KGQpIHtcbiAgcmV0dXJuIGQueDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHkoZCkge1xuICByZXR1cm4gZC55O1xufVxuXG52YXIgaW5pdGlhbFJhZGl1cyA9IDEwLFxuICAgIGluaXRpYWxBbmdsZSA9IE1hdGguUEkgKiAoMyAtIE1hdGguc3FydCg1KSk7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG5vZGVzKSB7XG4gIHZhciBzaW11bGF0aW9uLFxuICAgICAgYWxwaGEgPSAxLFxuICAgICAgYWxwaGFNaW4gPSAwLjAwMSxcbiAgICAgIGFscGhhRGVjYXkgPSAxIC0gTWF0aC5wb3coYWxwaGFNaW4sIDEgLyAzMDApLFxuICAgICAgYWxwaGFUYXJnZXQgPSAwLFxuICAgICAgdmVsb2NpdHlEZWNheSA9IDAuNixcbiAgICAgIGZvcmNlcyA9IG5ldyBNYXAoKSxcbiAgICAgIHN0ZXBwZXIgPSB0aW1lcihzdGVwKSxcbiAgICAgIGV2ZW50ID0gZGlzcGF0Y2goXCJ0aWNrXCIsIFwiZW5kXCIpLFxuICAgICAgcmFuZG9tID0gbGNnKCk7XG5cbiAgaWYgKG5vZGVzID09IG51bGwpIG5vZGVzID0gW107XG5cbiAgZnVuY3Rpb24gc3RlcCgpIHtcbiAgICB0aWNrKCk7XG4gICAgZXZlbnQuY2FsbChcInRpY2tcIiwgc2ltdWxhdGlvbik7XG4gICAgaWYgKGFscGhhIDwgYWxwaGFNaW4pIHtcbiAgICAgIHN0ZXBwZXIuc3RvcCgpO1xuICAgICAgZXZlbnQuY2FsbChcImVuZFwiLCBzaW11bGF0aW9uKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0aWNrKGl0ZXJhdGlvbnMpIHtcbiAgICB2YXIgaSwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTtcblxuICAgIGlmIChpdGVyYXRpb25zID09PSB1bmRlZmluZWQpIGl0ZXJhdGlvbnMgPSAxO1xuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBpdGVyYXRpb25zOyArK2spIHtcbiAgICAgIGFscGhhICs9IChhbHBoYVRhcmdldCAtIGFscGhhKSAqIGFscGhhRGVjYXk7XG5cbiAgICAgIGZvcmNlcy5mb3JFYWNoKGZ1bmN0aW9uKGZvcmNlKSB7XG4gICAgICAgIGZvcmNlKGFscGhhKTtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgaWYgKG5vZGUuZnggPT0gbnVsbCkgbm9kZS54ICs9IG5vZGUudnggKj0gdmVsb2NpdHlEZWNheTtcbiAgICAgICAgZWxzZSBub2RlLnggPSBub2RlLmZ4LCBub2RlLnZ4ID0gMDtcbiAgICAgICAgaWYgKG5vZGUuZnkgPT0gbnVsbCkgbm9kZS55ICs9IG5vZGUudnkgKj0gdmVsb2NpdHlEZWNheTtcbiAgICAgICAgZWxzZSBub2RlLnkgPSBub2RlLmZ5LCBub2RlLnZ5ID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2ltdWxhdGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemVOb2RlcygpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IG5vZGVzLmxlbmd0aCwgbm9kZTsgaSA8IG47ICsraSkge1xuICAgICAgbm9kZSA9IG5vZGVzW2ldLCBub2RlLmluZGV4ID0gaTtcbiAgICAgIGlmIChub2RlLmZ4ICE9IG51bGwpIG5vZGUueCA9IG5vZGUuZng7XG4gICAgICBpZiAobm9kZS5meSAhPSBudWxsKSBub2RlLnkgPSBub2RlLmZ5O1xuICAgICAgaWYgKGlzTmFOKG5vZGUueCkgfHwgaXNOYU4obm9kZS55KSkge1xuICAgICAgICB2YXIgcmFkaXVzID0gaW5pdGlhbFJhZGl1cyAqIE1hdGguc3FydCgwLjUgKyBpKSwgYW5nbGUgPSBpICogaW5pdGlhbEFuZ2xlO1xuICAgICAgICBub2RlLnggPSByYWRpdXMgKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgIG5vZGUueSA9IHJhZGl1cyAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc05hTihub2RlLnZ4KSB8fCBpc05hTihub2RlLnZ5KSkge1xuICAgICAgICBub2RlLnZ4ID0gbm9kZS52eSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZUZvcmNlKGZvcmNlKSB7XG4gICAgaWYgKGZvcmNlLmluaXRpYWxpemUpIGZvcmNlLmluaXRpYWxpemUobm9kZXMsIHJhbmRvbSk7XG4gICAgcmV0dXJuIGZvcmNlO1xuICB9XG5cbiAgaW5pdGlhbGl6ZU5vZGVzKCk7XG5cbiAgcmV0dXJuIHNpbXVsYXRpb24gPSB7XG4gICAgdGljazogdGljayxcblxuICAgIHJlc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHN0ZXBwZXIucmVzdGFydChzdGVwKSwgc2ltdWxhdGlvbjtcbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gc3RlcHBlci5zdG9wKCksIHNpbXVsYXRpb247XG4gICAgfSxcblxuICAgIG5vZGVzOiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChub2RlcyA9IF8sIGluaXRpYWxpemVOb2RlcygpLCBmb3JjZXMuZm9yRWFjaChpbml0aWFsaXplRm9yY2UpLCBzaW11bGF0aW9uKSA6IG5vZGVzO1xuICAgIH0sXG5cbiAgICBhbHBoYTogZnVuY3Rpb24oXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoYWxwaGEgPSArXywgc2ltdWxhdGlvbikgOiBhbHBoYTtcbiAgICB9LFxuXG4gICAgYWxwaGFNaW46IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFscGhhTWluID0gK18sIHNpbXVsYXRpb24pIDogYWxwaGFNaW47XG4gICAgfSxcblxuICAgIGFscGhhRGVjYXk6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFscGhhRGVjYXkgPSArXywgc2ltdWxhdGlvbikgOiArYWxwaGFEZWNheTtcbiAgICB9LFxuXG4gICAgYWxwaGFUYXJnZXQ6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKGFscGhhVGFyZ2V0ID0gK18sIHNpbXVsYXRpb24pIDogYWxwaGFUYXJnZXQ7XG4gICAgfSxcblxuICAgIHZlbG9jaXR5RGVjYXk6IGZ1bmN0aW9uKF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHZlbG9jaXR5RGVjYXkgPSAxIC0gXywgc2ltdWxhdGlvbikgOiAxIC0gdmVsb2NpdHlEZWNheTtcbiAgICB9LFxuXG4gICAgcmFuZG9tU291cmNlOiBmdW5jdGlvbihfKSB7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChyYW5kb20gPSBfLCBmb3JjZXMuZm9yRWFjaChpbml0aWFsaXplRm9yY2UpLCBzaW11bGF0aW9uKSA6IHJhbmRvbTtcbiAgICB9LFxuXG4gICAgZm9yY2U6IGZ1bmN0aW9uKG5hbWUsIF8pIHtcbiAgICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMSA/ICgoXyA9PSBudWxsID8gZm9yY2VzLmRlbGV0ZShuYW1lKSA6IGZvcmNlcy5zZXQobmFtZSwgaW5pdGlhbGl6ZUZvcmNlKF8pKSksIHNpbXVsYXRpb24pIDogZm9yY2VzLmdldChuYW1lKTtcbiAgICB9LFxuXG4gICAgZmluZDogZnVuY3Rpb24oeCwgeSwgcmFkaXVzKSB7XG4gICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgbiA9IG5vZGVzLmxlbmd0aCxcbiAgICAgICAgICBkeCxcbiAgICAgICAgICBkeSxcbiAgICAgICAgICBkMixcbiAgICAgICAgICBub2RlLFxuICAgICAgICAgIGNsb3Nlc3Q7XG5cbiAgICAgIGlmIChyYWRpdXMgPT0gbnVsbCkgcmFkaXVzID0gSW5maW5pdHk7XG4gICAgICBlbHNlIHJhZGl1cyAqPSByYWRpdXM7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBkeCA9IHggLSBub2RlLng7XG4gICAgICAgIGR5ID0geSAtIG5vZGUueTtcbiAgICAgICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgaWYgKGQyIDwgcmFkaXVzKSBjbG9zZXN0ID0gbm9kZSwgcmFkaXVzID0gZDI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjbG9zZXN0O1xuICAgIH0sXG5cbiAgICBvbjogZnVuY3Rpb24obmFtZSwgXykge1xuICAgICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gKGV2ZW50Lm9uKG5hbWUsIF8pLCBzaW11bGF0aW9uKSA6IGV2ZW50Lm9uKG5hbWUpO1xuICAgIH1cbiAgfTtcbn1cbiIsImltcG9ydCBjb25zdGFudCBmcm9tIFwiLi9jb25zdGFudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4KSB7XG4gIHZhciBzdHJlbmd0aCA9IGNvbnN0YW50KDAuMSksXG4gICAgICBub2RlcyxcbiAgICAgIHN0cmVuZ3RocyxcbiAgICAgIHh6O1xuXG4gIGlmICh0eXBlb2YgeCAhPT0gXCJmdW5jdGlvblwiKSB4ID0gY29uc3RhbnQoeCA9PSBudWxsID8gMCA6ICt4KTtcblxuICBmdW5jdGlvbiBmb3JjZShhbHBoYSkge1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gbm9kZXMubGVuZ3RoLCBub2RlOyBpIDwgbjsgKytpKSB7XG4gICAgICBub2RlID0gbm9kZXNbaV0sIG5vZGUudnggKz0gKHh6W2ldIC0gbm9kZS54KSAqIHN0cmVuZ3Roc1tpXSAqIGFscGhhO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluaXRpYWxpemUoKSB7XG4gICAgaWYgKCFub2RlcykgcmV0dXJuO1xuICAgIHZhciBpLCBuID0gbm9kZXMubGVuZ3RoO1xuICAgIHN0cmVuZ3RocyA9IG5ldyBBcnJheShuKTtcbiAgICB4eiA9IG5ldyBBcnJheShuKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBzdHJlbmd0aHNbaV0gPSBpc05hTih4eltpXSA9ICt4KG5vZGVzW2ldLCBpLCBub2RlcykpID8gMCA6ICtzdHJlbmd0aChub2Rlc1tpXSwgaSwgbm9kZXMpO1xuICAgIH1cbiAgfVxuXG4gIGZvcmNlLmluaXRpYWxpemUgPSBmdW5jdGlvbihfKSB7XG4gICAgbm9kZXMgPSBfO1xuICAgIGluaXRpYWxpemUoKTtcbiAgfTtcblxuICBmb3JjZS5zdHJlbmd0aCA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IChzdHJlbmd0aCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHN0cmVuZ3RoO1xuICB9O1xuXG4gIGZvcmNlLnggPSBmdW5jdGlvbihfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeCA9IHR5cGVvZiBfID09PSBcImZ1bmN0aW9uXCIgPyBfIDogY29uc3RhbnQoK18pLCBpbml0aWFsaXplKCksIGZvcmNlKSA6IHg7XG4gIH07XG5cbiAgcmV0dXJuIGZvcmNlO1xufVxuIiwiaW1wb3J0IGNvbnN0YW50IGZyb20gXCIuL2NvbnN0YW50LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHkpIHtcbiAgdmFyIHN0cmVuZ3RoID0gY29uc3RhbnQoMC4xKSxcbiAgICAgIG5vZGVzLFxuICAgICAgc3RyZW5ndGhzLFxuICAgICAgeXo7XG5cbiAgaWYgKHR5cGVvZiB5ICE9PSBcImZ1bmN0aW9uXCIpIHkgPSBjb25zdGFudCh5ID09IG51bGwgPyAwIDogK3kpO1xuXG4gIGZ1bmN0aW9uIGZvcmNlKGFscGhhKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBub2Rlcy5sZW5ndGgsIG5vZGU7IGkgPCBuOyArK2kpIHtcbiAgICAgIG5vZGUgPSBub2Rlc1tpXSwgbm9kZS52eSArPSAoeXpbaV0gLSBub2RlLnkpICogc3RyZW5ndGhzW2ldICogYWxwaGE7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAoIW5vZGVzKSByZXR1cm47XG4gICAgdmFyIGksIG4gPSBub2Rlcy5sZW5ndGg7XG4gICAgc3RyZW5ndGhzID0gbmV3IEFycmF5KG4pO1xuICAgIHl6ID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHN0cmVuZ3Roc1tpXSA9IGlzTmFOKHl6W2ldID0gK3kobm9kZXNbaV0sIGksIG5vZGVzKSkgPyAwIDogK3N0cmVuZ3RoKG5vZGVzW2ldLCBpLCBub2Rlcyk7XG4gICAgfVxuICB9XG5cbiAgZm9yY2UuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKF8pIHtcbiAgICBub2RlcyA9IF87XG4gICAgaW5pdGlhbGl6ZSgpO1xuICB9O1xuXG4gIGZvcmNlLnN0cmVuZ3RoID0gZnVuY3Rpb24oXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHN0cmVuZ3RoID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogc3RyZW5ndGg7XG4gIH07XG5cbiAgZm9yY2UueSA9IGZ1bmN0aW9uKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh5ID0gdHlwZW9mIF8gPT09IFwiZnVuY3Rpb25cIiA/IF8gOiBjb25zdGFudCgrXyksIGluaXRpYWxpemUoKSwgZm9yY2UpIDogeTtcbiAgfTtcblxuICByZXR1cm4gZm9yY2U7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkKSB7XG4gIGNvbnN0IHggPSArdGhpcy5feC5jYWxsKG51bGwsIGQpLFxuICAgICAgeSA9ICt0aGlzLl95LmNhbGwobnVsbCwgZCksXG4gICAgICB6ID0gK3RoaXMuX3ouY2FsbChudWxsLCBkKTtcbiAgcmV0dXJuIGFkZCh0aGlzLmNvdmVyKHgsIHksIHopLCB4LCB5LCB6LCBkKTtcbn1cblxuZnVuY3Rpb24gYWRkKHRyZWUsIHgsIHksIHosIGQpIHtcbiAgaWYgKGlzTmFOKHgpIHx8IGlzTmFOKHkpIHx8IGlzTmFOKHopKSByZXR1cm4gdHJlZTsgLy8gaWdub3JlIGludmFsaWQgcG9pbnRzXG5cbiAgdmFyIHBhcmVudCxcbiAgICAgIG5vZGUgPSB0cmVlLl9yb290LFxuICAgICAgbGVhZiA9IHtkYXRhOiBkfSxcbiAgICAgIHgwID0gdHJlZS5feDAsXG4gICAgICB5MCA9IHRyZWUuX3kwLFxuICAgICAgejAgPSB0cmVlLl96MCxcbiAgICAgIHgxID0gdHJlZS5feDEsXG4gICAgICB5MSA9IHRyZWUuX3kxLFxuICAgICAgejEgPSB0cmVlLl96MSxcbiAgICAgIHhtLFxuICAgICAgeW0sXG4gICAgICB6bSxcbiAgICAgIHhwLFxuICAgICAgeXAsXG4gICAgICB6cCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgICAgZGVlcCxcbiAgICAgIGksXG4gICAgICBqO1xuXG4gIC8vIElmIHRoZSB0cmVlIGlzIGVtcHR5LCBpbml0aWFsaXplIHRoZSByb290IGFzIGEgbGVhZi5cbiAgaWYgKCFub2RlKSByZXR1cm4gdHJlZS5fcm9vdCA9IGxlYWYsIHRyZWU7XG5cbiAgLy8gRmluZCB0aGUgZXhpc3RpbmcgbGVhZiBmb3IgdGhlIG5ldyBwb2ludCwgb3IgYWRkIGl0LlxuICB3aGlsZSAobm9kZS5sZW5ndGgpIHtcbiAgICBpZiAocmlnaHQgPSB4ID49ICh4bSA9ICh4MCArIHgxKSAvIDIpKSB4MCA9IHhtOyBlbHNlIHgxID0geG07XG4gICAgaWYgKGJvdHRvbSA9IHkgPj0gKHltID0gKHkwICsgeTEpIC8gMikpIHkwID0geW07IGVsc2UgeTEgPSB5bTtcbiAgICBpZiAoZGVlcCA9IHogPj0gKHptID0gKHowICsgejEpIC8gMikpIHowID0gem07IGVsc2UgejEgPSB6bTtcbiAgICBpZiAocGFyZW50ID0gbm9kZSwgIShub2RlID0gbm9kZVtpID0gZGVlcCA8PCAyIHwgYm90dG9tIDw8IDEgfCByaWdodF0pKSByZXR1cm4gcGFyZW50W2ldID0gbGVhZiwgdHJlZTtcbiAgfVxuXG4gIC8vIElzIHRoZSBuZXcgcG9pbnQgaXMgZXhhY3RseSBjb2luY2lkZW50IHdpdGggdGhlIGV4aXN0aW5nIHBvaW50P1xuICB4cCA9ICt0cmVlLl94LmNhbGwobnVsbCwgbm9kZS5kYXRhKTtcbiAgeXAgPSArdHJlZS5feS5jYWxsKG51bGwsIG5vZGUuZGF0YSk7XG4gIHpwID0gK3RyZWUuX3ouY2FsbChudWxsLCBub2RlLmRhdGEpO1xuICBpZiAoeCA9PT0geHAgJiYgeSA9PT0geXAgJiYgeiA9PT0genApIHJldHVybiBsZWFmLm5leHQgPSBub2RlLCBwYXJlbnQgPyBwYXJlbnRbaV0gPSBsZWFmIDogdHJlZS5fcm9vdCA9IGxlYWYsIHRyZWU7XG5cbiAgLy8gT3RoZXJ3aXNlLCBzcGxpdCB0aGUgbGVhZiBub2RlIHVudGlsIHRoZSBvbGQgYW5kIG5ldyBwb2ludCBhcmUgc2VwYXJhdGVkLlxuICBkbyB7XG4gICAgcGFyZW50ID0gcGFyZW50ID8gcGFyZW50W2ldID0gbmV3IEFycmF5KDgpIDogdHJlZS5fcm9vdCA9IG5ldyBBcnJheSg4KTtcbiAgICBpZiAocmlnaHQgPSB4ID49ICh4bSA9ICh4MCArIHgxKSAvIDIpKSB4MCA9IHhtOyBlbHNlIHgxID0geG07XG4gICAgaWYgKGJvdHRvbSA9IHkgPj0gKHltID0gKHkwICsgeTEpIC8gMikpIHkwID0geW07IGVsc2UgeTEgPSB5bTtcbiAgICBpZiAoZGVlcCA9IHogPj0gKHptID0gKHowICsgejEpIC8gMikpIHowID0gem07IGVsc2UgejEgPSB6bTtcbiAgfSB3aGlsZSAoKGkgPSBkZWVwIDw8IDIgfCBib3R0b20gPDwgMSB8IHJpZ2h0KSA9PT0gKGogPSAoenAgPj0gem0pIDw8IDIgfCAoeXAgPj0geW0pIDw8IDEgfCAoeHAgPj0geG0pKSk7XG4gIHJldHVybiBwYXJlbnRbal0gPSBub2RlLCBwYXJlbnRbaV0gPSBsZWFmLCB0cmVlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQWxsKGRhdGEpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSBkYXRhID0gQXJyYXkuZnJvbShkYXRhKTtcbiAgY29uc3QgbiA9IGRhdGEubGVuZ3RoO1xuICBjb25zdCB4eiA9IG5ldyBGbG9hdDY0QXJyYXkobik7XG4gIGNvbnN0IHl6ID0gbmV3IEZsb2F0NjRBcnJheShuKTtcbiAgY29uc3QgenogPSBuZXcgRmxvYXQ2NEFycmF5KG4pO1xuICBsZXQgeDAgPSBJbmZpbml0eSxcbiAgICAgIHkwID0gSW5maW5pdHksXG4gICAgICB6MCA9IEluZmluaXR5LFxuICAgICAgeDEgPSAtSW5maW5pdHksXG4gICAgICB5MSA9IC1JbmZpbml0eSxcbiAgICAgIHoxID0gLUluZmluaXR5O1xuXG4gIC8vIENvbXB1dGUgdGhlIHBvaW50cyBhbmQgdGhlaXIgZXh0ZW50LlxuICBmb3IgKGxldCBpID0gMCwgZCwgeCwgeSwgejsgaSA8IG47ICsraSkge1xuICAgIGlmIChpc05hTih4ID0gK3RoaXMuX3guY2FsbChudWxsLCBkID0gZGF0YVtpXSkpIHx8IGlzTmFOKHkgPSArdGhpcy5feS5jYWxsKG51bGwsIGQpKSB8fCBpc05hTih6ID0gK3RoaXMuX3ouY2FsbChudWxsLCBkKSkpIGNvbnRpbnVlO1xuICAgIHh6W2ldID0geDtcbiAgICB5eltpXSA9IHk7XG4gICAgenpbaV0gPSB6O1xuICAgIGlmICh4IDwgeDApIHgwID0geDtcbiAgICBpZiAoeCA+IHgxKSB4MSA9IHg7XG4gICAgaWYgKHkgPCB5MCkgeTAgPSB5O1xuICAgIGlmICh5ID4geTEpIHkxID0geTtcbiAgICBpZiAoeiA8IHowKSB6MCA9IHo7XG4gICAgaWYgKHogPiB6MSkgejEgPSB6O1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgd2VyZSBubyAodmFsaWQpIHBvaW50cywgYWJvcnQuXG4gIGlmICh4MCA+IHgxIHx8IHkwID4geTEgfHwgejAgPiB6MSkgcmV0dXJuIHRoaXM7XG5cbiAgLy8gRXhwYW5kIHRoZSB0cmVlIHRvIGNvdmVyIHRoZSBuZXcgcG9pbnRzLlxuICB0aGlzLmNvdmVyKHgwLCB5MCwgejApLmNvdmVyKHgxLCB5MSwgejEpO1xuXG4gIC8vIEFkZCB0aGUgbmV3IHBvaW50cy5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBhZGQodGhpcywgeHpbaV0sIHl6W2ldLCB6eltpXSwgZGF0YVtpXSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgaWYgKGlzTmFOKHggPSAreCkgfHwgaXNOYU4oeSA9ICt5KSB8fCBpc05hTih6ID0gK3opKSByZXR1cm4gdGhpczsgLy8gaWdub3JlIGludmFsaWQgcG9pbnRzXG5cbiAgdmFyIHgwID0gdGhpcy5feDAsXG4gICAgICB5MCA9IHRoaXMuX3kwLFxuICAgICAgejAgPSB0aGlzLl96MCxcbiAgICAgIHgxID0gdGhpcy5feDEsXG4gICAgICB5MSA9IHRoaXMuX3kxLFxuICAgICAgejEgPSB0aGlzLl96MTtcblxuICAvLyBJZiB0aGUgb2N0cmVlIGhhcyBubyBleHRlbnQsIGluaXRpYWxpemUgdGhlbS5cbiAgLy8gSW50ZWdlciBleHRlbnQgYXJlIG5lY2Vzc2FyeSBzbyB0aGF0IGlmIHdlIGxhdGVyIGRvdWJsZSB0aGUgZXh0ZW50LFxuICAvLyB0aGUgZXhpc3Rpbmcgb2N0YW50IGJvdW5kYXJpZXMgZG9u4oCZdCBjaGFuZ2UgZHVlIHRvIGZsb2F0aW5nIHBvaW50IGVycm9yIVxuICBpZiAoaXNOYU4oeDApKSB7XG4gICAgeDEgPSAoeDAgPSBNYXRoLmZsb29yKHgpKSArIDE7XG4gICAgeTEgPSAoeTAgPSBNYXRoLmZsb29yKHkpKSArIDE7XG4gICAgejEgPSAoejAgPSBNYXRoLmZsb29yKHopKSArIDE7XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIGRvdWJsZSByZXBlYXRlZGx5IHRvIGNvdmVyLlxuICBlbHNlIHtcbiAgICB2YXIgdCA9IHgxIC0geDAgfHwgMSxcbiAgICAgICAgbm9kZSA9IHRoaXMuX3Jvb3QsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgaTtcblxuICAgIHdoaWxlICh4MCA+IHggfHwgeCA+PSB4MSB8fCB5MCA+IHkgfHwgeSA+PSB5MSB8fCB6MCA+IHogfHwgeiA+PSB6MSkge1xuICAgICAgaSA9ICh6IDwgejApIDw8IDIgfCAoeSA8IHkwKSA8PCAxIHwgKHggPCB4MCk7XG4gICAgICBwYXJlbnQgPSBuZXcgQXJyYXkoOCksIHBhcmVudFtpXSA9IG5vZGUsIG5vZGUgPSBwYXJlbnQsIHQgKj0gMjtcbiAgICAgIHN3aXRjaCAoaSkge1xuICAgICAgICBjYXNlIDA6IHgxID0geDAgKyB0LCB5MSA9IHkwICsgdCwgejEgPSB6MCArIHQ7IGJyZWFrO1xuICAgICAgICBjYXNlIDE6IHgwID0geDEgLSB0LCB5MSA9IHkwICsgdCwgejEgPSB6MCArIHQ7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IHgxID0geDAgKyB0LCB5MCA9IHkxIC0gdCwgejEgPSB6MCArIHQ7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IHgwID0geDEgLSB0LCB5MCA9IHkxIC0gdCwgejEgPSB6MCArIHQ7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IHgxID0geDAgKyB0LCB5MSA9IHkwICsgdCwgejAgPSB6MSAtIHQ7IGJyZWFrO1xuICAgICAgICBjYXNlIDU6IHgwID0geDEgLSB0LCB5MSA9IHkwICsgdCwgejAgPSB6MSAtIHQ7IGJyZWFrO1xuICAgICAgICBjYXNlIDY6IHgxID0geDAgKyB0LCB5MCA9IHkxIC0gdCwgejAgPSB6MSAtIHQ7IGJyZWFrO1xuICAgICAgICBjYXNlIDc6IHgwID0geDEgLSB0LCB5MCA9IHkxIC0gdCwgejAgPSB6MSAtIHQ7IGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9yb290ICYmIHRoaXMuX3Jvb3QubGVuZ3RoKSB0aGlzLl9yb290ID0gbm9kZTtcbiAgfVxuXG4gIHRoaXMuX3gwID0geDA7XG4gIHRoaXMuX3kwID0geTA7XG4gIHRoaXMuX3owID0gejA7XG4gIHRoaXMuX3gxID0geDE7XG4gIHRoaXMuX3kxID0geTE7XG4gIHRoaXMuX3oxID0gejE7XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBkYXRhID0gW107XG4gIHRoaXMudmlzaXQoZnVuY3Rpb24obm9kZSkge1xuICAgIGlmICghbm9kZS5sZW5ndGgpIGRvIGRhdGEucHVzaChub2RlLmRhdGEpOyB3aGlsZSAobm9kZSA9IG5vZGUubmV4dClcbiAgfSk7XG4gIHJldHVybiBkYXRhO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oXykge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aFxuICAgICAgPyB0aGlzLmNvdmVyKCtfWzBdWzBdLCArX1swXVsxXSwgK19bMF1bMl0pLmNvdmVyKCtfWzFdWzBdLCArX1sxXVsxXSwgK19bMV1bMl0pXG4gICAgICA6IGlzTmFOKHRoaXMuX3gwKSA/IHVuZGVmaW5lZCA6IFtbdGhpcy5feDAsIHRoaXMuX3kwLCB0aGlzLl96MF0sIFt0aGlzLl94MSwgdGhpcy5feTEsIHRoaXMuX3oxXV07XG59XG4iLCJpbXBvcnQgT2N0YW50IGZyb20gXCIuL29jdGFudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih4LCB5LCB6LCByYWRpdXMpIHtcbiAgdmFyIGRhdGEsXG4gICAgICB4MCA9IHRoaXMuX3gwLFxuICAgICAgeTAgPSB0aGlzLl95MCxcbiAgICAgIHowID0gdGhpcy5fejAsXG4gICAgICB4MSxcbiAgICAgIHkxLFxuICAgICAgejEsXG4gICAgICB4MixcbiAgICAgIHkyLFxuICAgICAgejIsXG4gICAgICB4MyA9IHRoaXMuX3gxLFxuICAgICAgeTMgPSB0aGlzLl95MSxcbiAgICAgIHozID0gdGhpcy5fejEsXG4gICAgICBvY3RzID0gW10sXG4gICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgIHEsXG4gICAgICBpO1xuXG4gIGlmIChub2RlKSBvY3RzLnB1c2gobmV3IE9jdGFudChub2RlLCB4MCwgeTAsIHowLCB4MywgeTMsIHozKSk7XG4gIGlmIChyYWRpdXMgPT0gbnVsbCkgcmFkaXVzID0gSW5maW5pdHk7XG4gIGVsc2Uge1xuICAgIHgwID0geCAtIHJhZGl1cywgeTAgPSB5IC0gcmFkaXVzLCB6MCA9IHogLSByYWRpdXM7XG4gICAgeDMgPSB4ICsgcmFkaXVzLCB5MyA9IHkgKyByYWRpdXMsIHozID0geiArIHJhZGl1cztcbiAgICByYWRpdXMgKj0gcmFkaXVzO1xuICB9XG5cbiAgd2hpbGUgKHEgPSBvY3RzLnBvcCgpKSB7XG5cbiAgICAvLyBTdG9wIHNlYXJjaGluZyBpZiB0aGlzIG9jdGFudCBjYW7igJl0IGNvbnRhaW4gYSBjbG9zZXIgbm9kZS5cbiAgICBpZiAoIShub2RlID0gcS5ub2RlKVxuICAgICAgICB8fCAoeDEgPSBxLngwKSA+IHgzXG4gICAgICAgIHx8ICh5MSA9IHEueTApID4geTNcbiAgICAgICAgfHwgKHoxID0gcS56MCkgPiB6M1xuICAgICAgICB8fCAoeDIgPSBxLngxKSA8IHgwXG4gICAgICAgIHx8ICh5MiA9IHEueTEpIDwgeTBcbiAgICAgICAgfHwgKHoyID0gcS56MSkgPCB6MCkgY29udGludWU7XG5cbiAgICAvLyBCaXNlY3QgdGhlIGN1cnJlbnQgb2N0YW50LlxuICAgIGlmIChub2RlLmxlbmd0aCkge1xuICAgICAgdmFyIHhtID0gKHgxICsgeDIpIC8gMixcbiAgICAgICAgICB5bSA9ICh5MSArIHkyKSAvIDIsXG4gICAgICAgICAgem0gPSAoejEgKyB6MikgLyAyO1xuXG4gICAgICBvY3RzLnB1c2goXG4gICAgICAgIG5ldyBPY3RhbnQobm9kZVs3XSwgeG0sIHltLCB6bSwgeDIsIHkyLCB6MiksXG4gICAgICAgIG5ldyBPY3RhbnQobm9kZVs2XSwgeDEsIHltLCB6bSwgeG0sIHkyLCB6MiksXG4gICAgICAgIG5ldyBPY3RhbnQobm9kZVs1XSwgeG0sIHkxLCB6bSwgeDIsIHltLCB6MiksXG4gICAgICAgIG5ldyBPY3RhbnQobm9kZVs0XSwgeDEsIHkxLCB6bSwgeG0sIHltLCB6MiksXG4gICAgICAgIG5ldyBPY3RhbnQobm9kZVszXSwgeG0sIHltLCB6MSwgeDIsIHkyLCB6bSksXG4gICAgICAgIG5ldyBPY3RhbnQobm9kZVsyXSwgeDEsIHltLCB6MSwgeG0sIHkyLCB6bSksXG4gICAgICAgIG5ldyBPY3RhbnQobm9kZVsxXSwgeG0sIHkxLCB6MSwgeDIsIHltLCB6bSksXG4gICAgICAgIG5ldyBPY3RhbnQobm9kZVswXSwgeDEsIHkxLCB6MSwgeG0sIHltLCB6bSlcbiAgICAgICk7XG5cbiAgICAgIC8vIFZpc2l0IHRoZSBjbG9zZXN0IG9jdGFudCBmaXJzdC5cbiAgICAgIGlmIChpID0gKHogPj0gem0pIDw8IDIgfCAoeSA+PSB5bSkgPDwgMSB8ICh4ID49IHhtKSkge1xuICAgICAgICBxID0gb2N0c1tvY3RzLmxlbmd0aCAtIDFdO1xuICAgICAgICBvY3RzW29jdHMubGVuZ3RoIC0gMV0gPSBvY3RzW29jdHMubGVuZ3RoIC0gMSAtIGldO1xuICAgICAgICBvY3RzW29jdHMubGVuZ3RoIC0gMSAtIGldID0gcTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBWaXNpdCB0aGlzIHBvaW50LiAoVmlzaXRpbmcgY29pbmNpZGVudCBwb2ludHMgaXNu4oCZdCBuZWNlc3NhcnkhKVxuICAgIGVsc2Uge1xuICAgICAgdmFyIGR4ID0geCAtICt0aGlzLl94LmNhbGwobnVsbCwgbm9kZS5kYXRhKSxcbiAgICAgICAgICBkeSA9IHkgLSArdGhpcy5feS5jYWxsKG51bGwsIG5vZGUuZGF0YSksXG4gICAgICAgICAgZHogPSB6IC0gK3RoaXMuX3ouY2FsbChudWxsLCBub2RlLmRhdGEpLFxuICAgICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHkgKyBkeiAqIGR6O1xuICAgICAgaWYgKGQyIDwgcmFkaXVzKSB7XG4gICAgICAgIHZhciBkID0gTWF0aC5zcXJ0KHJhZGl1cyA9IGQyKTtcbiAgICAgICAgeDAgPSB4IC0gZCwgeTAgPSB5IC0gZCwgejAgPSB6IC0gZDtcbiAgICAgICAgeDMgPSB4ICsgZCwgeTMgPSB5ICsgZCwgejMgPSB6ICsgZDtcbiAgICAgICAgZGF0YSA9IG5vZGUuZGF0YTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cbiIsImNvbnN0IGRpc3RhbmNlID0gKHgxLCB5MSwgejEsIHgyLCB5MiwgejIpID0+IE1hdGguc3FydCgoeDEteDIpKioyICsgKHkxLXkyKSoqMiArICh6MS16MikqKjIpO1xuXG5leHBvcnQgZnVuY3Rpb24gZmluZEFsbFdpdGhpblJhZGl1cyh4LCB5LCB6LCByYWRpdXMpIHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgY29uc3QgeE1pbiA9IHggLSByYWRpdXM7XG4gIGNvbnN0IHlNaW4gPSB5IC0gcmFkaXVzO1xuICBjb25zdCB6TWluID0geiAtIHJhZGl1cztcbiAgY29uc3QgeE1heCA9IHggKyByYWRpdXM7XG4gIGNvbnN0IHlNYXggPSB5ICsgcmFkaXVzO1xuICBjb25zdCB6TWF4ID0geiArIHJhZGl1cztcblxuICB0aGlzLnZpc2l0KChub2RlLCB4MSwgeTEsIHoxLCB4MiwgeTIsIHoyKSA9PiB7XG4gICAgaWYgKCFub2RlLmxlbmd0aCkge1xuICAgICAgZG8ge1xuICAgICAgICBjb25zdCBkID0gbm9kZS5kYXRhO1xuICAgICAgICBpZiAoZGlzdGFuY2UoeCwgeSwgeiwgdGhpcy5feChkKSwgdGhpcy5feShkKSwgdGhpcy5feihkKSkgPD0gcmFkaXVzKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goZCk7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKG5vZGUgPSBub2RlLm5leHQpO1xuICAgIH1cbiAgICByZXR1cm4geDEgPiB4TWF4IHx8IHkxID4geU1heCB8fCB6MSA+IHpNYXggfHwgeDIgPCB4TWluIHx8IHkyIDwgeU1pbiB8fCB6MiA8IHpNaW47XG4gIH0pO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihub2RlLCB4MCwgeTAsIHowLCB4MSwgeTEsIHoxKSB7XG4gIHRoaXMubm9kZSA9IG5vZGU7XG4gIHRoaXMueDAgPSB4MDtcbiAgdGhpcy55MCA9IHkwO1xuICB0aGlzLnowID0gejA7XG4gIHRoaXMueDEgPSB4MTtcbiAgdGhpcy55MSA9IHkxO1xuICB0aGlzLnoxID0gejE7XG59XG4iLCJpbXBvcnQgdHJlZV9hZGQsIHthZGRBbGwgYXMgdHJlZV9hZGRBbGx9IGZyb20gXCIuL2FkZC5qc1wiO1xuaW1wb3J0IHRyZWVfY292ZXIgZnJvbSBcIi4vY292ZXIuanNcIjtcbmltcG9ydCB0cmVlX2RhdGEgZnJvbSBcIi4vZGF0YS5qc1wiO1xuaW1wb3J0IHRyZWVfZXh0ZW50IGZyb20gXCIuL2V4dGVudC5qc1wiO1xuaW1wb3J0IHRyZWVfZmluZCBmcm9tIFwiLi9maW5kLmpzXCI7XG5pbXBvcnQgeyBmaW5kQWxsV2l0aGluUmFkaXVzIGFzIHRyZWVfZmluZEFsbFdpdGhpblJhZGl1cyB9IGZyb20gXCIuL2ZpbmRBbGwuanNcIjtcbmltcG9ydCB0cmVlX3JlbW92ZSwge3JlbW92ZUFsbCBhcyB0cmVlX3JlbW92ZUFsbH0gZnJvbSBcIi4vcmVtb3ZlLmpzXCI7XG5pbXBvcnQgdHJlZV9yb290IGZyb20gXCIuL3Jvb3QuanNcIjtcbmltcG9ydCB0cmVlX3NpemUgZnJvbSBcIi4vc2l6ZS5qc1wiO1xuaW1wb3J0IHRyZWVfdmlzaXQgZnJvbSBcIi4vdmlzaXQuanNcIjtcbmltcG9ydCB0cmVlX3Zpc2l0QWZ0ZXIgZnJvbSBcIi4vdmlzaXRBZnRlci5qc1wiO1xuaW1wb3J0IHRyZWVfeCwge2RlZmF1bHRYfSBmcm9tIFwiLi94LmpzXCI7XG5pbXBvcnQgdHJlZV95LCB7ZGVmYXVsdFl9IGZyb20gXCIuL3kuanNcIjtcbmltcG9ydCB0cmVlX3osIHtkZWZhdWx0Wn0gZnJvbSBcIi4vei5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBvY3RyZWUobm9kZXMsIHgsIHksIHopIHtcbiAgdmFyIHRyZWUgPSBuZXcgT2N0cmVlKHggPT0gbnVsbCA/IGRlZmF1bHRYIDogeCwgeSA9PSBudWxsID8gZGVmYXVsdFkgOiB5LCB6ID09IG51bGwgPyBkZWZhdWx0WiA6IHosIE5hTiwgTmFOLCBOYU4sIE5hTiwgTmFOLCBOYU4pO1xuICByZXR1cm4gbm9kZXMgPT0gbnVsbCA/IHRyZWUgOiB0cmVlLmFkZEFsbChub2Rlcyk7XG59XG5cbmZ1bmN0aW9uIE9jdHJlZSh4LCB5LCB6LCB4MCwgeTAsIHowLCB4MSwgeTEsIHoxKSB7XG4gIHRoaXMuX3ggPSB4O1xuICB0aGlzLl95ID0geTtcbiAgdGhpcy5feiA9IHo7XG4gIHRoaXMuX3gwID0geDA7XG4gIHRoaXMuX3kwID0geTA7XG4gIHRoaXMuX3owID0gejA7XG4gIHRoaXMuX3gxID0geDE7XG4gIHRoaXMuX3kxID0geTE7XG4gIHRoaXMuX3oxID0gejE7XG4gIHRoaXMuX3Jvb3QgPSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGxlYWZfY29weShsZWFmKSB7XG4gIHZhciBjb3B5ID0ge2RhdGE6IGxlYWYuZGF0YX0sIG5leHQgPSBjb3B5O1xuICB3aGlsZSAobGVhZiA9IGxlYWYubmV4dCkgbmV4dCA9IG5leHQubmV4dCA9IHtkYXRhOiBsZWFmLmRhdGF9O1xuICByZXR1cm4gY29weTtcbn1cblxudmFyIHRyZWVQcm90byA9IG9jdHJlZS5wcm90b3R5cGUgPSBPY3RyZWUucHJvdG90eXBlO1xuXG50cmVlUHJvdG8uY29weSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgY29weSA9IG5ldyBPY3RyZWUodGhpcy5feCwgdGhpcy5feSwgdGhpcy5feiwgdGhpcy5feDAsIHRoaXMuX3kwLCB0aGlzLl96MCwgdGhpcy5feDEsIHRoaXMuX3kxLCB0aGlzLl96MSksXG4gICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgIG5vZGVzLFxuICAgICAgY2hpbGQ7XG5cbiAgaWYgKCFub2RlKSByZXR1cm4gY29weTtcblxuICBpZiAoIW5vZGUubGVuZ3RoKSByZXR1cm4gY29weS5fcm9vdCA9IGxlYWZfY29weShub2RlKSwgY29weTtcblxuICBub2RlcyA9IFt7c291cmNlOiBub2RlLCB0YXJnZXQ6IGNvcHkuX3Jvb3QgPSBuZXcgQXJyYXkoOCl9XTtcbiAgd2hpbGUgKG5vZGUgPSBub2Rlcy5wb3AoKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODsgKytpKSB7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlLnNvdXJjZVtpXSkge1xuICAgICAgICBpZiAoY2hpbGQubGVuZ3RoKSBub2Rlcy5wdXNoKHtzb3VyY2U6IGNoaWxkLCB0YXJnZXQ6IG5vZGUudGFyZ2V0W2ldID0gbmV3IEFycmF5KDgpfSk7XG4gICAgICAgIGVsc2Ugbm9kZS50YXJnZXRbaV0gPSBsZWFmX2NvcHkoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb3B5O1xufTtcblxudHJlZVByb3RvLmFkZCA9IHRyZWVfYWRkO1xudHJlZVByb3RvLmFkZEFsbCA9IHRyZWVfYWRkQWxsO1xudHJlZVByb3RvLmNvdmVyID0gdHJlZV9jb3ZlcjtcbnRyZWVQcm90by5kYXRhID0gdHJlZV9kYXRhO1xudHJlZVByb3RvLmV4dGVudCA9IHRyZWVfZXh0ZW50O1xudHJlZVByb3RvLmZpbmQgPSB0cmVlX2ZpbmQ7XG50cmVlUHJvdG8uZmluZEFsbFdpdGhpblJhZGl1cyA9IHRyZWVfZmluZEFsbFdpdGhpblJhZGl1cztcbnRyZWVQcm90by5yZW1vdmUgPSB0cmVlX3JlbW92ZTtcbnRyZWVQcm90by5yZW1vdmVBbGwgPSB0cmVlX3JlbW92ZUFsbDtcbnRyZWVQcm90by5yb290ID0gdHJlZV9yb290O1xudHJlZVByb3RvLnNpemUgPSB0cmVlX3NpemU7XG50cmVlUHJvdG8udmlzaXQgPSB0cmVlX3Zpc2l0O1xudHJlZVByb3RvLnZpc2l0QWZ0ZXIgPSB0cmVlX3Zpc2l0QWZ0ZXI7XG50cmVlUHJvdG8ueCA9IHRyZWVfeDtcbnRyZWVQcm90by55ID0gdHJlZV95O1xudHJlZVByb3RvLnogPSB0cmVlX3o7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkKSB7XG4gIGlmIChpc05hTih4ID0gK3RoaXMuX3guY2FsbChudWxsLCBkKSkgfHwgaXNOYU4oeSA9ICt0aGlzLl95LmNhbGwobnVsbCwgZCkpIHx8IGlzTmFOKHogPSArdGhpcy5fei5jYWxsKG51bGwsIGQpKSkgcmV0dXJuIHRoaXM7IC8vIGlnbm9yZSBpbnZhbGlkIHBvaW50c1xuXG4gIHZhciBwYXJlbnQsXG4gICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgIHJldGFpbmVyLFxuICAgICAgcHJldmlvdXMsXG4gICAgICBuZXh0LFxuICAgICAgeDAgPSB0aGlzLl94MCxcbiAgICAgIHkwID0gdGhpcy5feTAsXG4gICAgICB6MCA9IHRoaXMuX3owLFxuICAgICAgeDEgPSB0aGlzLl94MSxcbiAgICAgIHkxID0gdGhpcy5feTEsXG4gICAgICB6MSA9IHRoaXMuX3oxLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB6LFxuICAgICAgeG0sXG4gICAgICB5bSxcbiAgICAgIHptLFxuICAgICAgcmlnaHQsXG4gICAgICBib3R0b20sXG4gICAgICBkZWVwLFxuICAgICAgaSxcbiAgICAgIGo7XG5cbiAgLy8gSWYgdGhlIHRyZWUgaXMgZW1wdHksIGluaXRpYWxpemUgdGhlIHJvb3QgYXMgYSBsZWFmLlxuICBpZiAoIW5vZGUpIHJldHVybiB0aGlzO1xuXG4gIC8vIEZpbmQgdGhlIGxlYWYgbm9kZSBmb3IgdGhlIHBvaW50LlxuICAvLyBXaGlsZSBkZXNjZW5kaW5nLCBhbHNvIHJldGFpbiB0aGUgZGVlcGVzdCBwYXJlbnQgd2l0aCBhIG5vbi1yZW1vdmVkIHNpYmxpbmcuXG4gIGlmIChub2RlLmxlbmd0aCkgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAocmlnaHQgPSB4ID49ICh4bSA9ICh4MCArIHgxKSAvIDIpKSB4MCA9IHhtOyBlbHNlIHgxID0geG07XG4gICAgaWYgKGJvdHRvbSA9IHkgPj0gKHltID0gKHkwICsgeTEpIC8gMikpIHkwID0geW07IGVsc2UgeTEgPSB5bTtcbiAgICBpZiAoZGVlcCA9IHogPj0gKHptID0gKHowICsgejEpIC8gMikpIHowID0gem07IGVsc2UgejEgPSB6bTtcbiAgICBpZiAoIShwYXJlbnQgPSBub2RlLCBub2RlID0gbm9kZVtpID0gZGVlcCA8PCAyIHwgYm90dG9tIDw8IDEgfCByaWdodF0pKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIW5vZGUubGVuZ3RoKSBicmVhaztcbiAgICBpZiAocGFyZW50WyhpICsgMSkgJiA3XSB8fCBwYXJlbnRbKGkgKyAyKSAmIDddIHx8IHBhcmVudFsoaSArIDMpICYgN10gfHwgcGFyZW50WyhpICsgNCkgJiA3XSB8fCBwYXJlbnRbKGkgKyA1KSAmIDddIHx8IHBhcmVudFsoaSArIDYpICYgN10gfHwgcGFyZW50WyhpICsgNykgJiA3XSkgcmV0YWluZXIgPSBwYXJlbnQsIGogPSBpO1xuICB9XG5cbiAgLy8gRmluZCB0aGUgcG9pbnQgdG8gcmVtb3ZlLlxuICB3aGlsZSAobm9kZS5kYXRhICE9PSBkKSBpZiAoIShwcmV2aW91cyA9IG5vZGUsIG5vZGUgPSBub2RlLm5leHQpKSByZXR1cm4gdGhpcztcbiAgaWYgKG5leHQgPSBub2RlLm5leHQpIGRlbGV0ZSBub2RlLm5leHQ7XG5cbiAgLy8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNvaW5jaWRlbnQgcG9pbnRzLCByZW1vdmUganVzdCB0aGUgcG9pbnQuXG4gIGlmIChwcmV2aW91cykgcmV0dXJuIChuZXh0ID8gcHJldmlvdXMubmV4dCA9IG5leHQgOiBkZWxldGUgcHJldmlvdXMubmV4dCksIHRoaXM7XG5cbiAgLy8gSWYgdGhpcyBpcyB0aGUgcm9vdCBwb2ludCwgcmVtb3ZlIGl0LlxuICBpZiAoIXBhcmVudCkgcmV0dXJuIHRoaXMuX3Jvb3QgPSBuZXh0LCB0aGlzO1xuXG4gIC8vIFJlbW92ZSB0aGlzIGxlYWYuXG4gIG5leHQgPyBwYXJlbnRbaV0gPSBuZXh0IDogZGVsZXRlIHBhcmVudFtpXTtcblxuICAvLyBJZiB0aGUgcGFyZW50IG5vdyBjb250YWlucyBleGFjdGx5IG9uZSBsZWFmLCBjb2xsYXBzZSBzdXBlcmZsdW91cyBwYXJlbnRzLlxuICBpZiAoKG5vZGUgPSBwYXJlbnRbMF0gfHwgcGFyZW50WzFdIHx8IHBhcmVudFsyXSB8fCBwYXJlbnRbM10gfHwgcGFyZW50WzRdIHx8IHBhcmVudFs1XSB8fCBwYXJlbnRbNl0gfHwgcGFyZW50WzddKVxuICAgICAgJiYgbm9kZSA9PT0gKHBhcmVudFs3XSB8fCBwYXJlbnRbNl0gfHwgcGFyZW50WzVdIHx8IHBhcmVudFs0XSB8fCBwYXJlbnRbM10gfHwgcGFyZW50WzJdIHx8IHBhcmVudFsxXSB8fCBwYXJlbnRbMF0pXG4gICAgICAmJiAhbm9kZS5sZW5ndGgpIHtcbiAgICBpZiAocmV0YWluZXIpIHJldGFpbmVyW2pdID0gbm9kZTtcbiAgICBlbHNlIHRoaXMuX3Jvb3QgPSBub2RlO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVBbGwoZGF0YSkge1xuICBmb3IgKHZhciBpID0gMCwgbiA9IGRhdGEubGVuZ3RoOyBpIDwgbjsgKytpKSB0aGlzLnJlbW92ZShkYXRhW2ldKTtcbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX3Jvb3Q7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbigpIHtcbiAgdmFyIHNpemUgPSAwO1xuICB0aGlzLnZpc2l0KGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUubGVuZ3RoKSBkbyArK3NpemU7IHdoaWxlIChub2RlID0gbm9kZS5uZXh0KVxuICB9KTtcbiAgcmV0dXJuIHNpemU7XG59XG4iLCJpbXBvcnQgT2N0YW50IGZyb20gXCIuL29jdGFudC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgb2N0cyA9IFtdLCBxLCBub2RlID0gdGhpcy5fcm9vdCwgY2hpbGQsIHgwLCB5MCwgejAsIHgxLCB5MSwgejE7XG4gIGlmIChub2RlKSBvY3RzLnB1c2gobmV3IE9jdGFudChub2RlLCB0aGlzLl94MCwgdGhpcy5feTAsIHRoaXMuX3owLCB0aGlzLl94MSwgdGhpcy5feTEsIHRoaXMuX3oxKSk7XG4gIHdoaWxlIChxID0gb2N0cy5wb3AoKSkge1xuICAgIGlmICghY2FsbGJhY2sobm9kZSA9IHEubm9kZSwgeDAgPSBxLngwLCB5MCA9IHEueTAsIHowID0gcS56MCwgeDEgPSBxLngxLCB5MSA9IHEueTEsIHoxID0gcS56MSkgJiYgbm9kZS5sZW5ndGgpIHtcbiAgICAgIHZhciB4bSA9ICh4MCArIHgxKSAvIDIsIHltID0gKHkwICsgeTEpIC8gMiwgem0gPSAoejAgKyB6MSkgLyAyO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVs3XSkgb2N0cy5wdXNoKG5ldyBPY3RhbnQoY2hpbGQsIHhtLCB5bSwgem0sIHgxLCB5MSwgejEpKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbNl0pIG9jdHMucHVzaChuZXcgT2N0YW50KGNoaWxkLCB4MCwgeW0sIHptLCB4bSwgeTEsIHoxKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzVdKSBvY3RzLnB1c2gobmV3IE9jdGFudChjaGlsZCwgeG0sIHkwLCB6bSwgeDEsIHltLCB6MSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVs0XSkgb2N0cy5wdXNoKG5ldyBPY3RhbnQoY2hpbGQsIHgwLCB5MCwgem0sIHhtLCB5bSwgejEpKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbM10pIG9jdHMucHVzaChuZXcgT2N0YW50KGNoaWxkLCB4bSwgeW0sIHowLCB4MSwgeTEsIHptKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzJdKSBvY3RzLnB1c2gobmV3IE9jdGFudChjaGlsZCwgeDAsIHltLCB6MCwgeG0sIHkxLCB6bSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVsxXSkgb2N0cy5wdXNoKG5ldyBPY3RhbnQoY2hpbGQsIHhtLCB5MCwgejAsIHgxLCB5bSwgem0pKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMF0pIG9jdHMucHVzaChuZXcgT2N0YW50KGNoaWxkLCB4MCwgeTAsIHowLCB4bSwgeW0sIHptKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0aGlzO1xufVxuIiwiaW1wb3J0IE9jdGFudCBmcm9tIFwiLi9vY3RhbnQuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgdmFyIG9jdHMgPSBbXSwgbmV4dCA9IFtdLCBxO1xuICBpZiAodGhpcy5fcm9vdCkgb2N0cy5wdXNoKG5ldyBPY3RhbnQodGhpcy5fcm9vdCwgdGhpcy5feDAsIHRoaXMuX3kwLCB0aGlzLl96MCwgdGhpcy5feDEsIHRoaXMuX3kxLCB0aGlzLl96MSkpO1xuICB3aGlsZSAocSA9IG9jdHMucG9wKCkpIHtcbiAgICB2YXIgbm9kZSA9IHEubm9kZTtcbiAgICBpZiAobm9kZS5sZW5ndGgpIHtcbiAgICAgIHZhciBjaGlsZCwgeDAgPSBxLngwLCB5MCA9IHEueTAsIHowID0gcS56MCwgeDEgPSBxLngxLCB5MSA9IHEueTEsIHoxID0gcS56MSwgeG0gPSAoeDAgKyB4MSkgLyAyLCB5bSA9ICh5MCArIHkxKSAvIDIsIHptID0gKHowICsgejEpIC8gMjtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMF0pIG9jdHMucHVzaChuZXcgT2N0YW50KGNoaWxkLCB4MCwgeTAsIHowLCB4bSwgeW0sIHptKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzFdKSBvY3RzLnB1c2gobmV3IE9jdGFudChjaGlsZCwgeG0sIHkwLCB6MCwgeDEsIHltLCB6bSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVsyXSkgb2N0cy5wdXNoKG5ldyBPY3RhbnQoY2hpbGQsIHgwLCB5bSwgejAsIHhtLCB5MSwgem0pKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbM10pIG9jdHMucHVzaChuZXcgT2N0YW50KGNoaWxkLCB4bSwgeW0sIHowLCB4MSwgeTEsIHptKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzRdKSBvY3RzLnB1c2gobmV3IE9jdGFudChjaGlsZCwgeDAsIHkwLCB6bSwgeG0sIHltLCB6MSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVs1XSkgb2N0cy5wdXNoKG5ldyBPY3RhbnQoY2hpbGQsIHhtLCB5MCwgem0sIHgxLCB5bSwgejEpKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbNl0pIG9jdHMucHVzaChuZXcgT2N0YW50KGNoaWxkLCB4MCwgeW0sIHptLCB4bSwgeTEsIHoxKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzddKSBvY3RzLnB1c2gobmV3IE9jdGFudChjaGlsZCwgeG0sIHltLCB6bSwgeDEsIHkxLCB6MSkpO1xuICAgIH1cbiAgICBuZXh0LnB1c2gocSk7XG4gIH1cbiAgd2hpbGUgKHEgPSBuZXh0LnBvcCgpKSB7XG4gICAgY2FsbGJhY2socS5ub2RlLCBxLngwLCBxLnkwLCBxLnowLCBxLngxLCBxLnkxLCBxLnoxKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0WChkKSB7XG4gIHJldHVybiBkWzBdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihfKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRoaXMuX3ggPSBfLCB0aGlzKSA6IHRoaXMuX3g7XG59XG4iLCJleHBvcnQgZnVuY3Rpb24gZGVmYXVsdFkoZCkge1xuICByZXR1cm4gZFsxXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oXykge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh0aGlzLl95ID0gXywgdGhpcykgOiB0aGlzLl95O1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRaKGQpIHtcbiAgcmV0dXJuIGRbMl07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKF8pIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGhpcy5feiA9IF8sIHRoaXMpIDogdGhpcy5fejtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGQpIHtcbiAgY29uc3QgeCA9ICt0aGlzLl94LmNhbGwobnVsbCwgZCksXG4gICAgICB5ID0gK3RoaXMuX3kuY2FsbChudWxsLCBkKTtcbiAgcmV0dXJuIGFkZCh0aGlzLmNvdmVyKHgsIHkpLCB4LCB5LCBkKTtcbn1cblxuZnVuY3Rpb24gYWRkKHRyZWUsIHgsIHksIGQpIHtcbiAgaWYgKGlzTmFOKHgpIHx8IGlzTmFOKHkpKSByZXR1cm4gdHJlZTsgLy8gaWdub3JlIGludmFsaWQgcG9pbnRzXG5cbiAgdmFyIHBhcmVudCxcbiAgICAgIG5vZGUgPSB0cmVlLl9yb290LFxuICAgICAgbGVhZiA9IHtkYXRhOiBkfSxcbiAgICAgIHgwID0gdHJlZS5feDAsXG4gICAgICB5MCA9IHRyZWUuX3kwLFxuICAgICAgeDEgPSB0cmVlLl94MSxcbiAgICAgIHkxID0gdHJlZS5feTEsXG4gICAgICB4bSxcbiAgICAgIHltLFxuICAgICAgeHAsXG4gICAgICB5cCxcbiAgICAgIHJpZ2h0LFxuICAgICAgYm90dG9tLFxuICAgICAgaSxcbiAgICAgIGo7XG5cbiAgLy8gSWYgdGhlIHRyZWUgaXMgZW1wdHksIGluaXRpYWxpemUgdGhlIHJvb3QgYXMgYSBsZWFmLlxuICBpZiAoIW5vZGUpIHJldHVybiB0cmVlLl9yb290ID0gbGVhZiwgdHJlZTtcblxuICAvLyBGaW5kIHRoZSBleGlzdGluZyBsZWFmIGZvciB0aGUgbmV3IHBvaW50LCBvciBhZGQgaXQuXG4gIHdoaWxlIChub2RlLmxlbmd0aCkge1xuICAgIGlmIChyaWdodCA9IHggPj0gKHhtID0gKHgwICsgeDEpIC8gMikpIHgwID0geG07IGVsc2UgeDEgPSB4bTtcbiAgICBpZiAoYm90dG9tID0geSA+PSAoeW0gPSAoeTAgKyB5MSkgLyAyKSkgeTAgPSB5bTsgZWxzZSB5MSA9IHltO1xuICAgIGlmIChwYXJlbnQgPSBub2RlLCAhKG5vZGUgPSBub2RlW2kgPSBib3R0b20gPDwgMSB8IHJpZ2h0XSkpIHJldHVybiBwYXJlbnRbaV0gPSBsZWFmLCB0cmVlO1xuICB9XG5cbiAgLy8gSXMgdGhlIG5ldyBwb2ludCBpcyBleGFjdGx5IGNvaW5jaWRlbnQgd2l0aCB0aGUgZXhpc3RpbmcgcG9pbnQ/XG4gIHhwID0gK3RyZWUuX3guY2FsbChudWxsLCBub2RlLmRhdGEpO1xuICB5cCA9ICt0cmVlLl95LmNhbGwobnVsbCwgbm9kZS5kYXRhKTtcbiAgaWYgKHggPT09IHhwICYmIHkgPT09IHlwKSByZXR1cm4gbGVhZi5uZXh0ID0gbm9kZSwgcGFyZW50ID8gcGFyZW50W2ldID0gbGVhZiA6IHRyZWUuX3Jvb3QgPSBsZWFmLCB0cmVlO1xuXG4gIC8vIE90aGVyd2lzZSwgc3BsaXQgdGhlIGxlYWYgbm9kZSB1bnRpbCB0aGUgb2xkIGFuZCBuZXcgcG9pbnQgYXJlIHNlcGFyYXRlZC5cbiAgZG8ge1xuICAgIHBhcmVudCA9IHBhcmVudCA/IHBhcmVudFtpXSA9IG5ldyBBcnJheSg0KSA6IHRyZWUuX3Jvb3QgPSBuZXcgQXJyYXkoNCk7XG4gICAgaWYgKHJpZ2h0ID0geCA+PSAoeG0gPSAoeDAgKyB4MSkgLyAyKSkgeDAgPSB4bTsgZWxzZSB4MSA9IHhtO1xuICAgIGlmIChib3R0b20gPSB5ID49ICh5bSA9ICh5MCArIHkxKSAvIDIpKSB5MCA9IHltOyBlbHNlIHkxID0geW07XG4gIH0gd2hpbGUgKChpID0gYm90dG9tIDw8IDEgfCByaWdodCkgPT09IChqID0gKHlwID49IHltKSA8PCAxIHwgKHhwID49IHhtKSkpO1xuICByZXR1cm4gcGFyZW50W2pdID0gbm9kZSwgcGFyZW50W2ldID0gbGVhZiwgdHJlZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEFsbChkYXRhKSB7XG4gIHZhciBkLCBpLCBuID0gZGF0YS5sZW5ndGgsXG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHh6ID0gbmV3IEFycmF5KG4pLFxuICAgICAgeXogPSBuZXcgQXJyYXkobiksXG4gICAgICB4MCA9IEluZmluaXR5LFxuICAgICAgeTAgPSBJbmZpbml0eSxcbiAgICAgIHgxID0gLUluZmluaXR5LFxuICAgICAgeTEgPSAtSW5maW5pdHk7XG5cbiAgLy8gQ29tcHV0ZSB0aGUgcG9pbnRzIGFuZCB0aGVpciBleHRlbnQuXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoaXNOYU4oeCA9ICt0aGlzLl94LmNhbGwobnVsbCwgZCA9IGRhdGFbaV0pKSB8fCBpc05hTih5ID0gK3RoaXMuX3kuY2FsbChudWxsLCBkKSkpIGNvbnRpbnVlO1xuICAgIHh6W2ldID0geDtcbiAgICB5eltpXSA9IHk7XG4gICAgaWYgKHggPCB4MCkgeDAgPSB4O1xuICAgIGlmICh4ID4geDEpIHgxID0geDtcbiAgICBpZiAoeSA8IHkwKSB5MCA9IHk7XG4gICAgaWYgKHkgPiB5MSkgeTEgPSB5O1xuICB9XG5cbiAgLy8gSWYgdGhlcmUgd2VyZSBubyAodmFsaWQpIHBvaW50cywgYWJvcnQuXG4gIGlmICh4MCA+IHgxIHx8IHkwID4geTEpIHJldHVybiB0aGlzO1xuXG4gIC8vIEV4cGFuZCB0aGUgdHJlZSB0byBjb3ZlciB0aGUgbmV3IHBvaW50cy5cbiAgdGhpcy5jb3Zlcih4MCwgeTApLmNvdmVyKHgxLCB5MSk7XG5cbiAgLy8gQWRkIHRoZSBuZXcgcG9pbnRzLlxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgYWRkKHRoaXMsIHh6W2ldLCB5eltpXSwgZGF0YVtpXSk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgsIHkpIHtcbiAgaWYgKGlzTmFOKHggPSAreCkgfHwgaXNOYU4oeSA9ICt5KSkgcmV0dXJuIHRoaXM7IC8vIGlnbm9yZSBpbnZhbGlkIHBvaW50c1xuXG4gIHZhciB4MCA9IHRoaXMuX3gwLFxuICAgICAgeTAgPSB0aGlzLl95MCxcbiAgICAgIHgxID0gdGhpcy5feDEsXG4gICAgICB5MSA9IHRoaXMuX3kxO1xuXG4gIC8vIElmIHRoZSBxdWFkdHJlZSBoYXMgbm8gZXh0ZW50LCBpbml0aWFsaXplIHRoZW0uXG4gIC8vIEludGVnZXIgZXh0ZW50IGFyZSBuZWNlc3Nhcnkgc28gdGhhdCBpZiB3ZSBsYXRlciBkb3VibGUgdGhlIGV4dGVudCxcbiAgLy8gdGhlIGV4aXN0aW5nIHF1YWRyYW50IGJvdW5kYXJpZXMgZG9u4oCZdCBjaGFuZ2UgZHVlIHRvIGZsb2F0aW5nIHBvaW50IGVycm9yIVxuICBpZiAoaXNOYU4oeDApKSB7XG4gICAgeDEgPSAoeDAgPSBNYXRoLmZsb29yKHgpKSArIDE7XG4gICAgeTEgPSAoeTAgPSBNYXRoLmZsb29yKHkpKSArIDE7XG4gIH1cblxuICAvLyBPdGhlcndpc2UsIGRvdWJsZSByZXBlYXRlZGx5IHRvIGNvdmVyLlxuICBlbHNlIHtcbiAgICB2YXIgeiA9IHgxIC0geDAgfHwgMSxcbiAgICAgICAgbm9kZSA9IHRoaXMuX3Jvb3QsXG4gICAgICAgIHBhcmVudCxcbiAgICAgICAgaTtcblxuICAgIHdoaWxlICh4MCA+IHggfHwgeCA+PSB4MSB8fCB5MCA+IHkgfHwgeSA+PSB5MSkge1xuICAgICAgaSA9ICh5IDwgeTApIDw8IDEgfCAoeCA8IHgwKTtcbiAgICAgIHBhcmVudCA9IG5ldyBBcnJheSg0KSwgcGFyZW50W2ldID0gbm9kZSwgbm9kZSA9IHBhcmVudCwgeiAqPSAyO1xuICAgICAgc3dpdGNoIChpKSB7XG4gICAgICAgIGNhc2UgMDogeDEgPSB4MCArIHosIHkxID0geTAgKyB6OyBicmVhaztcbiAgICAgICAgY2FzZSAxOiB4MCA9IHgxIC0geiwgeTEgPSB5MCArIHo7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IHgxID0geDAgKyB6LCB5MCA9IHkxIC0gejsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogeDAgPSB4MSAtIHosIHkwID0geTEgLSB6OyBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcm9vdCAmJiB0aGlzLl9yb290Lmxlbmd0aCkgdGhpcy5fcm9vdCA9IG5vZGU7XG4gIH1cblxuICB0aGlzLl94MCA9IHgwO1xuICB0aGlzLl95MCA9IHkwO1xuICB0aGlzLl94MSA9IHgxO1xuICB0aGlzLl95MSA9IHkxO1xuICByZXR1cm4gdGhpcztcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICB2YXIgZGF0YSA9IFtdO1xuICB0aGlzLnZpc2l0KGZ1bmN0aW9uKG5vZGUpIHtcbiAgICBpZiAoIW5vZGUubGVuZ3RoKSBkbyBkYXRhLnB1c2gobm9kZS5kYXRhKTsgd2hpbGUgKG5vZGUgPSBub2RlLm5leHQpXG4gIH0pO1xuICByZXR1cm4gZGF0YTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKF8pIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGhcbiAgICAgID8gdGhpcy5jb3ZlcigrX1swXVswXSwgK19bMF1bMV0pLmNvdmVyKCtfWzFdWzBdLCArX1sxXVsxXSlcbiAgICAgIDogaXNOYU4odGhpcy5feDApID8gdW5kZWZpbmVkIDogW1t0aGlzLl94MCwgdGhpcy5feTBdLCBbdGhpcy5feDEsIHRoaXMuX3kxXV07XG59XG4iLCJpbXBvcnQgUXVhZCBmcm9tIFwiLi9xdWFkLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgsIHksIHJhZGl1cykge1xuICB2YXIgZGF0YSxcbiAgICAgIHgwID0gdGhpcy5feDAsXG4gICAgICB5MCA9IHRoaXMuX3kwLFxuICAgICAgeDEsXG4gICAgICB5MSxcbiAgICAgIHgyLFxuICAgICAgeTIsXG4gICAgICB4MyA9IHRoaXMuX3gxLFxuICAgICAgeTMgPSB0aGlzLl95MSxcbiAgICAgIHF1YWRzID0gW10sXG4gICAgICBub2RlID0gdGhpcy5fcm9vdCxcbiAgICAgIHEsXG4gICAgICBpO1xuXG4gIGlmIChub2RlKSBxdWFkcy5wdXNoKG5ldyBRdWFkKG5vZGUsIHgwLCB5MCwgeDMsIHkzKSk7XG4gIGlmIChyYWRpdXMgPT0gbnVsbCkgcmFkaXVzID0gSW5maW5pdHk7XG4gIGVsc2Uge1xuICAgIHgwID0geCAtIHJhZGl1cywgeTAgPSB5IC0gcmFkaXVzO1xuICAgIHgzID0geCArIHJhZGl1cywgeTMgPSB5ICsgcmFkaXVzO1xuICAgIHJhZGl1cyAqPSByYWRpdXM7XG4gIH1cblxuICB3aGlsZSAocSA9IHF1YWRzLnBvcCgpKSB7XG5cbiAgICAvLyBTdG9wIHNlYXJjaGluZyBpZiB0aGlzIHF1YWRyYW50IGNhbuKAmXQgY29udGFpbiBhIGNsb3NlciBub2RlLlxuICAgIGlmICghKG5vZGUgPSBxLm5vZGUpXG4gICAgICAgIHx8ICh4MSA9IHEueDApID4geDNcbiAgICAgICAgfHwgKHkxID0gcS55MCkgPiB5M1xuICAgICAgICB8fCAoeDIgPSBxLngxKSA8IHgwXG4gICAgICAgIHx8ICh5MiA9IHEueTEpIDwgeTApIGNvbnRpbnVlO1xuXG4gICAgLy8gQmlzZWN0IHRoZSBjdXJyZW50IHF1YWRyYW50LlxuICAgIGlmIChub2RlLmxlbmd0aCkge1xuICAgICAgdmFyIHhtID0gKHgxICsgeDIpIC8gMixcbiAgICAgICAgICB5bSA9ICh5MSArIHkyKSAvIDI7XG5cbiAgICAgIHF1YWRzLnB1c2goXG4gICAgICAgIG5ldyBRdWFkKG5vZGVbM10sIHhtLCB5bSwgeDIsIHkyKSxcbiAgICAgICAgbmV3IFF1YWQobm9kZVsyXSwgeDEsIHltLCB4bSwgeTIpLFxuICAgICAgICBuZXcgUXVhZChub2RlWzFdLCB4bSwgeTEsIHgyLCB5bSksXG4gICAgICAgIG5ldyBRdWFkKG5vZGVbMF0sIHgxLCB5MSwgeG0sIHltKVxuICAgICAgKTtcblxuICAgICAgLy8gVmlzaXQgdGhlIGNsb3Nlc3QgcXVhZHJhbnQgZmlyc3QuXG4gICAgICBpZiAoaSA9ICh5ID49IHltKSA8PCAxIHwgKHggPj0geG0pKSB7XG4gICAgICAgIHEgPSBxdWFkc1txdWFkcy5sZW5ndGggLSAxXTtcbiAgICAgICAgcXVhZHNbcXVhZHMubGVuZ3RoIC0gMV0gPSBxdWFkc1txdWFkcy5sZW5ndGggLSAxIC0gaV07XG4gICAgICAgIHF1YWRzW3F1YWRzLmxlbmd0aCAtIDEgLSBpXSA9IHE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVmlzaXQgdGhpcyBwb2ludC4gKFZpc2l0aW5nIGNvaW5jaWRlbnQgcG9pbnRzIGlzbuKAmXQgbmVjZXNzYXJ5ISlcbiAgICBlbHNlIHtcbiAgICAgIHZhciBkeCA9IHggLSArdGhpcy5feC5jYWxsKG51bGwsIG5vZGUuZGF0YSksXG4gICAgICAgICAgZHkgPSB5IC0gK3RoaXMuX3kuY2FsbChudWxsLCBub2RlLmRhdGEpLFxuICAgICAgICAgIGQyID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICBpZiAoZDIgPCByYWRpdXMpIHtcbiAgICAgICAgdmFyIGQgPSBNYXRoLnNxcnQocmFkaXVzID0gZDIpO1xuICAgICAgICB4MCA9IHggLSBkLCB5MCA9IHkgLSBkO1xuICAgICAgICB4MyA9IHggKyBkLCB5MyA9IHkgKyBkO1xuICAgICAgICBkYXRhID0gbm9kZS5kYXRhO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24obm9kZSwgeDAsIHkwLCB4MSwgeTEpIHtcbiAgdGhpcy5ub2RlID0gbm9kZTtcbiAgdGhpcy54MCA9IHgwO1xuICB0aGlzLnkwID0geTA7XG4gIHRoaXMueDEgPSB4MTtcbiAgdGhpcy55MSA9IHkxO1xufVxuIiwiaW1wb3J0IHRyZWVfYWRkLCB7YWRkQWxsIGFzIHRyZWVfYWRkQWxsfSBmcm9tIFwiLi9hZGQuanNcIjtcbmltcG9ydCB0cmVlX2NvdmVyIGZyb20gXCIuL2NvdmVyLmpzXCI7XG5pbXBvcnQgdHJlZV9kYXRhIGZyb20gXCIuL2RhdGEuanNcIjtcbmltcG9ydCB0cmVlX2V4dGVudCBmcm9tIFwiLi9leHRlbnQuanNcIjtcbmltcG9ydCB0cmVlX2ZpbmQgZnJvbSBcIi4vZmluZC5qc1wiO1xuaW1wb3J0IHRyZWVfcmVtb3ZlLCB7cmVtb3ZlQWxsIGFzIHRyZWVfcmVtb3ZlQWxsfSBmcm9tIFwiLi9yZW1vdmUuanNcIjtcbmltcG9ydCB0cmVlX3Jvb3QgZnJvbSBcIi4vcm9vdC5qc1wiO1xuaW1wb3J0IHRyZWVfc2l6ZSBmcm9tIFwiLi9zaXplLmpzXCI7XG5pbXBvcnQgdHJlZV92aXNpdCBmcm9tIFwiLi92aXNpdC5qc1wiO1xuaW1wb3J0IHRyZWVfdmlzaXRBZnRlciBmcm9tIFwiLi92aXNpdEFmdGVyLmpzXCI7XG5pbXBvcnQgdHJlZV94LCB7ZGVmYXVsdFh9IGZyb20gXCIuL3guanNcIjtcbmltcG9ydCB0cmVlX3ksIHtkZWZhdWx0WX0gZnJvbSBcIi4veS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBxdWFkdHJlZShub2RlcywgeCwgeSkge1xuICB2YXIgdHJlZSA9IG5ldyBRdWFkdHJlZSh4ID09IG51bGwgPyBkZWZhdWx0WCA6IHgsIHkgPT0gbnVsbCA/IGRlZmF1bHRZIDogeSwgTmFOLCBOYU4sIE5hTiwgTmFOKTtcbiAgcmV0dXJuIG5vZGVzID09IG51bGwgPyB0cmVlIDogdHJlZS5hZGRBbGwobm9kZXMpO1xufVxuXG5mdW5jdGlvbiBRdWFkdHJlZSh4LCB5LCB4MCwgeTAsIHgxLCB5MSkge1xuICB0aGlzLl94ID0geDtcbiAgdGhpcy5feSA9IHk7XG4gIHRoaXMuX3gwID0geDA7XG4gIHRoaXMuX3kwID0geTA7XG4gIHRoaXMuX3gxID0geDE7XG4gIHRoaXMuX3kxID0geTE7XG4gIHRoaXMuX3Jvb3QgPSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGxlYWZfY29weShsZWFmKSB7XG4gIHZhciBjb3B5ID0ge2RhdGE6IGxlYWYuZGF0YX0sIG5leHQgPSBjb3B5O1xuICB3aGlsZSAobGVhZiA9IGxlYWYubmV4dCkgbmV4dCA9IG5leHQubmV4dCA9IHtkYXRhOiBsZWFmLmRhdGF9O1xuICByZXR1cm4gY29weTtcbn1cblxudmFyIHRyZWVQcm90byA9IHF1YWR0cmVlLnByb3RvdHlwZSA9IFF1YWR0cmVlLnByb3RvdHlwZTtcblxudHJlZVByb3RvLmNvcHkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGNvcHkgPSBuZXcgUXVhZHRyZWUodGhpcy5feCwgdGhpcy5feSwgdGhpcy5feDAsIHRoaXMuX3kwLCB0aGlzLl94MSwgdGhpcy5feTEpLFxuICAgICAgbm9kZSA9IHRoaXMuX3Jvb3QsXG4gICAgICBub2RlcyxcbiAgICAgIGNoaWxkO1xuXG4gIGlmICghbm9kZSkgcmV0dXJuIGNvcHk7XG5cbiAgaWYgKCFub2RlLmxlbmd0aCkgcmV0dXJuIGNvcHkuX3Jvb3QgPSBsZWFmX2NvcHkobm9kZSksIGNvcHk7XG5cbiAgbm9kZXMgPSBbe3NvdXJjZTogbm9kZSwgdGFyZ2V0OiBjb3B5Ll9yb290ID0gbmV3IEFycmF5KDQpfV07XG4gIHdoaWxlIChub2RlID0gbm9kZXMucG9wKCkpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7ICsraSkge1xuICAgICAgaWYgKGNoaWxkID0gbm9kZS5zb3VyY2VbaV0pIHtcbiAgICAgICAgaWYgKGNoaWxkLmxlbmd0aCkgbm9kZXMucHVzaCh7c291cmNlOiBjaGlsZCwgdGFyZ2V0OiBub2RlLnRhcmdldFtpXSA9IG5ldyBBcnJheSg0KX0pO1xuICAgICAgICBlbHNlIG5vZGUudGFyZ2V0W2ldID0gbGVhZl9jb3B5KGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29weTtcbn07XG5cbnRyZWVQcm90by5hZGQgPSB0cmVlX2FkZDtcbnRyZWVQcm90by5hZGRBbGwgPSB0cmVlX2FkZEFsbDtcbnRyZWVQcm90by5jb3ZlciA9IHRyZWVfY292ZXI7XG50cmVlUHJvdG8uZGF0YSA9IHRyZWVfZGF0YTtcbnRyZWVQcm90by5leHRlbnQgPSB0cmVlX2V4dGVudDtcbnRyZWVQcm90by5maW5kID0gdHJlZV9maW5kO1xudHJlZVByb3RvLnJlbW92ZSA9IHRyZWVfcmVtb3ZlO1xudHJlZVByb3RvLnJlbW92ZUFsbCA9IHRyZWVfcmVtb3ZlQWxsO1xudHJlZVByb3RvLnJvb3QgPSB0cmVlX3Jvb3Q7XG50cmVlUHJvdG8uc2l6ZSA9IHRyZWVfc2l6ZTtcbnRyZWVQcm90by52aXNpdCA9IHRyZWVfdmlzaXQ7XG50cmVlUHJvdG8udmlzaXRBZnRlciA9IHRyZWVfdmlzaXRBZnRlcjtcbnRyZWVQcm90by54ID0gdHJlZV94O1xudHJlZVByb3RvLnkgPSB0cmVlX3k7XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihkKSB7XG4gIGlmIChpc05hTih4ID0gK3RoaXMuX3guY2FsbChudWxsLCBkKSkgfHwgaXNOYU4oeSA9ICt0aGlzLl95LmNhbGwobnVsbCwgZCkpKSByZXR1cm4gdGhpczsgLy8gaWdub3JlIGludmFsaWQgcG9pbnRzXG5cbiAgdmFyIHBhcmVudCxcbiAgICAgIG5vZGUgPSB0aGlzLl9yb290LFxuICAgICAgcmV0YWluZXIsXG4gICAgICBwcmV2aW91cyxcbiAgICAgIG5leHQsXG4gICAgICB4MCA9IHRoaXMuX3gwLFxuICAgICAgeTAgPSB0aGlzLl95MCxcbiAgICAgIHgxID0gdGhpcy5feDEsXG4gICAgICB5MSA9IHRoaXMuX3kxLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB4bSxcbiAgICAgIHltLFxuICAgICAgcmlnaHQsXG4gICAgICBib3R0b20sXG4gICAgICBpLFxuICAgICAgajtcblxuICAvLyBJZiB0aGUgdHJlZSBpcyBlbXB0eSwgaW5pdGlhbGl6ZSB0aGUgcm9vdCBhcyBhIGxlYWYuXG4gIGlmICghbm9kZSkgcmV0dXJuIHRoaXM7XG5cbiAgLy8gRmluZCB0aGUgbGVhZiBub2RlIGZvciB0aGUgcG9pbnQuXG4gIC8vIFdoaWxlIGRlc2NlbmRpbmcsIGFsc28gcmV0YWluIHRoZSBkZWVwZXN0IHBhcmVudCB3aXRoIGEgbm9uLXJlbW92ZWQgc2libGluZy5cbiAgaWYgKG5vZGUubGVuZ3RoKSB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChyaWdodCA9IHggPj0gKHhtID0gKHgwICsgeDEpIC8gMikpIHgwID0geG07IGVsc2UgeDEgPSB4bTtcbiAgICBpZiAoYm90dG9tID0geSA+PSAoeW0gPSAoeTAgKyB5MSkgLyAyKSkgeTAgPSB5bTsgZWxzZSB5MSA9IHltO1xuICAgIGlmICghKHBhcmVudCA9IG5vZGUsIG5vZGUgPSBub2RlW2kgPSBib3R0b20gPDwgMSB8IHJpZ2h0XSkpIHJldHVybiB0aGlzO1xuICAgIGlmICghbm9kZS5sZW5ndGgpIGJyZWFrO1xuICAgIGlmIChwYXJlbnRbKGkgKyAxKSAmIDNdIHx8IHBhcmVudFsoaSArIDIpICYgM10gfHwgcGFyZW50WyhpICsgMykgJiAzXSkgcmV0YWluZXIgPSBwYXJlbnQsIGogPSBpO1xuICB9XG5cbiAgLy8gRmluZCB0aGUgcG9pbnQgdG8gcmVtb3ZlLlxuICB3aGlsZSAobm9kZS5kYXRhICE9PSBkKSBpZiAoIShwcmV2aW91cyA9IG5vZGUsIG5vZGUgPSBub2RlLm5leHQpKSByZXR1cm4gdGhpcztcbiAgaWYgKG5leHQgPSBub2RlLm5leHQpIGRlbGV0ZSBub2RlLm5leHQ7XG5cbiAgLy8gSWYgdGhlcmUgYXJlIG11bHRpcGxlIGNvaW5jaWRlbnQgcG9pbnRzLCByZW1vdmUganVzdCB0aGUgcG9pbnQuXG4gIGlmIChwcmV2aW91cykgcmV0dXJuIChuZXh0ID8gcHJldmlvdXMubmV4dCA9IG5leHQgOiBkZWxldGUgcHJldmlvdXMubmV4dCksIHRoaXM7XG5cbiAgLy8gSWYgdGhpcyBpcyB0aGUgcm9vdCBwb2ludCwgcmVtb3ZlIGl0LlxuICBpZiAoIXBhcmVudCkgcmV0dXJuIHRoaXMuX3Jvb3QgPSBuZXh0LCB0aGlzO1xuXG4gIC8vIFJlbW92ZSB0aGlzIGxlYWYuXG4gIG5leHQgPyBwYXJlbnRbaV0gPSBuZXh0IDogZGVsZXRlIHBhcmVudFtpXTtcblxuICAvLyBJZiB0aGUgcGFyZW50IG5vdyBjb250YWlucyBleGFjdGx5IG9uZSBsZWFmLCBjb2xsYXBzZSBzdXBlcmZsdW91cyBwYXJlbnRzLlxuICBpZiAoKG5vZGUgPSBwYXJlbnRbMF0gfHwgcGFyZW50WzFdIHx8IHBhcmVudFsyXSB8fCBwYXJlbnRbM10pXG4gICAgICAmJiBub2RlID09PSAocGFyZW50WzNdIHx8IHBhcmVudFsyXSB8fCBwYXJlbnRbMV0gfHwgcGFyZW50WzBdKVxuICAgICAgJiYgIW5vZGUubGVuZ3RoKSB7XG4gICAgaWYgKHJldGFpbmVyKSByZXRhaW5lcltqXSA9IG5vZGU7XG4gICAgZWxzZSB0aGlzLl9yb290ID0gbm9kZTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQWxsKGRhdGEpIHtcbiAgZm9yICh2YXIgaSA9IDAsIG4gPSBkYXRhLmxlbmd0aDsgaSA8IG47ICsraSkgdGhpcy5yZW1vdmUoZGF0YVtpXSk7XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9yb290O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gIHZhciBzaXplID0gMDtcbiAgdGhpcy52aXNpdChmdW5jdGlvbihub2RlKSB7XG4gICAgaWYgKCFub2RlLmxlbmd0aCkgZG8gKytzaXplOyB3aGlsZSAobm9kZSA9IG5vZGUubmV4dClcbiAgfSk7XG4gIHJldHVybiBzaXplO1xufVxuIiwiaW1wb3J0IFF1YWQgZnJvbSBcIi4vcXVhZC5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihjYWxsYmFjaykge1xuICB2YXIgcXVhZHMgPSBbXSwgcSwgbm9kZSA9IHRoaXMuX3Jvb3QsIGNoaWxkLCB4MCwgeTAsIHgxLCB5MTtcbiAgaWYgKG5vZGUpIHF1YWRzLnB1c2gobmV3IFF1YWQobm9kZSwgdGhpcy5feDAsIHRoaXMuX3kwLCB0aGlzLl94MSwgdGhpcy5feTEpKTtcbiAgd2hpbGUgKHEgPSBxdWFkcy5wb3AoKSkge1xuICAgIGlmICghY2FsbGJhY2sobm9kZSA9IHEubm9kZSwgeDAgPSBxLngwLCB5MCA9IHEueTAsIHgxID0gcS54MSwgeTEgPSBxLnkxKSAmJiBub2RlLmxlbmd0aCkge1xuICAgICAgdmFyIHhtID0gKHgwICsgeDEpIC8gMiwgeW0gPSAoeTAgKyB5MSkgLyAyO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVszXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeG0sIHltLCB4MSwgeTEpKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMl0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHgwLCB5bSwgeG0sIHkxKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzFdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4bSwgeTAsIHgxLCB5bSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVswXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHkwLCB4bSwgeW0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG4iLCJpbXBvcnQgUXVhZCBmcm9tIFwiLi9xdWFkLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gIHZhciBxdWFkcyA9IFtdLCBuZXh0ID0gW10sIHE7XG4gIGlmICh0aGlzLl9yb290KSBxdWFkcy5wdXNoKG5ldyBRdWFkKHRoaXMuX3Jvb3QsIHRoaXMuX3gwLCB0aGlzLl95MCwgdGhpcy5feDEsIHRoaXMuX3kxKSk7XG4gIHdoaWxlIChxID0gcXVhZHMucG9wKCkpIHtcbiAgICB2YXIgbm9kZSA9IHEubm9kZTtcbiAgICBpZiAobm9kZS5sZW5ndGgpIHtcbiAgICAgIHZhciBjaGlsZCwgeDAgPSBxLngwLCB5MCA9IHEueTAsIHgxID0gcS54MSwgeTEgPSBxLnkxLCB4bSA9ICh4MCArIHgxKSAvIDIsIHltID0gKHkwICsgeTEpIC8gMjtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbMF0pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHgwLCB5MCwgeG0sIHltKSk7XG4gICAgICBpZiAoY2hpbGQgPSBub2RlWzFdKSBxdWFkcy5wdXNoKG5ldyBRdWFkKGNoaWxkLCB4bSwgeTAsIHgxLCB5bSkpO1xuICAgICAgaWYgKGNoaWxkID0gbm9kZVsyXSkgcXVhZHMucHVzaChuZXcgUXVhZChjaGlsZCwgeDAsIHltLCB4bSwgeTEpKTtcbiAgICAgIGlmIChjaGlsZCA9IG5vZGVbM10pIHF1YWRzLnB1c2gobmV3IFF1YWQoY2hpbGQsIHhtLCB5bSwgeDEsIHkxKSk7XG4gICAgfVxuICAgIG5leHQucHVzaChxKTtcbiAgfVxuICB3aGlsZSAocSA9IG5leHQucG9wKCkpIHtcbiAgICBjYWxsYmFjayhxLm5vZGUsIHEueDAsIHEueTAsIHEueDEsIHEueTEpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRYKGQpIHtcbiAgcmV0dXJuIGRbMF07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKF8pIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAodGhpcy5feCA9IF8sIHRoaXMpIDogdGhpcy5feDtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0WShkKSB7XG4gIHJldHVybiBkWzFdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihfKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gKHRoaXMuX3kgPSBfLCB0aGlzKSA6IHRoaXMuX3k7XG59XG4iLCJ2YXIgZnJhbWUgPSAwLCAvLyBpcyBhbiBhbmltYXRpb24gZnJhbWUgcGVuZGluZz9cbiAgICB0aW1lb3V0ID0gMCwgLy8gaXMgYSB0aW1lb3V0IHBlbmRpbmc/XG4gICAgaW50ZXJ2YWwgPSAwLCAvLyBhcmUgYW55IHRpbWVycyBhY3RpdmU/XG4gICAgcG9rZURlbGF5ID0gMTAwMCwgLy8gaG93IGZyZXF1ZW50bHkgd2UgY2hlY2sgZm9yIGNsb2NrIHNrZXdcbiAgICB0YXNrSGVhZCxcbiAgICB0YXNrVGFpbCxcbiAgICBjbG9ja0xhc3QgPSAwLFxuICAgIGNsb2NrTm93ID0gMCxcbiAgICBjbG9ja1NrZXcgPSAwLFxuICAgIGNsb2NrID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSBcIm9iamVjdFwiICYmIHBlcmZvcm1hbmNlLm5vdyA/IHBlcmZvcm1hbmNlIDogRGF0ZSxcbiAgICBzZXRGcmFtZSA9IHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpIDogZnVuY3Rpb24oZikgeyBzZXRUaW1lb3V0KGYsIDE3KTsgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIG5vdygpIHtcbiAgcmV0dXJuIGNsb2NrTm93IHx8IChzZXRGcmFtZShjbGVhck5vdyksIGNsb2NrTm93ID0gY2xvY2subm93KCkgKyBjbG9ja1NrZXcpO1xufVxuXG5mdW5jdGlvbiBjbGVhck5vdygpIHtcbiAgY2xvY2tOb3cgPSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gVGltZXIoKSB7XG4gIHRoaXMuX2NhbGwgPVxuICB0aGlzLl90aW1lID1cbiAgdGhpcy5fbmV4dCA9IG51bGw7XG59XG5cblRpbWVyLnByb3RvdHlwZSA9IHRpbWVyLnByb3RvdHlwZSA9IHtcbiAgY29uc3RydWN0b3I6IFRpbWVyLFxuICByZXN0YXJ0OiBmdW5jdGlvbihjYWxsYmFjaywgZGVsYXksIHRpbWUpIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYWxsYmFjayBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICB0aW1lID0gKHRpbWUgPT0gbnVsbCA/IG5vdygpIDogK3RpbWUpICsgKGRlbGF5ID09IG51bGwgPyAwIDogK2RlbGF5KTtcbiAgICBpZiAoIXRoaXMuX25leHQgJiYgdGFza1RhaWwgIT09IHRoaXMpIHtcbiAgICAgIGlmICh0YXNrVGFpbCkgdGFza1RhaWwuX25leHQgPSB0aGlzO1xuICAgICAgZWxzZSB0YXNrSGVhZCA9IHRoaXM7XG4gICAgICB0YXNrVGFpbCA9IHRoaXM7XG4gICAgfVxuICAgIHRoaXMuX2NhbGwgPSBjYWxsYmFjaztcbiAgICB0aGlzLl90aW1lID0gdGltZTtcbiAgICBzbGVlcCgpO1xuICB9LFxuICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fY2FsbCkge1xuICAgICAgdGhpcy5fY2FsbCA9IG51bGw7XG4gICAgICB0aGlzLl90aW1lID0gSW5maW5pdHk7XG4gICAgICBzbGVlcCgpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHRpbWVyKGNhbGxiYWNrLCBkZWxheSwgdGltZSkge1xuICB2YXIgdCA9IG5ldyBUaW1lcjtcbiAgdC5yZXN0YXJ0KGNhbGxiYWNrLCBkZWxheSwgdGltZSk7XG4gIHJldHVybiB0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdGltZXJGbHVzaCgpIHtcbiAgbm93KCk7IC8vIEdldCB0aGUgY3VycmVudCB0aW1lLCBpZiBub3QgYWxyZWFkeSBzZXQuXG4gICsrZnJhbWU7IC8vIFByZXRlbmQgd2XigJl2ZSBzZXQgYW4gYWxhcm0sIGlmIHdlIGhhdmVu4oCZdCBhbHJlYWR5LlxuICB2YXIgdCA9IHRhc2tIZWFkLCBlO1xuICB3aGlsZSAodCkge1xuICAgIGlmICgoZSA9IGNsb2NrTm93IC0gdC5fdGltZSkgPj0gMCkgdC5fY2FsbC5jYWxsKHVuZGVmaW5lZCwgZSk7XG4gICAgdCA9IHQuX25leHQ7XG4gIH1cbiAgLS1mcmFtZTtcbn1cblxuZnVuY3Rpb24gd2FrZSgpIHtcbiAgY2xvY2tOb3cgPSAoY2xvY2tMYXN0ID0gY2xvY2subm93KCkpICsgY2xvY2tTa2V3O1xuICBmcmFtZSA9IHRpbWVvdXQgPSAwO1xuICB0cnkge1xuICAgIHRpbWVyRmx1c2goKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBmcmFtZSA9IDA7XG4gICAgbmFwKCk7XG4gICAgY2xvY2tOb3cgPSAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBva2UoKSB7XG4gIHZhciBub3cgPSBjbG9jay5ub3coKSwgZGVsYXkgPSBub3cgLSBjbG9ja0xhc3Q7XG4gIGlmIChkZWxheSA+IHBva2VEZWxheSkgY2xvY2tTa2V3IC09IGRlbGF5LCBjbG9ja0xhc3QgPSBub3c7XG59XG5cbmZ1bmN0aW9uIG5hcCgpIHtcbiAgdmFyIHQwLCB0MSA9IHRhc2tIZWFkLCB0MiwgdGltZSA9IEluZmluaXR5O1xuICB3aGlsZSAodDEpIHtcbiAgICBpZiAodDEuX2NhbGwpIHtcbiAgICAgIGlmICh0aW1lID4gdDEuX3RpbWUpIHRpbWUgPSB0MS5fdGltZTtcbiAgICAgIHQwID0gdDEsIHQxID0gdDEuX25leHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHQyID0gdDEuX25leHQsIHQxLl9uZXh0ID0gbnVsbDtcbiAgICAgIHQxID0gdDAgPyB0MC5fbmV4dCA9IHQyIDogdGFza0hlYWQgPSB0MjtcbiAgICB9XG4gIH1cbiAgdGFza1RhaWwgPSB0MDtcbiAgc2xlZXAodGltZSk7XG59XG5cbmZ1bmN0aW9uIHNsZWVwKHRpbWUpIHtcbiAgaWYgKGZyYW1lKSByZXR1cm47IC8vIFNvb25lc3QgYWxhcm0gYWxyZWFkeSBzZXQsIG9yIHdpbGwgYmUuXG4gIGlmICh0aW1lb3V0KSB0aW1lb3V0ID0gY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICB2YXIgZGVsYXkgPSB0aW1lIC0gY2xvY2tOb3c7IC8vIFN0cmljdGx5IGxlc3MgdGhhbiBpZiB3ZSByZWNvbXB1dGVkIGNsb2NrTm93LlxuICBpZiAoZGVsYXkgPiAyNCkge1xuICAgIGlmICh0aW1lIDwgSW5maW5pdHkpIHRpbWVvdXQgPSBzZXRUaW1lb3V0KHdha2UsIHRpbWUgLSBjbG9jay5ub3coKSAtIGNsb2NrU2tldyk7XG4gICAgaWYgKGludGVydmFsKSBpbnRlcnZhbCA9IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpO1xuICB9IGVsc2Uge1xuICAgIGlmICghaW50ZXJ2YWwpIGNsb2NrTGFzdCA9IGNsb2NrLm5vdygpLCBpbnRlcnZhbCA9IHNldEludGVydmFsKHBva2UsIHBva2VEZWxheSk7XG4gICAgZnJhbWUgPSAxLCBzZXRGcmFtZSh3YWtlKTtcbiAgfVxufVxuIiwiLypcbkNvcHlyaWdodCAoYykgMjAxMi0yMDE0IENocmlzIFBldHRpdHRcblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdyYXBobGliOiByZXF1aXJlKFwiLi9saWIvZ3JhcGhsaWJcIiksXG5cbiAgbGF5b3V0OiByZXF1aXJlKFwiLi9saWIvbGF5b3V0XCIpLFxuICBkZWJ1ZzogcmVxdWlyZShcIi4vbGliL2RlYnVnXCIpLFxuICB1dGlsOiB7XG4gICAgdGltZTogcmVxdWlyZShcIi4vbGliL3V0aWxcIikudGltZSxcbiAgICBub3RpbWU6IHJlcXVpcmUoXCIuL2xpYi91dGlsXCIpLm5vdGltZVxuICB9LFxuICB2ZXJzaW9uOiByZXF1aXJlKFwiLi9saWIvdmVyc2lvblwiKVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgXyA9IHJlcXVpcmUoXCIuL2xvZGFzaFwiKTtcbnZhciBncmVlZHlGQVMgPSByZXF1aXJlKFwiLi9ncmVlZHktZmFzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcnVuOiBydW4sXG4gIHVuZG86IHVuZG9cbn07XG5cbmZ1bmN0aW9uIHJ1bihnKSB7XG4gIHZhciBmYXMgPSAoZy5ncmFwaCgpLmFjeWNsaWNlciA9PT0gXCJncmVlZHlcIlxuICAgID8gZ3JlZWR5RkFTKGcsIHdlaWdodEZuKGcpKVxuICAgIDogZGZzRkFTKGcpKTtcbiAgXy5mb3JFYWNoKGZhcywgZnVuY3Rpb24oZSkge1xuICAgIHZhciBsYWJlbCA9IGcuZWRnZShlKTtcbiAgICBnLnJlbW92ZUVkZ2UoZSk7XG4gICAgbGFiZWwuZm9yd2FyZE5hbWUgPSBlLm5hbWU7XG4gICAgbGFiZWwucmV2ZXJzZWQgPSB0cnVlO1xuICAgIGcuc2V0RWRnZShlLncsIGUudiwgbGFiZWwsIF8udW5pcXVlSWQoXCJyZXZcIikpO1xuICB9KTtcblxuICBmdW5jdGlvbiB3ZWlnaHRGbihnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHJldHVybiBnLmVkZ2UoZSkud2VpZ2h0O1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZGZzRkFTKGcpIHtcbiAgdmFyIGZhcyA9IFtdO1xuICB2YXIgc3RhY2sgPSB7fTtcbiAgdmFyIHZpc2l0ZWQgPSB7fTtcblxuICBmdW5jdGlvbiBkZnModikge1xuICAgIGlmIChfLmhhcyh2aXNpdGVkLCB2KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcbiAgICBzdGFja1t2XSA9IHRydWU7XG4gICAgXy5mb3JFYWNoKGcub3V0RWRnZXModiksIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmIChfLmhhcyhzdGFjaywgZS53KSkge1xuICAgICAgICBmYXMucHVzaChlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRmcyhlLncpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGRlbGV0ZSBzdGFja1t2XTtcbiAgfVxuXG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGRmcyk7XG4gIHJldHVybiBmYXM7XG59XG5cbmZ1bmN0aW9uIHVuZG8oZykge1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGxhYmVsID0gZy5lZGdlKGUpO1xuICAgIGlmIChsYWJlbC5yZXZlcnNlZCkge1xuICAgICAgZy5yZW1vdmVFZGdlKGUpO1xuXG4gICAgICB2YXIgZm9yd2FyZE5hbWUgPSBsYWJlbC5mb3J3YXJkTmFtZTtcbiAgICAgIGRlbGV0ZSBsYWJlbC5yZXZlcnNlZDtcbiAgICAgIGRlbGV0ZSBsYWJlbC5mb3J3YXJkTmFtZTtcbiAgICAgIGcuc2V0RWRnZShlLncsIGUudiwgbGFiZWwsIGZvcndhcmROYW1lKTtcbiAgICB9XG4gIH0pO1xufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi9sb2Rhc2hcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gYWRkQm9yZGVyU2VnbWVudHM7XG5cbmZ1bmN0aW9uIGFkZEJvcmRlclNlZ21lbnRzKGcpIHtcbiAgZnVuY3Rpb24gZGZzKHYpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBnLmNoaWxkcmVuKHYpO1xuICAgIHZhciBub2RlID0gZy5ub2RlKHYpO1xuICAgIGlmIChjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIF8uZm9yRWFjaChjaGlsZHJlbiwgZGZzKTtcbiAgICB9XG5cbiAgICBpZiAoXy5oYXMobm9kZSwgXCJtaW5SYW5rXCIpKSB7XG4gICAgICBub2RlLmJvcmRlckxlZnQgPSBbXTtcbiAgICAgIG5vZGUuYm9yZGVyUmlnaHQgPSBbXTtcbiAgICAgIGZvciAodmFyIHJhbmsgPSBub2RlLm1pblJhbmssIG1heFJhbmsgPSBub2RlLm1heFJhbmsgKyAxO1xuICAgICAgICByYW5rIDwgbWF4UmFuaztcbiAgICAgICAgKytyYW5rKSB7XG4gICAgICAgIGFkZEJvcmRlck5vZGUoZywgXCJib3JkZXJMZWZ0XCIsIFwiX2JsXCIsIHYsIG5vZGUsIHJhbmspO1xuICAgICAgICBhZGRCb3JkZXJOb2RlKGcsIFwiYm9yZGVyUmlnaHRcIiwgXCJfYnJcIiwgdiwgbm9kZSwgcmFuayk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgXy5mb3JFYWNoKGcuY2hpbGRyZW4oKSwgZGZzKTtcbn1cblxuZnVuY3Rpb24gYWRkQm9yZGVyTm9kZShnLCBwcm9wLCBwcmVmaXgsIHNnLCBzZ05vZGUsIHJhbmspIHtcbiAgdmFyIGxhYmVsID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwLCByYW5rOiByYW5rLCBib3JkZXJUeXBlOiBwcm9wIH07XG4gIHZhciBwcmV2ID0gc2dOb2RlW3Byb3BdW3JhbmsgLSAxXTtcbiAgdmFyIGN1cnIgPSB1dGlsLmFkZER1bW15Tm9kZShnLCBcImJvcmRlclwiLCBsYWJlbCwgcHJlZml4KTtcbiAgc2dOb2RlW3Byb3BdW3JhbmtdID0gY3VycjtcbiAgZy5zZXRQYXJlbnQoY3Vyciwgc2cpO1xuICBpZiAocHJldikge1xuICAgIGcuc2V0RWRnZShwcmV2LCBjdXJyLCB7IHdlaWdodDogMSB9KTtcbiAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfID0gcmVxdWlyZShcIi4vbG9kYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYWRqdXN0OiBhZGp1c3QsXG4gIHVuZG86IHVuZG9cbn07XG5cbmZ1bmN0aW9uIGFkanVzdChnKSB7XG4gIHZhciByYW5rRGlyID0gZy5ncmFwaCgpLnJhbmtkaXIudG9Mb3dlckNhc2UoKTtcbiAgaWYgKHJhbmtEaXIgPT09IFwibHJcIiB8fCByYW5rRGlyID09PSBcInJsXCIpIHtcbiAgICBzd2FwV2lkdGhIZWlnaHQoZyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5kbyhnKSB7XG4gIHZhciByYW5rRGlyID0gZy5ncmFwaCgpLnJhbmtkaXIudG9Mb3dlckNhc2UoKTtcbiAgaWYgKHJhbmtEaXIgPT09IFwiYnRcIiB8fCByYW5rRGlyID09PSBcInJsXCIpIHtcbiAgICByZXZlcnNlWShnKTtcbiAgfVxuXG4gIGlmIChyYW5rRGlyID09PSBcImxyXCIgfHwgcmFua0RpciA9PT0gXCJybFwiKSB7XG4gICAgc3dhcFhZKGcpO1xuICAgIHN3YXBXaWR0aEhlaWdodChnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzd2FwV2lkdGhIZWlnaHQoZykge1xuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7IHN3YXBXaWR0aEhlaWdodE9uZShnLm5vZGUodikpOyB9KTtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkgeyBzd2FwV2lkdGhIZWlnaHRPbmUoZy5lZGdlKGUpKTsgfSk7XG59XG5cbmZ1bmN0aW9uIHN3YXBXaWR0aEhlaWdodE9uZShhdHRycykge1xuICB2YXIgdyA9IGF0dHJzLndpZHRoO1xuICBhdHRycy53aWR0aCA9IGF0dHJzLmhlaWdodDtcbiAgYXR0cnMuaGVpZ2h0ID0gdztcbn1cblxuZnVuY3Rpb24gcmV2ZXJzZVkoZykge1xuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7IHJldmVyc2VZT25lKGcubm9kZSh2KSk7IH0pO1xuXG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWRnZSA9IGcuZWRnZShlKTtcbiAgICBfLmZvckVhY2goZWRnZS5wb2ludHMsIHJldmVyc2VZT25lKTtcbiAgICBpZiAoXy5oYXMoZWRnZSwgXCJ5XCIpKSB7XG4gICAgICByZXZlcnNlWU9uZShlZGdlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZXZlcnNlWU9uZShhdHRycykge1xuICBhdHRycy55ID0gLWF0dHJzLnk7XG59XG5cbmZ1bmN0aW9uIHN3YXBYWShnKSB7XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHsgc3dhcFhZT25lKGcubm9kZSh2KSk7IH0pO1xuXG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWRnZSA9IGcuZWRnZShlKTtcbiAgICBfLmZvckVhY2goZWRnZS5wb2ludHMsIHN3YXBYWU9uZSk7XG4gICAgaWYgKF8uaGFzKGVkZ2UsIFwieFwiKSkge1xuICAgICAgc3dhcFhZT25lKGVkZ2UpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHN3YXBYWU9uZShhdHRycykge1xuICB2YXIgeCA9IGF0dHJzLng7XG4gIGF0dHJzLnggPSBhdHRycy55O1xuICBhdHRycy55ID0geDtcbn1cbiIsIi8qXG4gKiBTaW1wbGUgZG91Ymx5IGxpbmtlZCBsaXN0IGltcGxlbWVudGF0aW9uIGRlcml2ZWQgZnJvbSBDb3JtZW4sIGV0IGFsLixcbiAqIFwiSW50cm9kdWN0aW9uIHRvIEFsZ29yaXRobXNcIi5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpc3Q7XG5cbmZ1bmN0aW9uIExpc3QoKSB7XG4gIHZhciBzZW50aW5lbCA9IHt9O1xuICBzZW50aW5lbC5fbmV4dCA9IHNlbnRpbmVsLl9wcmV2ID0gc2VudGluZWw7XG4gIHRoaXMuX3NlbnRpbmVsID0gc2VudGluZWw7XG59XG5cbkxpc3QucHJvdG90eXBlLmRlcXVldWUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbnRpbmVsID0gdGhpcy5fc2VudGluZWw7XG4gIHZhciBlbnRyeSA9IHNlbnRpbmVsLl9wcmV2O1xuICBpZiAoZW50cnkgIT09IHNlbnRpbmVsKSB7XG4gICAgdW5saW5rKGVudHJ5KTtcbiAgICByZXR1cm4gZW50cnk7XG4gIH1cbn07XG5cbkxpc3QucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbihlbnRyeSkge1xuICB2YXIgc2VudGluZWwgPSB0aGlzLl9zZW50aW5lbDtcbiAgaWYgKGVudHJ5Ll9wcmV2ICYmIGVudHJ5Ll9uZXh0KSB7XG4gICAgdW5saW5rKGVudHJ5KTtcbiAgfVxuICBlbnRyeS5fbmV4dCA9IHNlbnRpbmVsLl9uZXh0O1xuICBzZW50aW5lbC5fbmV4dC5fcHJldiA9IGVudHJ5O1xuICBzZW50aW5lbC5fbmV4dCA9IGVudHJ5O1xuICBlbnRyeS5fcHJldiA9IHNlbnRpbmVsO1xufTtcblxuTGlzdC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0cnMgPSBbXTtcbiAgdmFyIHNlbnRpbmVsID0gdGhpcy5fc2VudGluZWw7XG4gIHZhciBjdXJyID0gc2VudGluZWwuX3ByZXY7XG4gIHdoaWxlIChjdXJyICE9PSBzZW50aW5lbCkge1xuICAgIHN0cnMucHVzaChKU09OLnN0cmluZ2lmeShjdXJyLCBmaWx0ZXJPdXRMaW5rcykpO1xuICAgIGN1cnIgPSBjdXJyLl9wcmV2O1xuICB9XG4gIHJldHVybiBcIltcIiArIHN0cnMuam9pbihcIiwgXCIpICsgXCJdXCI7XG59O1xuXG5mdW5jdGlvbiB1bmxpbmsoZW50cnkpIHtcbiAgZW50cnkuX3ByZXYuX25leHQgPSBlbnRyeS5fbmV4dDtcbiAgZW50cnkuX25leHQuX3ByZXYgPSBlbnRyeS5fcHJldjtcbiAgZGVsZXRlIGVudHJ5Ll9uZXh0O1xuICBkZWxldGUgZW50cnkuX3ByZXY7XG59XG5cbmZ1bmN0aW9uIGZpbHRlck91dExpbmtzKGssIHYpIHtcbiAgaWYgKGsgIT09IFwiX25leHRcIiAmJiBrICE9PSBcIl9wcmV2XCIpIHtcbiAgICByZXR1cm4gdjtcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi9sb2Rhc2hcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgR3JhcGggPSByZXF1aXJlKFwiLi9ncmFwaGxpYlwiKS5HcmFwaDtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlYnVnT3JkZXJpbmc6IGRlYnVnT3JkZXJpbmdcbn07XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBkZWJ1Z09yZGVyaW5nKGcpIHtcbiAgdmFyIGxheWVyTWF0cml4ID0gdXRpbC5idWlsZExheWVyTWF0cml4KGcpO1xuXG4gIHZhciBoID0gbmV3IEdyYXBoKHsgY29tcG91bmQ6IHRydWUsIG11bHRpZ3JhcGg6IHRydWUgfSkuc2V0R3JhcGgoe30pO1xuXG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICBoLnNldE5vZGUodiwgeyBsYWJlbDogdiB9KTtcbiAgICBoLnNldFBhcmVudCh2LCBcImxheWVyXCIgKyBnLm5vZGUodikucmFuayk7XG4gIH0pO1xuXG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICBoLnNldEVkZ2UoZS52LCBlLncsIHt9LCBlLm5hbWUpO1xuICB9KTtcblxuICBfLmZvckVhY2gobGF5ZXJNYXRyaXgsIGZ1bmN0aW9uKGxheWVyLCBpKSB7XG4gICAgdmFyIGxheWVyViA9IFwibGF5ZXJcIiArIGk7XG4gICAgaC5zZXROb2RlKGxheWVyViwgeyByYW5rOiBcInNhbWVcIiB9KTtcbiAgICBfLnJlZHVjZShsYXllciwgZnVuY3Rpb24odSwgdikge1xuICAgICAgaC5zZXRFZGdlKHUsIHYsIHsgc3R5bGU6IFwiaW52aXNcIiB9KTtcbiAgICAgIHJldHVybiB2O1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gaDtcbn1cbiIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cblxudmFyIGdyYXBobGliO1xuXG5pZiAodHlwZW9mIHJlcXVpcmUgPT09IFwiZnVuY3Rpb25cIikge1xuICB0cnkge1xuICAgIGdyYXBobGliID0gcmVxdWlyZShcImdyYXBobGliXCIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxuICB9XG59XG5cbmlmICghZ3JhcGhsaWIpIHtcbiAgZ3JhcGhsaWIgPSB3aW5kb3cuZ3JhcGhsaWI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ3JhcGhsaWI7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuL2xvZGFzaFwiKTtcbnZhciBHcmFwaCA9IHJlcXVpcmUoXCIuL2dyYXBobGliXCIpLkdyYXBoO1xudmFyIExpc3QgPSByZXF1aXJlKFwiLi9kYXRhL2xpc3RcIik7XG5cbi8qXG4gKiBBIGdyZWVkeSBoZXVyaXN0aWMgZm9yIGZpbmRpbmcgYSBmZWVkYmFjayBhcmMgc2V0IGZvciBhIGdyYXBoLiBBIGZlZWRiYWNrXG4gKiBhcmMgc2V0IGlzIGEgc2V0IG9mIGVkZ2VzIHRoYXQgY2FuIGJlIHJlbW92ZWQgdG8gbWFrZSBhIGdyYXBoIGFjeWNsaWMuXG4gKiBUaGUgYWxnb3JpdGhtIGNvbWVzIGZyb206IFAuIEVhZGVzLCBYLiBMaW4sIGFuZCBXLiBGLiBTbXl0aCwgXCJBIGZhc3QgYW5kXG4gKiBlZmZlY3RpdmUgaGV1cmlzdGljIGZvciB0aGUgZmVlZGJhY2sgYXJjIHNldCBwcm9ibGVtLlwiIFRoaXMgaW1wbGVtZW50YXRpb25cbiAqIGFkanVzdHMgdGhhdCBmcm9tIHRoZSBwYXBlciB0byBhbGxvdyBmb3Igd2VpZ2h0ZWQgZWRnZXMuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZ3JlZWR5RkFTO1xuXG52YXIgREVGQVVMVF9XRUlHSFRfRk4gPSBfLmNvbnN0YW50KDEpO1xuXG5mdW5jdGlvbiBncmVlZHlGQVMoZywgd2VpZ2h0Rm4pIHtcbiAgaWYgKGcubm9kZUNvdW50KCkgPD0gMSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICB2YXIgc3RhdGUgPSBidWlsZFN0YXRlKGcsIHdlaWdodEZuIHx8IERFRkFVTFRfV0VJR0hUX0ZOKTtcbiAgdmFyIHJlc3VsdHMgPSBkb0dyZWVkeUZBUyhzdGF0ZS5ncmFwaCwgc3RhdGUuYnVja2V0cywgc3RhdGUuemVyb0lkeCk7XG5cbiAgLy8gRXhwYW5kIG11bHRpLWVkZ2VzXG4gIHJldHVybiBfLmZsYXR0ZW4oXy5tYXAocmVzdWx0cywgZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiBnLm91dEVkZ2VzKGUudiwgZS53KTtcbiAgfSksIHRydWUpO1xufVxuXG5mdW5jdGlvbiBkb0dyZWVkeUZBUyhnLCBidWNrZXRzLCB6ZXJvSWR4KSB7XG4gIHZhciByZXN1bHRzID0gW107XG4gIHZhciBzb3VyY2VzID0gYnVja2V0c1tidWNrZXRzLmxlbmd0aCAtIDFdO1xuICB2YXIgc2lua3MgPSBidWNrZXRzWzBdO1xuXG4gIHZhciBlbnRyeTtcbiAgd2hpbGUgKGcubm9kZUNvdW50KCkpIHtcbiAgICB3aGlsZSAoKGVudHJ5ID0gc2lua3MuZGVxdWV1ZSgpKSkgICB7IHJlbW92ZU5vZGUoZywgYnVja2V0cywgemVyb0lkeCwgZW50cnkpOyB9XG4gICAgd2hpbGUgKChlbnRyeSA9IHNvdXJjZXMuZGVxdWV1ZSgpKSkgeyByZW1vdmVOb2RlKGcsIGJ1Y2tldHMsIHplcm9JZHgsIGVudHJ5KTsgfVxuICAgIGlmIChnLm5vZGVDb3VudCgpKSB7XG4gICAgICBmb3IgKHZhciBpID0gYnVja2V0cy5sZW5ndGggLSAyOyBpID4gMDsgLS1pKSB7XG4gICAgICAgIGVudHJ5ID0gYnVja2V0c1tpXS5kZXF1ZXVlKCk7XG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIHJlc3VsdHMgPSByZXN1bHRzLmNvbmNhdChyZW1vdmVOb2RlKGcsIGJ1Y2tldHMsIHplcm9JZHgsIGVudHJ5LCB0cnVlKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gcmVtb3ZlTm9kZShnLCBidWNrZXRzLCB6ZXJvSWR4LCBlbnRyeSwgY29sbGVjdFByZWRlY2Vzc29ycykge1xuICB2YXIgcmVzdWx0cyA9IGNvbGxlY3RQcmVkZWNlc3NvcnMgPyBbXSA6IHVuZGVmaW5lZDtcblxuICBfLmZvckVhY2goZy5pbkVkZ2VzKGVudHJ5LnYpLCBmdW5jdGlvbihlZGdlKSB7XG4gICAgdmFyIHdlaWdodCA9IGcuZWRnZShlZGdlKTtcbiAgICB2YXIgdUVudHJ5ID0gZy5ub2RlKGVkZ2Uudik7XG5cbiAgICBpZiAoY29sbGVjdFByZWRlY2Vzc29ycykge1xuICAgICAgcmVzdWx0cy5wdXNoKHsgdjogZWRnZS52LCB3OiBlZGdlLncgfSk7XG4gICAgfVxuXG4gICAgdUVudHJ5Lm91dCAtPSB3ZWlnaHQ7XG4gICAgYXNzaWduQnVja2V0KGJ1Y2tldHMsIHplcm9JZHgsIHVFbnRyeSk7XG4gIH0pO1xuXG4gIF8uZm9yRWFjaChnLm91dEVkZ2VzKGVudHJ5LnYpLCBmdW5jdGlvbihlZGdlKSB7XG4gICAgdmFyIHdlaWdodCA9IGcuZWRnZShlZGdlKTtcbiAgICB2YXIgdyA9IGVkZ2UudztcbiAgICB2YXIgd0VudHJ5ID0gZy5ub2RlKHcpO1xuICAgIHdFbnRyeVtcImluXCJdIC09IHdlaWdodDtcbiAgICBhc3NpZ25CdWNrZXQoYnVja2V0cywgemVyb0lkeCwgd0VudHJ5KTtcbiAgfSk7XG5cbiAgZy5yZW1vdmVOb2RlKGVudHJ5LnYpO1xuXG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBidWlsZFN0YXRlKGcsIHdlaWdodEZuKSB7XG4gIHZhciBmYXNHcmFwaCA9IG5ldyBHcmFwaCgpO1xuICB2YXIgbWF4SW4gPSAwO1xuICB2YXIgbWF4T3V0ID0gMDtcblxuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgZmFzR3JhcGguc2V0Tm9kZSh2LCB7IHY6IHYsIFwiaW5cIjogMCwgb3V0OiAwIH0pO1xuICB9KTtcblxuICAvLyBBZ2dyZWdhdGUgd2VpZ2h0cyBvbiBub2RlcywgYnV0IGFsc28gc3VtIHRoZSB3ZWlnaHRzIGFjcm9zcyBtdWx0aS1lZGdlc1xuICAvLyBpbnRvIGEgc2luZ2xlIGVkZ2UgZm9yIHRoZSBmYXNHcmFwaC5cbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBwcmV2V2VpZ2h0ID0gZmFzR3JhcGguZWRnZShlLnYsIGUudykgfHwgMDtcbiAgICB2YXIgd2VpZ2h0ID0gd2VpZ2h0Rm4oZSk7XG4gICAgdmFyIGVkZ2VXZWlnaHQgPSBwcmV2V2VpZ2h0ICsgd2VpZ2h0O1xuICAgIGZhc0dyYXBoLnNldEVkZ2UoZS52LCBlLncsIGVkZ2VXZWlnaHQpO1xuICAgIG1heE91dCA9IE1hdGgubWF4KG1heE91dCwgZmFzR3JhcGgubm9kZShlLnYpLm91dCArPSB3ZWlnaHQpO1xuICAgIG1heEluICA9IE1hdGgubWF4KG1heEluLCAgZmFzR3JhcGgubm9kZShlLncpW1wiaW5cIl0gICs9IHdlaWdodCk7XG4gIH0pO1xuXG4gIHZhciBidWNrZXRzID0gXy5yYW5nZShtYXhPdXQgKyBtYXhJbiArIDMpLm1hcChmdW5jdGlvbigpIHsgcmV0dXJuIG5ldyBMaXN0KCk7IH0pO1xuICB2YXIgemVyb0lkeCA9IG1heEluICsgMTtcblxuICBfLmZvckVhY2goZmFzR3JhcGgubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIGFzc2lnbkJ1Y2tldChidWNrZXRzLCB6ZXJvSWR4LCBmYXNHcmFwaC5ub2RlKHYpKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHsgZ3JhcGg6IGZhc0dyYXBoLCBidWNrZXRzOiBidWNrZXRzLCB6ZXJvSWR4OiB6ZXJvSWR4IH07XG59XG5cbmZ1bmN0aW9uIGFzc2lnbkJ1Y2tldChidWNrZXRzLCB6ZXJvSWR4LCBlbnRyeSkge1xuICBpZiAoIWVudHJ5Lm91dCkge1xuICAgIGJ1Y2tldHNbMF0uZW5xdWV1ZShlbnRyeSk7XG4gIH0gZWxzZSBpZiAoIWVudHJ5W1wiaW5cIl0pIHtcbiAgICBidWNrZXRzW2J1Y2tldHMubGVuZ3RoIC0gMV0uZW5xdWV1ZShlbnRyeSk7XG4gIH0gZWxzZSB7XG4gICAgYnVja2V0c1tlbnRyeS5vdXQgLSBlbnRyeVtcImluXCJdICsgemVyb0lkeF0uZW5xdWV1ZShlbnRyeSk7XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgXyA9IHJlcXVpcmUoXCIuL2xvZGFzaFwiKTtcbnZhciBhY3ljbGljID0gcmVxdWlyZShcIi4vYWN5Y2xpY1wiKTtcbnZhciBub3JtYWxpemUgPSByZXF1aXJlKFwiLi9ub3JtYWxpemVcIik7XG52YXIgcmFuayA9IHJlcXVpcmUoXCIuL3JhbmtcIik7XG52YXIgbm9ybWFsaXplUmFua3MgPSByZXF1aXJlKFwiLi91dGlsXCIpLm5vcm1hbGl6ZVJhbmtzO1xudmFyIHBhcmVudER1bW15Q2hhaW5zID0gcmVxdWlyZShcIi4vcGFyZW50LWR1bW15LWNoYWluc1wiKTtcbnZhciByZW1vdmVFbXB0eVJhbmtzID0gcmVxdWlyZShcIi4vdXRpbFwiKS5yZW1vdmVFbXB0eVJhbmtzO1xudmFyIG5lc3RpbmdHcmFwaCA9IHJlcXVpcmUoXCIuL25lc3RpbmctZ3JhcGhcIik7XG52YXIgYWRkQm9yZGVyU2VnbWVudHMgPSByZXF1aXJlKFwiLi9hZGQtYm9yZGVyLXNlZ21lbnRzXCIpO1xudmFyIGNvb3JkaW5hdGVTeXN0ZW0gPSByZXF1aXJlKFwiLi9jb29yZGluYXRlLXN5c3RlbVwiKTtcbnZhciBvcmRlciA9IHJlcXVpcmUoXCIuL29yZGVyXCIpO1xudmFyIHBvc2l0aW9uID0gcmVxdWlyZShcIi4vcG9zaXRpb25cIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgR3JhcGggPSByZXF1aXJlKFwiLi9ncmFwaGxpYlwiKS5HcmFwaDtcblxubW9kdWxlLmV4cG9ydHMgPSBsYXlvdXQ7XG5cbmZ1bmN0aW9uIGxheW91dChnLCBvcHRzKSB7XG4gIHZhciB0aW1lID0gb3B0cyAmJiBvcHRzLmRlYnVnVGltaW5nID8gdXRpbC50aW1lIDogdXRpbC5ub3RpbWU7XG4gIHRpbWUoXCJsYXlvdXRcIiwgZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxheW91dEdyYXBoID0gXG4gICAgICB0aW1lKFwiICBidWlsZExheW91dEdyYXBoXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gYnVpbGRMYXlvdXRHcmFwaChnKTsgfSk7XG4gICAgdGltZShcIiAgcnVuTGF5b3V0XCIsICAgICAgICBmdW5jdGlvbigpIHsgcnVuTGF5b3V0KGxheW91dEdyYXBoLCB0aW1lKTsgfSk7XG4gICAgdGltZShcIiAgdXBkYXRlSW5wdXRHcmFwaFwiLCBmdW5jdGlvbigpIHsgdXBkYXRlSW5wdXRHcmFwaChnLCBsYXlvdXRHcmFwaCk7IH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcnVuTGF5b3V0KGcsIHRpbWUpIHtcbiAgdGltZShcIiAgICBtYWtlU3BhY2VGb3JFZGdlTGFiZWxzXCIsIGZ1bmN0aW9uKCkgeyBtYWtlU3BhY2VGb3JFZGdlTGFiZWxzKGcpOyB9KTtcbiAgdGltZShcIiAgICByZW1vdmVTZWxmRWRnZXNcIiwgICAgICAgIGZ1bmN0aW9uKCkgeyByZW1vdmVTZWxmRWRnZXMoZyk7IH0pO1xuICB0aW1lKFwiICAgIGFjeWNsaWNcIiwgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7IGFjeWNsaWMucnVuKGcpOyB9KTtcbiAgdGltZShcIiAgICBuZXN0aW5nR3JhcGgucnVuXCIsICAgICAgIGZ1bmN0aW9uKCkgeyBuZXN0aW5nR3JhcGgucnVuKGcpOyB9KTtcbiAgdGltZShcIiAgICByYW5rXCIsICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkgeyByYW5rKHV0aWwuYXNOb25Db21wb3VuZEdyYXBoKGcpKTsgfSk7XG4gIHRpbWUoXCIgICAgaW5qZWN0RWRnZUxhYmVsUHJveGllc1wiLCBmdW5jdGlvbigpIHsgaW5qZWN0RWRnZUxhYmVsUHJveGllcyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgcmVtb3ZlRW1wdHlSYW5rc1wiLCAgICAgICBmdW5jdGlvbigpIHsgcmVtb3ZlRW1wdHlSYW5rcyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgbmVzdGluZ0dyYXBoLmNsZWFudXBcIiwgICBmdW5jdGlvbigpIHsgbmVzdGluZ0dyYXBoLmNsZWFudXAoZyk7IH0pO1xuICB0aW1lKFwiICAgIG5vcm1hbGl6ZVJhbmtzXCIsICAgICAgICAgZnVuY3Rpb24oKSB7IG5vcm1hbGl6ZVJhbmtzKGcpOyB9KTtcbiAgdGltZShcIiAgICBhc3NpZ25SYW5rTWluTWF4XCIsICAgICAgIGZ1bmN0aW9uKCkgeyBhc3NpZ25SYW5rTWluTWF4KGcpOyB9KTtcbiAgdGltZShcIiAgICByZW1vdmVFZGdlTGFiZWxQcm94aWVzXCIsIGZ1bmN0aW9uKCkgeyByZW1vdmVFZGdlTGFiZWxQcm94aWVzKGcpOyB9KTtcbiAgdGltZShcIiAgICBub3JtYWxpemUucnVuXCIsICAgICAgICAgIGZ1bmN0aW9uKCkgeyBub3JtYWxpemUucnVuKGcpOyB9KTtcbiAgdGltZShcIiAgICBwYXJlbnREdW1teUNoYWluc1wiLCAgICAgIGZ1bmN0aW9uKCkgeyBwYXJlbnREdW1teUNoYWlucyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgYWRkQm9yZGVyU2VnbWVudHNcIiwgICAgICBmdW5jdGlvbigpIHsgYWRkQm9yZGVyU2VnbWVudHMoZyk7IH0pO1xuICB0aW1lKFwiICAgIG9yZGVyXCIsICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7IG9yZGVyKGcpOyB9KTtcbiAgdGltZShcIiAgICBpbnNlcnRTZWxmRWRnZXNcIiwgICAgICAgIGZ1bmN0aW9uKCkgeyBpbnNlcnRTZWxmRWRnZXMoZyk7IH0pO1xuICB0aW1lKFwiICAgIGFkanVzdENvb3JkaW5hdGVTeXN0ZW1cIiwgZnVuY3Rpb24oKSB7IGNvb3JkaW5hdGVTeXN0ZW0uYWRqdXN0KGcpOyB9KTtcbiAgdGltZShcIiAgICBwb3NpdGlvblwiLCAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkgeyBwb3NpdGlvbihnKTsgfSk7XG4gIHRpbWUoXCIgICAgcG9zaXRpb25TZWxmRWRnZXNcIiwgICAgICBmdW5jdGlvbigpIHsgcG9zaXRpb25TZWxmRWRnZXMoZyk7IH0pO1xuICB0aW1lKFwiICAgIHJlbW92ZUJvcmRlck5vZGVzXCIsICAgICAgZnVuY3Rpb24oKSB7IHJlbW92ZUJvcmRlck5vZGVzKGcpOyB9KTtcbiAgdGltZShcIiAgICBub3JtYWxpemUudW5kb1wiLCAgICAgICAgIGZ1bmN0aW9uKCkgeyBub3JtYWxpemUudW5kbyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgZml4dXBFZGdlTGFiZWxDb29yZHNcIiwgICBmdW5jdGlvbigpIHsgZml4dXBFZGdlTGFiZWxDb29yZHMoZyk7IH0pO1xuICB0aW1lKFwiICAgIHVuZG9Db29yZGluYXRlU3lzdGVtXCIsICAgZnVuY3Rpb24oKSB7IGNvb3JkaW5hdGVTeXN0ZW0udW5kbyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgdHJhbnNsYXRlR3JhcGhcIiwgICAgICAgICBmdW5jdGlvbigpIHsgdHJhbnNsYXRlR3JhcGgoZyk7IH0pO1xuICB0aW1lKFwiICAgIGFzc2lnbk5vZGVJbnRlcnNlY3RzXCIsICAgZnVuY3Rpb24oKSB7IGFzc2lnbk5vZGVJbnRlcnNlY3RzKGcpOyB9KTtcbiAgdGltZShcIiAgICByZXZlcnNlUG9pbnRzXCIsICAgICAgICAgIGZ1bmN0aW9uKCkgeyByZXZlcnNlUG9pbnRzRm9yUmV2ZXJzZWRFZGdlcyhnKTsgfSk7XG4gIHRpbWUoXCIgICAgYWN5Y2xpYy51bmRvXCIsICAgICAgICAgICBmdW5jdGlvbigpIHsgYWN5Y2xpYy51bmRvKGcpOyB9KTtcbn1cblxuLypcbiAqIENvcGllcyBmaW5hbCBsYXlvdXQgaW5mb3JtYXRpb24gZnJvbSB0aGUgbGF5b3V0IGdyYXBoIGJhY2sgdG8gdGhlIGlucHV0XG4gKiBncmFwaC4gVGhpcyBwcm9jZXNzIG9ubHkgY29waWVzIHdoaXRlbGlzdGVkIGF0dHJpYnV0ZXMgZnJvbSB0aGUgbGF5b3V0IGdyYXBoXG4gKiB0byB0aGUgaW5wdXQgZ3JhcGgsIHNvIGl0IHNlcnZlcyBhcyBhIGdvb2QgcGxhY2UgdG8gZGV0ZXJtaW5lIHdoYXRcbiAqIGF0dHJpYnV0ZXMgY2FuIGluZmx1ZW5jZSBsYXlvdXQuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUlucHV0R3JhcGgoaW5wdXRHcmFwaCwgbGF5b3V0R3JhcGgpIHtcbiAgXy5mb3JFYWNoKGlucHV0R3JhcGgubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBpbnB1dExhYmVsID0gaW5wdXRHcmFwaC5ub2RlKHYpO1xuICAgIHZhciBsYXlvdXRMYWJlbCA9IGxheW91dEdyYXBoLm5vZGUodik7XG5cbiAgICBpZiAoaW5wdXRMYWJlbCkge1xuICAgICAgaW5wdXRMYWJlbC54ID0gbGF5b3V0TGFiZWwueDtcbiAgICAgIGlucHV0TGFiZWwueSA9IGxheW91dExhYmVsLnk7XG5cbiAgICAgIGlmIChsYXlvdXRHcmFwaC5jaGlsZHJlbih2KS5sZW5ndGgpIHtcbiAgICAgICAgaW5wdXRMYWJlbC53aWR0aCA9IGxheW91dExhYmVsLndpZHRoO1xuICAgICAgICBpbnB1dExhYmVsLmhlaWdodCA9IGxheW91dExhYmVsLmhlaWdodDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIF8uZm9yRWFjaChpbnB1dEdyYXBoLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgaW5wdXRMYWJlbCA9IGlucHV0R3JhcGguZWRnZShlKTtcbiAgICB2YXIgbGF5b3V0TGFiZWwgPSBsYXlvdXRHcmFwaC5lZGdlKGUpO1xuXG4gICAgaW5wdXRMYWJlbC5wb2ludHMgPSBsYXlvdXRMYWJlbC5wb2ludHM7XG4gICAgaWYgKF8uaGFzKGxheW91dExhYmVsLCBcInhcIikpIHtcbiAgICAgIGlucHV0TGFiZWwueCA9IGxheW91dExhYmVsLng7XG4gICAgICBpbnB1dExhYmVsLnkgPSBsYXlvdXRMYWJlbC55O1xuICAgIH1cbiAgfSk7XG5cbiAgaW5wdXRHcmFwaC5ncmFwaCgpLndpZHRoID0gbGF5b3V0R3JhcGguZ3JhcGgoKS53aWR0aDtcbiAgaW5wdXRHcmFwaC5ncmFwaCgpLmhlaWdodCA9IGxheW91dEdyYXBoLmdyYXBoKCkuaGVpZ2h0O1xufVxuXG52YXIgZ3JhcGhOdW1BdHRycyA9IFtcIm5vZGVzZXBcIiwgXCJlZGdlc2VwXCIsIFwicmFua3NlcFwiLCBcIm1hcmdpbnhcIiwgXCJtYXJnaW55XCJdO1xudmFyIGdyYXBoRGVmYXVsdHMgPSB7IHJhbmtzZXA6IDUwLCBlZGdlc2VwOiAyMCwgbm9kZXNlcDogNTAsIHJhbmtkaXI6IFwidGJcIiB9O1xudmFyIGdyYXBoQXR0cnMgPSBbXCJhY3ljbGljZXJcIiwgXCJyYW5rZXJcIiwgXCJyYW5rZGlyXCIsIFwiYWxpZ25cIl07XG52YXIgbm9kZU51bUF0dHJzID0gW1wid2lkdGhcIiwgXCJoZWlnaHRcIl07XG52YXIgbm9kZURlZmF1bHRzID0geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG52YXIgZWRnZU51bUF0dHJzID0gW1wibWlubGVuXCIsIFwid2VpZ2h0XCIsIFwid2lkdGhcIiwgXCJoZWlnaHRcIiwgXCJsYWJlbG9mZnNldFwiXTtcbnZhciBlZGdlRGVmYXVsdHMgPSB7XG4gIG1pbmxlbjogMSwgd2VpZ2h0OiAxLCB3aWR0aDogMCwgaGVpZ2h0OiAwLFxuICBsYWJlbG9mZnNldDogMTAsIGxhYmVscG9zOiBcInJcIlxufTtcbnZhciBlZGdlQXR0cnMgPSBbXCJsYWJlbHBvc1wiXTtcblxuLypcbiAqIENvbnN0cnVjdHMgYSBuZXcgZ3JhcGggZnJvbSB0aGUgaW5wdXQgZ3JhcGgsIHdoaWNoIGNhbiBiZSB1c2VkIGZvciBsYXlvdXQuXG4gKiBUaGlzIHByb2Nlc3MgY29waWVzIG9ubHkgd2hpdGVsaXN0ZWQgYXR0cmlidXRlcyBmcm9tIHRoZSBpbnB1dCBncmFwaCB0byB0aGVcbiAqIGxheW91dCBncmFwaC4gVGh1cyB0aGlzIGZ1bmN0aW9uIHNlcnZlcyBhcyBhIGdvb2QgcGxhY2UgdG8gZGV0ZXJtaW5lIHdoYXRcbiAqIGF0dHJpYnV0ZXMgY2FuIGluZmx1ZW5jZSBsYXlvdXQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkTGF5b3V0R3JhcGgoaW5wdXRHcmFwaCkge1xuICB2YXIgZyA9IG5ldyBHcmFwaCh7IG11bHRpZ3JhcGg6IHRydWUsIGNvbXBvdW5kOiB0cnVlIH0pO1xuICB2YXIgZ3JhcGggPSBjYW5vbmljYWxpemUoaW5wdXRHcmFwaC5ncmFwaCgpKTtcblxuICBnLnNldEdyYXBoKF8ubWVyZ2Uoe30sXG4gICAgZ3JhcGhEZWZhdWx0cyxcbiAgICBzZWxlY3ROdW1iZXJBdHRycyhncmFwaCwgZ3JhcGhOdW1BdHRycyksXG4gICAgXy5waWNrKGdyYXBoLCBncmFwaEF0dHJzKSkpO1xuXG4gIF8uZm9yRWFjaChpbnB1dEdyYXBoLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgbm9kZSA9IGNhbm9uaWNhbGl6ZShpbnB1dEdyYXBoLm5vZGUodikpO1xuICAgIGcuc2V0Tm9kZSh2LCBfLmRlZmF1bHRzKHNlbGVjdE51bWJlckF0dHJzKG5vZGUsIG5vZGVOdW1BdHRycyksIG5vZGVEZWZhdWx0cykpO1xuICAgIGcuc2V0UGFyZW50KHYsIGlucHV0R3JhcGgucGFyZW50KHYpKTtcbiAgfSk7XG5cbiAgXy5mb3JFYWNoKGlucHV0R3JhcGguZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlID0gY2Fub25pY2FsaXplKGlucHV0R3JhcGguZWRnZShlKSk7XG4gICAgZy5zZXRFZGdlKGUsIF8ubWVyZ2Uoe30sXG4gICAgICBlZGdlRGVmYXVsdHMsXG4gICAgICBzZWxlY3ROdW1iZXJBdHRycyhlZGdlLCBlZGdlTnVtQXR0cnMpLFxuICAgICAgXy5waWNrKGVkZ2UsIGVkZ2VBdHRycykpKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGc7XG59XG5cbi8qXG4gKiBUaGlzIGlkZWEgY29tZXMgZnJvbSB0aGUgR2Fuc25lciBwYXBlcjogdG8gYWNjb3VudCBmb3IgZWRnZSBsYWJlbHMgaW4gb3VyXG4gKiBsYXlvdXQgd2Ugc3BsaXQgZWFjaCByYW5rIGluIGhhbGYgYnkgZG91YmxpbmcgbWlubGVuIGFuZCBoYWx2aW5nIHJhbmtzZXAuXG4gKiBUaGVuIHdlIGNhbiBwbGFjZSBsYWJlbHMgYXQgdGhlc2UgbWlkLXBvaW50cyBiZXR3ZWVuIG5vZGVzLlxuICpcbiAqIFdlIGFsc28gYWRkIHNvbWUgbWluaW1hbCBwYWRkaW5nIHRvIHRoZSB3aWR0aCB0byBwdXNoIHRoZSBsYWJlbCBmb3IgdGhlIGVkZ2VcbiAqIGF3YXkgZnJvbSB0aGUgZWRnZSBpdHNlbGYgYSBiaXQuXG4gKi9cbmZ1bmN0aW9uIG1ha2VTcGFjZUZvckVkZ2VMYWJlbHMoZykge1xuICB2YXIgZ3JhcGggPSBnLmdyYXBoKCk7XG4gIGdyYXBoLnJhbmtzZXAgLz0gMjtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlID0gZy5lZGdlKGUpO1xuICAgIGVkZ2UubWlubGVuICo9IDI7XG4gICAgaWYgKGVkZ2UubGFiZWxwb3MudG9Mb3dlckNhc2UoKSAhPT0gXCJjXCIpIHtcbiAgICAgIGlmIChncmFwaC5yYW5rZGlyID09PSBcIlRCXCIgfHwgZ3JhcGgucmFua2RpciA9PT0gXCJCVFwiKSB7XG4gICAgICAgIGVkZ2Uud2lkdGggKz0gZWRnZS5sYWJlbG9mZnNldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVkZ2UuaGVpZ2h0ICs9IGVkZ2UubGFiZWxvZmZzZXQ7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuLypcbiAqIENyZWF0ZXMgdGVtcG9yYXJ5IGR1bW15IG5vZGVzIHRoYXQgY2FwdHVyZSB0aGUgcmFuayBpbiB3aGljaCBlYWNoIGVkZ2Unc1xuICogbGFiZWwgaXMgZ29pbmcgdG8sIGlmIGl0IGhhcyBvbmUgb2Ygbm9uLXplcm8gd2lkdGggYW5kIGhlaWdodC4gV2UgZG8gdGhpc1xuICogc28gdGhhdCB3ZSBjYW4gc2FmZWx5IHJlbW92ZSBlbXB0eSByYW5rcyB3aGlsZSBwcmVzZXJ2aW5nIGJhbGFuY2UgZm9yIHRoZVxuICogbGFiZWwncyBwb3NpdGlvbi5cbiAqL1xuZnVuY3Rpb24gaW5qZWN0RWRnZUxhYmVsUHJveGllcyhnKSB7XG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWRnZSA9IGcuZWRnZShlKTtcbiAgICBpZiAoZWRnZS53aWR0aCAmJiBlZGdlLmhlaWdodCkge1xuICAgICAgdmFyIHYgPSBnLm5vZGUoZS52KTtcbiAgICAgIHZhciB3ID0gZy5ub2RlKGUudyk7XG4gICAgICB2YXIgbGFiZWwgPSB7IHJhbms6ICh3LnJhbmsgLSB2LnJhbmspIC8gMiArIHYucmFuaywgZTogZSB9O1xuICAgICAgdXRpbC5hZGREdW1teU5vZGUoZywgXCJlZGdlLXByb3h5XCIsIGxhYmVsLCBcIl9lcFwiKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhc3NpZ25SYW5rTWluTWF4KGcpIHtcbiAgdmFyIG1heFJhbmsgPSAwO1xuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gICAgaWYgKG5vZGUuYm9yZGVyVG9wKSB7XG4gICAgICBub2RlLm1pblJhbmsgPSBnLm5vZGUobm9kZS5ib3JkZXJUb3ApLnJhbms7XG4gICAgICBub2RlLm1heFJhbmsgPSBnLm5vZGUobm9kZS5ib3JkZXJCb3R0b20pLnJhbms7XG4gICAgICBtYXhSYW5rID0gXy5tYXgobWF4UmFuaywgbm9kZS5tYXhSYW5rKTtcbiAgICB9XG4gIH0pO1xuICBnLmdyYXBoKCkubWF4UmFuayA9IG1heFJhbms7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUVkZ2VMYWJlbFByb3hpZXMoZykge1xuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gICAgaWYgKG5vZGUuZHVtbXkgPT09IFwiZWRnZS1wcm94eVwiKSB7XG4gICAgICBnLmVkZ2Uobm9kZS5lKS5sYWJlbFJhbmsgPSBub2RlLnJhbms7XG4gICAgICBnLnJlbW92ZU5vZGUodik7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlR3JhcGgoZykge1xuICB2YXIgbWluWCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgdmFyIG1heFggPSAwO1xuICB2YXIgbWluWSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgdmFyIG1heFkgPSAwO1xuICB2YXIgZ3JhcGhMYWJlbCA9IGcuZ3JhcGgoKTtcbiAgdmFyIG1hcmdpblggPSBncmFwaExhYmVsLm1hcmdpbnggfHwgMDtcbiAgdmFyIG1hcmdpblkgPSBncmFwaExhYmVsLm1hcmdpbnkgfHwgMDtcblxuICBmdW5jdGlvbiBnZXRFeHRyZW1lcyhhdHRycykge1xuICAgIHZhciB4ID0gYXR0cnMueDtcbiAgICB2YXIgeSA9IGF0dHJzLnk7XG4gICAgdmFyIHcgPSBhdHRycy53aWR0aDtcbiAgICB2YXIgaCA9IGF0dHJzLmhlaWdodDtcbiAgICBtaW5YID0gTWF0aC5taW4obWluWCwgeCAtIHcgLyAyKTtcbiAgICBtYXhYID0gTWF0aC5tYXgobWF4WCwgeCArIHcgLyAyKTtcbiAgICBtaW5ZID0gTWF0aC5taW4obWluWSwgeSAtIGggLyAyKTtcbiAgICBtYXhZID0gTWF0aC5tYXgobWF4WSwgeSArIGggLyAyKTtcbiAgfVxuXG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHsgZ2V0RXh0cmVtZXMoZy5ub2RlKHYpKTsgfSk7XG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWRnZSA9IGcuZWRnZShlKTtcbiAgICBpZiAoXy5oYXMoZWRnZSwgXCJ4XCIpKSB7XG4gICAgICBnZXRFeHRyZW1lcyhlZGdlKTtcbiAgICB9XG4gIH0pO1xuXG4gIG1pblggLT0gbWFyZ2luWDtcbiAgbWluWSAtPSBtYXJnaW5ZO1xuXG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgbm9kZSA9IGcubm9kZSh2KTtcbiAgICBub2RlLnggLT0gbWluWDtcbiAgICBub2RlLnkgLT0gbWluWTtcbiAgfSk7XG5cbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlID0gZy5lZGdlKGUpO1xuICAgIF8uZm9yRWFjaChlZGdlLnBvaW50cywgZnVuY3Rpb24ocCkge1xuICAgICAgcC54IC09IG1pblg7XG4gICAgICBwLnkgLT0gbWluWTtcbiAgICB9KTtcbiAgICBpZiAoXy5oYXMoZWRnZSwgXCJ4XCIpKSB7IGVkZ2UueCAtPSBtaW5YOyB9XG4gICAgaWYgKF8uaGFzKGVkZ2UsIFwieVwiKSkgeyBlZGdlLnkgLT0gbWluWTsgfVxuICB9KTtcblxuICBncmFwaExhYmVsLndpZHRoID0gbWF4WCAtIG1pblggKyBtYXJnaW5YO1xuICBncmFwaExhYmVsLmhlaWdodCA9IG1heFkgLSBtaW5ZICsgbWFyZ2luWTtcbn1cblxuZnVuY3Rpb24gYXNzaWduTm9kZUludGVyc2VjdHMoZykge1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVkZ2UgPSBnLmVkZ2UoZSk7XG4gICAgdmFyIG5vZGVWID0gZy5ub2RlKGUudik7XG4gICAgdmFyIG5vZGVXID0gZy5ub2RlKGUudyk7XG4gICAgdmFyIHAxLCBwMjtcbiAgICBpZiAoIWVkZ2UucG9pbnRzKSB7XG4gICAgICBlZGdlLnBvaW50cyA9IFtdO1xuICAgICAgcDEgPSBub2RlVztcbiAgICAgIHAyID0gbm9kZVY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHAxID0gZWRnZS5wb2ludHNbMF07XG4gICAgICBwMiA9IGVkZ2UucG9pbnRzW2VkZ2UucG9pbnRzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBlZGdlLnBvaW50cy51bnNoaWZ0KHV0aWwuaW50ZXJzZWN0UmVjdChub2RlViwgcDEpKTtcbiAgICBlZGdlLnBvaW50cy5wdXNoKHV0aWwuaW50ZXJzZWN0UmVjdChub2RlVywgcDIpKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGZpeHVwRWRnZUxhYmVsQ29vcmRzKGcpIHtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGdlID0gZy5lZGdlKGUpO1xuICAgIGlmIChfLmhhcyhlZGdlLCBcInhcIikpIHtcbiAgICAgIGlmIChlZGdlLmxhYmVscG9zID09PSBcImxcIiB8fCBlZGdlLmxhYmVscG9zID09PSBcInJcIikge1xuICAgICAgICBlZGdlLndpZHRoIC09IGVkZ2UubGFiZWxvZmZzZXQ7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGVkZ2UubGFiZWxwb3MpIHtcbiAgICAgIGNhc2UgXCJsXCI6IGVkZ2UueCAtPSBlZGdlLndpZHRoIC8gMiArIGVkZ2UubGFiZWxvZmZzZXQ7IGJyZWFrO1xuICAgICAgY2FzZSBcInJcIjogZWRnZS54ICs9IGVkZ2Uud2lkdGggLyAyICsgZWRnZS5sYWJlbG9mZnNldDsgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmV2ZXJzZVBvaW50c0ZvclJldmVyc2VkRWRnZXMoZykge1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVkZ2UgPSBnLmVkZ2UoZSk7XG4gICAgaWYgKGVkZ2UucmV2ZXJzZWQpIHtcbiAgICAgIGVkZ2UucG9pbnRzLnJldmVyc2UoKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiByZW1vdmVCb3JkZXJOb2RlcyhnKSB7XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAoZy5jaGlsZHJlbih2KS5sZW5ndGgpIHtcbiAgICAgIHZhciBub2RlID0gZy5ub2RlKHYpO1xuICAgICAgdmFyIHQgPSBnLm5vZGUobm9kZS5ib3JkZXJUb3ApO1xuICAgICAgdmFyIGIgPSBnLm5vZGUobm9kZS5ib3JkZXJCb3R0b20pO1xuICAgICAgdmFyIGwgPSBnLm5vZGUoXy5sYXN0KG5vZGUuYm9yZGVyTGVmdCkpO1xuICAgICAgdmFyIHIgPSBnLm5vZGUoXy5sYXN0KG5vZGUuYm9yZGVyUmlnaHQpKTtcblxuICAgICAgbm9kZS53aWR0aCA9IE1hdGguYWJzKHIueCAtIGwueCk7XG4gICAgICBub2RlLmhlaWdodCA9IE1hdGguYWJzKGIueSAtIHQueSk7XG4gICAgICBub2RlLnggPSBsLnggKyBub2RlLndpZHRoIC8gMjtcbiAgICAgIG5vZGUueSA9IHQueSArIG5vZGUuaGVpZ2h0IC8gMjtcbiAgICB9XG4gIH0pO1xuXG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICBpZiAoZy5ub2RlKHYpLmR1bW15ID09PSBcImJvcmRlclwiKSB7XG4gICAgICBnLnJlbW92ZU5vZGUodik7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU2VsZkVkZ2VzKGcpIHtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIGlmIChlLnYgPT09IGUudykge1xuICAgICAgdmFyIG5vZGUgPSBnLm5vZGUoZS52KTtcbiAgICAgIGlmICghbm9kZS5zZWxmRWRnZXMpIHtcbiAgICAgICAgbm9kZS5zZWxmRWRnZXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2VsZkVkZ2VzLnB1c2goeyBlOiBlLCBsYWJlbDogZy5lZGdlKGUpIH0pO1xuICAgICAgZy5yZW1vdmVFZGdlKGUpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluc2VydFNlbGZFZGdlcyhnKSB7XG4gIHZhciBsYXllcnMgPSB1dGlsLmJ1aWxkTGF5ZXJNYXRyaXgoZyk7XG4gIF8uZm9yRWFjaChsYXllcnMsIGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgdmFyIG9yZGVyU2hpZnQgPSAwO1xuICAgIF8uZm9yRWFjaChsYXllciwgZnVuY3Rpb24odiwgaSkge1xuICAgICAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gICAgICBub2RlLm9yZGVyID0gaSArIG9yZGVyU2hpZnQ7XG4gICAgICBfLmZvckVhY2gobm9kZS5zZWxmRWRnZXMsIGZ1bmN0aW9uKHNlbGZFZGdlKSB7XG4gICAgICAgIHV0aWwuYWRkRHVtbXlOb2RlKGcsIFwic2VsZmVkZ2VcIiwge1xuICAgICAgICAgIHdpZHRoOiBzZWxmRWRnZS5sYWJlbC53aWR0aCxcbiAgICAgICAgICBoZWlnaHQ6IHNlbGZFZGdlLmxhYmVsLmhlaWdodCxcbiAgICAgICAgICByYW5rOiBub2RlLnJhbmssXG4gICAgICAgICAgb3JkZXI6IGkgKyAoKytvcmRlclNoaWZ0KSxcbiAgICAgICAgICBlOiBzZWxmRWRnZS5lLFxuICAgICAgICAgIGxhYmVsOiBzZWxmRWRnZS5sYWJlbFxuICAgICAgICB9LCBcIl9zZVwiKTtcbiAgICAgIH0pO1xuICAgICAgZGVsZXRlIG5vZGUuc2VsZkVkZ2VzO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcG9zaXRpb25TZWxmRWRnZXMoZykge1xuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gICAgaWYgKG5vZGUuZHVtbXkgPT09IFwic2VsZmVkZ2VcIikge1xuICAgICAgdmFyIHNlbGZOb2RlID0gZy5ub2RlKG5vZGUuZS52KTtcbiAgICAgIHZhciB4ID0gc2VsZk5vZGUueCArIHNlbGZOb2RlLndpZHRoIC8gMjtcbiAgICAgIHZhciB5ID0gc2VsZk5vZGUueTtcbiAgICAgIHZhciBkeCA9IG5vZGUueCAtIHg7XG4gICAgICB2YXIgZHkgPSBzZWxmTm9kZS5oZWlnaHQgLyAyO1xuICAgICAgZy5zZXRFZGdlKG5vZGUuZSwgbm9kZS5sYWJlbCk7XG4gICAgICBnLnJlbW92ZU5vZGUodik7XG4gICAgICBub2RlLmxhYmVsLnBvaW50cyA9IFtcbiAgICAgICAgeyB4OiB4ICsgMiAqIGR4IC8gMywgeTogeSAtIGR5IH0sXG4gICAgICAgIHsgeDogeCArIDUgKiBkeCAvIDYsIHk6IHkgLSBkeSB9LFxuICAgICAgICB7IHg6IHggKyAgICAgZHggICAgLCB5OiB5IH0sXG4gICAgICAgIHsgeDogeCArIDUgKiBkeCAvIDYsIHk6IHkgKyBkeSB9LFxuICAgICAgICB7IHg6IHggKyAyICogZHggLyAzLCB5OiB5ICsgZHkgfVxuICAgICAgXTtcbiAgICAgIG5vZGUubGFiZWwueCA9IG5vZGUueDtcbiAgICAgIG5vZGUubGFiZWwueSA9IG5vZGUueTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBzZWxlY3ROdW1iZXJBdHRycyhvYmosIGF0dHJzKSB7XG4gIHJldHVybiBfLm1hcFZhbHVlcyhfLnBpY2sob2JqLCBhdHRycyksIE51bWJlcik7XG59XG5cbmZ1bmN0aW9uIGNhbm9uaWNhbGl6ZShhdHRycykge1xuICB2YXIgbmV3QXR0cnMgPSB7fTtcbiAgXy5mb3JFYWNoKGF0dHJzLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgbmV3QXR0cnNbay50b0xvd2VyQ2FzZSgpXSA9IHY7XG4gIH0pO1xuICByZXR1cm4gbmV3QXR0cnM7XG59XG4iLCIvKiBnbG9iYWwgd2luZG93ICovXG5cbnZhciBsb2Rhc2g7XG5cbmlmICh0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gIHRyeSB7XG4gICAgbG9kYXNoID0ge1xuICAgICAgY2xvbmVEZWVwOiByZXF1aXJlKFwibG9kYXNoL2Nsb25lRGVlcFwiKSxcbiAgICAgIGNvbnN0YW50OiByZXF1aXJlKFwibG9kYXNoL2NvbnN0YW50XCIpLFxuICAgICAgZGVmYXVsdHM6IHJlcXVpcmUoXCJsb2Rhc2gvZGVmYXVsdHNcIiksXG4gICAgICBlYWNoOiByZXF1aXJlKFwibG9kYXNoL2VhY2hcIiksXG4gICAgICBmaWx0ZXI6IHJlcXVpcmUoXCJsb2Rhc2gvZmlsdGVyXCIpLFxuICAgICAgZmluZDogcmVxdWlyZShcImxvZGFzaC9maW5kXCIpLFxuICAgICAgZmxhdHRlbjogcmVxdWlyZShcImxvZGFzaC9mbGF0dGVuXCIpLFxuICAgICAgZm9yRWFjaDogcmVxdWlyZShcImxvZGFzaC9mb3JFYWNoXCIpLFxuICAgICAgZm9ySW46IHJlcXVpcmUoXCJsb2Rhc2gvZm9ySW5cIiksXG4gICAgICBoYXM6ICByZXF1aXJlKFwibG9kYXNoL2hhc1wiKSxcbiAgICAgIGlzVW5kZWZpbmVkOiByZXF1aXJlKFwibG9kYXNoL2lzVW5kZWZpbmVkXCIpLFxuICAgICAgbGFzdDogcmVxdWlyZShcImxvZGFzaC9sYXN0XCIpLFxuICAgICAgbWFwOiByZXF1aXJlKFwibG9kYXNoL21hcFwiKSxcbiAgICAgIG1hcFZhbHVlczogcmVxdWlyZShcImxvZGFzaC9tYXBWYWx1ZXNcIiksXG4gICAgICBtYXg6IHJlcXVpcmUoXCJsb2Rhc2gvbWF4XCIpLFxuICAgICAgbWVyZ2U6IHJlcXVpcmUoXCJsb2Rhc2gvbWVyZ2VcIiksXG4gICAgICBtaW46IHJlcXVpcmUoXCJsb2Rhc2gvbWluXCIpLFxuICAgICAgbWluQnk6IHJlcXVpcmUoXCJsb2Rhc2gvbWluQnlcIiksXG4gICAgICBub3c6IHJlcXVpcmUoXCJsb2Rhc2gvbm93XCIpLFxuICAgICAgcGljazogcmVxdWlyZShcImxvZGFzaC9waWNrXCIpLFxuICAgICAgcmFuZ2U6IHJlcXVpcmUoXCJsb2Rhc2gvcmFuZ2VcIiksXG4gICAgICByZWR1Y2U6IHJlcXVpcmUoXCJsb2Rhc2gvcmVkdWNlXCIpLFxuICAgICAgc29ydEJ5OiByZXF1aXJlKFwibG9kYXNoL3NvcnRCeVwiKSxcbiAgICAgIHVuaXF1ZUlkOiByZXF1aXJlKFwibG9kYXNoL3VuaXF1ZUlkXCIpLFxuICAgICAgdmFsdWVzOiByZXF1aXJlKFwibG9kYXNoL3ZhbHVlc1wiKSxcbiAgICAgIHppcE9iamVjdDogcmVxdWlyZShcImxvZGFzaC96aXBPYmplY3RcIiksXG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIGNvbnRpbnVlIHJlZ2FyZGxlc3Mgb2YgZXJyb3JcbiAgfVxufVxuXG5pZiAoIWxvZGFzaCkge1xuICBsb2Rhc2ggPSB3aW5kb3cuXztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsb2Rhc2g7XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuL2xvZGFzaFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJ1bjogcnVuLFxuICBjbGVhbnVwOiBjbGVhbnVwXG59O1xuXG4vKlxuICogQSBuZXN0aW5nIGdyYXBoIGNyZWF0ZXMgZHVtbXkgbm9kZXMgZm9yIHRoZSB0b3BzIGFuZCBib3R0b21zIG9mIHN1YmdyYXBocyxcbiAqIGFkZHMgYXBwcm9wcmlhdGUgZWRnZXMgdG8gZW5zdXJlIHRoYXQgYWxsIGNsdXN0ZXIgbm9kZXMgYXJlIHBsYWNlZCBiZXR3ZWVuXG4gKiB0aGVzZSBib3VuZHJpZXMsIGFuZCBlbnN1cmVzIHRoYXQgdGhlIGdyYXBoIGlzIGNvbm5lY3RlZC5cbiAqXG4gKiBJbiBhZGRpdGlvbiB3ZSBlbnN1cmUsIHRocm91Z2ggdGhlIHVzZSBvZiB0aGUgbWlubGVuIHByb3BlcnR5LCB0aGF0IG5vZGVzXG4gKiBhbmQgc3ViZ3JhcGggYm9yZGVyIG5vZGVzIHRvIG5vdCBlbmQgdXAgb24gdGhlIHNhbWUgcmFuay5cbiAqXG4gKiBQcmVjb25kaXRpb25zOlxuICpcbiAqICAgIDEuIElucHV0IGdyYXBoIGlzIGEgREFHXG4gKiAgICAyLiBOb2RlcyBpbiB0aGUgaW5wdXQgZ3JhcGggaGFzIGEgbWlubGVuIGF0dHJpYnV0ZVxuICpcbiAqIFBvc3Rjb25kaXRpb25zOlxuICpcbiAqICAgIDEuIElucHV0IGdyYXBoIGlzIGNvbm5lY3RlZC5cbiAqICAgIDIuIER1bW15IG5vZGVzIGFyZSBhZGRlZCBmb3IgdGhlIHRvcHMgYW5kIGJvdHRvbXMgb2Ygc3ViZ3JhcGhzLlxuICogICAgMy4gVGhlIG1pbmxlbiBhdHRyaWJ1dGUgZm9yIG5vZGVzIGlzIGFkanVzdGVkIHRvIGVuc3VyZSBub2RlcyBkbyBub3RcbiAqICAgICAgIGdldCBwbGFjZWQgb24gdGhlIHNhbWUgcmFuayBhcyBzdWJncmFwaCBib3JkZXIgbm9kZXMuXG4gKlxuICogVGhlIG5lc3RpbmcgZ3JhcGggaWRlYSBjb21lcyBmcm9tIFNhbmRlciwgXCJMYXlvdXQgb2YgQ29tcG91bmQgRGlyZWN0ZWRcbiAqIEdyYXBocy5cIlxuICovXG5mdW5jdGlvbiBydW4oZykge1xuICB2YXIgcm9vdCA9IHV0aWwuYWRkRHVtbXlOb2RlKGcsIFwicm9vdFwiLCB7fSwgXCJfcm9vdFwiKTtcbiAgdmFyIGRlcHRocyA9IHRyZWVEZXB0aHMoZyk7XG4gIHZhciBoZWlnaHQgPSBfLm1heChfLnZhbHVlcyhkZXB0aHMpKSAtIDE7IC8vIE5vdGU6IGRlcHRocyBpcyBhbiBPYmplY3Qgbm90IGFuIGFycmF5XG4gIHZhciBub2RlU2VwID0gMiAqIGhlaWdodCArIDE7XG5cbiAgZy5ncmFwaCgpLm5lc3RpbmdSb290ID0gcm9vdDtcblxuICAvLyBNdWx0aXBseSBtaW5sZW4gYnkgbm9kZVNlcCB0byBhbGlnbiBub2RlcyBvbiBub24tYm9yZGVyIHJhbmtzLlxuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7IGcuZWRnZShlKS5taW5sZW4gKj0gbm9kZVNlcDsgfSk7XG5cbiAgLy8gQ2FsY3VsYXRlIGEgd2VpZ2h0IHRoYXQgaXMgc3VmZmljaWVudCB0byBrZWVwIHN1YmdyYXBocyB2ZXJ0aWNhbGx5IGNvbXBhY3RcbiAgdmFyIHdlaWdodCA9IHN1bVdlaWdodHMoZykgKyAxO1xuXG4gIC8vIENyZWF0ZSBib3JkZXIgbm9kZXMgYW5kIGxpbmsgdGhlbSB1cFxuICBfLmZvckVhY2goZy5jaGlsZHJlbigpLCBmdW5jdGlvbihjaGlsZCkge1xuICAgIGRmcyhnLCByb290LCBub2RlU2VwLCB3ZWlnaHQsIGhlaWdodCwgZGVwdGhzLCBjaGlsZCk7XG4gIH0pO1xuXG4gIC8vIFNhdmUgdGhlIG11bHRpcGxpZXIgZm9yIG5vZGUgbGF5ZXJzIGZvciBsYXRlciByZW1vdmFsIG9mIGVtcHR5IGJvcmRlclxuICAvLyBsYXllcnMuXG4gIGcuZ3JhcGgoKS5ub2RlUmFua0ZhY3RvciA9IG5vZGVTZXA7XG59XG5cbmZ1bmN0aW9uIGRmcyhnLCByb290LCBub2RlU2VwLCB3ZWlnaHQsIGhlaWdodCwgZGVwdGhzLCB2KSB7XG4gIHZhciBjaGlsZHJlbiA9IGcuY2hpbGRyZW4odik7XG4gIGlmICghY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgaWYgKHYgIT09IHJvb3QpIHtcbiAgICAgIGcuc2V0RWRnZShyb290LCB2LCB7IHdlaWdodDogMCwgbWlubGVuOiBub2RlU2VwIH0pO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdG9wID0gdXRpbC5hZGRCb3JkZXJOb2RlKGcsIFwiX2J0XCIpO1xuICB2YXIgYm90dG9tID0gdXRpbC5hZGRCb3JkZXJOb2RlKGcsIFwiX2JiXCIpO1xuICB2YXIgbGFiZWwgPSBnLm5vZGUodik7XG5cbiAgZy5zZXRQYXJlbnQodG9wLCB2KTtcbiAgbGFiZWwuYm9yZGVyVG9wID0gdG9wO1xuICBnLnNldFBhcmVudChib3R0b20sIHYpO1xuICBsYWJlbC5ib3JkZXJCb3R0b20gPSBib3R0b207XG5cbiAgXy5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgIGRmcyhnLCByb290LCBub2RlU2VwLCB3ZWlnaHQsIGhlaWdodCwgZGVwdGhzLCBjaGlsZCk7XG5cbiAgICB2YXIgY2hpbGROb2RlID0gZy5ub2RlKGNoaWxkKTtcbiAgICB2YXIgY2hpbGRUb3AgPSBjaGlsZE5vZGUuYm9yZGVyVG9wID8gY2hpbGROb2RlLmJvcmRlclRvcCA6IGNoaWxkO1xuICAgIHZhciBjaGlsZEJvdHRvbSA9IGNoaWxkTm9kZS5ib3JkZXJCb3R0b20gPyBjaGlsZE5vZGUuYm9yZGVyQm90dG9tIDogY2hpbGQ7XG4gICAgdmFyIHRoaXNXZWlnaHQgPSBjaGlsZE5vZGUuYm9yZGVyVG9wID8gd2VpZ2h0IDogMiAqIHdlaWdodDtcbiAgICB2YXIgbWlubGVuID0gY2hpbGRUb3AgIT09IGNoaWxkQm90dG9tID8gMSA6IGhlaWdodCAtIGRlcHRoc1t2XSArIDE7XG5cbiAgICBnLnNldEVkZ2UodG9wLCBjaGlsZFRvcCwge1xuICAgICAgd2VpZ2h0OiB0aGlzV2VpZ2h0LFxuICAgICAgbWlubGVuOiBtaW5sZW4sXG4gICAgICBuZXN0aW5nRWRnZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgZy5zZXRFZGdlKGNoaWxkQm90dG9tLCBib3R0b20sIHtcbiAgICAgIHdlaWdodDogdGhpc1dlaWdodCxcbiAgICAgIG1pbmxlbjogbWlubGVuLFxuICAgICAgbmVzdGluZ0VkZ2U6IHRydWVcbiAgICB9KTtcbiAgfSk7XG5cbiAgaWYgKCFnLnBhcmVudCh2KSkge1xuICAgIGcuc2V0RWRnZShyb290LCB0b3AsIHsgd2VpZ2h0OiAwLCBtaW5sZW46IGhlaWdodCArIGRlcHRoc1t2XSB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmVlRGVwdGhzKGcpIHtcbiAgdmFyIGRlcHRocyA9IHt9O1xuICBmdW5jdGlvbiBkZnModiwgZGVwdGgpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBnLmNoaWxkcmVuKHYpO1xuICAgIGlmIChjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIF8uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgZGZzKGNoaWxkLCBkZXB0aCArIDEpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGRlcHRoc1t2XSA9IGRlcHRoO1xuICB9XG4gIF8uZm9yRWFjaChnLmNoaWxkcmVuKCksIGZ1bmN0aW9uKHYpIHsgZGZzKHYsIDEpOyB9KTtcbiAgcmV0dXJuIGRlcHRocztcbn1cblxuZnVuY3Rpb24gc3VtV2VpZ2h0cyhnKSB7XG4gIHJldHVybiBfLnJlZHVjZShnLmVkZ2VzKCksIGZ1bmN0aW9uKGFjYywgZSkge1xuICAgIHJldHVybiBhY2MgKyBnLmVkZ2UoZSkud2VpZ2h0O1xuICB9LCAwKTtcbn1cblxuZnVuY3Rpb24gY2xlYW51cChnKSB7XG4gIHZhciBncmFwaExhYmVsID0gZy5ncmFwaCgpO1xuICBnLnJlbW92ZU5vZGUoZ3JhcGhMYWJlbC5uZXN0aW5nUm9vdCk7XG4gIGRlbGV0ZSBncmFwaExhYmVsLm5lc3RpbmdSb290O1xuICBfLmZvckVhY2goZy5lZGdlcygpLCBmdW5jdGlvbihlKSB7XG4gICAgdmFyIGVkZ2UgPSBnLmVkZ2UoZSk7XG4gICAgaWYgKGVkZ2UubmVzdGluZ0VkZ2UpIHtcbiAgICAgIGcucmVtb3ZlRWRnZShlKTtcbiAgICB9XG4gIH0pO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfID0gcmVxdWlyZShcIi4vbG9kYXNoXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcnVuOiBydW4sXG4gIHVuZG86IHVuZG9cbn07XG5cbi8qXG4gKiBCcmVha3MgYW55IGxvbmcgZWRnZXMgaW4gdGhlIGdyYXBoIGludG8gc2hvcnQgc2VnbWVudHMgdGhhdCBzcGFuIDEgbGF5ZXJcbiAqIGVhY2guIFRoaXMgb3BlcmF0aW9uIGlzIHVuZG9hYmxlIHdpdGggdGhlIGRlbm9ybWFsaXplIGZ1bmN0aW9uLlxuICpcbiAqIFByZS1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIFRoZSBpbnB1dCBncmFwaCBpcyBhIERBRy5cbiAqICAgIDIuIEVhY2ggbm9kZSBpbiB0aGUgZ3JhcGggaGFzIGEgXCJyYW5rXCIgcHJvcGVydHkuXG4gKlxuICogUG9zdC1jb25kaXRpb246XG4gKlxuICogICAgMS4gQWxsIGVkZ2VzIGluIHRoZSBncmFwaCBoYXZlIGEgbGVuZ3RoIG9mIDEuXG4gKiAgICAyLiBEdW1teSBub2RlcyBhcmUgYWRkZWQgd2hlcmUgZWRnZXMgaGF2ZSBiZWVuIHNwbGl0IGludG8gc2VnbWVudHMuXG4gKiAgICAzLiBUaGUgZ3JhcGggaXMgYXVnbWVudGVkIHdpdGggYSBcImR1bW15Q2hhaW5zXCIgYXR0cmlidXRlIHdoaWNoIGNvbnRhaW5zXG4gKiAgICAgICB0aGUgZmlyc3QgZHVtbXkgaW4gZWFjaCBjaGFpbiBvZiBkdW1teSBub2RlcyBwcm9kdWNlZC5cbiAqL1xuZnVuY3Rpb24gcnVuKGcpIHtcbiAgZy5ncmFwaCgpLmR1bW15Q2hhaW5zID0gW107XG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGVkZ2UpIHsgbm9ybWFsaXplRWRnZShnLCBlZGdlKTsgfSk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUVkZ2UoZywgZSkge1xuICB2YXIgdiA9IGUudjtcbiAgdmFyIHZSYW5rID0gZy5ub2RlKHYpLnJhbms7XG4gIHZhciB3ID0gZS53O1xuICB2YXIgd1JhbmsgPSBnLm5vZGUodykucmFuaztcbiAgdmFyIG5hbWUgPSBlLm5hbWU7XG4gIHZhciBlZGdlTGFiZWwgPSBnLmVkZ2UoZSk7XG4gIHZhciBsYWJlbFJhbmsgPSBlZGdlTGFiZWwubGFiZWxSYW5rO1xuXG4gIGlmICh3UmFuayA9PT0gdlJhbmsgKyAxKSByZXR1cm47XG5cbiAgZy5yZW1vdmVFZGdlKGUpO1xuXG4gIHZhciBkdW1teSwgYXR0cnMsIGk7XG4gIGZvciAoaSA9IDAsICsrdlJhbms7IHZSYW5rIDwgd1Jhbms7ICsraSwgKyt2UmFuaykge1xuICAgIGVkZ2VMYWJlbC5wb2ludHMgPSBbXTtcbiAgICBhdHRycyA9IHtcbiAgICAgIHdpZHRoOiAwLCBoZWlnaHQ6IDAsXG4gICAgICBlZGdlTGFiZWw6IGVkZ2VMYWJlbCwgZWRnZU9iajogZSxcbiAgICAgIHJhbms6IHZSYW5rXG4gICAgfTtcbiAgICBkdW1teSA9IHV0aWwuYWRkRHVtbXlOb2RlKGcsIFwiZWRnZVwiLCBhdHRycywgXCJfZFwiKTtcbiAgICBpZiAodlJhbmsgPT09IGxhYmVsUmFuaykge1xuICAgICAgYXR0cnMud2lkdGggPSBlZGdlTGFiZWwud2lkdGg7XG4gICAgICBhdHRycy5oZWlnaHQgPSBlZGdlTGFiZWwuaGVpZ2h0O1xuICAgICAgYXR0cnMuZHVtbXkgPSBcImVkZ2UtbGFiZWxcIjtcbiAgICAgIGF0dHJzLmxhYmVscG9zID0gZWRnZUxhYmVsLmxhYmVscG9zO1xuICAgIH1cbiAgICBnLnNldEVkZ2UodiwgZHVtbXksIHsgd2VpZ2h0OiBlZGdlTGFiZWwud2VpZ2h0IH0sIG5hbWUpO1xuICAgIGlmIChpID09PSAwKSB7XG4gICAgICBnLmdyYXBoKCkuZHVtbXlDaGFpbnMucHVzaChkdW1teSk7XG4gICAgfVxuICAgIHYgPSBkdW1teTtcbiAgfVxuXG4gIGcuc2V0RWRnZSh2LCB3LCB7IHdlaWdodDogZWRnZUxhYmVsLndlaWdodCB9LCBuYW1lKTtcbn1cblxuZnVuY3Rpb24gdW5kbyhnKSB7XG4gIF8uZm9yRWFjaChnLmdyYXBoKCkuZHVtbXlDaGFpbnMsIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgbm9kZSA9IGcubm9kZSh2KTtcbiAgICB2YXIgb3JpZ0xhYmVsID0gbm9kZS5lZGdlTGFiZWw7XG4gICAgdmFyIHc7XG4gICAgZy5zZXRFZGdlKG5vZGUuZWRnZU9iaiwgb3JpZ0xhYmVsKTtcbiAgICB3aGlsZSAobm9kZS5kdW1teSkge1xuICAgICAgdyA9IGcuc3VjY2Vzc29ycyh2KVswXTtcbiAgICAgIGcucmVtb3ZlTm9kZSh2KTtcbiAgICAgIG9yaWdMYWJlbC5wb2ludHMucHVzaCh7IHg6IG5vZGUueCwgeTogbm9kZS55IH0pO1xuICAgICAgaWYgKG5vZGUuZHVtbXkgPT09IFwiZWRnZS1sYWJlbFwiKSB7XG4gICAgICAgIG9yaWdMYWJlbC54ID0gbm9kZS54O1xuICAgICAgICBvcmlnTGFiZWwueSA9IG5vZGUueTtcbiAgICAgICAgb3JpZ0xhYmVsLndpZHRoID0gbm9kZS53aWR0aDtcbiAgICAgICAgb3JpZ0xhYmVsLmhlaWdodCA9IG5vZGUuaGVpZ2h0O1xuICAgICAgfVxuICAgICAgdiA9IHc7XG4gICAgICBub2RlID0gZy5ub2RlKHYpO1xuICAgIH1cbiAgfSk7XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gYWRkU3ViZ3JhcGhDb25zdHJhaW50cztcblxuZnVuY3Rpb24gYWRkU3ViZ3JhcGhDb25zdHJhaW50cyhnLCBjZywgdnMpIHtcbiAgdmFyIHByZXYgPSB7fSxcbiAgICByb290UHJldjtcblxuICBfLmZvckVhY2godnMsIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgY2hpbGQgPSBnLnBhcmVudCh2KSxcbiAgICAgIHBhcmVudCxcbiAgICAgIHByZXZDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgIHBhcmVudCA9IGcucGFyZW50KGNoaWxkKTtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcHJldkNoaWxkID0gcHJldltwYXJlbnRdO1xuICAgICAgICBwcmV2W3BhcmVudF0gPSBjaGlsZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXZDaGlsZCA9IHJvb3RQcmV2O1xuICAgICAgICByb290UHJldiA9IGNoaWxkO1xuICAgICAgfVxuICAgICAgaWYgKHByZXZDaGlsZCAmJiBwcmV2Q2hpbGQgIT09IGNoaWxkKSB7XG4gICAgICAgIGNnLnNldEVkZ2UocHJldkNoaWxkLCBjaGlsZCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gcGFyZW50O1xuICAgIH1cbiAgfSk7XG5cbiAgLypcbiAgZnVuY3Rpb24gZGZzKHYpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSB2ID8gZy5jaGlsZHJlbih2KSA6IGcuY2hpbGRyZW4oKTtcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICB2YXIgbWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgICAgICAgIHN1YmdyYXBocyA9IFtdO1xuICAgICAgXy5lYWNoKGNoaWxkcmVuLCBmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICB2YXIgY2hpbGRNaW4gPSBkZnMoY2hpbGQpO1xuICAgICAgICBpZiAoZy5jaGlsZHJlbihjaGlsZCkubGVuZ3RoKSB7XG4gICAgICAgICAgc3ViZ3JhcGhzLnB1c2goeyB2OiBjaGlsZCwgb3JkZXI6IGNoaWxkTWluIH0pO1xuICAgICAgICB9XG4gICAgICAgIG1pbiA9IE1hdGgubWluKG1pbiwgY2hpbGRNaW4pO1xuICAgICAgfSk7XG4gICAgICBfLnJlZHVjZShfLnNvcnRCeShzdWJncmFwaHMsIFwib3JkZXJcIiksIGZ1bmN0aW9uKHByZXYsIGN1cnIpIHtcbiAgICAgICAgY2cuc2V0RWRnZShwcmV2LnYsIGN1cnIudik7XG4gICAgICAgIHJldHVybiBjdXJyO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICByZXR1cm4gZy5ub2RlKHYpLm9yZGVyO1xuICB9XG4gIGRmcyh1bmRlZmluZWQpO1xuICAqL1xufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhcnljZW50ZXI7XG5cbmZ1bmN0aW9uIGJhcnljZW50ZXIoZywgbW92YWJsZSkge1xuICByZXR1cm4gXy5tYXAobW92YWJsZSwgZnVuY3Rpb24odikge1xuICAgIHZhciBpblYgPSBnLmluRWRnZXModik7XG4gICAgaWYgKCFpblYubGVuZ3RoKSB7XG4gICAgICByZXR1cm4geyB2OiB2IH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciByZXN1bHQgPSBfLnJlZHVjZShpblYsIGZ1bmN0aW9uKGFjYywgZSkge1xuICAgICAgICB2YXIgZWRnZSA9IGcuZWRnZShlKSxcbiAgICAgICAgICBub2RlVSA9IGcubm9kZShlLnYpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1bTogYWNjLnN1bSArIChlZGdlLndlaWdodCAqIG5vZGVVLm9yZGVyKSxcbiAgICAgICAgICB3ZWlnaHQ6IGFjYy53ZWlnaHQgKyBlZGdlLndlaWdodFxuICAgICAgICB9O1xuICAgICAgfSwgeyBzdW06IDAsIHdlaWdodDogMCB9KTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdjogdixcbiAgICAgICAgYmFyeWNlbnRlcjogcmVzdWx0LnN1bSAvIHJlc3VsdC53ZWlnaHQsXG4gICAgICAgIHdlaWdodDogcmVzdWx0LndlaWdodFxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuXG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG52YXIgR3JhcGggPSByZXF1aXJlKFwiLi4vZ3JhcGhsaWJcIikuR3JhcGg7XG5cbm1vZHVsZS5leHBvcnRzID0gYnVpbGRMYXllckdyYXBoO1xuXG4vKlxuICogQ29uc3RydWN0cyBhIGdyYXBoIHRoYXQgY2FuIGJlIHVzZWQgdG8gc29ydCBhIGxheWVyIG9mIG5vZGVzLiBUaGUgZ3JhcGggd2lsbFxuICogY29udGFpbiBhbGwgYmFzZSBhbmQgc3ViZ3JhcGggbm9kZXMgZnJvbSB0aGUgcmVxdWVzdCBsYXllciBpbiB0aGVpciBvcmlnaW5hbFxuICogaGllcmFyY2h5IGFuZCBhbnkgZWRnZXMgdGhhdCBhcmUgaW5jaWRlbnQgb24gdGhlc2Ugbm9kZXMgYW5kIGFyZSBvZiB0aGUgdHlwZVxuICogcmVxdWVzdGVkIGJ5IHRoZSBcInJlbGF0aW9uc2hpcFwiIHBhcmFtZXRlci5cbiAqXG4gKiBOb2RlcyBmcm9tIHRoZSByZXF1ZXN0ZWQgcmFuayB0aGF0IGRvIG5vdCBoYXZlIHBhcmVudHMgYXJlIGFzc2lnbmVkIGEgcm9vdFxuICogbm9kZSBpbiB0aGUgb3V0cHV0IGdyYXBoLCB3aGljaCBpcyBzZXQgaW4gdGhlIHJvb3QgZ3JhcGggYXR0cmlidXRlLiBUaGlzXG4gKiBtYWtlcyBpdCBlYXN5IHRvIHdhbGsgdGhlIGhpZXJhcmNoeSBvZiBtb3ZhYmxlIG5vZGVzIGR1cmluZyBvcmRlcmluZy5cbiAqXG4gKiBQcmUtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBJbnB1dCBncmFwaCBpcyBhIERBR1xuICogICAgMi4gQmFzZSBub2RlcyBpbiB0aGUgaW5wdXQgZ3JhcGggaGF2ZSBhIHJhbmsgYXR0cmlidXRlXG4gKiAgICAzLiBTdWJncmFwaCBub2RlcyBpbiB0aGUgaW5wdXQgZ3JhcGggaGFzIG1pblJhbmsgYW5kIG1heFJhbmsgYXR0cmlidXRlc1xuICogICAgNC4gRWRnZXMgaGF2ZSBhbiBhc3NpZ25lZCB3ZWlnaHRcbiAqXG4gKiBQb3N0LWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gT3V0cHV0IGdyYXBoIGhhcyBhbGwgbm9kZXMgaW4gdGhlIG1vdmFibGUgcmFuayB3aXRoIHByZXNlcnZlZFxuICogICAgICAgaGllcmFyY2h5LlxuICogICAgMi4gUm9vdCBub2RlcyBpbiB0aGUgbW92YWJsZSBsYXllciBhcmUgbWFkZSBjaGlsZHJlbiBvZiB0aGUgbm9kZVxuICogICAgICAgaW5kaWNhdGVkIGJ5IHRoZSByb290IGF0dHJpYnV0ZSBvZiB0aGUgZ3JhcGguXG4gKiAgICAzLiBOb24tbW92YWJsZSBub2RlcyBpbmNpZGVudCBvbiBtb3ZhYmxlIG5vZGVzLCBzZWxlY3RlZCBieSB0aGVcbiAqICAgICAgIHJlbGF0aW9uc2hpcCBwYXJhbWV0ZXIsIGFyZSBpbmNsdWRlZCBpbiB0aGUgZ3JhcGggKHdpdGhvdXQgaGllcmFyY2h5KS5cbiAqICAgIDQuIEVkZ2VzIGluY2lkZW50IG9uIG1vdmFibGUgbm9kZXMsIHNlbGVjdGVkIGJ5IHRoZSByZWxhdGlvbnNoaXBcbiAqICAgICAgIHBhcmFtZXRlciwgYXJlIGFkZGVkIHRvIHRoZSBvdXRwdXQgZ3JhcGguXG4gKiAgICA1LiBUaGUgd2VpZ2h0cyBmb3IgY29waWVkIGVkZ2VzIGFyZSBhZ2dyZWdhdGVkIGFzIG5lZWQsIHNpbmNlIHRoZSBvdXRwdXRcbiAqICAgICAgIGdyYXBoIGlzIG5vdCBhIG11bHRpLWdyYXBoLlxuICovXG5mdW5jdGlvbiBidWlsZExheWVyR3JhcGgoZywgcmFuaywgcmVsYXRpb25zaGlwKSB7XG4gIHZhciByb290ID0gY3JlYXRlUm9vdE5vZGUoZyksXG4gICAgcmVzdWx0ID0gbmV3IEdyYXBoKHsgY29tcG91bmQ6IHRydWUgfSkuc2V0R3JhcGgoeyByb290OiByb290IH0pXG4gICAgICAuc2V0RGVmYXVsdE5vZGVMYWJlbChmdW5jdGlvbih2KSB7IHJldHVybiBnLm5vZGUodik7IH0pO1xuXG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgbm9kZSA9IGcubm9kZSh2KSxcbiAgICAgIHBhcmVudCA9IGcucGFyZW50KHYpO1xuXG4gICAgaWYgKG5vZGUucmFuayA9PT0gcmFuayB8fCBub2RlLm1pblJhbmsgPD0gcmFuayAmJiByYW5rIDw9IG5vZGUubWF4UmFuaykge1xuICAgICAgcmVzdWx0LnNldE5vZGUodik7XG4gICAgICByZXN1bHQuc2V0UGFyZW50KHYsIHBhcmVudCB8fCByb290KTtcblxuICAgICAgLy8gVGhpcyBhc3N1bWVzIHdlIGhhdmUgb25seSBzaG9ydCBlZGdlcyFcbiAgICAgIF8uZm9yRWFjaChnW3JlbGF0aW9uc2hpcF0odiksIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIHUgPSBlLnYgPT09IHYgPyBlLncgOiBlLnYsXG4gICAgICAgICAgZWRnZSA9IHJlc3VsdC5lZGdlKHUsIHYpLFxuICAgICAgICAgIHdlaWdodCA9ICFfLmlzVW5kZWZpbmVkKGVkZ2UpID8gZWRnZS53ZWlnaHQgOiAwO1xuICAgICAgICByZXN1bHQuc2V0RWRnZSh1LCB2LCB7IHdlaWdodDogZy5lZGdlKGUpLndlaWdodCArIHdlaWdodCB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoXy5oYXMobm9kZSwgXCJtaW5SYW5rXCIpKSB7XG4gICAgICAgIHJlc3VsdC5zZXROb2RlKHYsIHtcbiAgICAgICAgICBib3JkZXJMZWZ0OiBub2RlLmJvcmRlckxlZnRbcmFua10sXG4gICAgICAgICAgYm9yZGVyUmlnaHQ6IG5vZGUuYm9yZGVyUmlnaHRbcmFua11cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSb290Tm9kZShnKSB7XG4gIHZhciB2O1xuICB3aGlsZSAoZy5oYXNOb2RlKCh2ID0gXy51bmlxdWVJZChcIl9yb290XCIpKSkpO1xuICByZXR1cm4gdjtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gY3Jvc3NDb3VudDtcblxuLypcbiAqIEEgZnVuY3Rpb24gdGhhdCB0YWtlcyBhIGxheWVyaW5nIChhbiBhcnJheSBvZiBsYXllcnMsIGVhY2ggd2l0aCBhbiBhcnJheSBvZlxuICogb3JkZXJlcmQgbm9kZXMpIGFuZCBhIGdyYXBoIGFuZCByZXR1cm5zIGEgd2VpZ2h0ZWQgY3Jvc3NpbmcgY291bnQuXG4gKlxuICogUHJlLWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gSW5wdXQgZ3JhcGggbXVzdCBiZSBzaW1wbGUgKG5vdCBhIG11bHRpZ3JhcGgpLCBkaXJlY3RlZCwgYW5kIGluY2x1ZGVcbiAqICAgICAgIG9ubHkgc2ltcGxlIGVkZ2VzLlxuICogICAgMi4gRWRnZXMgaW4gdGhlIGlucHV0IGdyYXBoIG11c3QgaGF2ZSBhc3NpZ25lZCB3ZWlnaHRzLlxuICpcbiAqIFBvc3QtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBUaGUgZ3JhcGggYW5kIGxheWVyaW5nIG1hdHJpeCBhcmUgbGVmdCB1bmNoYW5nZWQuXG4gKlxuICogVGhpcyBhbGdvcml0aG0gaXMgZGVyaXZlZCBmcm9tIEJhcnRoLCBldCBhbC4sIFwiQmlsYXllciBDcm9zcyBDb3VudGluZy5cIlxuICovXG5mdW5jdGlvbiBjcm9zc0NvdW50KGcsIGxheWVyaW5nKSB7XG4gIHZhciBjYyA9IDA7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgbGF5ZXJpbmcubGVuZ3RoOyArK2kpIHtcbiAgICBjYyArPSB0d29MYXllckNyb3NzQ291bnQoZywgbGF5ZXJpbmdbaS0xXSwgbGF5ZXJpbmdbaV0pO1xuICB9XG4gIHJldHVybiBjYztcbn1cblxuZnVuY3Rpb24gdHdvTGF5ZXJDcm9zc0NvdW50KGcsIG5vcnRoTGF5ZXIsIHNvdXRoTGF5ZXIpIHtcbiAgLy8gU29ydCBhbGwgb2YgdGhlIGVkZ2VzIGJldHdlZW4gdGhlIG5vcnRoIGFuZCBzb3V0aCBsYXllcnMgYnkgdGhlaXIgcG9zaXRpb25cbiAgLy8gaW4gdGhlIG5vcnRoIGxheWVyIGFuZCB0aGVuIHRoZSBzb3V0aC4gTWFwIHRoZXNlIGVkZ2VzIHRvIHRoZSBwb3NpdGlvbiBvZlxuICAvLyB0aGVpciBoZWFkIGluIHRoZSBzb3V0aCBsYXllci5cbiAgdmFyIHNvdXRoUG9zID0gXy56aXBPYmplY3Qoc291dGhMYXllcixcbiAgICBfLm1hcChzb3V0aExheWVyLCBmdW5jdGlvbiAodiwgaSkgeyByZXR1cm4gaTsgfSkpO1xuICB2YXIgc291dGhFbnRyaWVzID0gXy5mbGF0dGVuKF8ubWFwKG5vcnRoTGF5ZXIsIGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gXy5zb3J0QnkoXy5tYXAoZy5vdXRFZGdlcyh2KSwgZnVuY3Rpb24oZSkge1xuICAgICAgcmV0dXJuIHsgcG9zOiBzb3V0aFBvc1tlLnddLCB3ZWlnaHQ6IGcuZWRnZShlKS53ZWlnaHQgfTtcbiAgICB9KSwgXCJwb3NcIik7XG4gIH0pLCB0cnVlKTtcblxuICAvLyBCdWlsZCB0aGUgYWNjdW11bGF0b3IgdHJlZVxuICB2YXIgZmlyc3RJbmRleCA9IDE7XG4gIHdoaWxlIChmaXJzdEluZGV4IDwgc291dGhMYXllci5sZW5ndGgpIGZpcnN0SW5kZXggPDw9IDE7XG4gIHZhciB0cmVlU2l6ZSA9IDIgKiBmaXJzdEluZGV4IC0gMTtcbiAgZmlyc3RJbmRleCAtPSAxO1xuICB2YXIgdHJlZSA9IF8ubWFwKG5ldyBBcnJheSh0cmVlU2l6ZSksIGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfSk7XG5cbiAgLy8gQ2FsY3VsYXRlIHRoZSB3ZWlnaHRlZCBjcm9zc2luZ3NcbiAgdmFyIGNjID0gMDtcbiAgXy5mb3JFYWNoKHNvdXRoRW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgdmFyIGluZGV4ID0gZW50cnkucG9zICsgZmlyc3RJbmRleDtcbiAgICB0cmVlW2luZGV4XSArPSBlbnRyeS53ZWlnaHQ7XG4gICAgdmFyIHdlaWdodFN1bSA9IDA7XG4gICAgd2hpbGUgKGluZGV4ID4gMCkge1xuICAgICAgaWYgKGluZGV4ICUgMikge1xuICAgICAgICB3ZWlnaHRTdW0gKz0gdHJlZVtpbmRleCArIDFdO1xuICAgICAgfVxuICAgICAgaW5kZXggPSAoaW5kZXggLSAxKSA+PiAxO1xuICAgICAgdHJlZVtpbmRleF0gKz0gZW50cnkud2VpZ2h0O1xuICAgIH1cbiAgICBjYyArPSBlbnRyeS53ZWlnaHQgKiB3ZWlnaHRTdW07XG4gIH0pKTtcblxuICByZXR1cm4gY2M7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xudmFyIGluaXRPcmRlciA9IHJlcXVpcmUoXCIuL2luaXQtb3JkZXJcIik7XG52YXIgY3Jvc3NDb3VudCA9IHJlcXVpcmUoXCIuL2Nyb3NzLWNvdW50XCIpO1xudmFyIHNvcnRTdWJncmFwaCA9IHJlcXVpcmUoXCIuL3NvcnQtc3ViZ3JhcGhcIik7XG52YXIgYnVpbGRMYXllckdyYXBoID0gcmVxdWlyZShcIi4vYnVpbGQtbGF5ZXItZ3JhcGhcIik7XG52YXIgYWRkU3ViZ3JhcGhDb25zdHJhaW50cyA9IHJlcXVpcmUoXCIuL2FkZC1zdWJncmFwaC1jb25zdHJhaW50c1wiKTtcbnZhciBHcmFwaCA9IHJlcXVpcmUoXCIuLi9ncmFwaGxpYlwiKS5HcmFwaDtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gb3JkZXI7XG5cbi8qXG4gKiBBcHBsaWVzIGhldXJpc3RpY3MgdG8gbWluaW1pemUgZWRnZSBjcm9zc2luZ3MgaW4gdGhlIGdyYXBoIGFuZCBzZXRzIHRoZSBiZXN0XG4gKiBvcmRlciBzb2x1dGlvbiBhcyBhbiBvcmRlciBhdHRyaWJ1dGUgb24gZWFjaCBub2RlLlxuICpcbiAqIFByZS1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIEdyYXBoIG11c3QgYmUgREFHXG4gKiAgICAyLiBHcmFwaCBub2RlcyBtdXN0IGJlIG9iamVjdHMgd2l0aCBhIFwicmFua1wiIGF0dHJpYnV0ZVxuICogICAgMy4gR3JhcGggZWRnZXMgbXVzdCBoYXZlIHRoZSBcIndlaWdodFwiIGF0dHJpYnV0ZVxuICpcbiAqIFBvc3QtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBHcmFwaCBub2RlcyB3aWxsIGhhdmUgYW4gXCJvcmRlclwiIGF0dHJpYnV0ZSBiYXNlZCBvbiB0aGUgcmVzdWx0cyBvZiB0aGVcbiAqICAgICAgIGFsZ29yaXRobS5cbiAqL1xuZnVuY3Rpb24gb3JkZXIoZykge1xuICB2YXIgbWF4UmFuayA9IHV0aWwubWF4UmFuayhnKSxcbiAgICBkb3duTGF5ZXJHcmFwaHMgPSBidWlsZExheWVyR3JhcGhzKGcsIF8ucmFuZ2UoMSwgbWF4UmFuayArIDEpLCBcImluRWRnZXNcIiksXG4gICAgdXBMYXllckdyYXBocyA9IGJ1aWxkTGF5ZXJHcmFwaHMoZywgXy5yYW5nZShtYXhSYW5rIC0gMSwgLTEsIC0xKSwgXCJvdXRFZGdlc1wiKTtcblxuICB2YXIgbGF5ZXJpbmcgPSBpbml0T3JkZXIoZyk7XG4gIGFzc2lnbk9yZGVyKGcsIGxheWVyaW5nKTtcblxuICB2YXIgYmVzdENDID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLFxuICAgIGJlc3Q7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxhc3RCZXN0ID0gMDsgbGFzdEJlc3QgPCA0OyArK2ksICsrbGFzdEJlc3QpIHtcbiAgICBzd2VlcExheWVyR3JhcGhzKGkgJSAyID8gZG93bkxheWVyR3JhcGhzIDogdXBMYXllckdyYXBocywgaSAlIDQgPj0gMik7XG5cbiAgICBsYXllcmluZyA9IHV0aWwuYnVpbGRMYXllck1hdHJpeChnKTtcbiAgICB2YXIgY2MgPSBjcm9zc0NvdW50KGcsIGxheWVyaW5nKTtcbiAgICBpZiAoY2MgPCBiZXN0Q0MpIHtcbiAgICAgIGxhc3RCZXN0ID0gMDtcbiAgICAgIGJlc3QgPSBfLmNsb25lRGVlcChsYXllcmluZyk7XG4gICAgICBiZXN0Q0MgPSBjYztcbiAgICB9XG4gIH1cblxuICBhc3NpZ25PcmRlcihnLCBiZXN0KTtcbn1cblxuZnVuY3Rpb24gYnVpbGRMYXllckdyYXBocyhnLCByYW5rcywgcmVsYXRpb25zaGlwKSB7XG4gIHJldHVybiBfLm1hcChyYW5rcywgZnVuY3Rpb24ocmFuaykge1xuICAgIHJldHVybiBidWlsZExheWVyR3JhcGgoZywgcmFuaywgcmVsYXRpb25zaGlwKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHN3ZWVwTGF5ZXJHcmFwaHMobGF5ZXJHcmFwaHMsIGJpYXNSaWdodCkge1xuICB2YXIgY2cgPSBuZXcgR3JhcGgoKTtcbiAgXy5mb3JFYWNoKGxheWVyR3JhcGhzLCBmdW5jdGlvbihsZykge1xuICAgIHZhciByb290ID0gbGcuZ3JhcGgoKS5yb290O1xuICAgIHZhciBzb3J0ZWQgPSBzb3J0U3ViZ3JhcGgobGcsIHJvb3QsIGNnLCBiaWFzUmlnaHQpO1xuICAgIF8uZm9yRWFjaChzb3J0ZWQudnMsIGZ1bmN0aW9uKHYsIGkpIHtcbiAgICAgIGxnLm5vZGUodikub3JkZXIgPSBpO1xuICAgIH0pO1xuICAgIGFkZFN1YmdyYXBoQ29uc3RyYWludHMobGcsIGNnLCBzb3J0ZWQudnMpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYXNzaWduT3JkZXIoZywgbGF5ZXJpbmcpIHtcbiAgXy5mb3JFYWNoKGxheWVyaW5nLCBmdW5jdGlvbihsYXllcikge1xuICAgIF8uZm9yRWFjaChsYXllciwgZnVuY3Rpb24odiwgaSkge1xuICAgICAgZy5ub2RlKHYpLm9yZGVyID0gaTtcbiAgICB9KTtcbiAgfSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGluaXRPcmRlcjtcblxuLypcbiAqIEFzc2lnbnMgYW4gaW5pdGlhbCBvcmRlciB2YWx1ZSBmb3IgZWFjaCBub2RlIGJ5IHBlcmZvcm1pbmcgYSBERlMgc2VhcmNoXG4gKiBzdGFydGluZyBmcm9tIG5vZGVzIGluIHRoZSBmaXJzdCByYW5rLiBOb2RlcyBhcmUgYXNzaWduZWQgYW4gb3JkZXIgaW4gdGhlaXJcbiAqIHJhbmsgYXMgdGhleSBhcmUgZmlyc3QgdmlzaXRlZC5cbiAqXG4gKiBUaGlzIGFwcHJvYWNoIGNvbWVzIGZyb20gR2Fuc25lciwgZXQgYWwuLCBcIkEgVGVjaG5pcXVlIGZvciBEcmF3aW5nIERpcmVjdGVkXG4gKiBHcmFwaHMuXCJcbiAqXG4gKiBSZXR1cm5zIGEgbGF5ZXJpbmcgbWF0cml4IHdpdGggYW4gYXJyYXkgcGVyIGxheWVyIGFuZCBlYWNoIGxheWVyIHNvcnRlZCBieVxuICogdGhlIG9yZGVyIG9mIGl0cyBub2Rlcy5cbiAqL1xuZnVuY3Rpb24gaW5pdE9yZGVyKGcpIHtcbiAgdmFyIHZpc2l0ZWQgPSB7fTtcbiAgdmFyIHNpbXBsZU5vZGVzID0gXy5maWx0ZXIoZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgcmV0dXJuICFnLmNoaWxkcmVuKHYpLmxlbmd0aDtcbiAgfSk7XG4gIHZhciBtYXhSYW5rID0gXy5tYXgoXy5tYXAoc2ltcGxlTm9kZXMsIGZ1bmN0aW9uKHYpIHsgcmV0dXJuIGcubm9kZSh2KS5yYW5rOyB9KSk7XG4gIHZhciBsYXllcnMgPSBfLm1hcChfLnJhbmdlKG1heFJhbmsgKyAxKSwgZnVuY3Rpb24oKSB7IHJldHVybiBbXTsgfSk7XG5cbiAgZnVuY3Rpb24gZGZzKHYpIHtcbiAgICBpZiAoXy5oYXModmlzaXRlZCwgdikpIHJldHVybjtcbiAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcbiAgICB2YXIgbm9kZSA9IGcubm9kZSh2KTtcbiAgICBsYXllcnNbbm9kZS5yYW5rXS5wdXNoKHYpO1xuICAgIF8uZm9yRWFjaChnLnN1Y2Nlc3NvcnModiksIGRmcyk7XG4gIH1cblxuICB2YXIgb3JkZXJlZFZzID0gXy5zb3J0Qnkoc2ltcGxlTm9kZXMsIGZ1bmN0aW9uKHYpIHsgcmV0dXJuIGcubm9kZSh2KS5yYW5rOyB9KTtcbiAgXy5mb3JFYWNoKG9yZGVyZWRWcywgZGZzKTtcblxuICByZXR1cm4gbGF5ZXJzO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXNvbHZlQ29uZmxpY3RzO1xuXG4vKlxuICogR2l2ZW4gYSBsaXN0IG9mIGVudHJpZXMgb2YgdGhlIGZvcm0ge3YsIGJhcnljZW50ZXIsIHdlaWdodH0gYW5kIGFcbiAqIGNvbnN0cmFpbnQgZ3JhcGggdGhpcyBmdW5jdGlvbiB3aWxsIHJlc29sdmUgYW55IGNvbmZsaWN0cyBiZXR3ZWVuIHRoZVxuICogY29uc3RyYWludCBncmFwaCBhbmQgdGhlIGJhcnljZW50ZXJzIGZvciB0aGUgZW50cmllcy4gSWYgdGhlIGJhcnljZW50ZXJzIGZvclxuICogYW4gZW50cnkgd291bGQgdmlvbGF0ZSBhIGNvbnN0cmFpbnQgaW4gdGhlIGNvbnN0cmFpbnQgZ3JhcGggdGhlbiB3ZSBjb2FsZXNjZVxuICogdGhlIG5vZGVzIGluIHRoZSBjb25mbGljdCBpbnRvIGEgbmV3IG5vZGUgdGhhdCByZXNwZWN0cyB0aGUgY29udHJhaW50IGFuZFxuICogYWdncmVnYXRlcyBiYXJ5Y2VudGVyIGFuZCB3ZWlnaHQgaW5mb3JtYXRpb24uXG4gKlxuICogVGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiB0aGUgZGVzY3JpcHRpb24gaW4gRm9yc3RlciwgXCJBIEZhc3QgYW5kXG4gKiBTaW1wbGUgSHVlcmlzdGljIGZvciBDb25zdHJhaW5lZCBUd28tTGV2ZWwgQ3Jvc3NpbmcgUmVkdWN0aW9uLFwiIHRob3VnaHQgaXRcbiAqIGRpZmZlcnMgaW4gc29tZSBzcGVjaWZpYyBkZXRhaWxzLlxuICpcbiAqIFByZS1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIEVhY2ggZW50cnkgaGFzIHRoZSBmb3JtIHt2LCBiYXJ5Y2VudGVyLCB3ZWlnaHR9LCBvciBpZiB0aGUgbm9kZSBoYXNcbiAqICAgICAgIG5vIGJhcnljZW50ZXIsIHRoZW4ge3Z9LlxuICpcbiAqIFJldHVybnM6XG4gKlxuICogICAgQSBuZXcgbGlzdCBvZiBlbnRyaWVzIG9mIHRoZSBmb3JtIHt2cywgaSwgYmFyeWNlbnRlciwgd2VpZ2h0fS4gVGhlIGxpc3RcbiAqICAgIGB2c2AgbWF5IGVpdGhlciBiZSBhIHNpbmdsZXRvbiBvciBpdCBtYXkgYmUgYW4gYWdncmVnYXRpb24gb2Ygbm9kZXNcbiAqICAgIG9yZGVyZWQgc3VjaCB0aGF0IHRoZXkgZG8gbm90IHZpb2xhdGUgY29uc3RyYWludHMgZnJvbSB0aGUgY29uc3RyYWludFxuICogICAgZ3JhcGguIFRoZSBwcm9wZXJ0eSBgaWAgaXMgdGhlIGxvd2VzdCBvcmlnaW5hbCBpbmRleCBvZiBhbnkgb2YgdGhlXG4gKiAgICBlbGVtZW50cyBpbiBgdnNgLlxuICovXG5mdW5jdGlvbiByZXNvbHZlQ29uZmxpY3RzKGVudHJpZXMsIGNnKSB7XG4gIHZhciBtYXBwZWRFbnRyaWVzID0ge307XG4gIF8uZm9yRWFjaChlbnRyaWVzLCBmdW5jdGlvbihlbnRyeSwgaSkge1xuICAgIHZhciB0bXAgPSBtYXBwZWRFbnRyaWVzW2VudHJ5LnZdID0ge1xuICAgICAgaW5kZWdyZWU6IDAsXG4gICAgICBcImluXCI6IFtdLFxuICAgICAgb3V0OiBbXSxcbiAgICAgIHZzOiBbZW50cnkudl0sXG4gICAgICBpOiBpXG4gICAgfTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoZW50cnkuYmFyeWNlbnRlcikpIHtcbiAgICAgIHRtcC5iYXJ5Y2VudGVyID0gZW50cnkuYmFyeWNlbnRlcjtcbiAgICAgIHRtcC53ZWlnaHQgPSBlbnRyeS53ZWlnaHQ7XG4gICAgfVxuICB9KTtcblxuICBfLmZvckVhY2goY2cuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBlbnRyeVYgPSBtYXBwZWRFbnRyaWVzW2Uudl07XG4gICAgdmFyIGVudHJ5VyA9IG1hcHBlZEVudHJpZXNbZS53XTtcbiAgICBpZiAoIV8uaXNVbmRlZmluZWQoZW50cnlWKSAmJiAhXy5pc1VuZGVmaW5lZChlbnRyeVcpKSB7XG4gICAgICBlbnRyeVcuaW5kZWdyZWUrKztcbiAgICAgIGVudHJ5Vi5vdXQucHVzaChtYXBwZWRFbnRyaWVzW2Uud10pO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHNvdXJjZVNldCA9IF8uZmlsdGVyKG1hcHBlZEVudHJpZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgcmV0dXJuICFlbnRyeS5pbmRlZ3JlZTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRvUmVzb2x2ZUNvbmZsaWN0cyhzb3VyY2VTZXQpO1xufVxuXG5mdW5jdGlvbiBkb1Jlc29sdmVDb25mbGljdHMoc291cmNlU2V0KSB7XG4gIHZhciBlbnRyaWVzID0gW107XG5cbiAgZnVuY3Rpb24gaGFuZGxlSW4odkVudHJ5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHVFbnRyeSkge1xuICAgICAgaWYgKHVFbnRyeS5tZXJnZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKF8uaXNVbmRlZmluZWQodUVudHJ5LmJhcnljZW50ZXIpIHx8XG4gICAgICAgICAgXy5pc1VuZGVmaW5lZCh2RW50cnkuYmFyeWNlbnRlcikgfHxcbiAgICAgICAgICB1RW50cnkuYmFyeWNlbnRlciA+PSB2RW50cnkuYmFyeWNlbnRlcikge1xuICAgICAgICBtZXJnZUVudHJpZXModkVudHJ5LCB1RW50cnkpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVPdXQodkVudHJ5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHdFbnRyeSkge1xuICAgICAgd0VudHJ5W1wiaW5cIl0ucHVzaCh2RW50cnkpO1xuICAgICAgaWYgKC0td0VudHJ5LmluZGVncmVlID09PSAwKSB7XG4gICAgICAgIHNvdXJjZVNldC5wdXNoKHdFbnRyeSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHdoaWxlIChzb3VyY2VTZXQubGVuZ3RoKSB7XG4gICAgdmFyIGVudHJ5ID0gc291cmNlU2V0LnBvcCgpO1xuICAgIGVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgXy5mb3JFYWNoKGVudHJ5W1wiaW5cIl0ucmV2ZXJzZSgpLCBoYW5kbGVJbihlbnRyeSkpO1xuICAgIF8uZm9yRWFjaChlbnRyeS5vdXQsIGhhbmRsZU91dChlbnRyeSkpO1xuICB9XG5cbiAgcmV0dXJuIF8ubWFwKF8uZmlsdGVyKGVudHJpZXMsIGZ1bmN0aW9uKGVudHJ5KSB7IHJldHVybiAhZW50cnkubWVyZ2VkOyB9KSxcbiAgICBmdW5jdGlvbihlbnRyeSkge1xuICAgICAgcmV0dXJuIF8ucGljayhlbnRyeSwgW1widnNcIiwgXCJpXCIsIFwiYmFyeWNlbnRlclwiLCBcIndlaWdodFwiXSk7XG4gICAgfSk7XG5cbn1cblxuZnVuY3Rpb24gbWVyZ2VFbnRyaWVzKHRhcmdldCwgc291cmNlKSB7XG4gIHZhciBzdW0gPSAwO1xuICB2YXIgd2VpZ2h0ID0gMDtcblxuICBpZiAodGFyZ2V0LndlaWdodCkge1xuICAgIHN1bSArPSB0YXJnZXQuYmFyeWNlbnRlciAqIHRhcmdldC53ZWlnaHQ7XG4gICAgd2VpZ2h0ICs9IHRhcmdldC53ZWlnaHQ7XG4gIH1cblxuICBpZiAoc291cmNlLndlaWdodCkge1xuICAgIHN1bSArPSBzb3VyY2UuYmFyeWNlbnRlciAqIHNvdXJjZS53ZWlnaHQ7XG4gICAgd2VpZ2h0ICs9IHNvdXJjZS53ZWlnaHQ7XG4gIH1cblxuICB0YXJnZXQudnMgPSBzb3VyY2UudnMuY29uY2F0KHRhcmdldC52cyk7XG4gIHRhcmdldC5iYXJ5Y2VudGVyID0gc3VtIC8gd2VpZ2h0O1xuICB0YXJnZXQud2VpZ2h0ID0gd2VpZ2h0O1xuICB0YXJnZXQuaSA9IE1hdGgubWluKHNvdXJjZS5pLCB0YXJnZXQuaSk7XG4gIHNvdXJjZS5tZXJnZWQgPSB0cnVlO1xufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xudmFyIGJhcnljZW50ZXIgPSByZXF1aXJlKFwiLi9iYXJ5Y2VudGVyXCIpO1xudmFyIHJlc29sdmVDb25mbGljdHMgPSByZXF1aXJlKFwiLi9yZXNvbHZlLWNvbmZsaWN0c1wiKTtcbnZhciBzb3J0ID0gcmVxdWlyZShcIi4vc29ydFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzb3J0U3ViZ3JhcGg7XG5cbmZ1bmN0aW9uIHNvcnRTdWJncmFwaChnLCB2LCBjZywgYmlhc1JpZ2h0KSB7XG4gIHZhciBtb3ZhYmxlID0gZy5jaGlsZHJlbih2KTtcbiAgdmFyIG5vZGUgPSBnLm5vZGUodik7XG4gIHZhciBibCA9IG5vZGUgPyBub2RlLmJvcmRlckxlZnQgOiB1bmRlZmluZWQ7XG4gIHZhciBiciA9IG5vZGUgPyBub2RlLmJvcmRlclJpZ2h0OiB1bmRlZmluZWQ7XG4gIHZhciBzdWJncmFwaHMgPSB7fTtcblxuICBpZiAoYmwpIHtcbiAgICBtb3ZhYmxlID0gXy5maWx0ZXIobW92YWJsZSwgZnVuY3Rpb24odykge1xuICAgICAgcmV0dXJuIHcgIT09IGJsICYmIHcgIT09IGJyO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGJhcnljZW50ZXJzID0gYmFyeWNlbnRlcihnLCBtb3ZhYmxlKTtcbiAgXy5mb3JFYWNoKGJhcnljZW50ZXJzLCBmdW5jdGlvbihlbnRyeSkge1xuICAgIGlmIChnLmNoaWxkcmVuKGVudHJ5LnYpLmxlbmd0aCkge1xuICAgICAgdmFyIHN1YmdyYXBoUmVzdWx0ID0gc29ydFN1YmdyYXBoKGcsIGVudHJ5LnYsIGNnLCBiaWFzUmlnaHQpO1xuICAgICAgc3ViZ3JhcGhzW2VudHJ5LnZdID0gc3ViZ3JhcGhSZXN1bHQ7XG4gICAgICBpZiAoXy5oYXMoc3ViZ3JhcGhSZXN1bHQsIFwiYmFyeWNlbnRlclwiKSkge1xuICAgICAgICBtZXJnZUJhcnljZW50ZXJzKGVudHJ5LCBzdWJncmFwaFJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICB2YXIgZW50cmllcyA9IHJlc29sdmVDb25mbGljdHMoYmFyeWNlbnRlcnMsIGNnKTtcbiAgZXhwYW5kU3ViZ3JhcGhzKGVudHJpZXMsIHN1YmdyYXBocyk7XG5cbiAgdmFyIHJlc3VsdCA9IHNvcnQoZW50cmllcywgYmlhc1JpZ2h0KTtcblxuICBpZiAoYmwpIHtcbiAgICByZXN1bHQudnMgPSBfLmZsYXR0ZW4oW2JsLCByZXN1bHQudnMsIGJyXSwgdHJ1ZSk7XG4gICAgaWYgKGcucHJlZGVjZXNzb3JzKGJsKS5sZW5ndGgpIHtcbiAgICAgIHZhciBibFByZWQgPSBnLm5vZGUoZy5wcmVkZWNlc3NvcnMoYmwpWzBdKSxcbiAgICAgICAgYnJQcmVkID0gZy5ub2RlKGcucHJlZGVjZXNzb3JzKGJyKVswXSk7XG4gICAgICBpZiAoIV8uaGFzKHJlc3VsdCwgXCJiYXJ5Y2VudGVyXCIpKSB7XG4gICAgICAgIHJlc3VsdC5iYXJ5Y2VudGVyID0gMDtcbiAgICAgICAgcmVzdWx0LndlaWdodCA9IDA7XG4gICAgICB9XG4gICAgICByZXN1bHQuYmFyeWNlbnRlciA9IChyZXN1bHQuYmFyeWNlbnRlciAqIHJlc3VsdC53ZWlnaHQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxQcmVkLm9yZGVyICsgYnJQcmVkLm9yZGVyKSAvIChyZXN1bHQud2VpZ2h0ICsgMik7XG4gICAgICByZXN1bHQud2VpZ2h0ICs9IDI7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZXhwYW5kU3ViZ3JhcGhzKGVudHJpZXMsIHN1YmdyYXBocykge1xuICBfLmZvckVhY2goZW50cmllcywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICBlbnRyeS52cyA9IF8uZmxhdHRlbihlbnRyeS52cy5tYXAoZnVuY3Rpb24odikge1xuICAgICAgaWYgKHN1YmdyYXBoc1t2XSkge1xuICAgICAgICByZXR1cm4gc3ViZ3JhcGhzW3ZdLnZzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHY7XG4gICAgfSksIHRydWUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gbWVyZ2VCYXJ5Y2VudGVycyh0YXJnZXQsIG90aGVyKSB7XG4gIGlmICghXy5pc1VuZGVmaW5lZCh0YXJnZXQuYmFyeWNlbnRlcikpIHtcbiAgICB0YXJnZXQuYmFyeWNlbnRlciA9ICh0YXJnZXQuYmFyeWNlbnRlciAqIHRhcmdldC53ZWlnaHQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgIG90aGVyLmJhcnljZW50ZXIgKiBvdGhlci53ZWlnaHQpIC9cbiAgICAgICAgICAgICAgICAgICAgICAgICh0YXJnZXQud2VpZ2h0ICsgb3RoZXIud2VpZ2h0KTtcbiAgICB0YXJnZXQud2VpZ2h0ICs9IG90aGVyLndlaWdodDtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuYmFyeWNlbnRlciA9IG90aGVyLmJhcnljZW50ZXI7XG4gICAgdGFyZ2V0LndlaWdodCA9IG90aGVyLndlaWdodDtcbiAgfVxufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzb3J0O1xuXG5mdW5jdGlvbiBzb3J0KGVudHJpZXMsIGJpYXNSaWdodCkge1xuICB2YXIgcGFydHMgPSB1dGlsLnBhcnRpdGlvbihlbnRyaWVzLCBmdW5jdGlvbihlbnRyeSkge1xuICAgIHJldHVybiBfLmhhcyhlbnRyeSwgXCJiYXJ5Y2VudGVyXCIpO1xuICB9KTtcbiAgdmFyIHNvcnRhYmxlID0gcGFydHMubGhzLFxuICAgIHVuc29ydGFibGUgPSBfLnNvcnRCeShwYXJ0cy5yaHMsIGZ1bmN0aW9uKGVudHJ5KSB7IHJldHVybiAtZW50cnkuaTsgfSksXG4gICAgdnMgPSBbXSxcbiAgICBzdW0gPSAwLFxuICAgIHdlaWdodCA9IDAsXG4gICAgdnNJbmRleCA9IDA7XG5cbiAgc29ydGFibGUuc29ydChjb21wYXJlV2l0aEJpYXMoISFiaWFzUmlnaHQpKTtcblxuICB2c0luZGV4ID0gY29uc3VtZVVuc29ydGFibGUodnMsIHVuc29ydGFibGUsIHZzSW5kZXgpO1xuXG4gIF8uZm9yRWFjaChzb3J0YWJsZSwgZnVuY3Rpb24gKGVudHJ5KSB7XG4gICAgdnNJbmRleCArPSBlbnRyeS52cy5sZW5ndGg7XG4gICAgdnMucHVzaChlbnRyeS52cyk7XG4gICAgc3VtICs9IGVudHJ5LmJhcnljZW50ZXIgKiBlbnRyeS53ZWlnaHQ7XG4gICAgd2VpZ2h0ICs9IGVudHJ5LndlaWdodDtcbiAgICB2c0luZGV4ID0gY29uc3VtZVVuc29ydGFibGUodnMsIHVuc29ydGFibGUsIHZzSW5kZXgpO1xuICB9KTtcblxuICB2YXIgcmVzdWx0ID0geyB2czogXy5mbGF0dGVuKHZzLCB0cnVlKSB9O1xuICBpZiAod2VpZ2h0KSB7XG4gICAgcmVzdWx0LmJhcnljZW50ZXIgPSBzdW0gLyB3ZWlnaHQ7XG4gICAgcmVzdWx0LndlaWdodCA9IHdlaWdodDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBjb25zdW1lVW5zb3J0YWJsZSh2cywgdW5zb3J0YWJsZSwgaW5kZXgpIHtcbiAgdmFyIGxhc3Q7XG4gIHdoaWxlICh1bnNvcnRhYmxlLmxlbmd0aCAmJiAobGFzdCA9IF8ubGFzdCh1bnNvcnRhYmxlKSkuaSA8PSBpbmRleCkge1xuICAgIHVuc29ydGFibGUucG9wKCk7XG4gICAgdnMucHVzaChsYXN0LnZzKTtcbiAgICBpbmRleCsrO1xuICB9XG4gIHJldHVybiBpbmRleDtcbn1cblxuZnVuY3Rpb24gY29tcGFyZVdpdGhCaWFzKGJpYXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGVudHJ5ViwgZW50cnlXKSB7XG4gICAgaWYgKGVudHJ5Vi5iYXJ5Y2VudGVyIDwgZW50cnlXLmJhcnljZW50ZXIpIHtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9IGVsc2UgaWYgKGVudHJ5Vi5iYXJ5Y2VudGVyID4gZW50cnlXLmJhcnljZW50ZXIpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiAhYmlhcyA/IGVudHJ5Vi5pIC0gZW50cnlXLmkgOiBlbnRyeVcuaSAtIGVudHJ5Vi5pO1xuICB9O1xufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gcGFyZW50RHVtbXlDaGFpbnM7XG5cbmZ1bmN0aW9uIHBhcmVudER1bW15Q2hhaW5zKGcpIHtcbiAgdmFyIHBvc3RvcmRlck51bXMgPSBwb3N0b3JkZXIoZyk7XG5cbiAgXy5mb3JFYWNoKGcuZ3JhcGgoKS5kdW1teUNoYWlucywgZnVuY3Rpb24odikge1xuICAgIHZhciBub2RlID0gZy5ub2RlKHYpO1xuICAgIHZhciBlZGdlT2JqID0gbm9kZS5lZGdlT2JqO1xuICAgIHZhciBwYXRoRGF0YSA9IGZpbmRQYXRoKGcsIHBvc3RvcmRlck51bXMsIGVkZ2VPYmoudiwgZWRnZU9iai53KTtcbiAgICB2YXIgcGF0aCA9IHBhdGhEYXRhLnBhdGg7XG4gICAgdmFyIGxjYSA9IHBhdGhEYXRhLmxjYTtcbiAgICB2YXIgcGF0aElkeCA9IDA7XG4gICAgdmFyIHBhdGhWID0gcGF0aFtwYXRoSWR4XTtcbiAgICB2YXIgYXNjZW5kaW5nID0gdHJ1ZTtcblxuICAgIHdoaWxlICh2ICE9PSBlZGdlT2JqLncpIHtcbiAgICAgIG5vZGUgPSBnLm5vZGUodik7XG5cbiAgICAgIGlmIChhc2NlbmRpbmcpIHtcbiAgICAgICAgd2hpbGUgKChwYXRoViA9IHBhdGhbcGF0aElkeF0pICE9PSBsY2EgJiZcbiAgICAgICAgICAgICAgIGcubm9kZShwYXRoVikubWF4UmFuayA8IG5vZGUucmFuaykge1xuICAgICAgICAgIHBhdGhJZHgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXRoViA9PT0gbGNhKSB7XG4gICAgICAgICAgYXNjZW5kaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFhc2NlbmRpbmcpIHtcbiAgICAgICAgd2hpbGUgKHBhdGhJZHggPCBwYXRoLmxlbmd0aCAtIDEgJiZcbiAgICAgICAgICAgICAgIGcubm9kZShwYXRoViA9IHBhdGhbcGF0aElkeCArIDFdKS5taW5SYW5rIDw9IG5vZGUucmFuaykge1xuICAgICAgICAgIHBhdGhJZHgrKztcbiAgICAgICAgfVxuICAgICAgICBwYXRoViA9IHBhdGhbcGF0aElkeF07XG4gICAgICB9XG5cbiAgICAgIGcuc2V0UGFyZW50KHYsIHBhdGhWKTtcbiAgICAgIHYgPSBnLnN1Y2Nlc3NvcnModilbMF07XG4gICAgfVxuICB9KTtcbn1cblxuLy8gRmluZCBhIHBhdGggZnJvbSB2IHRvIHcgdGhyb3VnaCB0aGUgbG93ZXN0IGNvbW1vbiBhbmNlc3RvciAoTENBKS4gUmV0dXJuIHRoZVxuLy8gZnVsbCBwYXRoIGFuZCB0aGUgTENBLlxuZnVuY3Rpb24gZmluZFBhdGgoZywgcG9zdG9yZGVyTnVtcywgdiwgdykge1xuICB2YXIgdlBhdGggPSBbXTtcbiAgdmFyIHdQYXRoID0gW107XG4gIHZhciBsb3cgPSBNYXRoLm1pbihwb3N0b3JkZXJOdW1zW3ZdLmxvdywgcG9zdG9yZGVyTnVtc1t3XS5sb3cpO1xuICB2YXIgbGltID0gTWF0aC5tYXgocG9zdG9yZGVyTnVtc1t2XS5saW0sIHBvc3RvcmRlck51bXNbd10ubGltKTtcbiAgdmFyIHBhcmVudDtcbiAgdmFyIGxjYTtcblxuICAvLyBUcmF2ZXJzZSB1cCBmcm9tIHYgdG8gZmluZCB0aGUgTENBXG4gIHBhcmVudCA9IHY7XG4gIGRvIHtcbiAgICBwYXJlbnQgPSBnLnBhcmVudChwYXJlbnQpO1xuICAgIHZQYXRoLnB1c2gocGFyZW50KTtcbiAgfSB3aGlsZSAocGFyZW50ICYmXG4gICAgICAgICAgIChwb3N0b3JkZXJOdW1zW3BhcmVudF0ubG93ID4gbG93IHx8IGxpbSA+IHBvc3RvcmRlck51bXNbcGFyZW50XS5saW0pKTtcbiAgbGNhID0gcGFyZW50O1xuXG4gIC8vIFRyYXZlcnNlIGZyb20gdyB0byBMQ0FcbiAgcGFyZW50ID0gdztcbiAgd2hpbGUgKChwYXJlbnQgPSBnLnBhcmVudChwYXJlbnQpKSAhPT0gbGNhKSB7XG4gICAgd1BhdGgucHVzaChwYXJlbnQpO1xuICB9XG5cbiAgcmV0dXJuIHsgcGF0aDogdlBhdGguY29uY2F0KHdQYXRoLnJldmVyc2UoKSksIGxjYTogbGNhIH07XG59XG5cbmZ1bmN0aW9uIHBvc3RvcmRlcihnKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdmFyIGxpbSA9IDA7XG5cbiAgZnVuY3Rpb24gZGZzKHYpIHtcbiAgICB2YXIgbG93ID0gbGltO1xuICAgIF8uZm9yRWFjaChnLmNoaWxkcmVuKHYpLCBkZnMpO1xuICAgIHJlc3VsdFt2XSA9IHsgbG93OiBsb3csIGxpbTogbGltKysgfTtcbiAgfVxuICBfLmZvckVhY2goZy5jaGlsZHJlbigpLCBkZnMpO1xuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xudmFyIEdyYXBoID0gcmVxdWlyZShcIi4uL2dyYXBobGliXCIpLkdyYXBoO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcblxuLypcbiAqIFRoaXMgbW9kdWxlIHByb3ZpZGVzIGNvb3JkaW5hdGUgYXNzaWdubWVudCBiYXNlZCBvbiBCcmFuZGVzIGFuZCBLw7ZwZiwgXCJGYXN0XG4gKiBhbmQgU2ltcGxlIEhvcml6b250YWwgQ29vcmRpbmF0ZSBBc3NpZ25tZW50LlwiXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHBvc2l0aW9uWDogcG9zaXRpb25YLFxuICBmaW5kVHlwZTFDb25mbGljdHM6IGZpbmRUeXBlMUNvbmZsaWN0cyxcbiAgZmluZFR5cGUyQ29uZmxpY3RzOiBmaW5kVHlwZTJDb25mbGljdHMsXG4gIGFkZENvbmZsaWN0OiBhZGRDb25mbGljdCxcbiAgaGFzQ29uZmxpY3Q6IGhhc0NvbmZsaWN0LFxuICB2ZXJ0aWNhbEFsaWdubWVudDogdmVydGljYWxBbGlnbm1lbnQsXG4gIGhvcml6b250YWxDb21wYWN0aW9uOiBob3Jpem9udGFsQ29tcGFjdGlvbixcbiAgYWxpZ25Db29yZGluYXRlczogYWxpZ25Db29yZGluYXRlcyxcbiAgZmluZFNtYWxsZXN0V2lkdGhBbGlnbm1lbnQ6IGZpbmRTbWFsbGVzdFdpZHRoQWxpZ25tZW50LFxuICBiYWxhbmNlOiBiYWxhbmNlXG59O1xuXG4vKlxuICogTWFya3MgYWxsIGVkZ2VzIGluIHRoZSBncmFwaCB3aXRoIGEgdHlwZS0xIGNvbmZsaWN0IHdpdGggdGhlIFwidHlwZTFDb25mbGljdFwiXG4gKiBwcm9wZXJ0eS4gQSB0eXBlLTEgY29uZmxpY3QgaXMgb25lIHdoZXJlIGEgbm9uLWlubmVyIHNlZ21lbnQgY3Jvc3NlcyBhblxuICogaW5uZXIgc2VnbWVudC4gQW4gaW5uZXIgc2VnbWVudCBpcyBhbiBlZGdlIHdpdGggYm90aCBpbmNpZGVudCBub2RlcyBtYXJrZWRcbiAqIHdpdGggdGhlIFwiZHVtbXlcIiBwcm9wZXJ0eS5cbiAqXG4gKiBUaGlzIGFsZ29yaXRobSBzY2FucyBsYXllciBieSBsYXllciwgc3RhcnRpbmcgd2l0aCB0aGUgc2Vjb25kLCBmb3IgdHlwZS0xXG4gKiBjb25mbGljdHMgYmV0d2VlbiB0aGUgY3VycmVudCBsYXllciBhbmQgdGhlIHByZXZpb3VzIGxheWVyLiBGb3IgZWFjaCBsYXllclxuICogaXQgc2NhbnMgdGhlIG5vZGVzIGZyb20gbGVmdCB0byByaWdodCB1bnRpbCBpdCByZWFjaGVzIG9uZSB0aGF0IGlzIGluY2lkZW50XG4gKiBvbiBhbiBpbm5lciBzZWdtZW50LiBJdCB0aGVuIHNjYW5zIHByZWRlY2Vzc29ycyB0byBkZXRlcm1pbmUgaWYgdGhleSBoYXZlXG4gKiBlZGdlcyB0aGF0IGNyb3NzIHRoYXQgaW5uZXIgc2VnbWVudC4gQXQgdGhlIGVuZCBhIGZpbmFsIHNjYW4gaXMgZG9uZSBmb3IgYWxsXG4gKiBub2RlcyBvbiB0aGUgY3VycmVudCByYW5rIHRvIHNlZSBpZiB0aGV5IGNyb3NzIHRoZSBsYXN0IHZpc2l0ZWQgaW5uZXJcbiAqIHNlZ21lbnQuXG4gKlxuICogVGhpcyBhbGdvcml0aG0gKHNhZmVseSkgYXNzdW1lcyB0aGF0IGEgZHVtbXkgbm9kZSB3aWxsIG9ubHkgYmUgaW5jaWRlbnQgb24gYVxuICogc2luZ2xlIG5vZGUgaW4gdGhlIGxheWVycyBiZWluZyBzY2FubmVkLlxuICovXG5mdW5jdGlvbiBmaW5kVHlwZTFDb25mbGljdHMoZywgbGF5ZXJpbmcpIHtcbiAgdmFyIGNvbmZsaWN0cyA9IHt9O1xuXG4gIGZ1bmN0aW9uIHZpc2l0TGF5ZXIocHJldkxheWVyLCBsYXllcikge1xuICAgIHZhclxuICAgICAgLy8gbGFzdCB2aXNpdGVkIG5vZGUgaW4gdGhlIHByZXZpb3VzIGxheWVyIHRoYXQgaXMgaW5jaWRlbnQgb24gYW4gaW5uZXJcbiAgICAgIC8vIHNlZ21lbnQuXG4gICAgICBrMCA9IDAsXG4gICAgICAvLyBUcmFja3MgdGhlIGxhc3Qgbm9kZSBpbiB0aGlzIGxheWVyIHNjYW5uZWQgZm9yIGNyb3NzaW5ncyB3aXRoIGEgdHlwZS0xXG4gICAgICAvLyBzZWdtZW50LlxuICAgICAgc2NhblBvcyA9IDAsXG4gICAgICBwcmV2TGF5ZXJMZW5ndGggPSBwcmV2TGF5ZXIubGVuZ3RoLFxuICAgICAgbGFzdE5vZGUgPSBfLmxhc3QobGF5ZXIpO1xuXG4gICAgXy5mb3JFYWNoKGxheWVyLCBmdW5jdGlvbih2LCBpKSB7XG4gICAgICB2YXIgdyA9IGZpbmRPdGhlcklubmVyU2VnbWVudE5vZGUoZywgdiksXG4gICAgICAgIGsxID0gdyA/IGcubm9kZSh3KS5vcmRlciA6IHByZXZMYXllckxlbmd0aDtcblxuICAgICAgaWYgKHcgfHwgdiA9PT0gbGFzdE5vZGUpIHtcbiAgICAgICAgXy5mb3JFYWNoKGxheWVyLnNsaWNlKHNjYW5Qb3MsIGkgKzEpLCBmdW5jdGlvbihzY2FuTm9kZSkge1xuICAgICAgICAgIF8uZm9yRWFjaChnLnByZWRlY2Vzc29ycyhzY2FuTm9kZSksIGZ1bmN0aW9uKHUpIHtcbiAgICAgICAgICAgIHZhciB1TGFiZWwgPSBnLm5vZGUodSksXG4gICAgICAgICAgICAgIHVQb3MgPSB1TGFiZWwub3JkZXI7XG4gICAgICAgICAgICBpZiAoKHVQb3MgPCBrMCB8fCBrMSA8IHVQb3MpICYmXG4gICAgICAgICAgICAgICAgISh1TGFiZWwuZHVtbXkgJiYgZy5ub2RlKHNjYW5Ob2RlKS5kdW1teSkpIHtcbiAgICAgICAgICAgICAgYWRkQ29uZmxpY3QoY29uZmxpY3RzLCB1LCBzY2FuTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzY2FuUG9zID0gaSArIDE7XG4gICAgICAgIGswID0gazE7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gbGF5ZXI7XG4gIH1cblxuICBfLnJlZHVjZShsYXllcmluZywgdmlzaXRMYXllcik7XG4gIHJldHVybiBjb25mbGljdHM7XG59XG5cbmZ1bmN0aW9uIGZpbmRUeXBlMkNvbmZsaWN0cyhnLCBsYXllcmluZykge1xuICB2YXIgY29uZmxpY3RzID0ge307XG5cbiAgZnVuY3Rpb24gc2Nhbihzb3V0aCwgc291dGhQb3MsIHNvdXRoRW5kLCBwcmV2Tm9ydGhCb3JkZXIsIG5leHROb3J0aEJvcmRlcikge1xuICAgIHZhciB2O1xuICAgIF8uZm9yRWFjaChfLnJhbmdlKHNvdXRoUG9zLCBzb3V0aEVuZCksIGZ1bmN0aW9uKGkpIHtcbiAgICAgIHYgPSBzb3V0aFtpXTtcbiAgICAgIGlmIChnLm5vZGUodikuZHVtbXkpIHtcbiAgICAgICAgXy5mb3JFYWNoKGcucHJlZGVjZXNzb3JzKHYpLCBmdW5jdGlvbih1KSB7XG4gICAgICAgICAgdmFyIHVOb2RlID0gZy5ub2RlKHUpO1xuICAgICAgICAgIGlmICh1Tm9kZS5kdW1teSAmJlxuICAgICAgICAgICAgICAodU5vZGUub3JkZXIgPCBwcmV2Tm9ydGhCb3JkZXIgfHwgdU5vZGUub3JkZXIgPiBuZXh0Tm9ydGhCb3JkZXIpKSB7XG4gICAgICAgICAgICBhZGRDb25mbGljdChjb25mbGljdHMsIHUsIHYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIHZpc2l0TGF5ZXIobm9ydGgsIHNvdXRoKSB7XG4gICAgdmFyIHByZXZOb3J0aFBvcyA9IC0xLFxuICAgICAgbmV4dE5vcnRoUG9zLFxuICAgICAgc291dGhQb3MgPSAwO1xuXG4gICAgXy5mb3JFYWNoKHNvdXRoLCBmdW5jdGlvbih2LCBzb3V0aExvb2thaGVhZCkge1xuICAgICAgaWYgKGcubm9kZSh2KS5kdW1teSA9PT0gXCJib3JkZXJcIikge1xuICAgICAgICB2YXIgcHJlZGVjZXNzb3JzID0gZy5wcmVkZWNlc3NvcnModik7XG4gICAgICAgIGlmIChwcmVkZWNlc3NvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgbmV4dE5vcnRoUG9zID0gZy5ub2RlKHByZWRlY2Vzc29yc1swXSkub3JkZXI7XG4gICAgICAgICAgc2Nhbihzb3V0aCwgc291dGhQb3MsIHNvdXRoTG9va2FoZWFkLCBwcmV2Tm9ydGhQb3MsIG5leHROb3J0aFBvcyk7XG4gICAgICAgICAgc291dGhQb3MgPSBzb3V0aExvb2thaGVhZDtcbiAgICAgICAgICBwcmV2Tm9ydGhQb3MgPSBuZXh0Tm9ydGhQb3M7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHNjYW4oc291dGgsIHNvdXRoUG9zLCBzb3V0aC5sZW5ndGgsIG5leHROb3J0aFBvcywgbm9ydGgubGVuZ3RoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBzb3V0aDtcbiAgfVxuXG4gIF8ucmVkdWNlKGxheWVyaW5nLCB2aXNpdExheWVyKTtcbiAgcmV0dXJuIGNvbmZsaWN0cztcbn1cblxuZnVuY3Rpb24gZmluZE90aGVySW5uZXJTZWdtZW50Tm9kZShnLCB2KSB7XG4gIGlmIChnLm5vZGUodikuZHVtbXkpIHtcbiAgICByZXR1cm4gXy5maW5kKGcucHJlZGVjZXNzb3JzKHYpLCBmdW5jdGlvbih1KSB7XG4gICAgICByZXR1cm4gZy5ub2RlKHUpLmR1bW15O1xuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZENvbmZsaWN0KGNvbmZsaWN0cywgdiwgdykge1xuICBpZiAodiA+IHcpIHtcbiAgICB2YXIgdG1wID0gdjtcbiAgICB2ID0gdztcbiAgICB3ID0gdG1wO1xuICB9XG5cbiAgdmFyIGNvbmZsaWN0c1YgPSBjb25mbGljdHNbdl07XG4gIGlmICghY29uZmxpY3RzVikge1xuICAgIGNvbmZsaWN0c1t2XSA9IGNvbmZsaWN0c1YgPSB7fTtcbiAgfVxuICBjb25mbGljdHNWW3ddID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaGFzQ29uZmxpY3QoY29uZmxpY3RzLCB2LCB3KSB7XG4gIGlmICh2ID4gdykge1xuICAgIHZhciB0bXAgPSB2O1xuICAgIHYgPSB3O1xuICAgIHcgPSB0bXA7XG4gIH1cbiAgcmV0dXJuIF8uaGFzKGNvbmZsaWN0c1t2XSwgdyk7XG59XG5cbi8qXG4gKiBUcnkgdG8gYWxpZ24gbm9kZXMgaW50byB2ZXJ0aWNhbCBcImJsb2Nrc1wiIHdoZXJlIHBvc3NpYmxlLiBUaGlzIGFsZ29yaXRobVxuICogYXR0ZW1wdHMgdG8gYWxpZ24gYSBub2RlIHdpdGggb25lIG9mIGl0cyBtZWRpYW4gbmVpZ2hib3JzLiBJZiB0aGUgZWRnZVxuICogY29ubmVjdGluZyBhIG5laWdoYm9yIGlzIGEgdHlwZS0xIGNvbmZsaWN0IHRoZW4gd2UgaWdub3JlIHRoYXQgcG9zc2liaWxpdHkuXG4gKiBJZiBhIHByZXZpb3VzIG5vZGUgaGFzIGFscmVhZHkgZm9ybWVkIGEgYmxvY2sgd2l0aCBhIG5vZGUgYWZ0ZXIgdGhlIG5vZGVcbiAqIHdlJ3JlIHRyeWluZyB0byBmb3JtIGEgYmxvY2sgd2l0aCwgd2UgYWxzbyBpZ25vcmUgdGhhdCBwb3NzaWJpbGl0eSAtIG91clxuICogYmxvY2tzIHdvdWxkIGJlIHNwbGl0IGluIHRoYXQgc2NlbmFyaW8uXG4gKi9cbmZ1bmN0aW9uIHZlcnRpY2FsQWxpZ25tZW50KGcsIGxheWVyaW5nLCBjb25mbGljdHMsIG5laWdoYm9yRm4pIHtcbiAgdmFyIHJvb3QgPSB7fSxcbiAgICBhbGlnbiA9IHt9LFxuICAgIHBvcyA9IHt9O1xuXG4gIC8vIFdlIGNhY2hlIHRoZSBwb3NpdGlvbiBoZXJlIGJhc2VkIG9uIHRoZSBsYXllcmluZyBiZWNhdXNlIHRoZSBncmFwaCBhbmRcbiAgLy8gbGF5ZXJpbmcgbWF5IGJlIG91dCBvZiBzeW5jLiBUaGUgbGF5ZXJpbmcgbWF0cml4IGlzIG1hbmlwdWxhdGVkIHRvXG4gIC8vIGdlbmVyYXRlIGRpZmZlcmVudCBleHRyZW1lIGFsaWdubWVudHMuXG4gIF8uZm9yRWFjaChsYXllcmluZywgZnVuY3Rpb24obGF5ZXIpIHtcbiAgICBfLmZvckVhY2gobGF5ZXIsIGZ1bmN0aW9uKHYsIG9yZGVyKSB7XG4gICAgICByb290W3ZdID0gdjtcbiAgICAgIGFsaWduW3ZdID0gdjtcbiAgICAgIHBvc1t2XSA9IG9yZGVyO1xuICAgIH0pO1xuICB9KTtcblxuICBfLmZvckVhY2gobGF5ZXJpbmcsIGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgdmFyIHByZXZJZHggPSAtMTtcbiAgICBfLmZvckVhY2gobGF5ZXIsIGZ1bmN0aW9uKHYpIHtcbiAgICAgIHZhciB3cyA9IG5laWdoYm9yRm4odik7XG4gICAgICBpZiAod3MubGVuZ3RoKSB7XG4gICAgICAgIHdzID0gXy5zb3J0Qnkod3MsIGZ1bmN0aW9uKHcpIHsgcmV0dXJuIHBvc1t3XTsgfSk7XG4gICAgICAgIHZhciBtcCA9ICh3cy5sZW5ndGggLSAxKSAvIDI7XG4gICAgICAgIGZvciAodmFyIGkgPSBNYXRoLmZsb29yKG1wKSwgaWwgPSBNYXRoLmNlaWwobXApOyBpIDw9IGlsOyArK2kpIHtcbiAgICAgICAgICB2YXIgdyA9IHdzW2ldO1xuICAgICAgICAgIGlmIChhbGlnblt2XSA9PT0gdiAmJlxuICAgICAgICAgICAgICBwcmV2SWR4IDwgcG9zW3ddICYmXG4gICAgICAgICAgICAgICFoYXNDb25mbGljdChjb25mbGljdHMsIHYsIHcpKSB7XG4gICAgICAgICAgICBhbGlnblt3XSA9IHY7XG4gICAgICAgICAgICBhbGlnblt2XSA9IHJvb3Rbdl0gPSByb290W3ddO1xuICAgICAgICAgICAgcHJldklkeCA9IHBvc1t3XTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHsgcm9vdDogcm9vdCwgYWxpZ246IGFsaWduIH07XG59XG5cbmZ1bmN0aW9uIGhvcml6b250YWxDb21wYWN0aW9uKGcsIGxheWVyaW5nLCByb290LCBhbGlnbiwgcmV2ZXJzZVNlcCkge1xuICAvLyBUaGlzIHBvcnRpb24gb2YgdGhlIGFsZ29yaXRobSBkaWZmZXJzIGZyb20gQksgZHVlIHRvIGEgbnVtYmVyIG9mIHByb2JsZW1zLlxuICAvLyBJbnN0ZWFkIG9mIHRoZWlyIGFsZ29yaXRobSB3ZSBjb25zdHJ1Y3QgYSBuZXcgYmxvY2sgZ3JhcGggYW5kIGRvIHR3b1xuICAvLyBzd2VlcHMuIFRoZSBmaXJzdCBzd2VlcCBwbGFjZXMgYmxvY2tzIHdpdGggdGhlIHNtYWxsZXN0IHBvc3NpYmxlXG4gIC8vIGNvb3JkaW5hdGVzLiBUaGUgc2Vjb25kIHN3ZWVwIHJlbW92ZXMgdW51c2VkIHNwYWNlIGJ5IG1vdmluZyBibG9ja3MgdG8gdGhlXG4gIC8vIGdyZWF0ZXN0IGNvb3JkaW5hdGVzIHdpdGhvdXQgdmlvbGF0aW5nIHNlcGFyYXRpb24uXG4gIHZhciB4cyA9IHt9LFxuICAgIGJsb2NrRyA9IGJ1aWxkQmxvY2tHcmFwaChnLCBsYXllcmluZywgcm9vdCwgcmV2ZXJzZVNlcCksXG4gICAgYm9yZGVyVHlwZSA9IHJldmVyc2VTZXAgPyBcImJvcmRlckxlZnRcIiA6IFwiYm9yZGVyUmlnaHRcIjtcblxuICBmdW5jdGlvbiBpdGVyYXRlKHNldFhzRnVuYywgbmV4dE5vZGVzRnVuYykge1xuICAgIHZhciBzdGFjayA9IGJsb2NrRy5ub2RlcygpO1xuICAgIHZhciBlbGVtID0gc3RhY2sucG9wKCk7XG4gICAgdmFyIHZpc2l0ZWQgPSB7fTtcbiAgICB3aGlsZSAoZWxlbSkge1xuICAgICAgaWYgKHZpc2l0ZWRbZWxlbV0pIHtcbiAgICAgICAgc2V0WHNGdW5jKGVsZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmlzaXRlZFtlbGVtXSA9IHRydWU7XG4gICAgICAgIHN0YWNrLnB1c2goZWxlbSk7XG4gICAgICAgIHN0YWNrID0gc3RhY2suY29uY2F0KG5leHROb2Rlc0Z1bmMoZWxlbSkpO1xuICAgICAgfVxuXG4gICAgICBlbGVtID0gc3RhY2sucG9wKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gRmlyc3QgcGFzcywgYXNzaWduIHNtYWxsZXN0IGNvb3JkaW5hdGVzXG4gIGZ1bmN0aW9uIHBhc3MxKGVsZW0pIHtcbiAgICB4c1tlbGVtXSA9IGJsb2NrRy5pbkVkZ2VzKGVsZW0pLnJlZHVjZShmdW5jdGlvbihhY2MsIGUpIHtcbiAgICAgIHJldHVybiBNYXRoLm1heChhY2MsIHhzW2Uudl0gKyBibG9ja0cuZWRnZShlKSk7XG4gICAgfSwgMCk7XG4gIH1cblxuICAvLyBTZWNvbmQgcGFzcywgYXNzaWduIGdyZWF0ZXN0IGNvb3JkaW5hdGVzXG4gIGZ1bmN0aW9uIHBhc3MyKGVsZW0pIHtcbiAgICB2YXIgbWluID0gYmxvY2tHLm91dEVkZ2VzKGVsZW0pLnJlZHVjZShmdW5jdGlvbihhY2MsIGUpIHtcbiAgICAgIHJldHVybiBNYXRoLm1pbihhY2MsIHhzW2Uud10gLSBibG9ja0cuZWRnZShlKSk7XG4gICAgfSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcblxuICAgIHZhciBub2RlID0gZy5ub2RlKGVsZW0pO1xuICAgIGlmIChtaW4gIT09IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSAmJiBub2RlLmJvcmRlclR5cGUgIT09IGJvcmRlclR5cGUpIHtcbiAgICAgIHhzW2VsZW1dID0gTWF0aC5tYXgoeHNbZWxlbV0sIG1pbik7XG4gICAgfVxuICB9XG5cbiAgaXRlcmF0ZShwYXNzMSwgYmxvY2tHLnByZWRlY2Vzc29ycy5iaW5kKGJsb2NrRykpO1xuICBpdGVyYXRlKHBhc3MyLCBibG9ja0cuc3VjY2Vzc29ycy5iaW5kKGJsb2NrRykpO1xuXG4gIC8vIEFzc2lnbiB4IGNvb3JkaW5hdGVzIHRvIGFsbCBub2Rlc1xuICBfLmZvckVhY2goYWxpZ24sIGZ1bmN0aW9uKHYpIHtcbiAgICB4c1t2XSA9IHhzW3Jvb3Rbdl1dO1xuICB9KTtcblxuICByZXR1cm4geHM7XG59XG5cblxuZnVuY3Rpb24gYnVpbGRCbG9ja0dyYXBoKGcsIGxheWVyaW5nLCByb290LCByZXZlcnNlU2VwKSB7XG4gIHZhciBibG9ja0dyYXBoID0gbmV3IEdyYXBoKCksXG4gICAgZ3JhcGhMYWJlbCA9IGcuZ3JhcGgoKSxcbiAgICBzZXBGbiA9IHNlcChncmFwaExhYmVsLm5vZGVzZXAsIGdyYXBoTGFiZWwuZWRnZXNlcCwgcmV2ZXJzZVNlcCk7XG5cbiAgXy5mb3JFYWNoKGxheWVyaW5nLCBmdW5jdGlvbihsYXllcikge1xuICAgIHZhciB1O1xuICAgIF8uZm9yRWFjaChsYXllciwgZnVuY3Rpb24odikge1xuICAgICAgdmFyIHZSb290ID0gcm9vdFt2XTtcbiAgICAgIGJsb2NrR3JhcGguc2V0Tm9kZSh2Um9vdCk7XG4gICAgICBpZiAodSkge1xuICAgICAgICB2YXIgdVJvb3QgPSByb290W3VdLFxuICAgICAgICAgIHByZXZNYXggPSBibG9ja0dyYXBoLmVkZ2UodVJvb3QsIHZSb290KTtcbiAgICAgICAgYmxvY2tHcmFwaC5zZXRFZGdlKHVSb290LCB2Um9vdCwgTWF0aC5tYXgoc2VwRm4oZywgdiwgdSksIHByZXZNYXggfHwgMCkpO1xuICAgICAgfVxuICAgICAgdSA9IHY7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBibG9ja0dyYXBoO1xufVxuXG4vKlxuICogUmV0dXJucyB0aGUgYWxpZ25tZW50IHRoYXQgaGFzIHRoZSBzbWFsbGVzdCB3aWR0aCBvZiB0aGUgZ2l2ZW4gYWxpZ25tZW50cy5cbiAqL1xuZnVuY3Rpb24gZmluZFNtYWxsZXN0V2lkdGhBbGlnbm1lbnQoZywgeHNzKSB7XG4gIHJldHVybiBfLm1pbkJ5KF8udmFsdWVzKHhzcyksIGZ1bmN0aW9uICh4cykge1xuICAgIHZhciBtYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgdmFyIG1pbiA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcblxuICAgIF8uZm9ySW4oeHMsIGZ1bmN0aW9uICh4LCB2KSB7XG4gICAgICB2YXIgaGFsZldpZHRoID0gd2lkdGgoZywgdikgLyAyO1xuXG4gICAgICBtYXggPSBNYXRoLm1heCh4ICsgaGFsZldpZHRoLCBtYXgpO1xuICAgICAgbWluID0gTWF0aC5taW4oeCAtIGhhbGZXaWR0aCwgbWluKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBtYXggLSBtaW47XG4gIH0pO1xufVxuXG4vKlxuICogQWxpZ24gdGhlIGNvb3JkaW5hdGVzIG9mIGVhY2ggb2YgdGhlIGxheW91dCBhbGlnbm1lbnRzIHN1Y2ggdGhhdFxuICogbGVmdC1iaWFzZWQgYWxpZ25tZW50cyBoYXZlIHRoZWlyIG1pbmltdW0gY29vcmRpbmF0ZSBhdCB0aGUgc2FtZSBwb2ludCBhc1xuICogdGhlIG1pbmltdW0gY29vcmRpbmF0ZSBvZiB0aGUgc21hbGxlc3Qgd2lkdGggYWxpZ25tZW50IGFuZCByaWdodC1iaWFzZWRcbiAqIGFsaWdubWVudHMgaGF2ZSB0aGVpciBtYXhpbXVtIGNvb3JkaW5hdGUgYXQgdGhlIHNhbWUgcG9pbnQgYXMgdGhlIG1heGltdW1cbiAqIGNvb3JkaW5hdGUgb2YgdGhlIHNtYWxsZXN0IHdpZHRoIGFsaWdubWVudC5cbiAqL1xuZnVuY3Rpb24gYWxpZ25Db29yZGluYXRlcyh4c3MsIGFsaWduVG8pIHtcbiAgdmFyIGFsaWduVG9WYWxzID0gXy52YWx1ZXMoYWxpZ25UbyksXG4gICAgYWxpZ25Ub01pbiA9IF8ubWluKGFsaWduVG9WYWxzKSxcbiAgICBhbGlnblRvTWF4ID0gXy5tYXgoYWxpZ25Ub1ZhbHMpO1xuXG4gIF8uZm9yRWFjaChbXCJ1XCIsIFwiZFwiXSwgZnVuY3Rpb24odmVydCkge1xuICAgIF8uZm9yRWFjaChbXCJsXCIsIFwiclwiXSwgZnVuY3Rpb24oaG9yaXopIHtcbiAgICAgIHZhciBhbGlnbm1lbnQgPSB2ZXJ0ICsgaG9yaXosXG4gICAgICAgIHhzID0geHNzW2FsaWdubWVudF0sXG4gICAgICAgIGRlbHRhO1xuICAgICAgaWYgKHhzID09PSBhbGlnblRvKSByZXR1cm47XG5cbiAgICAgIHZhciB4c1ZhbHMgPSBfLnZhbHVlcyh4cyk7XG4gICAgICBkZWx0YSA9IGhvcml6ID09PSBcImxcIiA/IGFsaWduVG9NaW4gLSBfLm1pbih4c1ZhbHMpIDogYWxpZ25Ub01heCAtIF8ubWF4KHhzVmFscyk7XG5cbiAgICAgIGlmIChkZWx0YSkge1xuICAgICAgICB4c3NbYWxpZ25tZW50XSA9IF8ubWFwVmFsdWVzKHhzLCBmdW5jdGlvbih4KSB7IHJldHVybiB4ICsgZGVsdGE7IH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYmFsYW5jZSh4c3MsIGFsaWduKSB7XG4gIHJldHVybiBfLm1hcFZhbHVlcyh4c3MudWwsIGZ1bmN0aW9uKGlnbm9yZSwgdikge1xuICAgIGlmIChhbGlnbikge1xuICAgICAgcmV0dXJuIHhzc1thbGlnbi50b0xvd2VyQ2FzZSgpXVt2XTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHhzID0gXy5zb3J0QnkoXy5tYXAoeHNzLCB2KSk7XG4gICAgICByZXR1cm4gKHhzWzFdICsgeHNbMl0pIC8gMjtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBwb3NpdGlvblgoZykge1xuICB2YXIgbGF5ZXJpbmcgPSB1dGlsLmJ1aWxkTGF5ZXJNYXRyaXgoZyk7XG4gIHZhciBjb25mbGljdHMgPSBfLm1lcmdlKFxuICAgIGZpbmRUeXBlMUNvbmZsaWN0cyhnLCBsYXllcmluZyksXG4gICAgZmluZFR5cGUyQ29uZmxpY3RzKGcsIGxheWVyaW5nKSk7XG5cbiAgdmFyIHhzcyA9IHt9O1xuICB2YXIgYWRqdXN0ZWRMYXllcmluZztcbiAgXy5mb3JFYWNoKFtcInVcIiwgXCJkXCJdLCBmdW5jdGlvbih2ZXJ0KSB7XG4gICAgYWRqdXN0ZWRMYXllcmluZyA9IHZlcnQgPT09IFwidVwiID8gbGF5ZXJpbmcgOiBfLnZhbHVlcyhsYXllcmluZykucmV2ZXJzZSgpO1xuICAgIF8uZm9yRWFjaChbXCJsXCIsIFwiclwiXSwgZnVuY3Rpb24oaG9yaXopIHtcbiAgICAgIGlmIChob3JpeiA9PT0gXCJyXCIpIHtcbiAgICAgICAgYWRqdXN0ZWRMYXllcmluZyA9IF8ubWFwKGFkanVzdGVkTGF5ZXJpbmcsIGZ1bmN0aW9uKGlubmVyKSB7XG4gICAgICAgICAgcmV0dXJuIF8udmFsdWVzKGlubmVyKS5yZXZlcnNlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmVpZ2hib3JGbiA9ICh2ZXJ0ID09PSBcInVcIiA/IGcucHJlZGVjZXNzb3JzIDogZy5zdWNjZXNzb3JzKS5iaW5kKGcpO1xuICAgICAgdmFyIGFsaWduID0gdmVydGljYWxBbGlnbm1lbnQoZywgYWRqdXN0ZWRMYXllcmluZywgY29uZmxpY3RzLCBuZWlnaGJvckZuKTtcbiAgICAgIHZhciB4cyA9IGhvcml6b250YWxDb21wYWN0aW9uKGcsIGFkanVzdGVkTGF5ZXJpbmcsXG4gICAgICAgIGFsaWduLnJvb3QsIGFsaWduLmFsaWduLCBob3JpeiA9PT0gXCJyXCIpO1xuICAgICAgaWYgKGhvcml6ID09PSBcInJcIikge1xuICAgICAgICB4cyA9IF8ubWFwVmFsdWVzKHhzLCBmdW5jdGlvbih4KSB7IHJldHVybiAteDsgfSk7XG4gICAgICB9XG4gICAgICB4c3NbdmVydCArIGhvcml6XSA9IHhzO1xuICAgIH0pO1xuICB9KTtcblxuICB2YXIgc21hbGxlc3RXaWR0aCA9IGZpbmRTbWFsbGVzdFdpZHRoQWxpZ25tZW50KGcsIHhzcyk7XG4gIGFsaWduQ29vcmRpbmF0ZXMoeHNzLCBzbWFsbGVzdFdpZHRoKTtcbiAgcmV0dXJuIGJhbGFuY2UoeHNzLCBnLmdyYXBoKCkuYWxpZ24pO1xufVxuXG5mdW5jdGlvbiBzZXAobm9kZVNlcCwgZWRnZVNlcCwgcmV2ZXJzZVNlcCkge1xuICByZXR1cm4gZnVuY3Rpb24oZywgdiwgdykge1xuICAgIHZhciB2TGFiZWwgPSBnLm5vZGUodik7XG4gICAgdmFyIHdMYWJlbCA9IGcubm9kZSh3KTtcbiAgICB2YXIgc3VtID0gMDtcbiAgICB2YXIgZGVsdGE7XG5cbiAgICBzdW0gKz0gdkxhYmVsLndpZHRoIC8gMjtcbiAgICBpZiAoXy5oYXModkxhYmVsLCBcImxhYmVscG9zXCIpKSB7XG4gICAgICBzd2l0Y2ggKHZMYWJlbC5sYWJlbHBvcy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBjYXNlIFwibFwiOiBkZWx0YSA9IC12TGFiZWwud2lkdGggLyAyOyBicmVhaztcbiAgICAgIGNhc2UgXCJyXCI6IGRlbHRhID0gdkxhYmVsLndpZHRoIC8gMjsgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWx0YSkge1xuICAgICAgc3VtICs9IHJldmVyc2VTZXAgPyBkZWx0YSA6IC1kZWx0YTtcbiAgICB9XG4gICAgZGVsdGEgPSAwO1xuXG4gICAgc3VtICs9ICh2TGFiZWwuZHVtbXkgPyBlZGdlU2VwIDogbm9kZVNlcCkgLyAyO1xuICAgIHN1bSArPSAod0xhYmVsLmR1bW15ID8gZWRnZVNlcCA6IG5vZGVTZXApIC8gMjtcblxuICAgIHN1bSArPSB3TGFiZWwud2lkdGggLyAyO1xuICAgIGlmIChfLmhhcyh3TGFiZWwsIFwibGFiZWxwb3NcIikpIHtcbiAgICAgIHN3aXRjaCAod0xhYmVsLmxhYmVscG9zLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGNhc2UgXCJsXCI6IGRlbHRhID0gd0xhYmVsLndpZHRoIC8gMjsgYnJlYWs7XG4gICAgICBjYXNlIFwiclwiOiBkZWx0YSA9IC13TGFiZWwud2lkdGggLyAyOyBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlbHRhKSB7XG4gICAgICBzdW0gKz0gcmV2ZXJzZVNlcCA/IGRlbHRhIDogLWRlbHRhO1xuICAgIH1cbiAgICBkZWx0YSA9IDA7XG5cbiAgICByZXR1cm4gc3VtO1xuICB9O1xufVxuXG5mdW5jdGlvbiB3aWR0aChnLCB2KSB7XG4gIHJldHVybiBnLm5vZGUodikud2lkdGg7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBwb3NpdGlvblggPSByZXF1aXJlKFwiLi9ia1wiKS5wb3NpdGlvblg7XG5cbm1vZHVsZS5leHBvcnRzID0gcG9zaXRpb247XG5cbmZ1bmN0aW9uIHBvc2l0aW9uKGcpIHtcbiAgZyA9IHV0aWwuYXNOb25Db21wb3VuZEdyYXBoKGcpO1xuXG4gIHBvc2l0aW9uWShnKTtcbiAgXy5mb3JFYWNoKHBvc2l0aW9uWChnKSwgZnVuY3Rpb24oeCwgdikge1xuICAgIGcubm9kZSh2KS54ID0geDtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBvc2l0aW9uWShnKSB7XG4gIHZhciBsYXllcmluZyA9IHV0aWwuYnVpbGRMYXllck1hdHJpeChnKTtcbiAgdmFyIHJhbmtTZXAgPSBnLmdyYXBoKCkucmFua3NlcDtcbiAgdmFyIHByZXZZID0gMDtcbiAgXy5mb3JFYWNoKGxheWVyaW5nLCBmdW5jdGlvbihsYXllcikge1xuICAgIHZhciBtYXhIZWlnaHQgPSBfLm1heChfLm1hcChsYXllciwgZnVuY3Rpb24odikgeyByZXR1cm4gZy5ub2RlKHYpLmhlaWdodDsgfSkpO1xuICAgIF8uZm9yRWFjaChsYXllciwgZnVuY3Rpb24odikge1xuICAgICAgZy5ub2RlKHYpLnkgPSBwcmV2WSArIG1heEhlaWdodCAvIDI7XG4gICAgfSk7XG4gICAgcHJldlkgKz0gbWF4SGVpZ2h0ICsgcmFua1NlcDtcbiAgfSk7XG59XG5cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG52YXIgR3JhcGggPSByZXF1aXJlKFwiLi4vZ3JhcGhsaWJcIikuR3JhcGg7XG52YXIgc2xhY2sgPSByZXF1aXJlKFwiLi91dGlsXCIpLnNsYWNrO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZlYXNpYmxlVHJlZTtcblxuLypcbiAqIENvbnN0cnVjdHMgYSBzcGFubmluZyB0cmVlIHdpdGggdGlnaHQgZWRnZXMgYW5kIGFkanVzdGVkIHRoZSBpbnB1dCBub2RlJ3NcbiAqIHJhbmtzIHRvIGFjaGlldmUgdGhpcy4gQSB0aWdodCBlZGdlIGlzIG9uZSB0aGF0IGlzIGhhcyBhIGxlbmd0aCB0aGF0IG1hdGNoZXNcbiAqIGl0cyBcIm1pbmxlblwiIGF0dHJpYnV0ZS5cbiAqXG4gKiBUaGUgYmFzaWMgc3RydWN0dXJlIGZvciB0aGlzIGZ1bmN0aW9uIGlzIGRlcml2ZWQgZnJvbSBHYW5zbmVyLCBldCBhbC4sIFwiQVxuICogVGVjaG5pcXVlIGZvciBEcmF3aW5nIERpcmVjdGVkIEdyYXBocy5cIlxuICpcbiAqIFByZS1jb25kaXRpb25zOlxuICpcbiAqICAgIDEuIEdyYXBoIG11c3QgYmUgYSBEQUcuXG4gKiAgICAyLiBHcmFwaCBtdXN0IGJlIGNvbm5lY3RlZC5cbiAqICAgIDMuIEdyYXBoIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgbm9kZS5cbiAqICAgIDUuIEdyYXBoIG5vZGVzIG11c3QgaGF2ZSBiZWVuIHByZXZpb3VzbHkgYXNzaWduZWQgYSBcInJhbmtcIiBwcm9wZXJ0eSB0aGF0XG4gKiAgICAgICByZXNwZWN0cyB0aGUgXCJtaW5sZW5cIiBwcm9wZXJ0eSBvZiBpbmNpZGVudCBlZGdlcy5cbiAqICAgIDYuIEdyYXBoIGVkZ2VzIG11c3QgaGF2ZSBhIFwibWlubGVuXCIgcHJvcGVydHkuXG4gKlxuICogUG9zdC1jb25kaXRpb25zOlxuICpcbiAqICAgIC0gR3JhcGggbm9kZXMgd2lsbCBoYXZlIHRoZWlyIHJhbmsgYWRqdXN0ZWQgdG8gZW5zdXJlIHRoYXQgYWxsIGVkZ2VzIGFyZVxuICogICAgICB0aWdodC5cbiAqXG4gKiBSZXR1cm5zIGEgdHJlZSAodW5kaXJlY3RlZCBncmFwaCkgdGhhdCBpcyBjb25zdHJ1Y3RlZCB1c2luZyBvbmx5IFwidGlnaHRcIlxuICogZWRnZXMuXG4gKi9cbmZ1bmN0aW9uIGZlYXNpYmxlVHJlZShnKSB7XG4gIHZhciB0ID0gbmV3IEdyYXBoKHsgZGlyZWN0ZWQ6IGZhbHNlIH0pO1xuXG4gIC8vIENob29zZSBhcmJpdHJhcnkgbm9kZSBmcm9tIHdoaWNoIHRvIHN0YXJ0IG91ciB0cmVlXG4gIHZhciBzdGFydCA9IGcubm9kZXMoKVswXTtcbiAgdmFyIHNpemUgPSBnLm5vZGVDb3VudCgpO1xuICB0LnNldE5vZGUoc3RhcnQsIHt9KTtcblxuICB2YXIgZWRnZSwgZGVsdGE7XG4gIHdoaWxlICh0aWdodFRyZWUodCwgZykgPCBzaXplKSB7XG4gICAgZWRnZSA9IGZpbmRNaW5TbGFja0VkZ2UodCwgZyk7XG4gICAgZGVsdGEgPSB0Lmhhc05vZGUoZWRnZS52KSA/IHNsYWNrKGcsIGVkZ2UpIDogLXNsYWNrKGcsIGVkZ2UpO1xuICAgIHNoaWZ0UmFua3ModCwgZywgZGVsdGEpO1xuICB9XG5cbiAgcmV0dXJuIHQ7XG59XG5cbi8qXG4gKiBGaW5kcyBhIG1heGltYWwgdHJlZSBvZiB0aWdodCBlZGdlcyBhbmQgcmV0dXJucyB0aGUgbnVtYmVyIG9mIG5vZGVzIGluIHRoZVxuICogdHJlZS5cbiAqL1xuZnVuY3Rpb24gdGlnaHRUcmVlKHQsIGcpIHtcbiAgZnVuY3Rpb24gZGZzKHYpIHtcbiAgICBfLmZvckVhY2goZy5ub2RlRWRnZXModiksIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHZhciBlZGdlViA9IGUudixcbiAgICAgICAgdyA9ICh2ID09PSBlZGdlVikgPyBlLncgOiBlZGdlVjtcbiAgICAgIGlmICghdC5oYXNOb2RlKHcpICYmICFzbGFjayhnLCBlKSkge1xuICAgICAgICB0LnNldE5vZGUodywge30pO1xuICAgICAgICB0LnNldEVkZ2Uodiwgdywge30pO1xuICAgICAgICBkZnModyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfLmZvckVhY2godC5ub2RlcygpLCBkZnMpO1xuICByZXR1cm4gdC5ub2RlQ291bnQoKTtcbn1cblxuLypcbiAqIEZpbmRzIHRoZSBlZGdlIHdpdGggdGhlIHNtYWxsZXN0IHNsYWNrIHRoYXQgaXMgaW5jaWRlbnQgb24gdHJlZSBhbmQgcmV0dXJuc1xuICogaXQuXG4gKi9cbmZ1bmN0aW9uIGZpbmRNaW5TbGFja0VkZ2UodCwgZykge1xuICByZXR1cm4gXy5taW5CeShnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAodC5oYXNOb2RlKGUudikgIT09IHQuaGFzTm9kZShlLncpKSB7XG4gICAgICByZXR1cm4gc2xhY2soZywgZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gc2hpZnRSYW5rcyh0LCBnLCBkZWx0YSkge1xuICBfLmZvckVhY2godC5ub2RlcygpLCBmdW5jdGlvbih2KSB7XG4gICAgZy5ub2RlKHYpLnJhbmsgKz0gZGVsdGE7XG4gIH0pO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciByYW5rVXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgbG9uZ2VzdFBhdGggPSByYW5rVXRpbC5sb25nZXN0UGF0aDtcbnZhciBmZWFzaWJsZVRyZWUgPSByZXF1aXJlKFwiLi9mZWFzaWJsZS10cmVlXCIpO1xudmFyIG5ldHdvcmtTaW1wbGV4ID0gcmVxdWlyZShcIi4vbmV0d29yay1zaW1wbGV4XCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJhbms7XG5cbi8qXG4gKiBBc3NpZ25zIGEgcmFuayB0byBlYWNoIG5vZGUgaW4gdGhlIGlucHV0IGdyYXBoIHRoYXQgcmVzcGVjdHMgdGhlIFwibWlubGVuXCJcbiAqIGNvbnN0cmFpbnQgc3BlY2lmaWVkIG9uIGVkZ2VzIGJldHdlZW4gbm9kZXMuXG4gKlxuICogVGhpcyBiYXNpYyBzdHJ1Y3R1cmUgaXMgZGVyaXZlZCBmcm9tIEdhbnNuZXIsIGV0IGFsLiwgXCJBIFRlY2huaXF1ZSBmb3JcbiAqIERyYXdpbmcgRGlyZWN0ZWQgR3JhcGhzLlwiXG4gKlxuICogUHJlLWNvbmRpdGlvbnM6XG4gKlxuICogICAgMS4gR3JhcGggbXVzdCBiZSBhIGNvbm5lY3RlZCBEQUdcbiAqICAgIDIuIEdyYXBoIG5vZGVzIG11c3QgYmUgb2JqZWN0c1xuICogICAgMy4gR3JhcGggZWRnZXMgbXVzdCBoYXZlIFwid2VpZ2h0XCIgYW5kIFwibWlubGVuXCIgYXR0cmlidXRlc1xuICpcbiAqIFBvc3QtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBHcmFwaCBub2RlcyB3aWxsIGhhdmUgYSBcInJhbmtcIiBhdHRyaWJ1dGUgYmFzZWQgb24gdGhlIHJlc3VsdHMgb2YgdGhlXG4gKiAgICAgICBhbGdvcml0aG0uIFJhbmtzIGNhbiBzdGFydCBhdCBhbnkgaW5kZXggKGluY2x1ZGluZyBuZWdhdGl2ZSksIHdlJ2xsXG4gKiAgICAgICBmaXggdGhlbSB1cCBsYXRlci5cbiAqL1xuZnVuY3Rpb24gcmFuayhnKSB7XG4gIHN3aXRjaChnLmdyYXBoKCkucmFua2VyKSB7XG4gIGNhc2UgXCJuZXR3b3JrLXNpbXBsZXhcIjogbmV0d29ya1NpbXBsZXhSYW5rZXIoZyk7IGJyZWFrO1xuICBjYXNlIFwidGlnaHQtdHJlZVwiOiB0aWdodFRyZWVSYW5rZXIoZyk7IGJyZWFrO1xuICBjYXNlIFwibG9uZ2VzdC1wYXRoXCI6IGxvbmdlc3RQYXRoUmFua2VyKGcpOyBicmVhaztcbiAgZGVmYXVsdDogbmV0d29ya1NpbXBsZXhSYW5rZXIoZyk7XG4gIH1cbn1cblxuLy8gQSBmYXN0IGFuZCBzaW1wbGUgcmFua2VyLCBidXQgcmVzdWx0cyBhcmUgZmFyIGZyb20gb3B0aW1hbC5cbnZhciBsb25nZXN0UGF0aFJhbmtlciA9IGxvbmdlc3RQYXRoO1xuXG5mdW5jdGlvbiB0aWdodFRyZWVSYW5rZXIoZykge1xuICBsb25nZXN0UGF0aChnKTtcbiAgZmVhc2libGVUcmVlKGcpO1xufVxuXG5mdW5jdGlvbiBuZXR3b3JrU2ltcGxleFJhbmtlcihnKSB7XG4gIG5ldHdvcmtTaW1wbGV4KGcpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcbnZhciBmZWFzaWJsZVRyZWUgPSByZXF1aXJlKFwiLi9mZWFzaWJsZS10cmVlXCIpO1xudmFyIHNsYWNrID0gcmVxdWlyZShcIi4vdXRpbFwiKS5zbGFjaztcbnZhciBpbml0UmFuayA9IHJlcXVpcmUoXCIuL3V0aWxcIikubG9uZ2VzdFBhdGg7XG52YXIgcHJlb3JkZXIgPSByZXF1aXJlKFwiLi4vZ3JhcGhsaWJcIikuYWxnLnByZW9yZGVyO1xudmFyIHBvc3RvcmRlciA9IHJlcXVpcmUoXCIuLi9ncmFwaGxpYlwiKS5hbGcucG9zdG9yZGVyO1xudmFyIHNpbXBsaWZ5ID0gcmVxdWlyZShcIi4uL3V0aWxcIikuc2ltcGxpZnk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmV0d29ya1NpbXBsZXg7XG5cbi8vIEV4cG9zZSBzb21lIGludGVybmFscyBmb3IgdGVzdGluZyBwdXJwb3Nlc1xubmV0d29ya1NpbXBsZXguaW5pdExvd0xpbVZhbHVlcyA9IGluaXRMb3dMaW1WYWx1ZXM7XG5uZXR3b3JrU2ltcGxleC5pbml0Q3V0VmFsdWVzID0gaW5pdEN1dFZhbHVlcztcbm5ldHdvcmtTaW1wbGV4LmNhbGNDdXRWYWx1ZSA9IGNhbGNDdXRWYWx1ZTtcbm5ldHdvcmtTaW1wbGV4LmxlYXZlRWRnZSA9IGxlYXZlRWRnZTtcbm5ldHdvcmtTaW1wbGV4LmVudGVyRWRnZSA9IGVudGVyRWRnZTtcbm5ldHdvcmtTaW1wbGV4LmV4Y2hhbmdlRWRnZXMgPSBleGNoYW5nZUVkZ2VzO1xuXG4vKlxuICogVGhlIG5ldHdvcmsgc2ltcGxleCBhbGdvcml0aG0gYXNzaWducyByYW5rcyB0byBlYWNoIG5vZGUgaW4gdGhlIGlucHV0IGdyYXBoXG4gKiBhbmQgaXRlcmF0aXZlbHkgaW1wcm92ZXMgdGhlIHJhbmtpbmcgdG8gcmVkdWNlIHRoZSBsZW5ndGggb2YgZWRnZXMuXG4gKlxuICogUHJlY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBUaGUgaW5wdXQgZ3JhcGggbXVzdCBiZSBhIERBRy5cbiAqICAgIDIuIEFsbCBub2RlcyBpbiB0aGUgZ3JhcGggbXVzdCBoYXZlIGFuIG9iamVjdCB2YWx1ZS5cbiAqICAgIDMuIEFsbCBlZGdlcyBpbiB0aGUgZ3JhcGggbXVzdCBoYXZlIFwibWlubGVuXCIgYW5kIFwid2VpZ2h0XCIgYXR0cmlidXRlcy5cbiAqXG4gKiBQb3N0Y29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBBbGwgbm9kZXMgaW4gdGhlIGdyYXBoIHdpbGwgaGF2ZSBhbiBhc3NpZ25lZCBcInJhbmtcIiBhdHRyaWJ1dGUgdGhhdCBoYXNcbiAqICAgICAgIGJlZW4gb3B0aW1pemVkIGJ5IHRoZSBuZXR3b3JrIHNpbXBsZXggYWxnb3JpdGhtLiBSYW5rcyBzdGFydCBhdCAwLlxuICpcbiAqXG4gKiBBIHJvdWdoIHNrZXRjaCBvZiB0aGUgYWxnb3JpdGhtIGlzIGFzIGZvbGxvd3M6XG4gKlxuICogICAgMS4gQXNzaWduIGluaXRpYWwgcmFua3MgdG8gZWFjaCBub2RlLiBXZSB1c2UgdGhlIGxvbmdlc3QgcGF0aCBhbGdvcml0aG0sXG4gKiAgICAgICB3aGljaCBhc3NpZ25zIHJhbmtzIHRvIHRoZSBsb3dlc3QgcG9zaXRpb24gcG9zc2libGUuIEluIGdlbmVyYWwgdGhpc1xuICogICAgICAgbGVhZHMgdG8gdmVyeSB3aWRlIGJvdHRvbSByYW5rcyBhbmQgdW5uZWNlc3NhcmlseSBsb25nIGVkZ2VzLlxuICogICAgMi4gQ29uc3RydWN0IGEgZmVhc2libGUgdGlnaHQgdHJlZS4gQSB0aWdodCB0cmVlIGlzIG9uZSBzdWNoIHRoYXQgYWxsXG4gKiAgICAgICBlZGdlcyBpbiB0aGUgdHJlZSBoYXZlIG5vIHNsYWNrIChkaWZmZXJlbmNlIGJldHdlZW4gbGVuZ3RoIG9mIGVkZ2VcbiAqICAgICAgIGFuZCBtaW5sZW4gZm9yIHRoZSBlZGdlKS4gVGhpcyBieSBpdHNlbGYgZ3JlYXRseSBpbXByb3ZlcyB0aGUgYXNzaWduZWRcbiAqICAgICAgIHJhbmtpbmdzIGJ5IHNob3J0aW5nIGVkZ2VzLlxuICogICAgMy4gSXRlcmF0aXZlbHkgZmluZCBlZGdlcyB0aGF0IGhhdmUgbmVnYXRpdmUgY3V0IHZhbHVlcy4gR2VuZXJhbGx5IGFcbiAqICAgICAgIG5lZ2F0aXZlIGN1dCB2YWx1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgZWRnZSBjb3VsZCBiZSByZW1vdmVkIGFuZCBhIG5ld1xuICogICAgICAgdHJlZSBlZGdlIGNvdWxkIGJlIGFkZGVkIHRvIHByb2R1Y2UgYSBtb3JlIGNvbXBhY3QgZ3JhcGguXG4gKlxuICogTXVjaCBvZiB0aGUgYWxnb3JpdGhtcyBoZXJlIGFyZSBkZXJpdmVkIGZyb20gR2Fuc25lciwgZXQgYWwuLCBcIkEgVGVjaG5pcXVlXG4gKiBmb3IgRHJhd2luZyBEaXJlY3RlZCBHcmFwaHMuXCIgVGhlIHN0cnVjdHVyZSBvZiB0aGUgZmlsZSByb3VnaGx5IGZvbGxvd3MgdGhlXG4gKiBzdHJ1Y3R1cmUgb2YgdGhlIG92ZXJhbGwgYWxnb3JpdGhtLlxuICovXG5mdW5jdGlvbiBuZXR3b3JrU2ltcGxleChnKSB7XG4gIGcgPSBzaW1wbGlmeShnKTtcbiAgaW5pdFJhbmsoZyk7XG4gIHZhciB0ID0gZmVhc2libGVUcmVlKGcpO1xuICBpbml0TG93TGltVmFsdWVzKHQpO1xuICBpbml0Q3V0VmFsdWVzKHQsIGcpO1xuXG4gIHZhciBlLCBmO1xuICB3aGlsZSAoKGUgPSBsZWF2ZUVkZ2UodCkpKSB7XG4gICAgZiA9IGVudGVyRWRnZSh0LCBnLCBlKTtcbiAgICBleGNoYW5nZUVkZ2VzKHQsIGcsIGUsIGYpO1xuICB9XG59XG5cbi8qXG4gKiBJbml0aWFsaXplcyBjdXQgdmFsdWVzIGZvciBhbGwgZWRnZXMgaW4gdGhlIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDdXRWYWx1ZXModCwgZykge1xuICB2YXIgdnMgPSBwb3N0b3JkZXIodCwgdC5ub2RlcygpKTtcbiAgdnMgPSB2cy5zbGljZSgwLCB2cy5sZW5ndGggLSAxKTtcbiAgXy5mb3JFYWNoKHZzLCBmdW5jdGlvbih2KSB7XG4gICAgYXNzaWduQ3V0VmFsdWUodCwgZywgdik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhc3NpZ25DdXRWYWx1ZSh0LCBnLCBjaGlsZCkge1xuICB2YXIgY2hpbGRMYWIgPSB0Lm5vZGUoY2hpbGQpO1xuICB2YXIgcGFyZW50ID0gY2hpbGRMYWIucGFyZW50O1xuICB0LmVkZ2UoY2hpbGQsIHBhcmVudCkuY3V0dmFsdWUgPSBjYWxjQ3V0VmFsdWUodCwgZywgY2hpbGQpO1xufVxuXG4vKlxuICogR2l2ZW4gdGhlIHRpZ2h0IHRyZWUsIGl0cyBncmFwaCwgYW5kIGEgY2hpbGQgaW4gdGhlIGdyYXBoIGNhbGN1bGF0ZSBhbmRcbiAqIHJldHVybiB0aGUgY3V0IHZhbHVlIGZvciB0aGUgZWRnZSBiZXR3ZWVuIHRoZSBjaGlsZCBhbmQgaXRzIHBhcmVudC5cbiAqL1xuZnVuY3Rpb24gY2FsY0N1dFZhbHVlKHQsIGcsIGNoaWxkKSB7XG4gIHZhciBjaGlsZExhYiA9IHQubm9kZShjaGlsZCk7XG4gIHZhciBwYXJlbnQgPSBjaGlsZExhYi5wYXJlbnQ7XG4gIC8vIFRydWUgaWYgdGhlIGNoaWxkIGlzIG9uIHRoZSB0YWlsIGVuZCBvZiB0aGUgZWRnZSBpbiB0aGUgZGlyZWN0ZWQgZ3JhcGhcbiAgdmFyIGNoaWxkSXNUYWlsID0gdHJ1ZTtcbiAgLy8gVGhlIGdyYXBoJ3MgdmlldyBvZiB0aGUgdHJlZSBlZGdlIHdlJ3JlIGluc3BlY3RpbmdcbiAgdmFyIGdyYXBoRWRnZSA9IGcuZWRnZShjaGlsZCwgcGFyZW50KTtcbiAgLy8gVGhlIGFjY3VtdWxhdGVkIGN1dCB2YWx1ZSBmb3IgdGhlIGVkZ2UgYmV0d2VlbiB0aGlzIG5vZGUgYW5kIGl0cyBwYXJlbnRcbiAgdmFyIGN1dFZhbHVlID0gMDtcblxuICBpZiAoIWdyYXBoRWRnZSkge1xuICAgIGNoaWxkSXNUYWlsID0gZmFsc2U7XG4gICAgZ3JhcGhFZGdlID0gZy5lZGdlKHBhcmVudCwgY2hpbGQpO1xuICB9XG5cbiAgY3V0VmFsdWUgPSBncmFwaEVkZ2Uud2VpZ2h0O1xuXG4gIF8uZm9yRWFjaChnLm5vZGVFZGdlcyhjaGlsZCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgaXNPdXRFZGdlID0gZS52ID09PSBjaGlsZCxcbiAgICAgIG90aGVyID0gaXNPdXRFZGdlID8gZS53IDogZS52O1xuXG4gICAgaWYgKG90aGVyICE9PSBwYXJlbnQpIHtcbiAgICAgIHZhciBwb2ludHNUb0hlYWQgPSBpc091dEVkZ2UgPT09IGNoaWxkSXNUYWlsLFxuICAgICAgICBvdGhlcldlaWdodCA9IGcuZWRnZShlKS53ZWlnaHQ7XG5cbiAgICAgIGN1dFZhbHVlICs9IHBvaW50c1RvSGVhZCA/IG90aGVyV2VpZ2h0IDogLW90aGVyV2VpZ2h0O1xuICAgICAgaWYgKGlzVHJlZUVkZ2UodCwgY2hpbGQsIG90aGVyKSkge1xuICAgICAgICB2YXIgb3RoZXJDdXRWYWx1ZSA9IHQuZWRnZShjaGlsZCwgb3RoZXIpLmN1dHZhbHVlO1xuICAgICAgICBjdXRWYWx1ZSArPSBwb2ludHNUb0hlYWQgPyAtb3RoZXJDdXRWYWx1ZSA6IG90aGVyQ3V0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gY3V0VmFsdWU7XG59XG5cbmZ1bmN0aW9uIGluaXRMb3dMaW1WYWx1ZXModHJlZSwgcm9vdCkge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDIpIHtcbiAgICByb290ID0gdHJlZS5ub2RlcygpWzBdO1xuICB9XG4gIGRmc0Fzc2lnbkxvd0xpbSh0cmVlLCB7fSwgMSwgcm9vdCk7XG59XG5cbmZ1bmN0aW9uIGRmc0Fzc2lnbkxvd0xpbSh0cmVlLCB2aXNpdGVkLCBuZXh0TGltLCB2LCBwYXJlbnQpIHtcbiAgdmFyIGxvdyA9IG5leHRMaW07XG4gIHZhciBsYWJlbCA9IHRyZWUubm9kZSh2KTtcblxuICB2aXNpdGVkW3ZdID0gdHJ1ZTtcbiAgXy5mb3JFYWNoKHRyZWUubmVpZ2hib3JzKHYpLCBmdW5jdGlvbih3KSB7XG4gICAgaWYgKCFfLmhhcyh2aXNpdGVkLCB3KSkge1xuICAgICAgbmV4dExpbSA9IGRmc0Fzc2lnbkxvd0xpbSh0cmVlLCB2aXNpdGVkLCBuZXh0TGltLCB3LCB2KTtcbiAgICB9XG4gIH0pO1xuXG4gIGxhYmVsLmxvdyA9IGxvdztcbiAgbGFiZWwubGltID0gbmV4dExpbSsrO1xuICBpZiAocGFyZW50KSB7XG4gICAgbGFiZWwucGFyZW50ID0gcGFyZW50O1xuICB9IGVsc2Uge1xuICAgIC8vIFRPRE8gc2hvdWxkIGJlIGFibGUgdG8gcmVtb3ZlIHRoaXMgd2hlbiB3ZSBpbmNyZW1lbnRhbGx5IHVwZGF0ZSBsb3cgbGltXG4gICAgZGVsZXRlIGxhYmVsLnBhcmVudDtcbiAgfVxuXG4gIHJldHVybiBuZXh0TGltO1xufVxuXG5mdW5jdGlvbiBsZWF2ZUVkZ2UodHJlZSkge1xuICByZXR1cm4gXy5maW5kKHRyZWUuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHJldHVybiB0cmVlLmVkZ2UoZSkuY3V0dmFsdWUgPCAwO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZW50ZXJFZGdlKHQsIGcsIGVkZ2UpIHtcbiAgdmFyIHYgPSBlZGdlLnY7XG4gIHZhciB3ID0gZWRnZS53O1xuXG4gIC8vIEZvciB0aGUgcmVzdCBvZiB0aGlzIGZ1bmN0aW9uIHdlIGFzc3VtZSB0aGF0IHYgaXMgdGhlIHRhaWwgYW5kIHcgaXMgdGhlXG4gIC8vIGhlYWQsIHNvIGlmIHdlIGRvbid0IGhhdmUgdGhpcyBlZGdlIGluIHRoZSBncmFwaCB3ZSBzaG91bGQgZmxpcCBpdCB0b1xuICAvLyBtYXRjaCB0aGUgY29ycmVjdCBvcmllbnRhdGlvbi5cbiAgaWYgKCFnLmhhc0VkZ2UodiwgdykpIHtcbiAgICB2ID0gZWRnZS53O1xuICAgIHcgPSBlZGdlLnY7XG4gIH1cblxuICB2YXIgdkxhYmVsID0gdC5ub2RlKHYpO1xuICB2YXIgd0xhYmVsID0gdC5ub2RlKHcpO1xuICB2YXIgdGFpbExhYmVsID0gdkxhYmVsO1xuICB2YXIgZmxpcCA9IGZhbHNlO1xuXG4gIC8vIElmIHRoZSByb290IGlzIGluIHRoZSB0YWlsIG9mIHRoZSBlZGdlIHRoZW4gd2UgbmVlZCB0byBmbGlwIHRoZSBsb2dpYyB0aGF0XG4gIC8vIGNoZWNrcyBmb3IgdGhlIGhlYWQgYW5kIHRhaWwgbm9kZXMgaW4gdGhlIGNhbmRpZGF0ZXMgZnVuY3Rpb24gYmVsb3cuXG4gIGlmICh2TGFiZWwubGltID4gd0xhYmVsLmxpbSkge1xuICAgIHRhaWxMYWJlbCA9IHdMYWJlbDtcbiAgICBmbGlwID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBjYW5kaWRhdGVzID0gXy5maWx0ZXIoZy5lZGdlcygpLCBmdW5jdGlvbihlZGdlKSB7XG4gICAgcmV0dXJuIGZsaXAgPT09IGlzRGVzY2VuZGFudCh0LCB0Lm5vZGUoZWRnZS52KSwgdGFpbExhYmVsKSAmJlxuICAgICAgICAgICBmbGlwICE9PSBpc0Rlc2NlbmRhbnQodCwgdC5ub2RlKGVkZ2UudyksIHRhaWxMYWJlbCk7XG4gIH0pO1xuXG4gIHJldHVybiBfLm1pbkJ5KGNhbmRpZGF0ZXMsIGZ1bmN0aW9uKGVkZ2UpIHsgcmV0dXJuIHNsYWNrKGcsIGVkZ2UpOyB9KTtcbn1cblxuZnVuY3Rpb24gZXhjaGFuZ2VFZGdlcyh0LCBnLCBlLCBmKSB7XG4gIHZhciB2ID0gZS52O1xuICB2YXIgdyA9IGUudztcbiAgdC5yZW1vdmVFZGdlKHYsIHcpO1xuICB0LnNldEVkZ2UoZi52LCBmLncsIHt9KTtcbiAgaW5pdExvd0xpbVZhbHVlcyh0KTtcbiAgaW5pdEN1dFZhbHVlcyh0LCBnKTtcbiAgdXBkYXRlUmFua3ModCwgZyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVJhbmtzKHQsIGcpIHtcbiAgdmFyIHJvb3QgPSBfLmZpbmQodC5ub2RlcygpLCBmdW5jdGlvbih2KSB7IHJldHVybiAhZy5ub2RlKHYpLnBhcmVudDsgfSk7XG4gIHZhciB2cyA9IHByZW9yZGVyKHQsIHJvb3QpO1xuICB2cyA9IHZzLnNsaWNlKDEpO1xuICBfLmZvckVhY2godnMsIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgcGFyZW50ID0gdC5ub2RlKHYpLnBhcmVudCxcbiAgICAgIGVkZ2UgPSBnLmVkZ2UodiwgcGFyZW50KSxcbiAgICAgIGZsaXBwZWQgPSBmYWxzZTtcblxuICAgIGlmICghZWRnZSkge1xuICAgICAgZWRnZSA9IGcuZWRnZShwYXJlbnQsIHYpO1xuICAgICAgZmxpcHBlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgZy5ub2RlKHYpLnJhbmsgPSBnLm5vZGUocGFyZW50KS5yYW5rICsgKGZsaXBwZWQgPyBlZGdlLm1pbmxlbiA6IC1lZGdlLm1pbmxlbik7XG4gIH0pO1xufVxuXG4vKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBlZGdlIGlzIGluIHRoZSB0cmVlLlxuICovXG5mdW5jdGlvbiBpc1RyZWVFZGdlKHRyZWUsIHUsIHYpIHtcbiAgcmV0dXJuIHRyZWUuaGFzRWRnZSh1LCB2KTtcbn1cblxuLypcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIG5vZGUgaXMgZGVzY2VuZGFudCBvZiB0aGUgcm9vdCBub2RlIHBlciB0aGVcbiAqIGFzc2lnbmVkIGxvdyBhbmQgbGltIGF0dHJpYnV0ZXMgaW4gdGhlIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIGlzRGVzY2VuZGFudCh0cmVlLCB2TGFiZWwsIHJvb3RMYWJlbCkge1xuICByZXR1cm4gcm9vdExhYmVsLmxvdyA8PSB2TGFiZWwubGltICYmIHZMYWJlbC5saW0gPD0gcm9vdExhYmVsLmxpbTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBsb25nZXN0UGF0aDogbG9uZ2VzdFBhdGgsXG4gIHNsYWNrOiBzbGFja1xufTtcblxuLypcbiAqIEluaXRpYWxpemVzIHJhbmtzIGZvciB0aGUgaW5wdXQgZ3JhcGggdXNpbmcgdGhlIGxvbmdlc3QgcGF0aCBhbGdvcml0aG0uIFRoaXNcbiAqIGFsZ29yaXRobSBzY2FsZXMgd2VsbCBhbmQgaXMgZmFzdCBpbiBwcmFjdGljZSwgaXQgeWllbGRzIHJhdGhlciBwb29yXG4gKiBzb2x1dGlvbnMuIE5vZGVzIGFyZSBwdXNoZWQgdG8gdGhlIGxvd2VzdCBsYXllciBwb3NzaWJsZSwgbGVhdmluZyB0aGUgYm90dG9tXG4gKiByYW5rcyB3aWRlIGFuZCBsZWF2aW5nIGVkZ2VzIGxvbmdlciB0aGFuIG5lY2Vzc2FyeS4gSG93ZXZlciwgZHVlIHRvIGl0c1xuICogc3BlZWQsIHRoaXMgYWxnb3JpdGhtIGlzIGdvb2QgZm9yIGdldHRpbmcgYW4gaW5pdGlhbCByYW5raW5nIHRoYXQgY2FuIGJlIGZlZFxuICogaW50byBvdGhlciBhbGdvcml0aG1zLlxuICpcbiAqIFRoaXMgYWxnb3JpdGhtIGRvZXMgbm90IG5vcm1hbGl6ZSBsYXllcnMgYmVjYXVzZSBpdCB3aWxsIGJlIHVzZWQgYnkgb3RoZXJcbiAqIGFsZ29yaXRobXMgaW4gbW9zdCBjYXNlcy4gSWYgdXNpbmcgdGhpcyBhbGdvcml0aG0gZGlyZWN0bHksIGJlIHN1cmUgdG9cbiAqIHJ1biBub3JtYWxpemUgYXQgdGhlIGVuZC5cbiAqXG4gKiBQcmUtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBJbnB1dCBncmFwaCBpcyBhIERBRy5cbiAqICAgIDIuIElucHV0IGdyYXBoIG5vZGUgbGFiZWxzIGNhbiBiZSBhc3NpZ25lZCBwcm9wZXJ0aWVzLlxuICpcbiAqIFBvc3QtY29uZGl0aW9uczpcbiAqXG4gKiAgICAxLiBFYWNoIG5vZGUgd2lsbCBiZSBhc3NpZ24gYW4gKHVubm9ybWFsaXplZCkgXCJyYW5rXCIgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGxvbmdlc3RQYXRoKGcpIHtcbiAgdmFyIHZpc2l0ZWQgPSB7fTtcblxuICBmdW5jdGlvbiBkZnModikge1xuICAgIHZhciBsYWJlbCA9IGcubm9kZSh2KTtcbiAgICBpZiAoXy5oYXModmlzaXRlZCwgdikpIHtcbiAgICAgIHJldHVybiBsYWJlbC5yYW5rO1xuICAgIH1cbiAgICB2aXNpdGVkW3ZdID0gdHJ1ZTtcblxuICAgIHZhciByYW5rID0gXy5taW4oXy5tYXAoZy5vdXRFZGdlcyh2KSwgZnVuY3Rpb24oZSkge1xuICAgICAgcmV0dXJuIGRmcyhlLncpIC0gZy5lZGdlKGUpLm1pbmxlbjtcbiAgICB9KSk7XG5cbiAgICBpZiAocmFuayA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZIHx8IC8vIHJldHVybiB2YWx1ZSBvZiBfLm1hcChbXSkgZm9yIExvZGFzaCAzXG4gICAgICAgIHJhbmsgPT09IHVuZGVmaW5lZCB8fCAvLyByZXR1cm4gdmFsdWUgb2YgXy5tYXAoW10pIGZvciBMb2Rhc2ggNFxuICAgICAgICByYW5rID09PSBudWxsKSB7IC8vIHJldHVybiB2YWx1ZSBvZiBfLm1hcChbbnVsbF0pXG4gICAgICByYW5rID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gKGxhYmVsLnJhbmsgPSByYW5rKTtcbiAgfVxuXG4gIF8uZm9yRWFjaChnLnNvdXJjZXMoKSwgZGZzKTtcbn1cblxuLypcbiAqIFJldHVybnMgdGhlIGFtb3VudCBvZiBzbGFjayBmb3IgdGhlIGdpdmVuIGVkZ2UuIFRoZSBzbGFjayBpcyBkZWZpbmVkIGFzIHRoZVxuICogZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBsZW5ndGggb2YgdGhlIGVkZ2UgYW5kIGl0cyBtaW5pbXVtIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gc2xhY2soZywgZSkge1xuICByZXR1cm4gZy5ub2RlKGUudykucmFuayAtIGcubm9kZShlLnYpLnJhbmsgLSBnLmVkZ2UoZSkubWlubGVuO1xufVxuIiwiLyogZXNsaW50IFwibm8tY29uc29sZVwiOiBvZmYgKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfID0gcmVxdWlyZShcIi4vbG9kYXNoXCIpO1xudmFyIEdyYXBoID0gcmVxdWlyZShcIi4vZ3JhcGhsaWJcIikuR3JhcGg7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhZGREdW1teU5vZGU6IGFkZER1bW15Tm9kZSxcbiAgc2ltcGxpZnk6IHNpbXBsaWZ5LFxuICBhc05vbkNvbXBvdW5kR3JhcGg6IGFzTm9uQ29tcG91bmRHcmFwaCxcbiAgc3VjY2Vzc29yV2VpZ2h0czogc3VjY2Vzc29yV2VpZ2h0cyxcbiAgcHJlZGVjZXNzb3JXZWlnaHRzOiBwcmVkZWNlc3NvcldlaWdodHMsXG4gIGludGVyc2VjdFJlY3Q6IGludGVyc2VjdFJlY3QsXG4gIGJ1aWxkTGF5ZXJNYXRyaXg6IGJ1aWxkTGF5ZXJNYXRyaXgsXG4gIG5vcm1hbGl6ZVJhbmtzOiBub3JtYWxpemVSYW5rcyxcbiAgcmVtb3ZlRW1wdHlSYW5rczogcmVtb3ZlRW1wdHlSYW5rcyxcbiAgYWRkQm9yZGVyTm9kZTogYWRkQm9yZGVyTm9kZSxcbiAgbWF4UmFuazogbWF4UmFuayxcbiAgcGFydGl0aW9uOiBwYXJ0aXRpb24sXG4gIHRpbWU6IHRpbWUsXG4gIG5vdGltZTogbm90aW1lXG59O1xuXG4vKlxuICogQWRkcyBhIGR1bW15IG5vZGUgdG8gdGhlIGdyYXBoIGFuZCByZXR1cm4gdi5cbiAqL1xuZnVuY3Rpb24gYWRkRHVtbXlOb2RlKGcsIHR5cGUsIGF0dHJzLCBuYW1lKSB7XG4gIHZhciB2O1xuICBkbyB7XG4gICAgdiA9IF8udW5pcXVlSWQobmFtZSk7XG4gIH0gd2hpbGUgKGcuaGFzTm9kZSh2KSk7XG5cbiAgYXR0cnMuZHVtbXkgPSB0eXBlO1xuICBnLnNldE5vZGUodiwgYXR0cnMpO1xuICByZXR1cm4gdjtcbn1cblxuLypcbiAqIFJldHVybnMgYSBuZXcgZ3JhcGggd2l0aCBvbmx5IHNpbXBsZSBlZGdlcy4gSGFuZGxlcyBhZ2dyZWdhdGlvbiBvZiBkYXRhXG4gKiBhc3NvY2lhdGVkIHdpdGggbXVsdGktZWRnZXMuXG4gKi9cbmZ1bmN0aW9uIHNpbXBsaWZ5KGcpIHtcbiAgdmFyIHNpbXBsaWZpZWQgPSBuZXcgR3JhcGgoKS5zZXRHcmFwaChnLmdyYXBoKCkpO1xuICBfLmZvckVhY2goZy5ub2RlcygpLCBmdW5jdGlvbih2KSB7IHNpbXBsaWZpZWQuc2V0Tm9kZSh2LCBnLm5vZGUodikpOyB9KTtcbiAgXy5mb3JFYWNoKGcuZWRnZXMoKSwgZnVuY3Rpb24oZSkge1xuICAgIHZhciBzaW1wbGVMYWJlbCA9IHNpbXBsaWZpZWQuZWRnZShlLnYsIGUudykgfHwgeyB3ZWlnaHQ6IDAsIG1pbmxlbjogMSB9O1xuICAgIHZhciBsYWJlbCA9IGcuZWRnZShlKTtcbiAgICBzaW1wbGlmaWVkLnNldEVkZ2UoZS52LCBlLncsIHtcbiAgICAgIHdlaWdodDogc2ltcGxlTGFiZWwud2VpZ2h0ICsgbGFiZWwud2VpZ2h0LFxuICAgICAgbWlubGVuOiBNYXRoLm1heChzaW1wbGVMYWJlbC5taW5sZW4sIGxhYmVsLm1pbmxlbilcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBzaW1wbGlmaWVkO1xufVxuXG5mdW5jdGlvbiBhc05vbkNvbXBvdW5kR3JhcGgoZykge1xuICB2YXIgc2ltcGxpZmllZCA9IG5ldyBHcmFwaCh7IG11bHRpZ3JhcGg6IGcuaXNNdWx0aWdyYXBoKCkgfSkuc2V0R3JhcGgoZy5ncmFwaCgpKTtcbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIGlmICghZy5jaGlsZHJlbih2KS5sZW5ndGgpIHtcbiAgICAgIHNpbXBsaWZpZWQuc2V0Tm9kZSh2LCBnLm5vZGUodikpO1xuICAgIH1cbiAgfSk7XG4gIF8uZm9yRWFjaChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICBzaW1wbGlmaWVkLnNldEVkZ2UoZSwgZy5lZGdlKGUpKTtcbiAgfSk7XG4gIHJldHVybiBzaW1wbGlmaWVkO1xufVxuXG5mdW5jdGlvbiBzdWNjZXNzb3JXZWlnaHRzKGcpIHtcbiAgdmFyIHdlaWdodE1hcCA9IF8ubWFwKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBzdWNzID0ge307XG4gICAgXy5mb3JFYWNoKGcub3V0RWRnZXModiksIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHN1Y3NbZS53XSA9IChzdWNzW2Uud10gfHwgMCkgKyBnLmVkZ2UoZSkud2VpZ2h0O1xuICAgIH0pO1xuICAgIHJldHVybiBzdWNzO1xuICB9KTtcbiAgcmV0dXJuIF8uemlwT2JqZWN0KGcubm9kZXMoKSwgd2VpZ2h0TWFwKTtcbn1cblxuZnVuY3Rpb24gcHJlZGVjZXNzb3JXZWlnaHRzKGcpIHtcbiAgdmFyIHdlaWdodE1hcCA9IF8ubWFwKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBwcmVkcyA9IHt9O1xuICAgIF8uZm9yRWFjaChnLmluRWRnZXModiksIGZ1bmN0aW9uKGUpIHtcbiAgICAgIHByZWRzW2Uudl0gPSAocHJlZHNbZS52XSB8fCAwKSArIGcuZWRnZShlKS53ZWlnaHQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByZWRzO1xuICB9KTtcbiAgcmV0dXJuIF8uemlwT2JqZWN0KGcubm9kZXMoKSwgd2VpZ2h0TWFwKTtcbn1cblxuLypcbiAqIEZpbmRzIHdoZXJlIGEgbGluZSBzdGFydGluZyBhdCBwb2ludCAoe3gsIHl9KSB3b3VsZCBpbnRlcnNlY3QgYSByZWN0YW5nbGVcbiAqICh7eCwgeSwgd2lkdGgsIGhlaWdodH0pIGlmIGl0IHdlcmUgcG9pbnRpbmcgYXQgdGhlIHJlY3RhbmdsZSdzIGNlbnRlci5cbiAqL1xuZnVuY3Rpb24gaW50ZXJzZWN0UmVjdChyZWN0LCBwb2ludCkge1xuICB2YXIgeCA9IHJlY3QueDtcbiAgdmFyIHkgPSByZWN0Lnk7XG5cbiAgLy8gUmVjdGFuZ2xlIGludGVyc2VjdGlvbiBhbGdvcml0aG0gZnJvbTpcbiAgLy8gaHR0cDovL21hdGguc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzEwODExMy9maW5kLWVkZ2UtYmV0d2Vlbi10d28tYm94ZXNcbiAgdmFyIGR4ID0gcG9pbnQueCAtIHg7XG4gIHZhciBkeSA9IHBvaW50LnkgLSB5O1xuICB2YXIgdyA9IHJlY3Qud2lkdGggLyAyO1xuICB2YXIgaCA9IHJlY3QuaGVpZ2h0IC8gMjtcblxuICBpZiAoIWR4ICYmICFkeSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBwb3NzaWJsZSB0byBmaW5kIGludGVyc2VjdGlvbiBpbnNpZGUgb2YgdGhlIHJlY3RhbmdsZVwiKTtcbiAgfVxuXG4gIHZhciBzeCwgc3k7XG4gIGlmIChNYXRoLmFicyhkeSkgKiB3ID4gTWF0aC5hYnMoZHgpICogaCkge1xuICAgIC8vIEludGVyc2VjdGlvbiBpcyB0b3Agb3IgYm90dG9tIG9mIHJlY3QuXG4gICAgaWYgKGR5IDwgMCkge1xuICAgICAgaCA9IC1oO1xuICAgIH1cbiAgICBzeCA9IGggKiBkeCAvIGR5O1xuICAgIHN5ID0gaDtcbiAgfSBlbHNlIHtcbiAgICAvLyBJbnRlcnNlY3Rpb24gaXMgbGVmdCBvciByaWdodCBvZiByZWN0LlxuICAgIGlmIChkeCA8IDApIHtcbiAgICAgIHcgPSAtdztcbiAgICB9XG4gICAgc3ggPSB3O1xuICAgIHN5ID0gdyAqIGR5IC8gZHg7XG4gIH1cblxuICByZXR1cm4geyB4OiB4ICsgc3gsIHk6IHkgKyBzeSB9O1xufVxuXG4vKlxuICogR2l2ZW4gYSBEQUcgd2l0aCBlYWNoIG5vZGUgYXNzaWduZWQgXCJyYW5rXCIgYW5kIFwib3JkZXJcIiBwcm9wZXJ0aWVzLCB0aGlzXG4gKiBmdW5jdGlvbiB3aWxsIHByb2R1Y2UgYSBtYXRyaXggd2l0aCB0aGUgaWRzIG9mIGVhY2ggbm9kZS5cbiAqL1xuZnVuY3Rpb24gYnVpbGRMYXllck1hdHJpeChnKSB7XG4gIHZhciBsYXllcmluZyA9IF8ubWFwKF8ucmFuZ2UobWF4UmFuayhnKSArIDEpLCBmdW5jdGlvbigpIHsgcmV0dXJuIFtdOyB9KTtcbiAgXy5mb3JFYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciBub2RlID0gZy5ub2RlKHYpO1xuICAgIHZhciByYW5rID0gbm9kZS5yYW5rO1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChyYW5rKSkge1xuICAgICAgbGF5ZXJpbmdbcmFua11bbm9kZS5vcmRlcl0gPSB2O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBsYXllcmluZztcbn1cblxuLypcbiAqIEFkanVzdHMgdGhlIHJhbmtzIGZvciBhbGwgbm9kZXMgaW4gdGhlIGdyYXBoIHN1Y2ggdGhhdCBhbGwgbm9kZXMgdiBoYXZlXG4gKiByYW5rKHYpID49IDAgYW5kIGF0IGxlYXN0IG9uZSBub2RlIHcgaGFzIHJhbmsodykgPSAwLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVSYW5rcyhnKSB7XG4gIHZhciBtaW4gPSBfLm1pbihfLm1hcChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHsgcmV0dXJuIGcubm9kZSh2KS5yYW5rOyB9KSk7XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgbm9kZSA9IGcubm9kZSh2KTtcbiAgICBpZiAoXy5oYXMobm9kZSwgXCJyYW5rXCIpKSB7XG4gICAgICBub2RlLnJhbmsgLT0gbWluO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUVtcHR5UmFua3MoZykge1xuICAvLyBSYW5rcyBtYXkgbm90IHN0YXJ0IGF0IDAsIHNvIHdlIG5lZWQgdG8gb2Zmc2V0IHRoZW1cbiAgdmFyIG9mZnNldCA9IF8ubWluKF8ubWFwKGcubm9kZXMoKSwgZnVuY3Rpb24odikgeyByZXR1cm4gZy5ub2RlKHYpLnJhbms7IH0pKTtcblxuICB2YXIgbGF5ZXJzID0gW107XG4gIF8uZm9yRWFjaChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgcmFuayA9IGcubm9kZSh2KS5yYW5rIC0gb2Zmc2V0O1xuICAgIGlmICghbGF5ZXJzW3JhbmtdKSB7XG4gICAgICBsYXllcnNbcmFua10gPSBbXTtcbiAgICB9XG4gICAgbGF5ZXJzW3JhbmtdLnB1c2godik7XG4gIH0pO1xuXG4gIHZhciBkZWx0YSA9IDA7XG4gIHZhciBub2RlUmFua0ZhY3RvciA9IGcuZ3JhcGgoKS5ub2RlUmFua0ZhY3RvcjtcbiAgXy5mb3JFYWNoKGxheWVycywgZnVuY3Rpb24odnMsIGkpIHtcbiAgICBpZiAoXy5pc1VuZGVmaW5lZCh2cykgJiYgaSAlIG5vZGVSYW5rRmFjdG9yICE9PSAwKSB7XG4gICAgICAtLWRlbHRhO1xuICAgIH0gZWxzZSBpZiAoZGVsdGEpIHtcbiAgICAgIF8uZm9yRWFjaCh2cywgZnVuY3Rpb24odikgeyBnLm5vZGUodikucmFuayArPSBkZWx0YTsgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkQm9yZGVyTm9kZShnLCBwcmVmaXgsIHJhbmssIG9yZGVyKSB7XG4gIHZhciBub2RlID0ge1xuICAgIHdpZHRoOiAwLFxuICAgIGhlaWdodDogMFxuICB9O1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSB7XG4gICAgbm9kZS5yYW5rID0gcmFuaztcbiAgICBub2RlLm9yZGVyID0gb3JkZXI7XG4gIH1cbiAgcmV0dXJuIGFkZER1bW15Tm9kZShnLCBcImJvcmRlclwiLCBub2RlLCBwcmVmaXgpO1xufVxuXG5mdW5jdGlvbiBtYXhSYW5rKGcpIHtcbiAgcmV0dXJuIF8ubWF4KF8ubWFwKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHZhciByYW5rID0gZy5ub2RlKHYpLnJhbms7XG4gICAgaWYgKCFfLmlzVW5kZWZpbmVkKHJhbmspKSB7XG4gICAgICByZXR1cm4gcmFuaztcbiAgICB9XG4gIH0pKTtcbn1cblxuLypcbiAqIFBhcnRpdGlvbiBhIGNvbGxlY3Rpb24gaW50byB0d28gZ3JvdXBzOiBgbGhzYCBhbmQgYHJoc2AuIElmIHRoZSBzdXBwbGllZFxuICogZnVuY3Rpb24gcmV0dXJucyB0cnVlIGZvciBhbiBlbnRyeSBpdCBnb2VzIGludG8gYGxoc2AuIE90aGVyd2lzZSBpdCBnb2VzXG4gKiBpbnRvIGByaHMuXG4gKi9cbmZ1bmN0aW9uIHBhcnRpdGlvbihjb2xsZWN0aW9uLCBmbikge1xuICB2YXIgcmVzdWx0ID0geyBsaHM6IFtdLCByaHM6IFtdIH07XG4gIF8uZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmIChmbih2YWx1ZSkpIHtcbiAgICAgIHJlc3VsdC5saHMucHVzaCh2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5yaHMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLypcbiAqIFJldHVybnMgYSBuZXcgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZm5gIHdpdGggYSB0aW1lci4gVGhlIHdyYXBwZXIgbG9ncyB0aGVcbiAqIHRpbWUgaXQgdGFrZXMgdG8gZXhlY3V0ZSB0aGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRpbWUobmFtZSwgZm4pIHtcbiAgdmFyIHN0YXJ0ID0gXy5ub3coKTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjb25zb2xlLmxvZyhuYW1lICsgXCIgdGltZTogXCIgKyAoXy5ub3coKSAtIHN0YXJ0KSArIFwibXNcIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gbm90aW1lKG5hbWUsIGZuKSB7XG4gIHJldHVybiBmbigpO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjAuOC41XCI7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNCwgQ2hyaXMgUGV0dGl0dFxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICpcbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSwgdGhpc1xuICogbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKlxuICogMi4gUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLFxuICogdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICogYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKlxuICogMy4gTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgY29weXJpZ2h0IGhvbGRlciBub3IgdGhlIG5hbWVzIG9mIGl0cyBjb250cmlidXRvcnNcbiAqIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0cyBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0XG4gKiBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG4gKiBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuICogV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuICogRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIENPUFlSSUdIVCBIT0xERVIgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRVxuICogRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcbiAqIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SXG4gKiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUlxuICogQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSxcbiAqIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFXG4gKiBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbnZhciBsaWIgPSByZXF1aXJlKFwiLi9saWJcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBHcmFwaDogbGliLkdyYXBoLFxuICBqc29uOiByZXF1aXJlKFwiLi9saWIvanNvblwiKSxcbiAgYWxnOiByZXF1aXJlKFwiLi9saWIvYWxnXCIpLFxuICB2ZXJzaW9uOiBsaWIudmVyc2lvblxufTtcbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb21wb25lbnRzO1xuXG5mdW5jdGlvbiBjb21wb25lbnRzKGcpIHtcbiAgdmFyIHZpc2l0ZWQgPSB7fTtcbiAgdmFyIGNtcHRzID0gW107XG4gIHZhciBjbXB0O1xuXG4gIGZ1bmN0aW9uIGRmcyh2KSB7XG4gICAgaWYgKF8uaGFzKHZpc2l0ZWQsIHYpKSByZXR1cm47XG4gICAgdmlzaXRlZFt2XSA9IHRydWU7XG4gICAgY21wdC5wdXNoKHYpO1xuICAgIF8uZWFjaChnLnN1Y2Nlc3NvcnModiksIGRmcyk7XG4gICAgXy5lYWNoKGcucHJlZGVjZXNzb3JzKHYpLCBkZnMpO1xuICB9XG5cbiAgXy5lYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIGNtcHQgPSBbXTtcbiAgICBkZnModik7XG4gICAgaWYgKGNtcHQubGVuZ3RoKSB7XG4gICAgICBjbXB0cy5wdXNoKGNtcHQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNtcHRzO1xufVxuIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRmcztcblxuLypcbiAqIEEgaGVscGVyIHRoYXQgcHJlZm9ybXMgYSBwcmUtIG9yIHBvc3Qtb3JkZXIgdHJhdmVyc2FsIG9uIHRoZSBpbnB1dCBncmFwaFxuICogYW5kIHJldHVybnMgdGhlIG5vZGVzIGluIHRoZSBvcmRlciB0aGV5IHdlcmUgdmlzaXRlZC4gSWYgdGhlIGdyYXBoIGlzXG4gKiB1bmRpcmVjdGVkIHRoZW4gdGhpcyBhbGdvcml0aG0gd2lsbCBuYXZpZ2F0ZSB1c2luZyBuZWlnaGJvcnMuIElmIHRoZSBncmFwaFxuICogaXMgZGlyZWN0ZWQgdGhlbiB0aGlzIGFsZ29yaXRobSB3aWxsIG5hdmlnYXRlIHVzaW5nIHN1Y2Nlc3NvcnMuXG4gKlxuICogT3JkZXIgbXVzdCBiZSBvbmUgb2YgXCJwcmVcIiBvciBcInBvc3RcIi5cbiAqL1xuZnVuY3Rpb24gZGZzKGcsIHZzLCBvcmRlcikge1xuICBpZiAoIV8uaXNBcnJheSh2cykpIHtcbiAgICB2cyA9IFt2c107XG4gIH1cblxuICB2YXIgbmF2aWdhdGlvbiA9IChnLmlzRGlyZWN0ZWQoKSA/IGcuc3VjY2Vzc29ycyA6IGcubmVpZ2hib3JzKS5iaW5kKGcpO1xuXG4gIHZhciBhY2MgPSBbXTtcbiAgdmFyIHZpc2l0ZWQgPSB7fTtcbiAgXy5lYWNoKHZzLCBmdW5jdGlvbih2KSB7XG4gICAgaWYgKCFnLmhhc05vZGUodikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkdyYXBoIGRvZXMgbm90IGhhdmUgbm9kZTogXCIgKyB2KTtcbiAgICB9XG5cbiAgICBkb0RmcyhnLCB2LCBvcmRlciA9PT0gXCJwb3N0XCIsIHZpc2l0ZWQsIG5hdmlnYXRpb24sIGFjYyk7XG4gIH0pO1xuICByZXR1cm4gYWNjO1xufVxuXG5mdW5jdGlvbiBkb0RmcyhnLCB2LCBwb3N0b3JkZXIsIHZpc2l0ZWQsIG5hdmlnYXRpb24sIGFjYykge1xuICBpZiAoIV8uaGFzKHZpc2l0ZWQsIHYpKSB7XG4gICAgdmlzaXRlZFt2XSA9IHRydWU7XG5cbiAgICBpZiAoIXBvc3RvcmRlcikgeyBhY2MucHVzaCh2KTsgfVxuICAgIF8uZWFjaChuYXZpZ2F0aW9uKHYpLCBmdW5jdGlvbih3KSB7XG4gICAgICBkb0RmcyhnLCB3LCBwb3N0b3JkZXIsIHZpc2l0ZWQsIG5hdmlnYXRpb24sIGFjYyk7XG4gICAgfSk7XG4gICAgaWYgKHBvc3RvcmRlcikgeyBhY2MucHVzaCh2KTsgfVxuICB9XG59XG4iLCJ2YXIgZGlqa3N0cmEgPSByZXF1aXJlKFwiLi9kaWprc3RyYVwiKTtcbnZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkaWprc3RyYUFsbDtcblxuZnVuY3Rpb24gZGlqa3N0cmFBbGwoZywgd2VpZ2h0RnVuYywgZWRnZUZ1bmMpIHtcbiAgcmV0dXJuIF8udHJhbnNmb3JtKGcubm9kZXMoKSwgZnVuY3Rpb24oYWNjLCB2KSB7XG4gICAgYWNjW3ZdID0gZGlqa3N0cmEoZywgdiwgd2VpZ2h0RnVuYywgZWRnZUZ1bmMpO1xuICB9LCB7fSk7XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG52YXIgUHJpb3JpdHlRdWV1ZSA9IHJlcXVpcmUoXCIuLi9kYXRhL3ByaW9yaXR5LXF1ZXVlXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRpamtzdHJhO1xuXG52YXIgREVGQVVMVF9XRUlHSFRfRlVOQyA9IF8uY29uc3RhbnQoMSk7XG5cbmZ1bmN0aW9uIGRpamtzdHJhKGcsIHNvdXJjZSwgd2VpZ2h0Rm4sIGVkZ2VGbikge1xuICByZXR1cm4gcnVuRGlqa3N0cmEoZywgU3RyaW5nKHNvdXJjZSksXG4gICAgd2VpZ2h0Rm4gfHwgREVGQVVMVF9XRUlHSFRfRlVOQyxcbiAgICBlZGdlRm4gfHwgZnVuY3Rpb24odikgeyByZXR1cm4gZy5vdXRFZGdlcyh2KTsgfSk7XG59XG5cbmZ1bmN0aW9uIHJ1bkRpamtzdHJhKGcsIHNvdXJjZSwgd2VpZ2h0Rm4sIGVkZ2VGbikge1xuICB2YXIgcmVzdWx0cyA9IHt9O1xuICB2YXIgcHEgPSBuZXcgUHJpb3JpdHlRdWV1ZSgpO1xuICB2YXIgdiwgdkVudHJ5O1xuXG4gIHZhciB1cGRhdGVOZWlnaGJvcnMgPSBmdW5jdGlvbihlZGdlKSB7XG4gICAgdmFyIHcgPSBlZGdlLnYgIT09IHYgPyBlZGdlLnYgOiBlZGdlLnc7XG4gICAgdmFyIHdFbnRyeSA9IHJlc3VsdHNbd107XG4gICAgdmFyIHdlaWdodCA9IHdlaWdodEZuKGVkZ2UpO1xuICAgIHZhciBkaXN0YW5jZSA9IHZFbnRyeS5kaXN0YW5jZSArIHdlaWdodDtcblxuICAgIGlmICh3ZWlnaHQgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaWprc3RyYSBkb2VzIG5vdCBhbGxvdyBuZWdhdGl2ZSBlZGdlIHdlaWdodHMuIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICBcIkJhZCBlZGdlOiBcIiArIGVkZ2UgKyBcIiBXZWlnaHQ6IFwiICsgd2VpZ2h0KTtcbiAgICB9XG5cbiAgICBpZiAoZGlzdGFuY2UgPCB3RW50cnkuZGlzdGFuY2UpIHtcbiAgICAgIHdFbnRyeS5kaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgd0VudHJ5LnByZWRlY2Vzc29yID0gdjtcbiAgICAgIHBxLmRlY3JlYXNlKHcsIGRpc3RhbmNlKTtcbiAgICB9XG4gIH07XG5cbiAgZy5ub2RlcygpLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgIHZhciBkaXN0YW5jZSA9IHYgPT09IHNvdXJjZSA/IDAgOiBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgcmVzdWx0c1t2XSA9IHsgZGlzdGFuY2U6IGRpc3RhbmNlIH07XG4gICAgcHEuYWRkKHYsIGRpc3RhbmNlKTtcbiAgfSk7XG5cbiAgd2hpbGUgKHBxLnNpemUoKSA+IDApIHtcbiAgICB2ID0gcHEucmVtb3ZlTWluKCk7XG4gICAgdkVudHJ5ID0gcmVzdWx0c1t2XTtcbiAgICBpZiAodkVudHJ5LmRpc3RhbmNlID09PSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGVkZ2VGbih2KS5mb3JFYWNoKHVwZGF0ZU5laWdoYm9ycyk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn1cbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcbnZhciB0YXJqYW4gPSByZXF1aXJlKFwiLi90YXJqYW5cIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZEN5Y2xlcztcblxuZnVuY3Rpb24gZmluZEN5Y2xlcyhnKSB7XG4gIHJldHVybiBfLmZpbHRlcih0YXJqYW4oZyksIGZ1bmN0aW9uKGNtcHQpIHtcbiAgICByZXR1cm4gY21wdC5sZW5ndGggPiAxIHx8IChjbXB0Lmxlbmd0aCA9PT0gMSAmJiBnLmhhc0VkZ2UoY21wdFswXSwgY21wdFswXSkpO1xuICB9KTtcbn1cbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmbG95ZFdhcnNoYWxsO1xuXG52YXIgREVGQVVMVF9XRUlHSFRfRlVOQyA9IF8uY29uc3RhbnQoMSk7XG5cbmZ1bmN0aW9uIGZsb3lkV2Fyc2hhbGwoZywgd2VpZ2h0Rm4sIGVkZ2VGbikge1xuICByZXR1cm4gcnVuRmxveWRXYXJzaGFsbChnLFxuICAgIHdlaWdodEZuIHx8IERFRkFVTFRfV0VJR0hUX0ZVTkMsXG4gICAgZWRnZUZuIHx8IGZ1bmN0aW9uKHYpIHsgcmV0dXJuIGcub3V0RWRnZXModik7IH0pO1xufVxuXG5mdW5jdGlvbiBydW5GbG95ZFdhcnNoYWxsKGcsIHdlaWdodEZuLCBlZGdlRm4pIHtcbiAgdmFyIHJlc3VsdHMgPSB7fTtcbiAgdmFyIG5vZGVzID0gZy5ub2RlcygpO1xuXG4gIG5vZGVzLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgIHJlc3VsdHNbdl0gPSB7fTtcbiAgICByZXN1bHRzW3ZdW3ZdID0geyBkaXN0YW5jZTogMCB9O1xuICAgIG5vZGVzLmZvckVhY2goZnVuY3Rpb24odykge1xuICAgICAgaWYgKHYgIT09IHcpIHtcbiAgICAgICAgcmVzdWx0c1t2XVt3XSA9IHsgZGlzdGFuY2U6IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSB9O1xuICAgICAgfVxuICAgIH0pO1xuICAgIGVkZ2VGbih2KS5mb3JFYWNoKGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICAgIHZhciB3ID0gZWRnZS52ID09PSB2ID8gZWRnZS53IDogZWRnZS52O1xuICAgICAgdmFyIGQgPSB3ZWlnaHRGbihlZGdlKTtcbiAgICAgIHJlc3VsdHNbdl1bd10gPSB7IGRpc3RhbmNlOiBkLCBwcmVkZWNlc3NvcjogdiB9O1xuICAgIH0pO1xuICB9KTtcblxuICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICB2YXIgcm93SyA9IHJlc3VsdHNba107XG4gICAgbm9kZXMuZm9yRWFjaChmdW5jdGlvbihpKSB7XG4gICAgICB2YXIgcm93SSA9IHJlc3VsdHNbaV07XG4gICAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKGopIHtcbiAgICAgICAgdmFyIGlrID0gcm93SVtrXTtcbiAgICAgICAgdmFyIGtqID0gcm93S1tqXTtcbiAgICAgICAgdmFyIGlqID0gcm93SVtqXTtcbiAgICAgICAgdmFyIGFsdERpc3RhbmNlID0gaWsuZGlzdGFuY2UgKyBrai5kaXN0YW5jZTtcbiAgICAgICAgaWYgKGFsdERpc3RhbmNlIDwgaWouZGlzdGFuY2UpIHtcbiAgICAgICAgICBpai5kaXN0YW5jZSA9IGFsdERpc3RhbmNlO1xuICAgICAgICAgIGlqLnByZWRlY2Vzc29yID0ga2oucHJlZGVjZXNzb3I7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcblxuICByZXR1cm4gcmVzdWx0cztcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBjb21wb25lbnRzOiByZXF1aXJlKFwiLi9jb21wb25lbnRzXCIpLFxuICBkaWprc3RyYTogcmVxdWlyZShcIi4vZGlqa3N0cmFcIiksXG4gIGRpamtzdHJhQWxsOiByZXF1aXJlKFwiLi9kaWprc3RyYS1hbGxcIiksXG4gIGZpbmRDeWNsZXM6IHJlcXVpcmUoXCIuL2ZpbmQtY3ljbGVzXCIpLFxuICBmbG95ZFdhcnNoYWxsOiByZXF1aXJlKFwiLi9mbG95ZC13YXJzaGFsbFwiKSxcbiAgaXNBY3ljbGljOiByZXF1aXJlKFwiLi9pcy1hY3ljbGljXCIpLFxuICBwb3N0b3JkZXI6IHJlcXVpcmUoXCIuL3Bvc3RvcmRlclwiKSxcbiAgcHJlb3JkZXI6IHJlcXVpcmUoXCIuL3ByZW9yZGVyXCIpLFxuICBwcmltOiByZXF1aXJlKFwiLi9wcmltXCIpLFxuICB0YXJqYW46IHJlcXVpcmUoXCIuL3RhcmphblwiKSxcbiAgdG9wc29ydDogcmVxdWlyZShcIi4vdG9wc29ydFwiKVxufTtcbiIsInZhciB0b3Bzb3J0ID0gcmVxdWlyZShcIi4vdG9wc29ydFwiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0FjeWNsaWM7XG5cbmZ1bmN0aW9uIGlzQWN5Y2xpYyhnKSB7XG4gIHRyeSB7XG4gICAgdG9wc29ydChnKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlIGluc3RhbmNlb2YgdG9wc29ydC5DeWNsZUV4Y2VwdGlvbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuIiwidmFyIGRmcyA9IHJlcXVpcmUoXCIuL2Rmc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBwb3N0b3JkZXI7XG5cbmZ1bmN0aW9uIHBvc3RvcmRlcihnLCB2cykge1xuICByZXR1cm4gZGZzKGcsIHZzLCBcInBvc3RcIik7XG59XG4iLCJ2YXIgZGZzID0gcmVxdWlyZShcIi4vZGZzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHByZW9yZGVyO1xuXG5mdW5jdGlvbiBwcmVvcmRlcihnLCB2cykge1xuICByZXR1cm4gZGZzKGcsIHZzLCBcInByZVwiKTtcbn1cbiIsInZhciBfID0gcmVxdWlyZShcIi4uL2xvZGFzaFwiKTtcbnZhciBHcmFwaCA9IHJlcXVpcmUoXCIuLi9ncmFwaFwiKTtcbnZhciBQcmlvcml0eVF1ZXVlID0gcmVxdWlyZShcIi4uL2RhdGEvcHJpb3JpdHktcXVldWVcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gcHJpbTtcblxuZnVuY3Rpb24gcHJpbShnLCB3ZWlnaHRGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgR3JhcGgoKTtcbiAgdmFyIHBhcmVudHMgPSB7fTtcbiAgdmFyIHBxID0gbmV3IFByaW9yaXR5UXVldWUoKTtcbiAgdmFyIHY7XG5cbiAgZnVuY3Rpb24gdXBkYXRlTmVpZ2hib3JzKGVkZ2UpIHtcbiAgICB2YXIgdyA9IGVkZ2UudiA9PT0gdiA/IGVkZ2UudyA6IGVkZ2UudjtcbiAgICB2YXIgcHJpID0gcHEucHJpb3JpdHkodyk7XG4gICAgaWYgKHByaSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZWRnZVdlaWdodCA9IHdlaWdodEZ1bmMoZWRnZSk7XG4gICAgICBpZiAoZWRnZVdlaWdodCA8IHByaSkge1xuICAgICAgICBwYXJlbnRzW3ddID0gdjtcbiAgICAgICAgcHEuZGVjcmVhc2UodywgZWRnZVdlaWdodCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGcubm9kZUNvdW50KCkgPT09IDApIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgXy5lYWNoKGcubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHBxLmFkZCh2LCBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgIHJlc3VsdC5zZXROb2RlKHYpO1xuICB9KTtcblxuICAvLyBTdGFydCBmcm9tIGFuIGFyYml0cmFyeSBub2RlXG4gIHBxLmRlY3JlYXNlKGcubm9kZXMoKVswXSwgMCk7XG5cbiAgdmFyIGluaXQgPSBmYWxzZTtcbiAgd2hpbGUgKHBxLnNpemUoKSA+IDApIHtcbiAgICB2ID0gcHEucmVtb3ZlTWluKCk7XG4gICAgaWYgKF8uaGFzKHBhcmVudHMsIHYpKSB7XG4gICAgICByZXN1bHQuc2V0RWRnZSh2LCBwYXJlbnRzW3ZdKTtcbiAgICB9IGVsc2UgaWYgKGluaXQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIklucHV0IGdyYXBoIGlzIG5vdCBjb25uZWN0ZWQ6IFwiICsgZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluaXQgPSB0cnVlO1xuICAgIH1cblxuICAgIGcubm9kZUVkZ2VzKHYpLmZvckVhY2godXBkYXRlTmVpZ2hib3JzKTtcbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gdGFyamFuO1xuXG5mdW5jdGlvbiB0YXJqYW4oZykge1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgc3RhY2sgPSBbXTtcbiAgdmFyIHZpc2l0ZWQgPSB7fTsgLy8gbm9kZSBpZCAtPiB7IG9uU3RhY2ssIGxvd2xpbmssIGluZGV4IH1cbiAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICBmdW5jdGlvbiBkZnModikge1xuICAgIHZhciBlbnRyeSA9IHZpc2l0ZWRbdl0gPSB7XG4gICAgICBvblN0YWNrOiB0cnVlLFxuICAgICAgbG93bGluazogaW5kZXgsXG4gICAgICBpbmRleDogaW5kZXgrK1xuICAgIH07XG4gICAgc3RhY2sucHVzaCh2KTtcblxuICAgIGcuc3VjY2Vzc29ycyh2KS5mb3JFYWNoKGZ1bmN0aW9uKHcpIHtcbiAgICAgIGlmICghXy5oYXModmlzaXRlZCwgdykpIHtcbiAgICAgICAgZGZzKHcpO1xuICAgICAgICBlbnRyeS5sb3dsaW5rID0gTWF0aC5taW4oZW50cnkubG93bGluaywgdmlzaXRlZFt3XS5sb3dsaW5rKTtcbiAgICAgIH0gZWxzZSBpZiAodmlzaXRlZFt3XS5vblN0YWNrKSB7XG4gICAgICAgIGVudHJ5Lmxvd2xpbmsgPSBNYXRoLm1pbihlbnRyeS5sb3dsaW5rLCB2aXNpdGVkW3ddLmluZGV4KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChlbnRyeS5sb3dsaW5rID09PSBlbnRyeS5pbmRleCkge1xuICAgICAgdmFyIGNtcHQgPSBbXTtcbiAgICAgIHZhciB3O1xuICAgICAgZG8ge1xuICAgICAgICB3ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIHZpc2l0ZWRbd10ub25TdGFjayA9IGZhbHNlO1xuICAgICAgICBjbXB0LnB1c2godyk7XG4gICAgICB9IHdoaWxlICh2ICE9PSB3KTtcbiAgICAgIHJlc3VsdHMucHVzaChjbXB0KTtcbiAgICB9XG4gIH1cblxuICBnLm5vZGVzKCkuZm9yRWFjaChmdW5jdGlvbih2KSB7XG4gICAgaWYgKCFfLmhhcyh2aXNpdGVkLCB2KSkge1xuICAgICAgZGZzKHYpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gdG9wc29ydDtcbnRvcHNvcnQuQ3ljbGVFeGNlcHRpb24gPSBDeWNsZUV4Y2VwdGlvbjtcblxuZnVuY3Rpb24gdG9wc29ydChnKSB7XG4gIHZhciB2aXNpdGVkID0ge307XG4gIHZhciBzdGFjayA9IHt9O1xuICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gIGZ1bmN0aW9uIHZpc2l0KG5vZGUpIHtcbiAgICBpZiAoXy5oYXMoc3RhY2ssIG5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgQ3ljbGVFeGNlcHRpb24oKTtcbiAgICB9XG5cbiAgICBpZiAoIV8uaGFzKHZpc2l0ZWQsIG5vZGUpKSB7XG4gICAgICBzdGFja1tub2RlXSA9IHRydWU7XG4gICAgICB2aXNpdGVkW25vZGVdID0gdHJ1ZTtcbiAgICAgIF8uZWFjaChnLnByZWRlY2Vzc29ycyhub2RlKSwgdmlzaXQpO1xuICAgICAgZGVsZXRlIHN0YWNrW25vZGVdO1xuICAgICAgcmVzdWx0cy5wdXNoKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIF8uZWFjaChnLnNpbmtzKCksIHZpc2l0KTtcblxuICBpZiAoXy5zaXplKHZpc2l0ZWQpICE9PSBnLm5vZGVDb3VudCgpKSB7XG4gICAgdGhyb3cgbmV3IEN5Y2xlRXhjZXB0aW9uKCk7XG4gIH1cblxuICByZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gQ3ljbGVFeGNlcHRpb24oKSB7fVxuQ3ljbGVFeGNlcHRpb24ucHJvdG90eXBlID0gbmV3IEVycm9yKCk7IC8vIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRXJyb3IgdG8gcGFzcyB0ZXN0aW5nIiwidmFyIF8gPSByZXF1aXJlKFwiLi4vbG9kYXNoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByaW9yaXR5UXVldWU7XG5cbi8qKlxuICogQSBtaW4tcHJpb3JpdHkgcXVldWUgZGF0YSBzdHJ1Y3R1cmUuIFRoaXMgYWxnb3JpdGhtIGlzIGRlcml2ZWQgZnJvbSBDb3JtZW4sXG4gKiBldCBhbC4sIFwiSW50cm9kdWN0aW9uIHRvIEFsZ29yaXRobXNcIi4gVGhlIGJhc2ljIGlkZWEgb2YgYSBtaW4tcHJpb3JpdHlcbiAqIHF1ZXVlIGlzIHRoYXQgeW91IGNhbiBlZmZpY2llbnRseSAoaW4gTygxKSB0aW1lKSBnZXQgdGhlIHNtYWxsZXN0IGtleSBpblxuICogdGhlIHF1ZXVlLiBBZGRpbmcgYW5kIHJlbW92aW5nIGVsZW1lbnRzIHRha2VzIE8obG9nIG4pIHRpbWUuIEEga2V5IGNhblxuICogaGF2ZSBpdHMgcHJpb3JpdHkgZGVjcmVhc2VkIGluIE8obG9nIG4pIHRpbWUuXG4gKi9cbmZ1bmN0aW9uIFByaW9yaXR5UXVldWUoKSB7XG4gIHRoaXMuX2FyciA9IFtdO1xuICB0aGlzLl9rZXlJbmRpY2VzID0ge307XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBxdWV1ZS4gVGFrZXMgYE8oMSlgIHRpbWUuXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2Fyci5sZW5ndGg7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGtleXMgdGhhdCBhcmUgaW4gdGhlIHF1ZXVlLiBUYWtlcyBgTyhuKWAgdGltZS5cbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fYXJyLm1hcChmdW5jdGlvbih4KSB7IHJldHVybiB4LmtleTsgfSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYHRydWVgIGlmICoqa2V5KiogaXMgaW4gdGhlIHF1ZXVlIGFuZCBgZmFsc2VgIGlmIG5vdC5cbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24oa2V5KSB7XG4gIHJldHVybiBfLmhhcyh0aGlzLl9rZXlJbmRpY2VzLCBrZXkpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBwcmlvcml0eSBmb3IgKiprZXkqKi4gSWYgKiprZXkqKiBpcyBub3QgcHJlc2VudCBpbiB0aGUgcXVldWVcbiAqIHRoZW4gdGhpcyBmdW5jdGlvbiByZXR1cm5zIGB1bmRlZmluZWRgLiBUYWtlcyBgTygxKWAgdGltZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0ga2V5XG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLnByaW9yaXR5ID0gZnVuY3Rpb24oa2V5KSB7XG4gIHZhciBpbmRleCA9IHRoaXMuX2tleUluZGljZXNba2V5XTtcbiAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdGhpcy5fYXJyW2luZGV4XS5wcmlvcml0eTtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBrZXkgZm9yIHRoZSBtaW5pbXVtIGVsZW1lbnQgaW4gdGhpcyBxdWV1ZS4gSWYgdGhlIHF1ZXVlIGlzXG4gKiBlbXB0eSB0aGlzIGZ1bmN0aW9uIHRocm93cyBhbiBFcnJvci4gVGFrZXMgYE8oMSlgIHRpbWUuXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5zaXplKCkgPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJRdWV1ZSB1bmRlcmZsb3dcIik7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2FyclswXS5rZXk7XG59O1xuXG4vKipcbiAqIEluc2VydHMgYSBuZXcga2V5IGludG8gdGhlIHByaW9yaXR5IHF1ZXVlLiBJZiB0aGUga2V5IGFscmVhZHkgZXhpc3RzIGluXG4gKiB0aGUgcXVldWUgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGBmYWxzZWA7IG90aGVyd2lzZSBpdCB3aWxsIHJldHVybiBgdHJ1ZWAuXG4gKiBUYWtlcyBgTyhuKWAgdGltZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0ga2V5IHRoZSBrZXkgdG8gYWRkXG4gKiBAcGFyYW0ge051bWJlcn0gcHJpb3JpdHkgdGhlIGluaXRpYWwgcHJpb3JpdHkgZm9yIHRoZSBrZXlcbiAqL1xuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24oa2V5LCBwcmlvcml0eSkge1xuICB2YXIga2V5SW5kaWNlcyA9IHRoaXMuX2tleUluZGljZXM7XG4gIGtleSA9IFN0cmluZyhrZXkpO1xuICBpZiAoIV8uaGFzKGtleUluZGljZXMsIGtleSkpIHtcbiAgICB2YXIgYXJyID0gdGhpcy5fYXJyO1xuICAgIHZhciBpbmRleCA9IGFyci5sZW5ndGg7XG4gICAga2V5SW5kaWNlc1trZXldID0gaW5kZXg7XG4gICAgYXJyLnB1c2goe2tleToga2V5LCBwcmlvcml0eTogcHJpb3JpdHl9KTtcbiAgICB0aGlzLl9kZWNyZWFzZShpbmRleCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGFuZCByZXR1cm5zIHRoZSBzbWFsbGVzdCBrZXkgaW4gdGhlIHF1ZXVlLiBUYWtlcyBgTyhsb2cgbilgIHRpbWUuXG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLnJlbW92ZU1pbiA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl9zd2FwKDAsIHRoaXMuX2Fyci5sZW5ndGggLSAxKTtcbiAgdmFyIG1pbiA9IHRoaXMuX2Fyci5wb3AoKTtcbiAgZGVsZXRlIHRoaXMuX2tleUluZGljZXNbbWluLmtleV07XG4gIHRoaXMuX2hlYXBpZnkoMCk7XG4gIHJldHVybiBtaW4ua2V5O1xufTtcblxuLyoqXG4gKiBEZWNyZWFzZXMgdGhlIHByaW9yaXR5IGZvciAqKmtleSoqIHRvICoqcHJpb3JpdHkqKi4gSWYgdGhlIG5ldyBwcmlvcml0eSBpc1xuICogZ3JlYXRlciB0aGFuIHRoZSBwcmV2aW91cyBwcmlvcml0eSwgdGhpcyBmdW5jdGlvbiB3aWxsIHRocm93IGFuIEVycm9yLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBrZXkgdGhlIGtleSBmb3Igd2hpY2ggdG8gcmFpc2UgcHJpb3JpdHlcbiAqIEBwYXJhbSB7TnVtYmVyfSBwcmlvcml0eSB0aGUgbmV3IHByaW9yaXR5IGZvciB0aGUga2V5XG4gKi9cblByaW9yaXR5UXVldWUucHJvdG90eXBlLmRlY3JlYXNlID0gZnVuY3Rpb24oa2V5LCBwcmlvcml0eSkge1xuICB2YXIgaW5kZXggPSB0aGlzLl9rZXlJbmRpY2VzW2tleV07XG4gIGlmIChwcmlvcml0eSA+IHRoaXMuX2FycltpbmRleF0ucHJpb3JpdHkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJOZXcgcHJpb3JpdHkgaXMgZ3JlYXRlciB0aGFuIGN1cnJlbnQgcHJpb3JpdHkuIFwiICtcbiAgICAgICAgXCJLZXk6IFwiICsga2V5ICsgXCIgT2xkOiBcIiArIHRoaXMuX2FycltpbmRleF0ucHJpb3JpdHkgKyBcIiBOZXc6IFwiICsgcHJpb3JpdHkpO1xuICB9XG4gIHRoaXMuX2FycltpbmRleF0ucHJpb3JpdHkgPSBwcmlvcml0eTtcbiAgdGhpcy5fZGVjcmVhc2UoaW5kZXgpO1xufTtcblxuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuX2hlYXBpZnkgPSBmdW5jdGlvbihpKSB7XG4gIHZhciBhcnIgPSB0aGlzLl9hcnI7XG4gIHZhciBsID0gMiAqIGk7XG4gIHZhciByID0gbCArIDE7XG4gIHZhciBsYXJnZXN0ID0gaTtcbiAgaWYgKGwgPCBhcnIubGVuZ3RoKSB7XG4gICAgbGFyZ2VzdCA9IGFycltsXS5wcmlvcml0eSA8IGFycltsYXJnZXN0XS5wcmlvcml0eSA/IGwgOiBsYXJnZXN0O1xuICAgIGlmIChyIDwgYXJyLmxlbmd0aCkge1xuICAgICAgbGFyZ2VzdCA9IGFycltyXS5wcmlvcml0eSA8IGFycltsYXJnZXN0XS5wcmlvcml0eSA/IHIgOiBsYXJnZXN0O1xuICAgIH1cbiAgICBpZiAobGFyZ2VzdCAhPT0gaSkge1xuICAgICAgdGhpcy5fc3dhcChpLCBsYXJnZXN0KTtcbiAgICAgIHRoaXMuX2hlYXBpZnkobGFyZ2VzdCk7XG4gICAgfVxuICB9XG59O1xuXG5Qcmlvcml0eVF1ZXVlLnByb3RvdHlwZS5fZGVjcmVhc2UgPSBmdW5jdGlvbihpbmRleCkge1xuICB2YXIgYXJyID0gdGhpcy5fYXJyO1xuICB2YXIgcHJpb3JpdHkgPSBhcnJbaW5kZXhdLnByaW9yaXR5O1xuICB2YXIgcGFyZW50O1xuICB3aGlsZSAoaW5kZXggIT09IDApIHtcbiAgICBwYXJlbnQgPSBpbmRleCA+PiAxO1xuICAgIGlmIChhcnJbcGFyZW50XS5wcmlvcml0eSA8IHByaW9yaXR5KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5fc3dhcChpbmRleCwgcGFyZW50KTtcbiAgICBpbmRleCA9IHBhcmVudDtcbiAgfVxufTtcblxuUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuX3N3YXAgPSBmdW5jdGlvbihpLCBqKSB7XG4gIHZhciBhcnIgPSB0aGlzLl9hcnI7XG4gIHZhciBrZXlJbmRpY2VzID0gdGhpcy5fa2V5SW5kaWNlcztcbiAgdmFyIG9yaWdBcnJJID0gYXJyW2ldO1xuICB2YXIgb3JpZ0FyckogPSBhcnJbal07XG4gIGFycltpXSA9IG9yaWdBcnJKO1xuICBhcnJbal0gPSBvcmlnQXJySTtcbiAga2V5SW5kaWNlc1tvcmlnQXJySi5rZXldID0gaTtcbiAga2V5SW5kaWNlc1tvcmlnQXJySS5rZXldID0gajtcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIF8gPSByZXF1aXJlKFwiLi9sb2Rhc2hcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gR3JhcGg7XG5cbnZhciBERUZBVUxUX0VER0VfTkFNRSA9IFwiXFx4MDBcIjtcbnZhciBHUkFQSF9OT0RFID0gXCJcXHgwMFwiO1xudmFyIEVER0VfS0VZX0RFTElNID0gXCJcXHgwMVwiO1xuXG4vLyBJbXBsZW1lbnRhdGlvbiBub3Rlczpcbi8vXG4vLyAgKiBOb2RlIGlkIHF1ZXJ5IGZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIHN0cmluZyBpZHMgZm9yIHRoZSBub2Rlc1xuLy8gICogRWRnZSBpZCBxdWVyeSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBcImVkZ2VPYmpcIiwgZWRnZSBvYmplY3QsIHRoYXQgaXNcbi8vICAgIGNvbXBvc2VkIG9mIGVub3VnaCBpbmZvcm1hdGlvbiB0byB1bmlxdWVseSBpZGVudGlmeSBhbiBlZGdlOiB7diwgdywgbmFtZX0uXG4vLyAgKiBJbnRlcm5hbGx5IHdlIHVzZSBhbiBcImVkZ2VJZFwiLCBhIHN0cmluZ2lmaWVkIGZvcm0gb2YgdGhlIGVkZ2VPYmosIHRvXG4vLyAgICByZWZlcmVuY2UgZWRnZXMuIFRoaXMgaXMgYmVjYXVzZSB3ZSBuZWVkIGEgcGVyZm9ybWFudCB3YXkgdG8gbG9vayB0aGVzZVxuLy8gICAgZWRnZXMgdXAgYW5kLCBvYmplY3QgcHJvcGVydGllcywgd2hpY2ggaGF2ZSBzdHJpbmcga2V5cywgYXJlIHRoZSBjbG9zZXN0XG4vLyAgICB3ZSdyZSBnb2luZyB0byBnZXQgdG8gYSBwZXJmb3JtYW50IGhhc2h0YWJsZSBpbiBKYXZhU2NyaXB0LlxuXG5mdW5jdGlvbiBHcmFwaChvcHRzKSB7XG4gIHRoaXMuX2lzRGlyZWN0ZWQgPSBfLmhhcyhvcHRzLCBcImRpcmVjdGVkXCIpID8gb3B0cy5kaXJlY3RlZCA6IHRydWU7XG4gIHRoaXMuX2lzTXVsdGlncmFwaCA9IF8uaGFzKG9wdHMsIFwibXVsdGlncmFwaFwiKSA/IG9wdHMubXVsdGlncmFwaCA6IGZhbHNlO1xuICB0aGlzLl9pc0NvbXBvdW5kID0gXy5oYXMob3B0cywgXCJjb21wb3VuZFwiKSA/IG9wdHMuY29tcG91bmQgOiBmYWxzZTtcblxuICAvLyBMYWJlbCBmb3IgdGhlIGdyYXBoIGl0c2VsZlxuICB0aGlzLl9sYWJlbCA9IHVuZGVmaW5lZDtcblxuICAvLyBEZWZhdWx0cyB0byBiZSBzZXQgd2hlbiBjcmVhdGluZyBhIG5ldyBub2RlXG4gIHRoaXMuX2RlZmF1bHROb2RlTGFiZWxGbiA9IF8uY29uc3RhbnQodW5kZWZpbmVkKTtcblxuICAvLyBEZWZhdWx0cyB0byBiZSBzZXQgd2hlbiBjcmVhdGluZyBhIG5ldyBlZGdlXG4gIHRoaXMuX2RlZmF1bHRFZGdlTGFiZWxGbiA9IF8uY29uc3RhbnQodW5kZWZpbmVkKTtcblxuICAvLyB2IC0+IGxhYmVsXG4gIHRoaXMuX25vZGVzID0ge307XG5cbiAgaWYgKHRoaXMuX2lzQ29tcG91bmQpIHtcbiAgICAvLyB2IC0+IHBhcmVudFxuICAgIHRoaXMuX3BhcmVudCA9IHt9O1xuXG4gICAgLy8gdiAtPiBjaGlsZHJlblxuICAgIHRoaXMuX2NoaWxkcmVuID0ge307XG4gICAgdGhpcy5fY2hpbGRyZW5bR1JBUEhfTk9ERV0gPSB7fTtcbiAgfVxuXG4gIC8vIHYgLT4gZWRnZU9ialxuICB0aGlzLl9pbiA9IHt9O1xuXG4gIC8vIHUgLT4gdiAtPiBOdW1iZXJcbiAgdGhpcy5fcHJlZHMgPSB7fTtcblxuICAvLyB2IC0+IGVkZ2VPYmpcbiAgdGhpcy5fb3V0ID0ge307XG5cbiAgLy8gdiAtPiB3IC0+IE51bWJlclxuICB0aGlzLl9zdWNzID0ge307XG5cbiAgLy8gZSAtPiBlZGdlT2JqXG4gIHRoaXMuX2VkZ2VPYmpzID0ge307XG5cbiAgLy8gZSAtPiBsYWJlbFxuICB0aGlzLl9lZGdlTGFiZWxzID0ge307XG59XG5cbi8qIE51bWJlciBvZiBub2RlcyBpbiB0aGUgZ3JhcGguIFNob3VsZCBvbmx5IGJlIGNoYW5nZWQgYnkgdGhlIGltcGxlbWVudGF0aW9uLiAqL1xuR3JhcGgucHJvdG90eXBlLl9ub2RlQ291bnQgPSAwO1xuXG4vKiBOdW1iZXIgb2YgZWRnZXMgaW4gdGhlIGdyYXBoLiBTaG91bGQgb25seSBiZSBjaGFuZ2VkIGJ5IHRoZSBpbXBsZW1lbnRhdGlvbi4gKi9cbkdyYXBoLnByb3RvdHlwZS5fZWRnZUNvdW50ID0gMDtcblxuXG4vKiA9PT0gR3JhcGggZnVuY3Rpb25zID09PT09PT09PSAqL1xuXG5HcmFwaC5wcm90b3R5cGUuaXNEaXJlY3RlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5faXNEaXJlY3RlZDtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5pc011bHRpZ3JhcGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2lzTXVsdGlncmFwaDtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5pc0NvbXBvdW5kID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9pc0NvbXBvdW5kO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnNldEdyYXBoID0gZnVuY3Rpb24obGFiZWwpIHtcbiAgdGhpcy5fbGFiZWwgPSBsYWJlbDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuZ3JhcGggPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX2xhYmVsO1xufTtcblxuXG4vKiA9PT0gTm9kZSBmdW5jdGlvbnMgPT09PT09PT09PSAqL1xuXG5HcmFwaC5wcm90b3R5cGUuc2V0RGVmYXVsdE5vZGVMYWJlbCA9IGZ1bmN0aW9uKG5ld0RlZmF1bHQpIHtcbiAgaWYgKCFfLmlzRnVuY3Rpb24obmV3RGVmYXVsdCkpIHtcbiAgICBuZXdEZWZhdWx0ID0gXy5jb25zdGFudChuZXdEZWZhdWx0KTtcbiAgfVxuICB0aGlzLl9kZWZhdWx0Tm9kZUxhYmVsRm4gPSBuZXdEZWZhdWx0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5ub2RlQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHRoaXMuX25vZGVDb3VudDtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5ub2RlcyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gXy5rZXlzKHRoaXMuX25vZGVzKTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5zb3VyY2VzID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgcmV0dXJuIF8uZmlsdGVyKHRoaXMubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgIHJldHVybiBfLmlzRW1wdHkoc2VsZi5faW5bdl0pO1xuICB9KTtcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5zaW5rcyA9IGZ1bmN0aW9uKCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHJldHVybiBfLmZpbHRlcih0aGlzLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICByZXR1cm4gXy5pc0VtcHR5KHNlbGYuX291dFt2XSk7XG4gIH0pO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnNldE5vZGVzID0gZnVuY3Rpb24odnMsIHZhbHVlKSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIF8uZWFjaCh2cywgZnVuY3Rpb24odikge1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHNlbGYuc2V0Tm9kZSh2LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuc2V0Tm9kZSh2KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkdyYXBoLnByb3RvdHlwZS5zZXROb2RlID0gZnVuY3Rpb24odiwgdmFsdWUpIHtcbiAgaWYgKF8uaGFzKHRoaXMuX25vZGVzLCB2KSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgdGhpcy5fbm9kZXNbdl0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0aGlzLl9ub2Rlc1t2XSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gdmFsdWUgOiB0aGlzLl9kZWZhdWx0Tm9kZUxhYmVsRm4odik7XG4gIGlmICh0aGlzLl9pc0NvbXBvdW5kKSB7XG4gICAgdGhpcy5fcGFyZW50W3ZdID0gR1JBUEhfTk9ERTtcbiAgICB0aGlzLl9jaGlsZHJlblt2XSA9IHt9O1xuICAgIHRoaXMuX2NoaWxkcmVuW0dSQVBIX05PREVdW3ZdID0gdHJ1ZTtcbiAgfVxuICB0aGlzLl9pblt2XSA9IHt9O1xuICB0aGlzLl9wcmVkc1t2XSA9IHt9O1xuICB0aGlzLl9vdXRbdl0gPSB7fTtcbiAgdGhpcy5fc3Vjc1t2XSA9IHt9O1xuICArK3RoaXMuX25vZGVDb3VudDtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUubm9kZSA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIHRoaXMuX25vZGVzW3ZdO1xufTtcblxuR3JhcGgucHJvdG90eXBlLmhhc05vZGUgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBfLmhhcyh0aGlzLl9ub2Rlcywgdik7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUucmVtb3ZlTm9kZSA9ICBmdW5jdGlvbih2KSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKF8uaGFzKHRoaXMuX25vZGVzLCB2KSkge1xuICAgIHZhciByZW1vdmVFZGdlID0gZnVuY3Rpb24oZSkgeyBzZWxmLnJlbW92ZUVkZ2Uoc2VsZi5fZWRnZU9ianNbZV0pOyB9O1xuICAgIGRlbGV0ZSB0aGlzLl9ub2Rlc1t2XTtcbiAgICBpZiAodGhpcy5faXNDb21wb3VuZCkge1xuICAgICAgdGhpcy5fcmVtb3ZlRnJvbVBhcmVudHNDaGlsZExpc3Qodik7XG4gICAgICBkZWxldGUgdGhpcy5fcGFyZW50W3ZdO1xuICAgICAgXy5lYWNoKHRoaXMuY2hpbGRyZW4odiksIGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIHNlbGYuc2V0UGFyZW50KGNoaWxkKTtcbiAgICAgIH0pO1xuICAgICAgZGVsZXRlIHRoaXMuX2NoaWxkcmVuW3ZdO1xuICAgIH1cbiAgICBfLmVhY2goXy5rZXlzKHRoaXMuX2luW3ZdKSwgcmVtb3ZlRWRnZSk7XG4gICAgZGVsZXRlIHRoaXMuX2luW3ZdO1xuICAgIGRlbGV0ZSB0aGlzLl9wcmVkc1t2XTtcbiAgICBfLmVhY2goXy5rZXlzKHRoaXMuX291dFt2XSksIHJlbW92ZUVkZ2UpO1xuICAgIGRlbGV0ZSB0aGlzLl9vdXRbdl07XG4gICAgZGVsZXRlIHRoaXMuX3N1Y3Nbdl07XG4gICAgLS10aGlzLl9ub2RlQ291bnQ7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuc2V0UGFyZW50ID0gZnVuY3Rpb24odiwgcGFyZW50KSB7XG4gIGlmICghdGhpcy5faXNDb21wb3VuZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgcGFyZW50IGluIGEgbm9uLWNvbXBvdW5kIGdyYXBoXCIpO1xuICB9XG5cbiAgaWYgKF8uaXNVbmRlZmluZWQocGFyZW50KSkge1xuICAgIHBhcmVudCA9IEdSQVBIX05PREU7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29lcmNlIHBhcmVudCB0byBzdHJpbmdcbiAgICBwYXJlbnQgKz0gXCJcIjtcbiAgICBmb3IgKHZhciBhbmNlc3RvciA9IHBhcmVudDtcbiAgICAgICFfLmlzVW5kZWZpbmVkKGFuY2VzdG9yKTtcbiAgICAgIGFuY2VzdG9yID0gdGhpcy5wYXJlbnQoYW5jZXN0b3IpKSB7XG4gICAgICBpZiAoYW5jZXN0b3IgPT09IHYpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2V0dGluZyBcIiArIHBhcmVudCsgXCIgYXMgcGFyZW50IG9mIFwiICsgdiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiB3b3VsZCBjcmVhdGUgYSBjeWNsZVwiKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnNldE5vZGUocGFyZW50KTtcbiAgfVxuXG4gIHRoaXMuc2V0Tm9kZSh2KTtcbiAgdGhpcy5fcmVtb3ZlRnJvbVBhcmVudHNDaGlsZExpc3Qodik7XG4gIHRoaXMuX3BhcmVudFt2XSA9IHBhcmVudDtcbiAgdGhpcy5fY2hpbGRyZW5bcGFyZW50XVt2XSA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhcGgucHJvdG90eXBlLl9yZW1vdmVGcm9tUGFyZW50c0NoaWxkTGlzdCA9IGZ1bmN0aW9uKHYpIHtcbiAgZGVsZXRlIHRoaXMuX2NoaWxkcmVuW3RoaXMuX3BhcmVudFt2XV1bdl07XG59O1xuXG5HcmFwaC5wcm90b3R5cGUucGFyZW50ID0gZnVuY3Rpb24odikge1xuICBpZiAodGhpcy5faXNDb21wb3VuZCkge1xuICAgIHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnRbdl07XG4gICAgaWYgKHBhcmVudCAhPT0gR1JBUEhfTk9ERSkge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG4gIH1cbn07XG5cbkdyYXBoLnByb3RvdHlwZS5jaGlsZHJlbiA9IGZ1bmN0aW9uKHYpIHtcbiAgaWYgKF8uaXNVbmRlZmluZWQodikpIHtcbiAgICB2ID0gR1JBUEhfTk9ERTtcbiAgfVxuXG4gIGlmICh0aGlzLl9pc0NvbXBvdW5kKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW5bdl07XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gXy5rZXlzKGNoaWxkcmVuKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodiA9PT0gR1JBUEhfTk9ERSkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzKCk7XG4gIH0gZWxzZSBpZiAodGhpcy5oYXNOb2RlKHYpKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59O1xuXG5HcmFwaC5wcm90b3R5cGUucHJlZGVjZXNzb3JzID0gZnVuY3Rpb24odikge1xuICB2YXIgcHJlZHNWID0gdGhpcy5fcHJlZHNbdl07XG4gIGlmIChwcmVkc1YpIHtcbiAgICByZXR1cm4gXy5rZXlzKHByZWRzVik7XG4gIH1cbn07XG5cbkdyYXBoLnByb3RvdHlwZS5zdWNjZXNzb3JzID0gZnVuY3Rpb24odikge1xuICB2YXIgc3Vjc1YgPSB0aGlzLl9zdWNzW3ZdO1xuICBpZiAoc3Vjc1YpIHtcbiAgICByZXR1cm4gXy5rZXlzKHN1Y3NWKTtcbiAgfVxufTtcblxuR3JhcGgucHJvdG90eXBlLm5laWdoYm9ycyA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIHByZWRzID0gdGhpcy5wcmVkZWNlc3NvcnModik7XG4gIGlmIChwcmVkcykge1xuICAgIHJldHVybiBfLnVuaW9uKHByZWRzLCB0aGlzLnN1Y2Nlc3NvcnModikpO1xuICB9XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuaXNMZWFmID0gZnVuY3Rpb24gKHYpIHtcbiAgdmFyIG5laWdoYm9ycztcbiAgaWYgKHRoaXMuaXNEaXJlY3RlZCgpKSB7XG4gICAgbmVpZ2hib3JzID0gdGhpcy5zdWNjZXNzb3JzKHYpO1xuICB9IGVsc2Uge1xuICAgIG5laWdoYm9ycyA9IHRoaXMubmVpZ2hib3JzKHYpO1xuICB9XG4gIHJldHVybiBuZWlnaGJvcnMubGVuZ3RoID09PSAwO1xufTtcblxuR3JhcGgucHJvdG90eXBlLmZpbHRlck5vZGVzID0gZnVuY3Rpb24oZmlsdGVyKSB7XG4gIHZhciBjb3B5ID0gbmV3IHRoaXMuY29uc3RydWN0b3Ioe1xuICAgIGRpcmVjdGVkOiB0aGlzLl9pc0RpcmVjdGVkLFxuICAgIG11bHRpZ3JhcGg6IHRoaXMuX2lzTXVsdGlncmFwaCxcbiAgICBjb21wb3VuZDogdGhpcy5faXNDb21wb3VuZFxuICB9KTtcblxuICBjb3B5LnNldEdyYXBoKHRoaXMuZ3JhcGgoKSk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBfLmVhY2godGhpcy5fbm9kZXMsIGZ1bmN0aW9uKHZhbHVlLCB2KSB7XG4gICAgaWYgKGZpbHRlcih2KSkge1xuICAgICAgY29weS5zZXROb2RlKHYsIHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuXG4gIF8uZWFjaCh0aGlzLl9lZGdlT2JqcywgZnVuY3Rpb24oZSkge1xuICAgIGlmIChjb3B5Lmhhc05vZGUoZS52KSAmJiBjb3B5Lmhhc05vZGUoZS53KSkge1xuICAgICAgY29weS5zZXRFZGdlKGUsIHNlbGYuZWRnZShlKSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgcGFyZW50cyA9IHt9O1xuICBmdW5jdGlvbiBmaW5kUGFyZW50KHYpIHtcbiAgICB2YXIgcGFyZW50ID0gc2VsZi5wYXJlbnQodik7XG4gICAgaWYgKHBhcmVudCA9PT0gdW5kZWZpbmVkIHx8IGNvcHkuaGFzTm9kZShwYXJlbnQpKSB7XG4gICAgICBwYXJlbnRzW3ZdID0gcGFyZW50O1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9IGVsc2UgaWYgKHBhcmVudCBpbiBwYXJlbnRzKSB7XG4gICAgICByZXR1cm4gcGFyZW50c1twYXJlbnRdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmluZFBhcmVudChwYXJlbnQpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLl9pc0NvbXBvdW5kKSB7XG4gICAgXy5lYWNoKGNvcHkubm9kZXMoKSwgZnVuY3Rpb24odikge1xuICAgICAgY29weS5zZXRQYXJlbnQodiwgZmluZFBhcmVudCh2KSk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gY29weTtcbn07XG5cbi8qID09PSBFZGdlIGZ1bmN0aW9ucyA9PT09PT09PT09ICovXG5cbkdyYXBoLnByb3RvdHlwZS5zZXREZWZhdWx0RWRnZUxhYmVsID0gZnVuY3Rpb24obmV3RGVmYXVsdCkge1xuICBpZiAoIV8uaXNGdW5jdGlvbihuZXdEZWZhdWx0KSkge1xuICAgIG5ld0RlZmF1bHQgPSBfLmNvbnN0YW50KG5ld0RlZmF1bHQpO1xuICB9XG4gIHRoaXMuX2RlZmF1bHRFZGdlTGFiZWxGbiA9IG5ld0RlZmF1bHQ7XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhcGgucHJvdG90eXBlLmVkZ2VDb3VudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZWRnZUNvdW50O1xufTtcblxuR3JhcGgucHJvdG90eXBlLmVkZ2VzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBfLnZhbHVlcyh0aGlzLl9lZGdlT2Jqcyk7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuc2V0UGF0aCA9IGZ1bmN0aW9uKHZzLCB2YWx1ZSkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICBfLnJlZHVjZSh2cywgZnVuY3Rpb24odiwgdykge1xuICAgIGlmIChhcmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHNlbGYuc2V0RWRnZSh2LCB3LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGYuc2V0RWRnZSh2LCB3KTtcbiAgICB9XG4gICAgcmV0dXJuIHc7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qXG4gKiBzZXRFZGdlKHYsIHcsIFt2YWx1ZSwgW25hbWVdXSlcbiAqIHNldEVkZ2UoeyB2LCB3LCBbbmFtZV0gfSwgW3ZhbHVlXSlcbiAqL1xuR3JhcGgucHJvdG90eXBlLnNldEVkZ2UgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHYsIHcsIG5hbWUsIHZhbHVlO1xuICB2YXIgdmFsdWVTcGVjaWZpZWQgPSBmYWxzZTtcbiAgdmFyIGFyZzAgPSBhcmd1bWVudHNbMF07XG5cbiAgaWYgKHR5cGVvZiBhcmcwID09PSBcIm9iamVjdFwiICYmIGFyZzAgIT09IG51bGwgJiYgXCJ2XCIgaW4gYXJnMCkge1xuICAgIHYgPSBhcmcwLnY7XG4gICAgdyA9IGFyZzAudztcbiAgICBuYW1lID0gYXJnMC5uYW1lO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICB2YWx1ZSA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIHZhbHVlU3BlY2lmaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdiA9IGFyZzA7XG4gICAgdyA9IGFyZ3VtZW50c1sxXTtcbiAgICBuYW1lID0gYXJndW1lbnRzWzNdO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgdmFsdWUgPSBhcmd1bWVudHNbMl07XG4gICAgICB2YWx1ZVNwZWNpZmllZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdiA9IFwiXCIgKyB2O1xuICB3ID0gXCJcIiArIHc7XG4gIGlmICghXy5pc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIG5hbWUgPSBcIlwiICsgbmFtZTtcbiAgfVxuXG4gIHZhciBlID0gZWRnZUFyZ3NUb0lkKHRoaXMuX2lzRGlyZWN0ZWQsIHYsIHcsIG5hbWUpO1xuICBpZiAoXy5oYXModGhpcy5fZWRnZUxhYmVscywgZSkpIHtcbiAgICBpZiAodmFsdWVTcGVjaWZpZWQpIHtcbiAgICAgIHRoaXMuX2VkZ2VMYWJlbHNbZV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBpZiAoIV8uaXNVbmRlZmluZWQobmFtZSkgJiYgIXRoaXMuX2lzTXVsdGlncmFwaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgYSBuYW1lZCBlZGdlIHdoZW4gaXNNdWx0aWdyYXBoID0gZmFsc2VcIik7XG4gIH1cblxuICAvLyBJdCBkaWRuJ3QgZXhpc3QsIHNvIHdlIG5lZWQgdG8gY3JlYXRlIGl0LlxuICAvLyBGaXJzdCBlbnN1cmUgdGhlIG5vZGVzIGV4aXN0LlxuICB0aGlzLnNldE5vZGUodik7XG4gIHRoaXMuc2V0Tm9kZSh3KTtcblxuICB0aGlzLl9lZGdlTGFiZWxzW2VdID0gdmFsdWVTcGVjaWZpZWQgPyB2YWx1ZSA6IHRoaXMuX2RlZmF1bHRFZGdlTGFiZWxGbih2LCB3LCBuYW1lKTtcblxuICB2YXIgZWRnZU9iaiA9IGVkZ2VBcmdzVG9PYmoodGhpcy5faXNEaXJlY3RlZCwgdiwgdywgbmFtZSk7XG4gIC8vIEVuc3VyZSB3ZSBhZGQgdW5kaXJlY3RlZCBlZGdlcyBpbiBhIGNvbnNpc3RlbnQgd2F5LlxuICB2ID0gZWRnZU9iai52O1xuICB3ID0gZWRnZU9iai53O1xuXG4gIE9iamVjdC5mcmVlemUoZWRnZU9iaik7XG4gIHRoaXMuX2VkZ2VPYmpzW2VdID0gZWRnZU9iajtcbiAgaW5jcmVtZW50T3JJbml0RW50cnkodGhpcy5fcHJlZHNbd10sIHYpO1xuICBpbmNyZW1lbnRPckluaXRFbnRyeSh0aGlzLl9zdWNzW3ZdLCB3KTtcbiAgdGhpcy5faW5bd11bZV0gPSBlZGdlT2JqO1xuICB0aGlzLl9vdXRbdl1bZV0gPSBlZGdlT2JqO1xuICB0aGlzLl9lZGdlQ291bnQrKztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuZWRnZSA9IGZ1bmN0aW9uKHYsIHcsIG5hbWUpIHtcbiAgdmFyIGUgPSAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgID8gZWRnZU9ialRvSWQodGhpcy5faXNEaXJlY3RlZCwgYXJndW1lbnRzWzBdKVxuICAgIDogZWRnZUFyZ3NUb0lkKHRoaXMuX2lzRGlyZWN0ZWQsIHYsIHcsIG5hbWUpKTtcbiAgcmV0dXJuIHRoaXMuX2VkZ2VMYWJlbHNbZV07XG59O1xuXG5HcmFwaC5wcm90b3R5cGUuaGFzRWRnZSA9IGZ1bmN0aW9uKHYsIHcsIG5hbWUpIHtcbiAgdmFyIGUgPSAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMVxuICAgID8gZWRnZU9ialRvSWQodGhpcy5faXNEaXJlY3RlZCwgYXJndW1lbnRzWzBdKVxuICAgIDogZWRnZUFyZ3NUb0lkKHRoaXMuX2lzRGlyZWN0ZWQsIHYsIHcsIG5hbWUpKTtcbiAgcmV0dXJuIF8uaGFzKHRoaXMuX2VkZ2VMYWJlbHMsIGUpO1xufTtcblxuR3JhcGgucHJvdG90eXBlLnJlbW92ZUVkZ2UgPSBmdW5jdGlvbih2LCB3LCBuYW1lKSB7XG4gIHZhciBlID0gKGFyZ3VtZW50cy5sZW5ndGggPT09IDFcbiAgICA/IGVkZ2VPYmpUb0lkKHRoaXMuX2lzRGlyZWN0ZWQsIGFyZ3VtZW50c1swXSlcbiAgICA6IGVkZ2VBcmdzVG9JZCh0aGlzLl9pc0RpcmVjdGVkLCB2LCB3LCBuYW1lKSk7XG4gIHZhciBlZGdlID0gdGhpcy5fZWRnZU9ianNbZV07XG4gIGlmIChlZGdlKSB7XG4gICAgdiA9IGVkZ2UudjtcbiAgICB3ID0gZWRnZS53O1xuICAgIGRlbGV0ZSB0aGlzLl9lZGdlTGFiZWxzW2VdO1xuICAgIGRlbGV0ZSB0aGlzLl9lZGdlT2Jqc1tlXTtcbiAgICBkZWNyZW1lbnRPclJlbW92ZUVudHJ5KHRoaXMuX3ByZWRzW3ddLCB2KTtcbiAgICBkZWNyZW1lbnRPclJlbW92ZUVudHJ5KHRoaXMuX3N1Y3Nbdl0sIHcpO1xuICAgIGRlbGV0ZSB0aGlzLl9pblt3XVtlXTtcbiAgICBkZWxldGUgdGhpcy5fb3V0W3ZdW2VdO1xuICAgIHRoaXMuX2VkZ2VDb3VudC0tO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuR3JhcGgucHJvdG90eXBlLmluRWRnZXMgPSBmdW5jdGlvbih2LCB1KSB7XG4gIHZhciBpblYgPSB0aGlzLl9pblt2XTtcbiAgaWYgKGluVikge1xuICAgIHZhciBlZGdlcyA9IF8udmFsdWVzKGluVik7XG4gICAgaWYgKCF1KSB7XG4gICAgICByZXR1cm4gZWRnZXM7XG4gICAgfVxuICAgIHJldHVybiBfLmZpbHRlcihlZGdlcywgZnVuY3Rpb24oZWRnZSkgeyByZXR1cm4gZWRnZS52ID09PSB1OyB9KTtcbiAgfVxufTtcblxuR3JhcGgucHJvdG90eXBlLm91dEVkZ2VzID0gZnVuY3Rpb24odiwgdykge1xuICB2YXIgb3V0ViA9IHRoaXMuX291dFt2XTtcbiAgaWYgKG91dFYpIHtcbiAgICB2YXIgZWRnZXMgPSBfLnZhbHVlcyhvdXRWKTtcbiAgICBpZiAoIXcpIHtcbiAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgcmV0dXJuIF8uZmlsdGVyKGVkZ2VzLCBmdW5jdGlvbihlZGdlKSB7IHJldHVybiBlZGdlLncgPT09IHc7IH0pO1xuICB9XG59O1xuXG5HcmFwaC5wcm90b3R5cGUubm9kZUVkZ2VzID0gZnVuY3Rpb24odiwgdykge1xuICB2YXIgaW5FZGdlcyA9IHRoaXMuaW5FZGdlcyh2LCB3KTtcbiAgaWYgKGluRWRnZXMpIHtcbiAgICByZXR1cm4gaW5FZGdlcy5jb25jYXQodGhpcy5vdXRFZGdlcyh2LCB3KSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGluY3JlbWVudE9ySW5pdEVudHJ5KG1hcCwgaykge1xuICBpZiAobWFwW2tdKSB7XG4gICAgbWFwW2tdKys7XG4gIH0gZWxzZSB7XG4gICAgbWFwW2tdID0gMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWNyZW1lbnRPclJlbW92ZUVudHJ5KG1hcCwgaykge1xuICBpZiAoIS0tbWFwW2tdKSB7IGRlbGV0ZSBtYXBba107IH1cbn1cblxuZnVuY3Rpb24gZWRnZUFyZ3NUb0lkKGlzRGlyZWN0ZWQsIHZfLCB3XywgbmFtZSkge1xuICB2YXIgdiA9IFwiXCIgKyB2XztcbiAgdmFyIHcgPSBcIlwiICsgd187XG4gIGlmICghaXNEaXJlY3RlZCAmJiB2ID4gdykge1xuICAgIHZhciB0bXAgPSB2O1xuICAgIHYgPSB3O1xuICAgIHcgPSB0bXA7XG4gIH1cbiAgcmV0dXJuIHYgKyBFREdFX0tFWV9ERUxJTSArIHcgKyBFREdFX0tFWV9ERUxJTSArXG4gICAgICAgICAgICAgKF8uaXNVbmRlZmluZWQobmFtZSkgPyBERUZBVUxUX0VER0VfTkFNRSA6IG5hbWUpO1xufVxuXG5mdW5jdGlvbiBlZGdlQXJnc1RvT2JqKGlzRGlyZWN0ZWQsIHZfLCB3XywgbmFtZSkge1xuICB2YXIgdiA9IFwiXCIgKyB2XztcbiAgdmFyIHcgPSBcIlwiICsgd187XG4gIGlmICghaXNEaXJlY3RlZCAmJiB2ID4gdykge1xuICAgIHZhciB0bXAgPSB2O1xuICAgIHYgPSB3O1xuICAgIHcgPSB0bXA7XG4gIH1cbiAgdmFyIGVkZ2VPYmogPSAgeyB2OiB2LCB3OiB3IH07XG4gIGlmIChuYW1lKSB7XG4gICAgZWRnZU9iai5uYW1lID0gbmFtZTtcbiAgfVxuICByZXR1cm4gZWRnZU9iajtcbn1cblxuZnVuY3Rpb24gZWRnZU9ialRvSWQoaXNEaXJlY3RlZCwgZWRnZU9iaikge1xuICByZXR1cm4gZWRnZUFyZ3NUb0lkKGlzRGlyZWN0ZWQsIGVkZ2VPYmoudiwgZWRnZU9iai53LCBlZGdlT2JqLm5hbWUpO1xufVxuIiwiLy8gSW5jbHVkZXMgb25seSB0aGUgXCJjb3JlXCIgb2YgZ3JhcGhsaWJcbm1vZHVsZS5leHBvcnRzID0ge1xuICBHcmFwaDogcmVxdWlyZShcIi4vZ3JhcGhcIiksXG4gIHZlcnNpb246IHJlcXVpcmUoXCIuL3ZlcnNpb25cIilcbn07XG4iLCJ2YXIgXyA9IHJlcXVpcmUoXCIuL2xvZGFzaFwiKTtcbnZhciBHcmFwaCA9IHJlcXVpcmUoXCIuL2dyYXBoXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgd3JpdGU6IHdyaXRlLFxuICByZWFkOiByZWFkXG59O1xuXG5mdW5jdGlvbiB3cml0ZShnKSB7XG4gIHZhciBqc29uID0ge1xuICAgIG9wdGlvbnM6IHtcbiAgICAgIGRpcmVjdGVkOiBnLmlzRGlyZWN0ZWQoKSxcbiAgICAgIG11bHRpZ3JhcGg6IGcuaXNNdWx0aWdyYXBoKCksXG4gICAgICBjb21wb3VuZDogZy5pc0NvbXBvdW5kKClcbiAgICB9LFxuICAgIG5vZGVzOiB3cml0ZU5vZGVzKGcpLFxuICAgIGVkZ2VzOiB3cml0ZUVkZ2VzKGcpXG4gIH07XG4gIGlmICghXy5pc1VuZGVmaW5lZChnLmdyYXBoKCkpKSB7XG4gICAganNvbi52YWx1ZSA9IF8uY2xvbmUoZy5ncmFwaCgpKTtcbiAgfVxuICByZXR1cm4ganNvbjtcbn1cblxuZnVuY3Rpb24gd3JpdGVOb2RlcyhnKSB7XG4gIHJldHVybiBfLm1hcChnLm5vZGVzKCksIGZ1bmN0aW9uKHYpIHtcbiAgICB2YXIgbm9kZVZhbHVlID0gZy5ub2RlKHYpO1xuICAgIHZhciBwYXJlbnQgPSBnLnBhcmVudCh2KTtcbiAgICB2YXIgbm9kZSA9IHsgdjogdiB9O1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChub2RlVmFsdWUpKSB7XG4gICAgICBub2RlLnZhbHVlID0gbm9kZVZhbHVlO1xuICAgIH1cbiAgICBpZiAoIV8uaXNVbmRlZmluZWQocGFyZW50KSkge1xuICAgICAgbm9kZS5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gd3JpdGVFZGdlcyhnKSB7XG4gIHJldHVybiBfLm1hcChnLmVkZ2VzKCksIGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgZWRnZVZhbHVlID0gZy5lZGdlKGUpO1xuICAgIHZhciBlZGdlID0geyB2OiBlLnYsIHc6IGUudyB9O1xuICAgIGlmICghXy5pc1VuZGVmaW5lZChlLm5hbWUpKSB7XG4gICAgICBlZGdlLm5hbWUgPSBlLm5hbWU7XG4gICAgfVxuICAgIGlmICghXy5pc1VuZGVmaW5lZChlZGdlVmFsdWUpKSB7XG4gICAgICBlZGdlLnZhbHVlID0gZWRnZVZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gZWRnZTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlYWQoanNvbikge1xuICB2YXIgZyA9IG5ldyBHcmFwaChqc29uLm9wdGlvbnMpLnNldEdyYXBoKGpzb24udmFsdWUpO1xuICBfLmVhY2goanNvbi5ub2RlcywgZnVuY3Rpb24oZW50cnkpIHtcbiAgICBnLnNldE5vZGUoZW50cnkudiwgZW50cnkudmFsdWUpO1xuICAgIGlmIChlbnRyeS5wYXJlbnQpIHtcbiAgICAgIGcuc2V0UGFyZW50KGVudHJ5LnYsIGVudHJ5LnBhcmVudCk7XG4gICAgfVxuICB9KTtcbiAgXy5lYWNoKGpzb24uZWRnZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgZy5zZXRFZGdlKHsgdjogZW50cnkudiwgdzogZW50cnkudywgbmFtZTogZW50cnkubmFtZSB9LCBlbnRyeS52YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gZztcbn1cbiIsIi8qIGdsb2JhbCB3aW5kb3cgKi9cblxudmFyIGxvZGFzaDtcblxuaWYgKHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgdHJ5IHtcbiAgICBsb2Rhc2ggPSB7XG4gICAgICBjbG9uZTogcmVxdWlyZShcImxvZGFzaC9jbG9uZVwiKSxcbiAgICAgIGNvbnN0YW50OiByZXF1aXJlKFwibG9kYXNoL2NvbnN0YW50XCIpLFxuICAgICAgZWFjaDogcmVxdWlyZShcImxvZGFzaC9lYWNoXCIpLFxuICAgICAgZmlsdGVyOiByZXF1aXJlKFwibG9kYXNoL2ZpbHRlclwiKSxcbiAgICAgIGhhczogIHJlcXVpcmUoXCJsb2Rhc2gvaGFzXCIpLFxuICAgICAgaXNBcnJheTogcmVxdWlyZShcImxvZGFzaC9pc0FycmF5XCIpLFxuICAgICAgaXNFbXB0eTogcmVxdWlyZShcImxvZGFzaC9pc0VtcHR5XCIpLFxuICAgICAgaXNGdW5jdGlvbjogcmVxdWlyZShcImxvZGFzaC9pc0Z1bmN0aW9uXCIpLFxuICAgICAgaXNVbmRlZmluZWQ6IHJlcXVpcmUoXCJsb2Rhc2gvaXNVbmRlZmluZWRcIiksXG4gICAgICBrZXlzOiByZXF1aXJlKFwibG9kYXNoL2tleXNcIiksXG4gICAgICBtYXA6IHJlcXVpcmUoXCJsb2Rhc2gvbWFwXCIpLFxuICAgICAgcmVkdWNlOiByZXF1aXJlKFwibG9kYXNoL3JlZHVjZVwiKSxcbiAgICAgIHNpemU6IHJlcXVpcmUoXCJsb2Rhc2gvc2l6ZVwiKSxcbiAgICAgIHRyYW5zZm9ybTogcmVxdWlyZShcImxvZGFzaC90cmFuc2Zvcm1cIiksXG4gICAgICB1bmlvbjogcmVxdWlyZShcImxvZGFzaC91bmlvblwiKSxcbiAgICAgIHZhbHVlczogcmVxdWlyZShcImxvZGFzaC92YWx1ZXNcIilcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gY29udGludWUgcmVnYXJkbGVzcyBvZiBlcnJvclxuICB9XG59XG5cbmlmICghbG9kYXNoKSB7XG4gIGxvZGFzaCA9IHdpbmRvdy5fO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxvZGFzaDtcbiIsIm1vZHVsZS5leHBvcnRzID0gJzIuMS44JztcbiIsIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbmNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbi8qKlxuICogQ2hlY2tzIGlmIGFuIG9iamVjdCBpcyBhbiBpbnN0YW5jZSBvZiBhbiBBcnJheSAoYXJyYXkgb3IgdHlwZWQgYXJyYXksIGV4Y2VwdCB0aG9zZSB0aGF0IGNvbnRhaW4gYmlnaW50IHZhbHVlcykuXG4gKlxuICogQHBhcmFtIHZhbHVlIC0gT2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybnMgVHJ1ZSBpZiB0aGUgb2JqZWN0IGlzIGFuIGFycmF5IG9yIGEgdHlwZWQgYXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0FueUFycmF5KHZhbHVlKSB7XG4gICAgY29uc3QgdGFnID0gdG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgcmV0dXJuIHRhZy5lbmRzV2l0aCgnQXJyYXldJykgJiYgIXRhZy5pbmNsdWRlcygnQmlnJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIERhdGFWaWV3ID0gZ2V0TmF0aXZlKHJvb3QsICdEYXRhVmlldycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFWaWV3O1xuIiwidmFyIGhhc2hDbGVhciA9IHJlcXVpcmUoJy4vX2hhc2hDbGVhcicpLFxuICAgIGhhc2hEZWxldGUgPSByZXF1aXJlKCcuL19oYXNoRGVsZXRlJyksXG4gICAgaGFzaEdldCA9IHJlcXVpcmUoJy4vX2hhc2hHZXQnKSxcbiAgICBoYXNoSGFzID0gcmVxdWlyZSgnLi9faGFzaEhhcycpLFxuICAgIGhhc2hTZXQgPSByZXF1aXJlKCcuL19oYXNoU2V0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYEhhc2hgLlxuSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG5IYXNoLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBoYXNoRGVsZXRlO1xuSGFzaC5wcm90b3R5cGUuZ2V0ID0gaGFzaEdldDtcbkhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG5IYXNoLnByb3RvdHlwZS5zZXQgPSBoYXNoU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEhhc2g7XG4iLCJ2YXIgbGlzdENhY2hlQ2xlYXIgPSByZXF1aXJlKCcuL19saXN0Q2FjaGVDbGVhcicpLFxuICAgIGxpc3RDYWNoZURlbGV0ZSA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZURlbGV0ZScpLFxuICAgIGxpc3RDYWNoZUdldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUdldCcpLFxuICAgIGxpc3RDYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZUhhcycpLFxuICAgIGxpc3RDYWNoZVNldCA9IHJlcXVpcmUoJy4vX2xpc3RDYWNoZVNldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gIHRoaXMuY2xlYXIoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICB9XG59XG5cbi8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuTGlzdENhY2hlLnByb3RvdHlwZS5jbGVhciA9IGxpc3RDYWNoZUNsZWFyO1xuTGlzdENhY2hlLnByb3RvdHlwZVsnZGVsZXRlJ10gPSBsaXN0Q2FjaGVEZWxldGU7XG5MaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbkxpc3RDYWNoZS5wcm90b3R5cGUuaGFzID0gbGlzdENhY2hlSGFzO1xuTGlzdENhY2hlLnByb3RvdHlwZS5zZXQgPSBsaXN0Q2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTGlzdENhY2hlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBNYXAgPSBnZXROYXRpdmUocm9vdCwgJ01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcDtcbiIsInZhciBtYXBDYWNoZUNsZWFyID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVDbGVhcicpLFxuICAgIG1hcENhY2hlRGVsZXRlID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVEZWxldGUnKSxcbiAgICBtYXBDYWNoZUdldCA9IHJlcXVpcmUoJy4vX21hcENhY2hlR2V0JyksXG4gICAgbWFwQ2FjaGVIYXMgPSByZXF1aXJlKCcuL19tYXBDYWNoZUhhcycpLFxuICAgIG1hcENhY2hlU2V0ID0gcmVxdWlyZSgnLi9fbWFwQ2FjaGVTZXQnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWFwIGNhY2hlIG9iamVjdCB0byBzdG9yZSBrZXktdmFsdWUgcGFpcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gKi9cbmZ1bmN0aW9uIE1hcENhY2hlKGVudHJpZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgdGhpcy5jbGVhcigpO1xuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYE1hcENhY2hlYC5cbk1hcENhY2hlLnByb3RvdHlwZS5jbGVhciA9IG1hcENhY2hlQ2xlYXI7XG5NYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG5NYXBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gbWFwQ2FjaGVHZXQ7XG5NYXBDYWNoZS5wcm90b3R5cGUuaGFzID0gbWFwQ2FjaGVIYXM7XG5NYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gTWFwQ2FjaGU7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyksXG4gICAgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xudmFyIFByb21pc2UgPSBnZXROYXRpdmUocm9vdCwgJ1Byb21pc2UnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBQcm9taXNlO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpLFxuICAgIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHRoYXQgYXJlIHZlcmlmaWVkIHRvIGJlIG5hdGl2ZS4gKi9cbnZhciBTZXQgPSBnZXROYXRpdmUocm9vdCwgJ1NldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldDtcbiIsInZhciBNYXBDYWNoZSA9IHJlcXVpcmUoJy4vX01hcENhY2hlJyksXG4gICAgc2V0Q2FjaGVBZGQgPSByZXF1aXJlKCcuL19zZXRDYWNoZUFkZCcpLFxuICAgIHNldENhY2hlSGFzID0gcmVxdWlyZSgnLi9fc2V0Q2FjaGVIYXMnKTtcblxuLyoqXG4gKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjYWNoZSBvYmplY3QgdG8gc3RvcmUgdW5pcXVlIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTZXRDYWNoZSh2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gIHRoaXMuX19kYXRhX18gPSBuZXcgTWFwQ2FjaGU7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gIH1cbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cblNldENhY2hlLnByb3RvdHlwZS5hZGQgPSBTZXRDYWNoZS5wcm90b3R5cGUucHVzaCA9IHNldENhY2hlQWRkO1xuU2V0Q2FjaGUucHJvdG90eXBlLmhhcyA9IHNldENhY2hlSGFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNldENhY2hlO1xuIiwidmFyIExpc3RDYWNoZSA9IHJlcXVpcmUoJy4vX0xpc3RDYWNoZScpLFxuICAgIHN0YWNrQ2xlYXIgPSByZXF1aXJlKCcuL19zdGFja0NsZWFyJyksXG4gICAgc3RhY2tEZWxldGUgPSByZXF1aXJlKCcuL19zdGFja0RlbGV0ZScpLFxuICAgIHN0YWNrR2V0ID0gcmVxdWlyZSgnLi9fc3RhY2tHZXQnKSxcbiAgICBzdGFja0hhcyA9IHJlcXVpcmUoJy4vX3N0YWNrSGFzJyksXG4gICAgc3RhY2tTZXQgPSByZXF1aXJlKCcuL19zdGFja1NldCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzdGFjayBjYWNoZSBvYmplY3QgdG8gc3RvcmUga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICovXG5mdW5jdGlvbiBTdGFjayhlbnRyaWVzKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGUoZW50cmllcyk7XG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbn1cblxuLy8gQWRkIG1ldGhvZHMgdG8gYFN0YWNrYC5cblN0YWNrLnByb3RvdHlwZS5jbGVhciA9IHN0YWNrQ2xlYXI7XG5TdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG5TdGFjay5wcm90b3R5cGUuZ2V0ID0gc3RhY2tHZXQ7XG5TdGFjay5wcm90b3R5cGUuaGFzID0gc3RhY2tIYXM7XG5TdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbm1vZHVsZS5leHBvcnRzID0gU3RhY2s7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgU3ltYm9sID0gcm9vdC5TeW1ib2w7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ltYm9sO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIFVpbnQ4QXJyYXkgPSByb290LlVpbnQ4QXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gVWludDhBcnJheTtcbiIsInZhciBnZXROYXRpdmUgPSByZXF1aXJlKCcuL19nZXROYXRpdmUnKSxcbiAgICByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgV2Vha01hcCA9IGdldE5hdGl2ZShyb290LCAnV2Vha01hcCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYWtNYXA7XG4iLCIvKipcbiAqIEEgZmFzdGVyIGFsdGVybmF0aXZlIHRvIGBGdW5jdGlvbiNhcHBseWAsIHRoaXMgZnVuY3Rpb24gaW52b2tlcyBgZnVuY2BcbiAqIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgdGhlIGFyZ3VtZW50cyBvZiBgYXJnc2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGZ1bmNgLlxuICovXG5mdW5jdGlvbiBhcHBseShmdW5jLCB0aGlzQXJnLCBhcmdzKSB7XG4gIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgY2FzZSAxOiByZXR1cm4gZnVuYy5jYWxsKHRoaXNBcmcsIGFyZ3NbMF0pO1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXBwbHk7XG4iLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5mb3JFYWNoYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlFYWNoKGFycmF5LCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKGl0ZXJhdGVlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlFYWNoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFycmF5RmlsdGVyKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5RmlsdGVyO1xuIiwidmFyIGJhc2VJbmRleE9mID0gcmVxdWlyZSgnLi9fYmFzZUluZGV4T2YnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uaW5jbHVkZXNgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICogc3BlY2lmeWluZyBhbiBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB0YXJnZXRgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5SW5jbHVkZXMoYXJyYXksIHZhbHVlKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgcmV0dXJuICEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgMCkgPiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUluY2x1ZGVzO1xuIiwiLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFycmF5SW5jbHVkZXNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlJbmNsdWRlc1dpdGgoYXJyYXksIHZhbHVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgYXJyYXlbaW5kZXhdKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiIsInZhciBiYXNlVGltZXMgPSByZXF1aXJlKCcuL19iYXNlVGltZXMnKSxcbiAgICBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vaXNBcmd1bWVudHMnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgdGhlIGFycmF5LWxpa2UgYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaGVyaXRlZCBTcGVjaWZ5IHJldHVybmluZyBpbmhlcml0ZWQgcHJvcGVydHkgbmFtZXMuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBhcnJheUxpa2VLZXlzKHZhbHVlLCBpbmhlcml0ZWQpIHtcbiAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICBpc0FyZyA9ICFpc0FyciAmJiBpc0FyZ3VtZW50cyh2YWx1ZSksXG4gICAgICBpc0J1ZmYgPSAhaXNBcnIgJiYgIWlzQXJnICYmIGlzQnVmZmVyKHZhbHVlKSxcbiAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgc2tpcEluZGV4ZXMgPSBpc0FyciB8fCBpc0FyZyB8fCBpc0J1ZmYgfHwgaXNUeXBlLFxuICAgICAgcmVzdWx0ID0gc2tpcEluZGV4ZXMgPyBiYXNlVGltZXModmFsdWUubGVuZ3RoLCBTdHJpbmcpIDogW10sXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICgoaW5oZXJpdGVkIHx8IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGtleSkpICYmXG4gICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAvLyBTYWZhcmkgOSBoYXMgZW51bWVyYWJsZSBgYXJndW1lbnRzLmxlbmd0aGAgaW4gc3RyaWN0IG1vZGUuXG4gICAgICAgICAgIGtleSA9PSAnbGVuZ3RoJyB8fFxuICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgKGlzQnVmZiAmJiAoa2V5ID09ICdvZmZzZXQnIHx8IGtleSA9PSAncGFyZW50JykpIHx8XG4gICAgICAgICAgIC8vIFBoYW50b21KUyAyIGhhcyBlbnVtZXJhYmxlIG5vbi1pbmRleCBwcm9wZXJ0aWVzIG9uIHR5cGVkIGFycmF5cy5cbiAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgIC8vIFNraXAgaW5kZXggcHJvcGVydGllcy5cbiAgICAgICAgICAgaXNJbmRleChrZXksIGxlbmd0aClcbiAgICAgICAgKSkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlMaWtlS2V5cztcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLm1hcGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBhcnJheU1hcChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlNYXA7XG4iLCIvKipcbiAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byBhcHBlbmQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAqL1xuZnVuY3Rpb24gYXJyYXlQdXNoKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgb2Zmc2V0ID0gYXJyYXkubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXJyYXlQdXNoO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ucmVkdWNlYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YCBhc1xuICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICovXG5mdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbKytpbmRleF07XG4gIH1cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBhY2N1bXVsYXRvciA9IGl0ZXJhdGVlKGFjY3VtdWxhdG9yLCBhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSk7XG4gIH1cbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFycmF5UmVkdWNlO1xuIiwiLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc29tZWAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlXG4gKiBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5U29tZShhcnJheSwgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhcnJheVNvbWU7XG4iLCJ2YXIgYmFzZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fYmFzZVByb3BlcnR5Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgc2l6ZSBvZiBhbiBBU0NJSSBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAqL1xudmFyIGFzY2lpU2l6ZSA9IGJhc2VQcm9wZXJ0eSgnbGVuZ3RoJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXNjaWlTaXplO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpO1xuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYXNzaWduVmFsdWVgIGV4Y2VwdCB0aGF0IGl0IGRvZXNuJ3QgYXNzaWduXG4gKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgaWYgKCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmICFlcShvYmplY3Rba2V5XSwgdmFsdWUpKSB8fFxuICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2lnbk1lcmdlVmFsdWU7XG4iLCJ2YXIgYmFzZUFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnblZhbHVlJyksXG4gICAgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICovXG5mdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgdmFyIG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gIGlmICghKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGVxKG9ialZhbHVlLCB2YWx1ZSkpIHx8XG4gICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzaWduVmFsdWU7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgaW5kZXggYXQgd2hpY2ggdGhlIGBrZXlgIGlzIGZvdW5kIGluIGBhcnJheWAgb2Yga2V5LXZhbHVlIHBhaXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICByZXR1cm4gbGVuZ3RoO1xuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzb2NJbmRleE9mO1xuIiwidmFyIGNvcHlPYmplY3QgPSByZXF1aXJlKCcuL19jb3B5T2JqZWN0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gKiBvciBgY3VzdG9taXplcmAgZnVuY3Rpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUFzc2lnbjtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBc3NpZ25JbihvYmplY3QsIHNvdXJjZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQXNzaWduSW47XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuL19kZWZpbmVQcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBhc3NpZ25WYWx1ZWAgYW5kIGBhc3NpZ25NZXJnZVZhbHVlYCB3aXRob3V0XG4gKiB2YWx1ZSBjaGVja3MuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAqL1xuZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nICYmIGRlZmluZVByb3BlcnR5KSB7XG4gICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgJ2VudW1lcmFibGUnOiB0cnVlLFxuICAgICAgJ3ZhbHVlJzogdmFsdWUsXG4gICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VBc3NpZ25WYWx1ZTtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgYXJyYXlFYWNoID0gcmVxdWlyZSgnLi9fYXJyYXlFYWNoJyksXG4gICAgYXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19hc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VBc3NpZ24gPSByZXF1aXJlKCcuL19iYXNlQXNzaWduJyksXG4gICAgYmFzZUFzc2lnbkluID0gcmVxdWlyZSgnLi9fYmFzZUFzc2lnbkluJyksXG4gICAgY2xvbmVCdWZmZXIgPSByZXF1aXJlKCcuL19jbG9uZUJ1ZmZlcicpLFxuICAgIGNvcHlBcnJheSA9IHJlcXVpcmUoJy4vX2NvcHlBcnJheScpLFxuICAgIGNvcHlTeW1ib2xzID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHMnKSxcbiAgICBjb3B5U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fY29weVN5bWJvbHNJbicpLFxuICAgIGdldEFsbEtleXMgPSByZXF1aXJlKCcuL19nZXRBbGxLZXlzJyksXG4gICAgZ2V0QWxsS2V5c0luID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5c0luJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaW5pdENsb25lQXJyYXkgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVBcnJheScpLFxuICAgIGluaXRDbG9uZUJ5VGFnID0gcmVxdWlyZSgnLi9faW5pdENsb25lQnlUYWcnKSxcbiAgICBpbml0Q2xvbmVPYmplY3QgPSByZXF1aXJlKCcuL19pbml0Q2xvbmVPYmplY3QnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNNYXAgPSByZXF1aXJlKCcuL2lzTWFwJyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgaXNTZXQgPSByZXF1aXJlKCcuL2lzU2V0JyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpLFxuICAgIGtleXNJbiA9IHJlcXVpcmUoJy4va2V5c0luJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGNsb25pbmcuICovXG52YXIgQ0xPTkVfREVFUF9GTEFHID0gMSxcbiAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBhcmdzVGFnID0gJ1tvYmplY3QgQXJndW1lbnRzXScsXG4gICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgZ2VuVGFnID0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbnZhciBjbG9uZWFibGVUYWdzID0ge307XG5jbG9uZWFibGVUYWdzW2FyZ3NUYWddID0gY2xvbmVhYmxlVGFnc1thcnJheVRhZ10gPVxuY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XG5jbG9uZWFibGVUYWdzW2Jvb2xUYWddID0gY2xvbmVhYmxlVGFnc1tkYXRlVGFnXSA9XG5jbG9uZWFibGVUYWdzW2Zsb2F0MzJUYWddID0gY2xvbmVhYmxlVGFnc1tmbG9hdDY0VGFnXSA9XG5jbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxuY2xvbmVhYmxlVGFnc1tpbnQzMlRhZ10gPSBjbG9uZWFibGVUYWdzW21hcFRhZ10gPVxuY2xvbmVhYmxlVGFnc1tudW1iZXJUYWddID0gY2xvbmVhYmxlVGFnc1tvYmplY3RUYWddID1cbmNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG5jbG9uZWFibGVUYWdzW3N0cmluZ1RhZ10gPSBjbG9uZWFibGVUYWdzW3N5bWJvbFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50OFRhZ10gPSBjbG9uZWFibGVUYWdzW3VpbnQ4Q2xhbXBlZFRhZ10gPVxuY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbmNsb25lYWJsZVRhZ3NbZXJyb3JUYWddID0gY2xvbmVhYmxlVGFnc1tmdW5jVGFnXSA9XG5jbG9uZWFibGVUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xvbmVgIGFuZCBgXy5jbG9uZURlZXBgIHdoaWNoIHRyYWNrc1xuICogdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBEZWVwIGNsb25lXG4gKiAgMiAtIEZsYXR0ZW4gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAqICA0IC0gQ2xvbmUgc3ltYm9sc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY2xvbmluZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIHBhcmVudCBvYmplY3Qgb2YgYHZhbHVlYC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBhbmQgdGhlaXIgY2xvbmUgY291bnRlcnBhcnRzLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUNsb25lKHZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIG9iamVjdCwgc3RhY2spIHtcbiAgdmFyIHJlc3VsdCxcbiAgICAgIGlzRGVlcCA9IGJpdG1hc2sgJiBDTE9ORV9ERUVQX0ZMQUcsXG4gICAgICBpc0ZsYXQgPSBiaXRtYXNrICYgQ0xPTkVfRkxBVF9GTEFHLFxuICAgICAgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcblxuICBpZiAoY3VzdG9taXplcikge1xuICAgIHJlc3VsdCA9IG9iamVjdCA/IGN1c3RvbWl6ZXIodmFsdWUsIGtleSwgb2JqZWN0LCBzdGFjaykgOiBjdXN0b21pemVyKHZhbHVlKTtcbiAgfVxuICBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHZhciBpc0FyciA9IGlzQXJyYXkodmFsdWUpO1xuICBpZiAoaXNBcnIpIHtcbiAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgaWYgKCFpc0RlZXApIHtcbiAgICAgIHJldHVybiBjb3B5QXJyYXkodmFsdWUsIHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpLFxuICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgaWYgKGlzQnVmZmVyKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGNsb25lQnVmZmVyKHZhbHVlLCBpc0RlZXApO1xuICAgIH1cbiAgICBpZiAodGFnID09IG9iamVjdFRhZyB8fCB0YWcgPT0gYXJnc1RhZyB8fCAoaXNGdW5jICYmICFvYmplY3QpKSB7XG4gICAgICByZXN1bHQgPSAoaXNGbGF0IHx8IGlzRnVuYykgPyB7fSA6IGluaXRDbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICByZXR1cm4gaXNGbGF0XG4gICAgICAgICAgPyBjb3B5U3ltYm9sc0luKHZhbHVlLCBiYXNlQXNzaWduSW4ocmVzdWx0LCB2YWx1ZSkpXG4gICAgICAgICAgOiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QgPyB2YWx1ZSA6IHt9O1xuICAgICAgfVxuICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKTtcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQodmFsdWUpO1xuICBpZiAoc3RhY2tlZCkge1xuICAgIHJldHVybiBzdGFja2VkO1xuICB9XG4gIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICBpZiAoaXNTZXQodmFsdWUpKSB7XG4gICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbihzdWJWYWx1ZSkge1xuICAgICAgcmVzdWx0LmFkZChiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN1YlZhbHVlLCB2YWx1ZSwgc3RhY2spKTtcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChpc01hcCh2YWx1ZSkpIHtcbiAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdC5zZXQoa2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIga2V5c0Z1bmMgPSBpc0Z1bGxcbiAgICA/IChpc0ZsYXQgPyBnZXRBbGxLZXlzSW4gOiBnZXRBbGxLZXlzKVxuICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gIHZhciBwcm9wcyA9IGlzQXJyID8gdW5kZWZpbmVkIDoga2V5c0Z1bmModmFsdWUpO1xuICBhcnJheUVhY2gocHJvcHMgfHwgdmFsdWUsIGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGtleSA9IHN1YlZhbHVlO1xuICAgICAgc3ViVmFsdWUgPSB2YWx1ZVtrZXldO1xuICAgIH1cbiAgICAvLyBSZWN1cnNpdmVseSBwb3B1bGF0ZSBjbG9uZSAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIGFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgdmFsdWUsIHN0YWNrKSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VDbG9uZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gKiBwcm9wZXJ0aWVzIHRvIHRoZSBjcmVhdGVkIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvIFRoZSBvYmplY3QgdG8gaW5oZXJpdCBmcm9tLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xudmFyIGJhc2VDcmVhdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIG9iamVjdCgpIHt9XG4gIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgIGlmICghaXNPYmplY3QocHJvdG8pKSB7XG4gICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGlmIChvYmplY3RDcmVhdGUpIHtcbiAgICAgIHJldHVybiBvYmplY3RDcmVhdGUocHJvdG8pO1xuICAgIH1cbiAgICBvYmplY3QucHJvdG90eXBlID0gcHJvdG87XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBvYmplY3Q7XG4gICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlQ3JlYXRlO1xuIiwidmFyIGJhc2VGb3JPd24gPSByZXF1aXJlKCcuL19iYXNlRm9yT3duJyksXG4gICAgY3JlYXRlQmFzZUVhY2ggPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRWFjaCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICovXG52YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRWFjaDtcbiIsInZhciBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8ubWF4YCBhbmQgYF8ubWluYCB3aGljaCBhY2NlcHRzIGFcbiAqIGBjb21wYXJhdG9yYCB0byBkZXRlcm1pbmUgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmF0b3IgVGhlIGNvbXBhcmF0b3IgdXNlZCB0byBjb21wYXJlIHZhbHVlcy5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBleHRyZW11bSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUV4dHJlbXVtKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgY3VycmVudCA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgIGlmIChjdXJyZW50ICE9IG51bGwgJiYgKGNvbXB1dGVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICA/IChjdXJyZW50ID09PSBjdXJyZW50ICYmICFpc1N5bWJvbChjdXJyZW50KSlcbiAgICAgICAgICA6IGNvbXBhcmF0b3IoY3VycmVudCwgY29tcHV0ZWQpXG4gICAgICAgICkpIHtcbiAgICAgIHZhciBjb21wdXRlZCA9IGN1cnJlbnQsXG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUV4dHJlbXVtO1xuIiwidmFyIGJhc2VFYWNoID0gcmVxdWlyZSgnLi9fYmFzZUVhY2gnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWx0ZXJgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbHRlcihjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGaWx0ZXI7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAqIHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgsIGZyb21SaWdodCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICB3aGlsZSAoKGZyb21SaWdodCA/IGluZGV4LS0gOiArK2luZGV4IDwgbGVuZ3RoKSkge1xuICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRmluZEluZGV4O1xuIiwidmFyIGFycmF5UHVzaCA9IHJlcXVpcmUoJy4vX2FycmF5UHVzaCcpLFxuICAgIGlzRmxhdHRlbmFibGUgPSByZXF1aXJlKCcuL19pc0ZsYXR0ZW5hYmxlJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBkZXB0aCBUaGUgbWF4aW11bSByZWN1cnNpb24gZGVwdGguXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwcmVkaWNhdGU9aXNGbGF0dGVuYWJsZV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXN1bHQ9W11dIFRoZSBpbml0aWFsIHJlc3VsdCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gYmFzZUZsYXR0ZW4oYXJyYXksIGRlcHRoLCBwcmVkaWNhdGUsIGlzU3RyaWN0LCByZXN1bHQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgcHJlZGljYXRlIHx8IChwcmVkaWNhdGUgPSBpc0ZsYXR0ZW5hYmxlKTtcbiAgcmVzdWx0IHx8IChyZXN1bHQgPSBbXSk7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgaWYgKGRlcHRoID4gMCAmJiBwcmVkaWNhdGUodmFsdWUpKSB7XG4gICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGZsYXR0ZW4gYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGJhc2VGbGF0dGVuKHZhbHVlLCBkZXB0aCAtIDEsIHByZWRpY2F0ZSwgaXNTdHJpY3QsIHJlc3VsdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcnJheVB1c2gocmVzdWx0LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VGbGF0dGVuO1xuIiwidmFyIGNyZWF0ZUJhc2VGb3IgPSByZXF1aXJlKCcuL19jcmVhdGVCYXNlRm9yJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGJhc2VGb3JPd25gIHdoaWNoIGl0ZXJhdGVzIG92ZXIgYG9iamVjdGBcbiAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG52YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlRm9yO1xuIiwidmFyIGJhc2VGb3IgPSByZXF1aXJlKCcuL19iYXNlRm9yJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93bmAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3Iob2JqZWN0LCBpdGVyYXRlZSwga2V5cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUZvck93bjtcbiIsInZhciBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHBhdGgpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gMCxcbiAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gIHdoaWxlIChvYmplY3QgIT0gbnVsbCAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gIH1cbiAgcmV0dXJuIChpbmRleCAmJiBpbmRleCA9PSBsZW5ndGgpID8gb2JqZWN0IDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VHZXQ7XG4iLCJ2YXIgYXJyYXlQdXNoID0gcmVxdWlyZSgnLi9fYXJyYXlQdXNoJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBnZXRBbGxLZXlzYCBhbmQgYGdldEFsbEtleXNJbmAgd2hpY2ggdXNlc1xuICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGBvYmplY3RgLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gIHZhciByZXN1bHQgPSBrZXlzRnVuYyhvYmplY3QpO1xuICByZXR1cm4gaXNBcnJheShvYmplY3QpID8gcmVzdWx0IDogYXJyYXlQdXNoKHJlc3VsdCwgc3ltYm9sc0Z1bmMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUdldEFsbEtleXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgZ2V0UmF3VGFnID0gcmVxdWlyZSgnLi9fZ2V0UmF3VGFnJyksXG4gICAgb2JqZWN0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19vYmplY3RUb1N0cmluZycpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbnVsbFRhZyA9ICdbb2JqZWN0IE51bGxdJyxcbiAgICB1bmRlZmluZWRUYWcgPSAnW29iamVjdCBVbmRlZmluZWRdJztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldFRhZ2Agd2l0aG91dCBmYWxsYmFja3MgZm9yIGJ1Z2d5IGVudmlyb25tZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICovXG5mdW5jdGlvbiBiYXNlR2V0VGFnKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWRUYWcgOiBudWxsVGFnO1xuICB9XG4gIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICA/IGdldFJhd1RhZyh2YWx1ZSlcbiAgICA6IG9iamVjdFRvU3RyaW5nKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR2V0VGFnO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ndGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUd0KHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPiBvdGhlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlR3Q7XG4iLCIvKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc2Agd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUhhcyhvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUhhcztcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaGFzSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgZGVlcCBwYXRocy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYga2V5IGluIE9iamVjdChvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VIYXNJbjtcbiIsInZhciBiYXNlRmluZEluZGV4ID0gcmVxdWlyZSgnLi9fYmFzZUZpbmRJbmRleCcpLFxuICAgIGJhc2VJc05hTiA9IHJlcXVpcmUoJy4vX2Jhc2VJc05hTicpLFxuICAgIHN0cmljdEluZGV4T2YgPSByZXF1aXJlKCcuL19zdHJpY3RJbmRleE9mJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaW5kZXhPZmAgd2l0aG91dCBgZnJvbUluZGV4YCBib3VuZHMgY2hlY2tzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWVcbiAgICA/IHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpXG4gICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGZyb21JbmRleCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUluZGV4T2Y7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzQXJndW1lbnRzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc0FyZ3VtZW50cyh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcmdzVGFnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0FyZ3VtZW50cztcbiIsInZhciBiYXNlSXNFcXVhbERlZXAgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbERlZXAnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzRXF1YWxgIHdoaWNoIHN1cHBvcnRzIHBhcnRpYWwgY29tcGFyaXNvbnNcbiAqIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtib29sZWFufSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLlxuICogIDEgLSBVbm9yZGVyZWQgY29tcGFyaXNvblxuICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBgdmFsdWVgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNFcXVhbCh2YWx1ZSwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlICYmIG90aGVyICE9PSBvdGhlcjtcbiAgfVxuICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNFcXVhbDtcbiIsInZhciBTdGFjayA9IHJlcXVpcmUoJy4vX1N0YWNrJyksXG4gICAgZXF1YWxBcnJheXMgPSByZXF1aXJlKCcuL19lcXVhbEFycmF5cycpLFxuICAgIGVxdWFsQnlUYWcgPSByZXF1aXJlKCcuL19lcXVhbEJ5VGFnJyksXG4gICAgZXF1YWxPYmplY3RzID0gcmVxdWlyZSgnLi9fZXF1YWxPYmplY3RzJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgb2JqZWN0VGFnID0gJ1tvYmplY3QgT2JqZWN0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbGAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICogcmVmZXJlbmNlcyB0byBiZSBjb21wYXJlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgdmFyIG9iaklzQXJyID0gaXNBcnJheShvYmplY3QpLFxuICAgICAgb3RoSXNBcnIgPSBpc0FycmF5KG90aGVyKSxcbiAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgIG90aFRhZyA9IG90aElzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob3RoZXIpO1xuXG4gIG9ialRhZyA9IG9ialRhZyA9PSBhcmdzVGFnID8gb2JqZWN0VGFnIDogb2JqVGFnO1xuICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICB2YXIgb2JqSXNPYmogPSBvYmpUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgb3RoSXNPYmogPSBvdGhUYWcgPT0gb2JqZWN0VGFnLFxuICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICBpZiAoaXNTYW1lVGFnICYmIGlzQnVmZmVyKG9iamVjdCkpIHtcbiAgICBpZiAoIWlzQnVmZmVyKG90aGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBvYmpJc0FyciA9IHRydWU7XG4gICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYW1lVGFnICYmICFvYmpJc09iaikge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgcmV0dXJuIChvYmpJc0FyciB8fCBpc1R5cGVkQXJyYXkob2JqZWN0KSlcbiAgICAgID8gZXF1YWxBcnJheXMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaylcbiAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICB9XG4gIGlmICghKGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRykpIHtcbiAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICBvdGhJc1dyYXBwZWQgPSBvdGhJc09iaiAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCAnX193cmFwcGVkX18nKTtcblxuICAgIGlmIChvYmpJc1dyYXBwZWQgfHwgb3RoSXNXcmFwcGVkKSB7XG4gICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgb3RoVW53cmFwcGVkID0gb3RoSXNXcmFwcGVkID8gb3RoZXIudmFsdWUoKSA6IG90aGVyO1xuXG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgIH1cbiAgfVxuICBpZiAoIWlzU2FtZVRhZykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICByZXR1cm4gZXF1YWxPYmplY3RzKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc0VxdWFsRGVlcDtcbiIsInZhciBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc09iamVjdExpa2UgPSByZXF1aXJlKCcuL2lzT2JqZWN0TGlrZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNNYXBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc01hcCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IG1hcFRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNNYXA7XG4iLCJ2YXIgU3RhY2sgPSByZXF1aXJlKCcuL19TdGFjaycpLFxuICAgIGJhc2VJc0VxdWFsID0gcmVxdWlyZSgnLi9fYmFzZUlzRXF1YWwnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgdmFsdWUgY29tcGFyaXNvbnMuICovXG52YXIgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgPSAxLFxuICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTWF0Y2hgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSwgY3VzdG9taXplcikge1xuICB2YXIgaW5kZXggPSBtYXRjaERhdGEubGVuZ3RoLFxuICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICBub0N1c3RvbWl6ZXIgPSAhY3VzdG9taXplcjtcblxuICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICByZXR1cm4gIWxlbmd0aDtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICB2YXIgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgaWYgKChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSlcbiAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgIDogIShkYXRhWzBdIGluIG9iamVjdClcbiAgICAgICAgKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgZGF0YSA9IG1hdGNoRGF0YVtpbmRleF07XG4gICAgdmFyIGtleSA9IGRhdGFbMF0sXG4gICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgIHNyY1ZhbHVlID0gZGF0YVsxXTtcblxuICAgIGlmIChub0N1c3RvbWl6ZXIgJiYgZGF0YVsyXSkge1xuICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBzdGFjayA9IG5ldyBTdGFjaztcbiAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzdWx0ID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgOiByZXN1bHRcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzTWF0Y2g7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc05hTjtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNNYXNrZWQgPSByZXF1aXJlKCcuL19pc01hc2tlZCcpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIHRvU291cmNlID0gcmVxdWlyZSgnLi9fdG9Tb3VyY2UnKTtcblxuLyoqXG4gKiBVc2VkIHRvIG1hdGNoIGBSZWdFeHBgXG4gKiBbc3ludGF4IGNoYXJhY3RlcnNdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXBhdHRlcm5zKS5cbiAqL1xudmFyIHJlUmVnRXhwQ2hhciA9IC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZztcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IGhvc3QgY29uc3RydWN0b3JzIChTYWZhcmkpLiAqL1xudmFyIHJlSXNIb3N0Q3RvciA9IC9eXFxbb2JqZWN0IC4rP0NvbnN0cnVjdG9yXFxdJC87XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXG4gICAgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXG52YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKiogVXNlZCB0byBkZXRlY3QgaWYgYSBtZXRob2QgaXMgbmF0aXZlLiAqL1xudmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgZnVuY1RvU3RyaW5nLmNhbGwoaGFzT3duUHJvcGVydHkpLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgLnJlcGxhY2UoL2hhc093blByb3BlcnR5fChmdW5jdGlvbikuKj8oPz1cXFxcXFwoKXwgZm9yIC4rPyg/PVxcXFxcXF0pL2csICckMS4qPycpICsgJyQnXG4pO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG5hdGl2ZSBmdW5jdGlvbixcbiAqICBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc05hdGl2ZSh2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSB8fCBpc01hc2tlZCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHBhdHRlcm4gPSBpc0Z1bmN0aW9uKHZhbHVlKSA/IHJlSXNOYXRpdmUgOiByZUlzSG9zdEN0b3I7XG4gIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlSXNOYXRpdmU7XG4iLCJ2YXIgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzU2V0YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBiYXNlSXNTZXQodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBzZXRUYWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZUlzU2V0O1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFyZ3NUYWcgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICBhcnJheVRhZyA9ICdbb2JqZWN0IEFycmF5XScsXG4gICAgYm9vbFRhZyA9ICdbb2JqZWN0IEJvb2xlYW5dJyxcbiAgICBkYXRlVGFnID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgIGVycm9yVGFnID0gJ1tvYmplY3QgRXJyb3JdJyxcbiAgICBmdW5jVGFnID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICB3ZWFrTWFwVGFnID0gJ1tvYmplY3QgV2Vha01hcF0nO1xuXG52YXIgYXJyYXlCdWZmZXJUYWcgPSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nLFxuICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICBmbG9hdDMyVGFnID0gJ1tvYmplY3QgRmxvYXQzMkFycmF5XScsXG4gICAgZmxvYXQ2NFRhZyA9ICdbb2JqZWN0IEZsb2F0NjRBcnJheV0nLFxuICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICBpbnQxNlRhZyA9ICdbb2JqZWN0IEludDE2QXJyYXldJyxcbiAgICBpbnQzMlRhZyA9ICdbb2JqZWN0IEludDMyQXJyYXldJyxcbiAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICB1aW50OENsYW1wZWRUYWcgPSAnW29iamVjdCBVaW50OENsYW1wZWRBcnJheV0nLFxuICAgIHVpbnQxNlRhZyA9ICdbb2JqZWN0IFVpbnQxNkFycmF5XScsXG4gICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgb2YgdHlwZWQgYXJyYXlzLiAqL1xudmFyIHR5cGVkQXJyYXlUYWdzID0ge307XG50eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDhUYWddID0gdHlwZWRBcnJheVRhZ3NbaW50MTZUYWddID1cbnR5cGVkQXJyYXlUYWdzW2ludDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW3VpbnQ4VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG50eXBlZEFycmF5VGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbnR5cGVkQXJyYXlUYWdzW2FyZ3NUYWddID0gdHlwZWRBcnJheVRhZ3NbYXJyYXlUYWddID1cbnR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbnR5cGVkQXJyYXlUYWdzW2RhdGFWaWV3VGFnXSA9IHR5cGVkQXJyYXlUYWdzW2RhdGVUYWddID1cbnR5cGVkQXJyYXlUYWdzW2Vycm9yVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Z1bmNUYWddID1cbnR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbnR5cGVkQXJyYXlUYWdzW29iamVjdFRhZ10gPSB0eXBlZEFycmF5VGFnc1tyZWdleHBUYWddID1cbnR5cGVkQXJyYXlUYWdzW3NldFRhZ10gPSB0eXBlZEFycmF5VGFnc1tzdHJpbmdUYWddID1cbnR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHR5cGVkIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiZcbiAgICBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICEhdHlwZWRBcnJheVRhZ3NbYmFzZUdldFRhZyh2YWx1ZSldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJc1R5cGVkQXJyYXk7XG4iLCJ2YXIgYmFzZU1hdGNoZXMgPSByZXF1aXJlKCcuL19iYXNlTWF0Y2hlcycpLFxuICAgIGJhc2VNYXRjaGVzUHJvcGVydHkgPSByZXF1aXJlKCcuL19iYXNlTWF0Y2hlc1Byb3BlcnR5JyksXG4gICAgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5JyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIHByb3BlcnR5ID0gcmVxdWlyZSgnLi9wcm9wZXJ0eScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLml0ZXJhdGVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSBbdmFsdWU9Xy5pZGVudGl0eV0gVGhlIHZhbHVlIHRvIGNvbnZlcnQgdG8gYW4gaXRlcmF0ZWUuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICovXG5mdW5jdGlvbiBiYXNlSXRlcmF0ZWUodmFsdWUpIHtcbiAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgLy8gU2VlIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTYwMzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGlkZW50aXR5O1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgID8gYmFzZU1hdGNoZXNQcm9wZXJ0eSh2YWx1ZVswXSwgdmFsdWVbMV0pXG4gICAgICA6IGJhc2VNYXRjaGVzKHZhbHVlKTtcbiAgfVxuICByZXR1cm4gcHJvcGVydHkodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VJdGVyYXRlZTtcbiIsInZhciBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyksXG4gICAgbmF0aXZlS2V5cyA9IHJlcXVpcmUoJy4vX25hdGl2ZUtleXMnKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICBpZiAoIWlzUHJvdG90eXBlKG9iamVjdCkpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyhvYmplY3QpO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VLZXlzO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBuYXRpdmVLZXlzSW4gPSByZXF1aXJlKCcuL19uYXRpdmVLZXlzSW4nKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqL1xuZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUtleXNJbihvYmplY3QpO1xuICB9XG4gIHZhciBpc1Byb3RvID0gaXNQcm90b3R5cGUob2JqZWN0KSxcbiAgICAgIHJlc3VsdCA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICBpZiAoIShrZXkgPT0gJ2NvbnN0cnVjdG9yJyAmJiAoaXNQcm90byB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlS2V5c0luO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5sdGAgd2hpY2ggZG9lc24ndCBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBgb3RoZXJgLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZUx0KHZhbHVlLCBvdGhlcikge1xuICByZXR1cm4gdmFsdWUgPCBvdGhlcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTHQ7XG4iLCJ2YXIgYmFzZUVhY2ggPSByZXF1aXJlKCcuL19iYXNlRWFjaCcpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgbWFwcGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlTWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgcmVzdWx0WysraW5kZXhdID0gaXRlcmF0ZWUodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VNYXA7XG4iLCJ2YXIgYmFzZUlzTWF0Y2ggPSByZXF1aXJlKCcuL19iYXNlSXNNYXRjaCcpLFxuICAgIGdldE1hdGNoRGF0YSA9IHJlcXVpcmUoJy4vX2dldE1hdGNoRGF0YScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gIHZhciBtYXRjaERhdGEgPSBnZXRNYXRjaERhdGEoc291cmNlKTtcbiAgaWYgKG1hdGNoRGF0YS5sZW5ndGggPT0gMSAmJiBtYXRjaERhdGFbMF1bMl0pIHtcbiAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU1hdGNoZXM7XG4iLCJ2YXIgYmFzZUlzRXF1YWwgPSByZXF1aXJlKCcuL19iYXNlSXNFcXVhbCcpLFxuICAgIGdldCA9IHJlcXVpcmUoJy4vZ2V0JyksXG4gICAgaGFzSW4gPSByZXF1aXJlKCcuL2hhc0luJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlID0gcmVxdWlyZSgnLi9fbWF0Y2hlc1N0cmljdENvbXBhcmFibGUnKSxcbiAgICB0b0tleSA9IHJlcXVpcmUoJy4vX3RvS2V5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzUHJvcGVydHlgIHdoaWNoIGRvZXNuJ3QgY2xvbmUgYHNyY1ZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICBpZiAoaXNLZXkocGF0aCkgJiYgaXNTdHJpY3RDb21wYXJhYmxlKHNyY1ZhbHVlKSkge1xuICAgIHJldHVybiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZSh0b0tleShwYXRoKSwgc3JjVmFsdWUpO1xuICB9XG4gIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgb2JqVmFsdWUgPSBnZXQob2JqZWN0LCBwYXRoKTtcbiAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgPyBoYXNJbihvYmplY3QsIHBhdGgpXG4gICAgICA6IGJhc2VJc0VxdWFsKHNyY1ZhbHVlLCBvYmpWYWx1ZSwgQ09NUEFSRV9QQVJUSUFMX0ZMQUcgfCBDT01QQVJFX1VOT1JERVJFRF9GTEFHKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWF0Y2hlc1Byb3BlcnR5O1xuIiwidmFyIFN0YWNrID0gcmVxdWlyZSgnLi9fU3RhY2snKSxcbiAgICBhc3NpZ25NZXJnZVZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduTWVyZ2VWYWx1ZScpLFxuICAgIGJhc2VGb3IgPSByZXF1aXJlKCcuL19iYXNlRm9yJyksXG4gICAgYmFzZU1lcmdlRGVlcCA9IHJlcXVpcmUoJy4vX2Jhc2VNZXJnZURlZXAnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpLFxuICAgIHNhZmVHZXQgPSByZXF1aXJlKCcuL19zYWZlR2V0Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVyZ2VgIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBtZXJnZWQgdmFsdWVzLlxuICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAqICBjb3VudGVycGFydHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIGlmIChvYmplY3QgPT09IHNvdXJjZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBiYXNlRm9yKHNvdXJjZSwgZnVuY3Rpb24oc3JjVmFsdWUsIGtleSkge1xuICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgYmFzZU1lcmdlRGVlcChvYmplY3QsIHNvdXJjZSwga2V5LCBzcmNJbmRleCwgYmFzZU1lcmdlLCBjdXN0b21pemVyLCBzdGFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICA/IGN1c3RvbWl6ZXIoc2FmZUdldChvYmplY3QsIGtleSksIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgfVxuICAgICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfSwga2V5c0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWVyZ2U7XG4iLCJ2YXIgYXNzaWduTWVyZ2VWYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnbk1lcmdlVmFsdWUnKSxcbiAgICBjbG9uZUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQnVmZmVyJyksXG4gICAgY2xvbmVUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9fY2xvbmVUeXBlZEFycmF5JyksXG4gICAgY29weUFycmF5ID0gcmVxdWlyZSgnLi9fY29weUFycmF5JyksXG4gICAgaW5pdENsb25lT2JqZWN0ID0gcmVxdWlyZSgnLi9faW5pdENsb25lT2JqZWN0JyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQXJyYXlMaWtlT2JqZWN0ID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZU9iamVjdCcpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzRnVuY3Rpb24gPSByZXF1aXJlKCcuL2lzRnVuY3Rpb24nKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1BsYWluT2JqZWN0ID0gcmVxdWlyZSgnLi9pc1BsYWluT2JqZWN0JyksXG4gICAgaXNUeXBlZEFycmF5ID0gcmVxdWlyZSgnLi9pc1R5cGVkQXJyYXknKSxcbiAgICBzYWZlR2V0ID0gcmVxdWlyZSgnLi9fc2FmZUdldCcpLFxuICAgIHRvUGxhaW5PYmplY3QgPSByZXF1aXJlKCcuL3RvUGxhaW5PYmplY3QnKTtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICogZGVlcCBtZXJnZXMgYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cyBlbmFibGluZyBvYmplY3RzIHdpdGggY2lyY3VsYXJcbiAqIHJlZmVyZW5jZXMgdG8gYmUgbWVyZ2VkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBtZXJnZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBzcmNJbmRleCBUaGUgaW5kZXggb2YgYHNvdXJjZWAuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gKiAgY291bnRlcnBhcnRzLlxuICovXG5mdW5jdGlvbiBiYXNlTWVyZ2VEZWVwKG9iamVjdCwgc291cmNlLCBrZXksIHNyY0luZGV4LCBtZXJnZUZ1bmMsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gIHZhciBvYmpWYWx1ZSA9IHNhZmVHZXQob2JqZWN0LCBrZXkpLFxuICAgICAgc3JjVmFsdWUgPSBzYWZlR2V0KHNvdXJjZSwga2V5KSxcbiAgICAgIHN0YWNrZWQgPSBzdGFjay5nZXQoc3JjVmFsdWUpO1xuXG4gIGlmIChzdGFja2VkKSB7XG4gICAgYXNzaWduTWVyZ2VWYWx1ZShvYmplY3QsIGtleSwgc3RhY2tlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlLCAoa2V5ICsgJycpLCBvYmplY3QsIHNvdXJjZSwgc3RhY2spXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIGlzQ29tbW9uID0gbmV3VmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICBpZiAoaXNDb21tb24pIHtcbiAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHNyY1ZhbHVlKSxcbiAgICAgICAgaXNCdWZmID0gIWlzQXJyICYmIGlzQnVmZmVyKHNyY1ZhbHVlKSxcbiAgICAgICAgaXNUeXBlZCA9ICFpc0FyciAmJiAhaXNCdWZmICYmIGlzVHlwZWRBcnJheShzcmNWYWx1ZSk7XG5cbiAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgIGlmIChpc0FyciB8fCBpc0J1ZmYgfHwgaXNUeXBlZCkge1xuICAgICAgaWYgKGlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChpc0FycmF5TGlrZU9iamVjdChvYmpWYWx1ZSkpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNCdWZmKSB7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xvbmVCdWZmZXIoc3JjVmFsdWUsIHRydWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBuZXdWYWx1ZSA9IGNsb25lVHlwZWRBcnJheShzcmNWYWx1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgbmV3VmFsdWUgPSBbXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNQbGFpbk9iamVjdChzcmNWYWx1ZSkgfHwgaXNBcmd1bWVudHMoc3JjVmFsdWUpKSB7XG4gICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgaWYgKGlzQXJndW1lbnRzKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IHRvUGxhaW5PYmplY3Qob2JqVmFsdWUpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIWlzT2JqZWN0KG9ialZhbHVlKSB8fCBpc0Z1bmN0aW9uKG9ialZhbHVlKSkge1xuICAgICAgICBuZXdWYWx1ZSA9IGluaXRDbG9uZU9iamVjdChzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKGlzQ29tbW9uKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgc3RhY2suc2V0KHNyY1ZhbHVlLCBuZXdWYWx1ZSk7XG4gICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICBzdGFja1snZGVsZXRlJ10oc3JjVmFsdWUpO1xuICB9XG4gIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlTWVyZ2VEZWVwO1xuIiwidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGJhc2VNYXAgPSByZXF1aXJlKCcuL19iYXNlTWFwJyksXG4gICAgYmFzZVNvcnRCeSA9IHJlcXVpcmUoJy4vX2Jhc2VTb3J0QnknKSxcbiAgICBiYXNlVW5hcnkgPSByZXF1aXJlKCcuL19iYXNlVW5hcnknKSxcbiAgICBjb21wYXJlTXVsdGlwbGUgPSByZXF1aXJlKCcuL19jb21wYXJlTXVsdGlwbGUnKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ub3JkZXJCeWAgd2l0aG91dCBwYXJhbSBndWFyZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb25bXXxPYmplY3RbXXxzdHJpbmdbXX0gaXRlcmF0ZWVzIFRoZSBpdGVyYXRlZXMgdG8gc29ydCBieS5cbiAqIEBwYXJhbSB7c3RyaW5nW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gIGlmIChpdGVyYXRlZXMubGVuZ3RoKSB7XG4gICAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgaWYgKGlzQXJyYXkoaXRlcmF0ZWUpKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBiYXNlR2V0KHZhbHVlLCBpdGVyYXRlZS5sZW5ndGggPT09IDEgPyBpdGVyYXRlZVswXSA6IGl0ZXJhdGVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdGVlO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGl0ZXJhdGVlcyA9IFtpZGVudGl0eV07XG4gIH1cblxuICB2YXIgaW5kZXggPSAtMTtcbiAgaXRlcmF0ZWVzID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBiYXNlVW5hcnkoYmFzZUl0ZXJhdGVlKSk7XG5cbiAgdmFyIHJlc3VsdCA9IGJhc2VNYXAoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgIHZhciBjcml0ZXJpYSA9IGFycmF5TWFwKGl0ZXJhdGVlcywgZnVuY3Rpb24oaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHsgJ2NyaXRlcmlhJzogY3JpdGVyaWEsICdpbmRleCc6ICsraW5kZXgsICd2YWx1ZSc6IHZhbHVlIH07XG4gIH0pO1xuXG4gIHJldHVybiBiYXNlU29ydEJ5KHJlc3VsdCwgZnVuY3Rpb24ob2JqZWN0LCBvdGhlcikge1xuICAgIHJldHVybiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZU9yZGVyQnk7XG4iLCJ2YXIgYmFzZVBpY2tCeSA9IHJlcXVpcmUoJy4vX2Jhc2VQaWNrQnknKSxcbiAgICBoYXNJbiA9IHJlcXVpcmUoJy4vaGFzSW4nKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5waWNrYCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAqIHByb3BlcnR5IGlkZW50aWZpZXJzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcGF0aHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgcmV0dXJuIGhhc0luKG9iamVjdCwgcGF0aCk7XG4gIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQaWNrO1xuIiwidmFyIGJhc2VHZXQgPSByZXF1aXJlKCcuL19iYXNlR2V0JyksXG4gICAgYmFzZVNldCA9IHJlcXVpcmUoJy4vX2Jhc2VTZXQnKSxcbiAgICBjYXN0UGF0aCA9IHJlcXVpcmUoJy4vX2Nhc3RQYXRoJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgIGBfLnBpY2tCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICByZXN1bHQgPSB7fTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBwYXRoID0gcGF0aHNbaW5kZXhdLFxuICAgICAgICB2YWx1ZSA9IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcblxuICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIHBhdGgpKSB7XG4gICAgICBiYXNlU2V0KHJlc3VsdCwgY2FzdFBhdGgocGF0aCwgb2JqZWN0KSwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQaWNrQnk7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnByb3BlcnR5YCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eShrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VQcm9wZXJ0eTtcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVByb3BlcnR5YCB3aGljaCBzdXBwb3J0cyBkZWVwIHBhdGhzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VQcm9wZXJ0eURlZXAocGF0aCkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUHJvcGVydHlEZWVwO1xuIiwiLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZUNlaWwgPSBNYXRoLmNlaWwsXG4gICAgbmF0aXZlTWF4ID0gTWF0aC5tYXg7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZ2VgIGFuZCBgXy5yYW5nZVJpZ2h0YCB3aGljaCBkb2Vzbid0XG4gKiBjb2VyY2UgYXJndW1lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RlcCBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5nZSBvZiBudW1iZXJzLlxuICovXG5mdW5jdGlvbiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KG5hdGl2ZUNlaWwoKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSwgMCksXG4gICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHJlc3VsdFtmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XSA9IHN0YXJ0O1xuICAgIHN0YXJ0ICs9IHN0ZXA7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmFuZ2U7XG4iLCIvKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlZHVjZWAgYW5kIGBfLnJlZHVjZVJpZ2h0YCwgd2l0aG91dCBzdXBwb3J0XG4gKiBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmAgdXNpbmcgYGVhY2hGdW5jYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluaXRBY2N1bSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBvciBsYXN0IGVsZW1lbnQgb2ZcbiAqICBgY29sbGVjdGlvbmAgYXMgdGhlIGluaXRpYWwgdmFsdWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgZWFjaEZ1bmMpIHtcbiAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgYWNjdW11bGF0b3IgPSBpbml0QWNjdW1cbiAgICAgID8gKGluaXRBY2N1bSA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgIDogaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gIH0pO1xuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVJlZHVjZTtcbiIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKSxcbiAgICBvdmVyUmVzdCA9IHJlcXVpcmUoJy4vX292ZXJSZXN0JyksXG4gICAgc2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19zZXRUb1N0cmluZycpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlc3RgIHdoaWNoIGRvZXNuJ3QgdmFsaWRhdGUgb3IgY29lcmNlIGFyZ3VtZW50cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXBwbHkgYSByZXN0IHBhcmFtZXRlciB0by5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgc3RhcnQsIGlkZW50aXR5KSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUmVzdDtcbiIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzSW5kZXggPSByZXF1aXJlKCcuL19pc0luZGV4JyksXG4gICAgaXNPYmplY3QgPSByZXF1aXJlKCcuL2lzT2JqZWN0JyksXG4gICAgdG9LZXkgPSByZXF1aXJlKCcuL190b0tleScpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNldGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgcGF0aCBjcmVhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTZXQob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICByZXR1cm4gb2JqZWN0O1xuICB9XG4gIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aC5sZW5ndGgsXG4gICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgbmVzdGVkID0gb2JqZWN0O1xuXG4gIHdoaWxlIChuZXN0ZWQgIT0gbnVsbCAmJiArK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKSxcbiAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nIHx8IGtleSA9PT0gJ2NvbnN0cnVjdG9yJyB8fCBrZXkgPT09ICdwcm90b3R5cGUnKSB7XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIGlmIChpbmRleCAhPSBsYXN0SW5kZXgpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgbmV3VmFsdWUgPSBjdXN0b21pemVyID8gY3VzdG9taXplcihvYmpWYWx1ZSwga2V5LCBuZXN0ZWQpIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSlcbiAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgOiAoaXNJbmRleChwYXRoW2luZGV4ICsgMV0pID8gW10gOiB7fSk7XG4gICAgICB9XG4gICAgfVxuICAgIGFzc2lnblZhbHVlKG5lc3RlZCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU2V0O1xuIiwidmFyIGNvbnN0YW50ID0gcmVxdWlyZSgnLi9jb25zdGFudCcpLFxuICAgIGRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9fZGVmaW5lUHJvcGVydHknKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgc2V0VG9TdHJpbmdgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaG90IGxvb3Agc2hvcnRpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICovXG52YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgcmV0dXJuIGRlZmluZVByb3BlcnR5KGZ1bmMsICd0b1N0cmluZycsIHtcbiAgICAnY29uZmlndXJhYmxlJzogdHJ1ZSxcbiAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICd2YWx1ZSc6IGNvbnN0YW50KHN0cmluZyksXG4gICAgJ3dyaXRhYmxlJzogdHJ1ZVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVNldFRvU3RyaW5nO1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0QnlgIHdoaWNoIHVzZXMgYGNvbXBhcmVyYCB0byBkZWZpbmUgdGhlXG4gKiBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nXG4gKiB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzb3J0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyZXIgVGhlIGZ1bmN0aW9uIHRvIGRlZmluZSBzb3J0IG9yZGVyLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTb3J0QnkoYXJyYXksIGNvbXBhcmVyKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgYXJyYXkuc29ydChjb21wYXJlcik7XG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIGFycmF5W2xlbmd0aF0gPSBhcnJheVtsZW5ndGhdLnZhbHVlO1xuICB9XG4gIHJldHVybiBhcnJheTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlU29ydEJ5O1xuIiwiLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50aW1lc2Agd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzXG4gKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUaW1lcyhuLCBpdGVyYXRlZSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbikge1xuICAgIHJlc3VsdFtpbmRleF0gPSBpdGVyYXRlZShpbmRleCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVGltZXM7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgYXJyYXlNYXAgPSByZXF1aXJlKCcuL19hcnJheU1hcCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG52YXIgc3ltYm9sUHJvdG8gPSBTeW1ib2wgPyBTeW1ib2wucHJvdG90eXBlIDogdW5kZWZpbmVkLFxuICAgIHN5bWJvbFRvU3RyaW5nID0gc3ltYm9sUHJvdG8gPyBzeW1ib2xQcm90by50b1N0cmluZyA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAqIHZhbHVlcyB0byBlbXB0eSBzdHJpbmdzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBiYXNlVG9TdHJpbmcodmFsdWUpIHtcbiAgLy8gRXhpdCBlYXJseSBmb3Igc3RyaW5ncyB0byBhdm9pZCBhIHBlcmZvcm1hbmNlIGhpdCBpbiBzb21lIGVudmlyb25tZW50cy5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBjb252ZXJ0IHZhbHVlcyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgYmFzZVRvU3RyaW5nKSArICcnO1xuICB9XG4gIGlmIChpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3ltYm9sVG9TdHJpbmcgPyBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbHVlKSA6ICcnO1xuICB9XG4gIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gIHJldHVybiAocmVzdWx0ID09ICcwJyAmJiAoMSAvIHZhbHVlKSA9PSAtSU5GSU5JVFkpID8gJy0wJyA6IHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVG9TdHJpbmc7XG4iLCJ2YXIgdHJpbW1lZEVuZEluZGV4ID0gcmVxdWlyZSgnLi9fdHJpbW1lZEVuZEluZGV4Jyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgd2hpdGVzcGFjZS4gKi9cbnZhciByZVRyaW1TdGFydCA9IC9eXFxzKy87XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udHJpbWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byB0cmltLlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGJhc2VUcmltKHN0cmluZykge1xuICByZXR1cm4gc3RyaW5nXG4gICAgPyBzdHJpbmcuc2xpY2UoMCwgdHJpbW1lZEVuZEluZGV4KHN0cmluZykgKyAxKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJylcbiAgICA6IHN0cmluZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVHJpbTtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jKHZhbHVlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlVW5hcnk7XG4iLCJ2YXIgU2V0Q2FjaGUgPSByZXF1aXJlKCcuL19TZXRDYWNoZScpLFxuICAgIGFycmF5SW5jbHVkZXMgPSByZXF1aXJlKCcuL19hcnJheUluY2x1ZGVzJyksXG4gICAgYXJyYXlJbmNsdWRlc1dpdGggPSByZXF1aXJlKCcuL19hcnJheUluY2x1ZGVzV2l0aCcpLFxuICAgIGNhY2hlSGFzID0gcmVxdWlyZSgnLi9fY2FjaGVIYXMnKSxcbiAgICBjcmVhdGVTZXQgPSByZXF1aXJlKCcuL19jcmVhdGVTZXQnKSxcbiAgICBzZXRUb0FycmF5ID0gcmVxdWlyZSgnLi9fc2V0VG9BcnJheScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICovXG5mdW5jdGlvbiBiYXNlVW5pcShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBpbmNsdWRlcyA9IGFycmF5SW5jbHVkZXMsXG4gICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICByZXN1bHQgPSBbXSxcbiAgICAgIHNlZW4gPSByZXN1bHQ7XG5cbiAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gIH1cbiAgZWxzZSBpZiAobGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICB2YXIgc2V0ID0gaXRlcmF0ZWUgPyBudWxsIDogY3JlYXRlU2V0KGFycmF5KTtcbiAgICBpZiAoc2V0KSB7XG4gICAgICByZXR1cm4gc2V0VG9BcnJheShzZXQpO1xuICAgIH1cbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgc2VlbiA9IG5ldyBTZXRDYWNoZTtcbiAgfVxuICBlbHNlIHtcbiAgICBzZWVuID0gaXRlcmF0ZWUgPyBbXSA6IHJlc3VsdDtcbiAgfVxuICBvdXRlcjpcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgIHZhciBzZWVuSW5kZXggPSBzZWVuLmxlbmd0aDtcbiAgICAgIHdoaWxlIChzZWVuSW5kZXgtLSkge1xuICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWluY2x1ZGVzKHNlZW4sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgaWYgKHNlZW4gIT09IHJlc3VsdCkge1xuICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VVbmlxO1xuIiwidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKTtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICogYXJyYXkgb2YgYG9iamVjdGAgcHJvcGVydHkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWVzXG4gKiBvZiBgcHJvcHNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICByZXR1cm4gYXJyYXlNYXAocHJvcHMsIGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZVZhbHVlcztcbiIsIi8qKlxuICogVGhpcyBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnppcE9iamVjdGAgd2hpY2ggYXNzaWducyB2YWx1ZXMgdXNpbmcgYGFzc2lnbkZ1bmNgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGFzc2lnbkZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFzc2lnbiB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBiYXNlWmlwT2JqZWN0KHByb3BzLCB2YWx1ZXMsIGFzc2lnbkZ1bmMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICB2YWxzTGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IHt9O1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHZhbHVlID0gaW5kZXggPCB2YWxzTGVuZ3RoID8gdmFsdWVzW2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICBhc3NpZ25GdW5jKHJlc3VsdCwgcHJvcHNbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlWmlwT2JqZWN0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYSBgY2FjaGVgIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjYWNoZSBUaGUgY2FjaGUgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICByZXR1cm4gY2FjaGUuaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FjaGVIYXM7XG4iLCJ2YXIgaWRlbnRpdHkgPSByZXF1aXJlKCcuL2lkZW50aXR5Jyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBgaWRlbnRpdHlgIGlmIGl0J3Mgbm90IGEgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgY2FzdCBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FzdEZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ2Z1bmN0aW9uJyA/IHZhbHVlIDogaWRlbnRpdHk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdEZ1bmN0aW9uO1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0tleSA9IHJlcXVpcmUoJy4vX2lzS2V5JyksXG4gICAgc3RyaW5nVG9QYXRoID0gcmVxdWlyZSgnLi9fc3RyaW5nVG9QYXRoJyksXG4gICAgdG9TdHJpbmcgPSByZXF1aXJlKCcuL3RvU3RyaW5nJyk7XG5cbi8qKlxuICogQ2FzdHMgYHZhbHVlYCB0byBhIHBhdGggYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG5mdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gaXNLZXkodmFsdWUsIG9iamVjdCkgPyBbdmFsdWVdIDogc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FzdFBhdGg7XG4iLCJ2YXIgVWludDhBcnJheSA9IHJlcXVpcmUoJy4vX1VpbnQ4QXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtBcnJheUJ1ZmZlcn0gUmV0dXJucyB0aGUgY2xvbmVkIGFycmF5IGJ1ZmZlci5cbiAqL1xuZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICB2YXIgcmVzdWx0ID0gbmV3IGFycmF5QnVmZmVyLmNvbnN0cnVjdG9yKGFycmF5QnVmZmVyLmJ5dGVMZW5ndGgpO1xuICBuZXcgVWludDhBcnJheShyZXN1bHQpLnNldChuZXcgVWludDhBcnJheShhcnJheUJ1ZmZlcikpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lQXJyYXlCdWZmZXI7XG4iLCJ2YXIgcm9vdCA9IHJlcXVpcmUoJy4vX3Jvb3QnKTtcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbnZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLiAqL1xudmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuLyoqIERldGVjdCB0aGUgcG9wdWxhciBDb21tb25KUyBleHRlbnNpb24gYG1vZHVsZS5leHBvcnRzYC4gKi9cbnZhciBtb2R1bGVFeHBvcnRzID0gZnJlZU1vZHVsZSAmJiBmcmVlTW9kdWxlLmV4cG9ydHMgPT09IGZyZWVFeHBvcnRzO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBCdWZmZXIgPSBtb2R1bGVFeHBvcnRzID8gcm9vdC5CdWZmZXIgOiB1bmRlZmluZWQsXG4gICAgYWxsb2NVbnNhZmUgPSBCdWZmZXIgPyBCdWZmZXIuYWxsb2NVbnNhZmUgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsb25lIG9mICBgYnVmZmVyYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIGNsb25lLlxuICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gKi9cbmZ1bmN0aW9uIGNsb25lQnVmZmVyKGJ1ZmZlciwgaXNEZWVwKSB7XG4gIGlmIChpc0RlZXApIHtcbiAgICByZXR1cm4gYnVmZmVyLnNsaWNlKCk7XG4gIH1cbiAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICByZXN1bHQgPSBhbGxvY1Vuc2FmZSA/IGFsbG9jVW5zYWZlKGxlbmd0aCkgOiBuZXcgYnVmZmVyLmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgYnVmZmVyLmNvcHkocmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZUJ1ZmZlcjtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgZGF0YSB2aWV3LlxuICovXG5mdW5jdGlvbiBjbG9uZURhdGFWaWV3KGRhdGFWaWV3LCBpc0RlZXApIHtcbiAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIoZGF0YVZpZXcuYnVmZmVyKSA6IGRhdGFWaWV3LmJ1ZmZlcjtcbiAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGF0YVZpZXc7XG4iLCIvKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbnZhciByZUZsYWdzID0gL1xcdyokLztcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHJlZ2V4cGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWdleHAgVGhlIHJlZ2V4cCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gKi9cbmZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlZ2V4cCkge1xuICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gIHJlc3VsdC5sYXN0SW5kZXggPSByZWdleHAubGFzdEluZGV4O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lUmVnRXhwO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgdGhlIGBzeW1ib2xgIG9iamVjdC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHN5bWJvbCBUaGUgc3ltYm9sIG9iamVjdCB0byBjbG9uZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBzeW1ib2wgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBjbG9uZVN5bWJvbChzeW1ib2wpIHtcbiAgcmV0dXJuIHN5bWJvbFZhbHVlT2YgPyBPYmplY3Qoc3ltYm9sVmFsdWVPZi5jYWxsKHN5bWJvbCkpIDoge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2xvbmVTeW1ib2w7XG4iLCJ2YXIgY2xvbmVBcnJheUJ1ZmZlciA9IHJlcXVpcmUoJy4vX2Nsb25lQXJyYXlCdWZmZXInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHR5cGVkIGFycmF5LlxuICovXG5mdW5jdGlvbiBjbG9uZVR5cGVkQXJyYXkodHlwZWRBcnJheSwgaXNEZWVwKSB7XG4gIHZhciBidWZmZXIgPSBpc0RlZXAgPyBjbG9uZUFycmF5QnVmZmVyKHR5cGVkQXJyYXkuYnVmZmVyKSA6IHR5cGVkQXJyYXkuYnVmZmVyO1xuICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZVR5cGVkQXJyYXk7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKlxuICogQ29tcGFyZXMgdmFsdWVzIHRvIHNvcnQgdGhlbSBpbiBhc2NlbmRpbmcgb3JkZXIuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3IgZm9yIGB2YWx1ZWAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XG4gIGlmICh2YWx1ZSAhPT0gb3RoZXIpIHtcbiAgICB2YXIgdmFsSXNEZWZpbmVkID0gdmFsdWUgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgIHZhbElzUmVmbGV4aXZlID0gdmFsdWUgPT09IHZhbHVlLFxuICAgICAgICB2YWxJc1N5bWJvbCA9IGlzU3ltYm9sKHZhbHVlKTtcblxuICAgIHZhciBvdGhJc0RlZmluZWQgPSBvdGhlciAhPT0gdW5kZWZpbmVkLFxuICAgICAgICBvdGhJc051bGwgPSBvdGhlciA9PT0gbnVsbCxcbiAgICAgICAgb3RoSXNSZWZsZXhpdmUgPSBvdGhlciA9PT0gb3RoZXIsXG4gICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2wob3RoZXIpO1xuXG4gICAgaWYgKCghb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCAmJiAhdmFsSXNTeW1ib2wgJiYgdmFsdWUgPiBvdGhlcikgfHxcbiAgICAgICAgKHZhbElzU3ltYm9sICYmIG90aElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSAmJiAhb3RoSXNOdWxsICYmICFvdGhJc1N5bWJvbCkgfHxcbiAgICAgICAgKHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICghdmFsSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlKSB8fFxuICAgICAgICAhdmFsSXNSZWZsZXhpdmUpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBpZiAoKCF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sICYmICFvdGhJc1N5bWJvbCAmJiB2YWx1ZSA8IG90aGVyKSB8fFxuICAgICAgICAob3RoSXNTeW1ib2wgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlICYmICF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sKSB8fFxuICAgICAgICAob3RoSXNOdWxsICYmIHZhbElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgKCFvdGhJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICFvdGhJc1JlZmxleGl2ZSkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21wYXJlQXNjZW5kaW5nO1xuIiwidmFyIGNvbXBhcmVBc2NlbmRpbmcgPSByZXF1aXJlKCcuL19jb21wYXJlQXNjZW5kaW5nJyk7XG5cbi8qKlxuICogVXNlZCBieSBgXy5vcmRlckJ5YCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgYSB2YWx1ZSB0byBhbm90aGVyXG4gKiBhbmQgc3RhYmxlIHNvcnQgdGhlbS5cbiAqXG4gKiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICogc3BlY2lmeSBhbiBvcmRlciBvZiBcImRlc2NcIiBmb3IgZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlclxuICogb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbltdfHN0cmluZ1tdfSBvcmRlcnMgVGhlIG9yZGVyIHRvIHNvcnQgYnkgZm9yIGVhY2ggcHJvcGVydHkuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzb3J0IG9yZGVyIGluZGljYXRvciBmb3IgYG9iamVjdGAuXG4gKi9cbmZ1bmN0aW9uIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgIG90aENyaXRlcmlhID0gb3RoZXIuY3JpdGVyaWEsXG4gICAgICBsZW5ndGggPSBvYmpDcml0ZXJpYS5sZW5ndGgsXG4gICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIHJlc3VsdCA9IGNvbXBhcmVBc2NlbmRpbmcob2JqQ3JpdGVyaWFbaW5kZXhdLCBvdGhDcml0ZXJpYVtpbmRleF0pO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGlmIChpbmRleCA+PSBvcmRlcnNMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBvcmRlciA9IG9yZGVyc1tpbmRleF07XG4gICAgICByZXR1cm4gcmVzdWx0ICogKG9yZGVyID09ICdkZXNjJyA/IC0xIDogMSk7XG4gICAgfVxuICB9XG4gIC8vIEZpeGVzIGFuIGBBcnJheSNzb3J0YCBidWcgaW4gdGhlIEpTIGVuZ2luZSBlbWJlZGRlZCBpbiBBZG9iZSBhcHBsaWNhdGlvbnNcbiAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgLy8gYG9iamVjdGAgYW5kIGBvdGhlcmAuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vamFzaGtlbmFzL3VuZGVyc2NvcmUvcHVsbC8xMjQ3XG4gIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gIC8vXG4gIC8vIFRoaXMgYWxzbyBlbnN1cmVzIGEgc3RhYmxlIHNvcnQgaW4gVjggYW5kIG90aGVyIGVuZ2luZXMuXG4gIC8vIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD05MCBmb3IgbW9yZSBkZXRhaWxzLlxuICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29tcGFyZU11bHRpcGxlO1xuIiwiLyoqXG4gKiBDb3BpZXMgdGhlIHZhbHVlcyBvZiBgc291cmNlYCB0byBgYXJyYXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBzb3VyY2UgVGhlIGFycmF5IHRvIGNvcHkgdmFsdWVzIGZyb20uXG4gKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICovXG5mdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGg7XG5cbiAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgYXJyYXlbaW5kZXhdID0gc291cmNlW2luZGV4XTtcbiAgfVxuICByZXR1cm4gYXJyYXk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weUFycmF5O1xuIiwidmFyIGFzc2lnblZhbHVlID0gcmVxdWlyZSgnLi9fYXNzaWduVmFsdWUnKSxcbiAgICBiYXNlQXNzaWduVmFsdWUgPSByZXF1aXJlKCcuL19iYXNlQXNzaWduVmFsdWUnKTtcblxuLyoqXG4gKiBDb3BpZXMgcHJvcGVydGllcyBvZiBgc291cmNlYCB0byBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb3BpZWQgdmFsdWVzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqL1xuZnVuY3Rpb24gY29weU9iamVjdChzb3VyY2UsIHByb3BzLCBvYmplY3QsIGN1c3RvbWl6ZXIpIHtcbiAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgb2JqZWN0IHx8IChvYmplY3QgPSB7fSk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIga2V5ID0gcHJvcHNbaW5kZXhdO1xuXG4gICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgPyBjdXN0b21pemVyKG9iamVjdFtrZXldLCBzb3VyY2Vba2V5XSwga2V5LCBvYmplY3QsIHNvdXJjZSlcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG5ld1ZhbHVlID0gc291cmNlW2tleV07XG4gICAgfVxuICAgIGlmIChpc05ldykge1xuICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weU9iamVjdDtcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGdldFN5bWJvbHMgPSByZXF1aXJlKCcuL19nZXRTeW1ib2xzJyk7XG5cbi8qKlxuICogQ29waWVzIG93biBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9scyhzb3VyY2UsIG9iamVjdCkge1xuICByZXR1cm4gY29weU9iamVjdChzb3VyY2UsIGdldFN5bWJvbHMoc291cmNlKSwgb2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb3B5U3ltYm9scztcbiIsInZhciBjb3B5T2JqZWN0ID0gcmVxdWlyZSgnLi9fY29weU9iamVjdCcpLFxuICAgIGdldFN5bWJvbHNJbiA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHNJbicpO1xuXG4vKipcbiAqIENvcGllcyBvd24gYW5kIGluaGVyaXRlZCBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdD17fV0gVGhlIG9iamVjdCB0byBjb3B5IHN5bWJvbHMgdG8uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBjb3B5U3ltYm9sc0luKHNvdXJjZSwgb2JqZWN0KSB7XG4gIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9sc0luKHNvdXJjZSksIG9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29weVN5bWJvbHNJbjtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG52YXIgY29yZUpzRGF0YSA9IHJvb3RbJ19fY29yZS1qc19zaGFyZWRfXyddO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvcmVKc0RhdGE7XG4iLCJ2YXIgYmFzZVJlc3QgPSByZXF1aXJlKCcuL19iYXNlUmVzdCcpLFxuICAgIGlzSXRlcmF0ZWVDYWxsID0gcmVxdWlyZSgnLi9faXNJdGVyYXRlZUNhbGwnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFzc2lnbmVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICByZXR1cm4gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICBjdXN0b21pemVyID0gbGVuZ3RoID4gMSA/IHNvdXJjZXNbbGVuZ3RoIC0gMV0gOiB1bmRlZmluZWQsXG4gICAgICAgIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgID8gKGxlbmd0aC0tLCBjdXN0b21pemVyKVxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICBjdXN0b21pemVyID0gbGVuZ3RoIDwgMyA/IHVuZGVmaW5lZCA6IGN1c3RvbWl6ZXI7XG4gICAgICBsZW5ndGggPSAxO1xuICAgIH1cbiAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgaWYgKHNvdXJjZSkge1xuICAgICAgICBhc3NpZ25lcihvYmplY3QsIHNvdXJjZSwgaW5kZXgsIGN1c3RvbWl6ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVBc3NpZ25lcjtcbiIsInZhciBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBiYXNlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCYXNlRWFjaChlYWNoRnVuYywgZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgIH1cbiAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICByZXR1cm4gZWFjaEZ1bmMoY29sbGVjdGlvbiwgaXRlcmF0ZWUpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgIGluZGV4ID0gZnJvbVJpZ2h0ID8gbGVuZ3RoIDogLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuXG4gICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgIGlmIChpdGVyYXRlZShpdGVyYWJsZVtpbmRleF0sIGluZGV4LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVCYXNlRWFjaDtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGJhc2UgZnVuY3Rpb24gZm9yIG1ldGhvZHMgbGlrZSBgXy5mb3JJbmAgYW5kIGBfLmZvck93bmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQmFzZUZvcihmcm9tUmlnaHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGl0ZXJhYmxlID0gT2JqZWN0KG9iamVjdCksXG4gICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUJhc2VGb3I7XG4iLCJ2YXIgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAga2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbmRJbmRleEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGNvbGxlY3Rpb24gaW5kZXguXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmaW5kIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVGaW5kKGZpbmRJbmRleEZ1bmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGl0ZXJhYmxlID0gT2JqZWN0KGNvbGxlY3Rpb24pO1xuICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgY29sbGVjdGlvbiA9IGtleXMoY29sbGVjdGlvbik7XG4gICAgICBwcmVkaWNhdGUgPSBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpOyB9O1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXhGdW5jKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZnJvbUluZGV4KTtcbiAgICByZXR1cm4gaW5kZXggPiAtMSA/IGl0ZXJhYmxlW2l0ZXJhdGVlID8gY29sbGVjdGlvbltpbmRleF0gOiBpbmRleF0gOiB1bmRlZmluZWQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlRmluZDtcbiIsInZhciBiYXNlUmFuZ2UgPSByZXF1aXJlKCcuL19iYXNlUmFuZ2UnKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vX2lzSXRlcmF0ZWVDYWxsJyksXG4gICAgdG9GaW5pdGUgPSByZXF1aXJlKCcuL3RvRmluaXRlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBfLnJhbmdlYCBvciBgXy5yYW5nZVJpZ2h0YCBmdW5jdGlvbi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByYW5nZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUmFuZ2UoZnJvbVJpZ2h0KSB7XG4gIHJldHVybiBmdW5jdGlvbihzdGFydCwgZW5kLCBzdGVwKSB7XG4gICAgaWYgKHN0ZXAgJiYgdHlwZW9mIHN0ZXAgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RhcnQsIGVuZCwgc3RlcCkpIHtcbiAgICAgIGVuZCA9IHN0ZXAgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8vIEVuc3VyZSB0aGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICBzdGFydCA9IHRvRmluaXRlKHN0YXJ0KTtcbiAgICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgIH1cbiAgICBzdGVwID0gc3RlcCA9PT0gdW5kZWZpbmVkID8gKHN0YXJ0IDwgZW5kID8gMSA6IC0xKSA6IHRvRmluaXRlKHN0ZXApO1xuICAgIHJldHVybiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVSYW5nZTtcbiIsInZhciBTZXQgPSByZXF1aXJlKCcuL19TZXQnKSxcbiAgICBub29wID0gcmVxdWlyZSgnLi9ub29wJyksXG4gICAgc2V0VG9BcnJheSA9IHJlcXVpcmUoJy4vX3NldFRvQXJyYXknKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2V0IG9iamVjdCBvZiBgdmFsdWVzYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gYWRkIHRvIHRoZSBzZXQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgc2V0LlxuICovXG52YXIgY3JlYXRlU2V0ID0gIShTZXQgJiYgKDEgLyBzZXRUb0FycmF5KG5ldyBTZXQoWywtMF0pKVsxXSkgPT0gSU5GSU5JVFkpID8gbm9vcCA6IGZ1bmN0aW9uKHZhbHVlcykge1xuICByZXR1cm4gbmV3IFNldCh2YWx1ZXMpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVTZXQ7XG4iLCJ2YXIgZ2V0TmF0aXZlID0gcmVxdWlyZSgnLi9fZ2V0TmF0aXZlJyk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgIGZ1bmMoe30sICcnLCB7fSk7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmluZVByb3BlcnR5O1xuIiwidmFyIFNldENhY2hlID0gcmVxdWlyZSgnLi9fU2V0Q2FjaGUnKSxcbiAgICBhcnJheVNvbWUgPSByZXF1aXJlKCcuL19hcnJheVNvbWUnKSxcbiAgICBjYWNoZUhhcyA9IHJlcXVpcmUoJy4vX2NhY2hlSGFzJyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gKiBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheX0gb3RoZXIgVGhlIG90aGVyIGFycmF5IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJyYXlzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICB2YXIgaXNQYXJ0aWFsID0gYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHLFxuICAgICAgYXJyTGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gIGlmIChhcnJMZW5ndGggIT0gb3RoTGVuZ3RoICYmICEoaXNQYXJ0aWFsICYmIG90aExlbmd0aCA+IGFyckxlbmd0aCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gQ2hlY2sgdGhhdCBjeWNsaWMgdmFsdWVzIGFyZSBlcXVhbC5cbiAgdmFyIGFyclN0YWNrZWQgPSBzdGFjay5nZXQoYXJyYXkpO1xuICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XG4gIGlmIChhcnJTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcbiAgICByZXR1cm4gYXJyU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IGFycmF5O1xuICB9XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgcmVzdWx0ID0gdHJ1ZSxcbiAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gIHN0YWNrLnNldChhcnJheSwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIGFycmF5KTtcblxuICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gIHdoaWxlICgrK2luZGV4IDwgYXJyTGVuZ3RoKSB7XG4gICAgdmFyIGFyclZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICB2YXIgY29tcGFyZWQgPSBpc1BhcnRpYWxcbiAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgIDogY3VzdG9taXplcihhcnJWYWx1ZSwgb3RoVmFsdWUsIGluZGV4LCBhcnJheSwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChjb21wYXJlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKHNlZW4pIHtcbiAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgIGlmICghY2FjaGVIYXMoc2Vlbiwgb3RoSW5kZXgpICYmXG4gICAgICAgICAgICAgICAgKGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKSB7XG4gICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8XG4gICAgICAgICAgICBlcXVhbEZ1bmMoYXJyVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaylcbiAgICAgICAgKSkge1xuICAgICAgcmVzdWx0ID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgc3RhY2tbJ2RlbGV0ZSddKGFycmF5KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbEFycmF5cztcbiIsInZhciBTeW1ib2wgPSByZXF1aXJlKCcuL19TeW1ib2wnKSxcbiAgICBVaW50OEFycmF5ID0gcmVxdWlyZSgnLi9fVWludDhBcnJheScpLFxuICAgIGVxID0gcmVxdWlyZSgnLi9lcScpLFxuICAgIGVxdWFsQXJyYXlzID0gcmVxdWlyZSgnLi9fZXF1YWxBcnJheXMnKSxcbiAgICBtYXBUb0FycmF5ID0gcmVxdWlyZSgnLi9fbWFwVG9BcnJheScpLFxuICAgIHNldFRvQXJyYXkgPSByZXF1aXJlKCcuL19zZXRUb0FycmF5Jyk7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIHZhbHVlIGNvbXBhcmlzb25zLiAqL1xudmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICBDT01QQVJFX1VOT1JERVJFRF9GTEFHID0gMjtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBlcnJvclRhZyA9ICdbb2JqZWN0IEVycm9yXScsXG4gICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgbnVtYmVyVGFnID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XScsXG4gICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgc3ltYm9sVGFnID0gJ1tvYmplY3QgU3ltYm9sXSc7XG5cbnZhciBhcnJheUJ1ZmZlclRhZyA9ICdbb2JqZWN0IEFycmF5QnVmZmVyXScsXG4gICAgZGF0YVZpZXdUYWcgPSAnW29iamVjdCBEYXRhVmlld10nO1xuXG4vKiogVXNlZCB0byBjb252ZXJ0IHN5bWJvbHMgdG8gcHJpbWl0aXZlcyBhbmQgc3RyaW5ncy4gKi9cbnZhciBzeW1ib2xQcm90byA9IFN5bWJvbCA/IFN5bWJvbC5wcm90b3R5cGUgOiB1bmRlZmluZWQsXG4gICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGNvbXBhcmluZyBvYmplY3RzIG9mXG4gKiB0aGUgc2FtZSBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY29tcGFyaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAqIGBCb29sZWFuYCwgYERhdGVgLCBgRXJyb3JgLCBgTnVtYmVyYCwgYFJlZ0V4cGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3RzIHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCB0YWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIGRhdGFWaWV3VGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgb3RoZXIgPSBvdGhlci5idWZmZXI7XG5cbiAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICFlcXVhbEZ1bmMobmV3IFVpbnQ4QXJyYXkob2JqZWN0KSwgbmV3IFVpbnQ4QXJyYXkob3RoZXIpKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcblxuICAgIGNhc2UgYm9vbFRhZzpcbiAgICBjYXNlIGRhdGVUYWc6XG4gICAgY2FzZSBudW1iZXJUYWc6XG4gICAgICAvLyBDb2VyY2UgYm9vbGVhbnMgdG8gYDFgIG9yIGAwYCBhbmQgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzLlxuICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgIHJldHVybiBlcSgrb2JqZWN0LCArb3RoZXIpO1xuXG4gICAgY2FzZSBlcnJvclRhZzpcbiAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAvLyBhcyBlcXVhbC4gU2VlIGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1yZWdleHAucHJvdG90eXBlLnRvc3RyaW5nXG4gICAgICAvLyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHZhciBjb252ZXJ0ID0gbWFwVG9BcnJheTtcblxuICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRztcbiAgICAgIGNvbnZlcnQgfHwgKGNvbnZlcnQgPSBzZXRUb0FycmF5KTtcblxuICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgaWYgKHN0YWNrZWQpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICBiaXRtYXNrIHw9IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUc7XG5cbiAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgdmFyIHJlc3VsdCA9IGVxdWFsQXJyYXlzKGNvbnZlcnQob2JqZWN0KSwgY29udmVydChvdGhlciksIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZi5jYWxsKG9iamVjdCkgPT0gc3ltYm9sVmFsdWVPZi5jYWxsKG90aGVyKTtcbiAgICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXF1YWxCeVRhZztcbiIsInZhciBnZXRBbGxLZXlzID0gcmVxdWlyZSgnLi9fZ2V0QWxsS2V5cycpO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbnZhciBDT01QQVJFX1BBUlRJQUxfRkxBRyA9IDE7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3JcbiAqIHBhcnRpYWwgZGVlcCBjb21wYXJpc29ucy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhY2sgVHJhY2tzIHRyYXZlcnNlZCBgb2JqZWN0YCBhbmQgYG90aGVyYCBvYmplY3RzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKSB7XG4gIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUcsXG4gICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgIG9iakxlbmd0aCA9IG9ialByb3BzLmxlbmd0aCxcbiAgICAgIG90aFByb3BzID0gZ2V0QWxsS2V5cyhvdGhlciksXG4gICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgaWYgKG9iakxlbmd0aCAhPSBvdGhMZW5ndGggJiYgIWlzUGFydGlhbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaW5kZXggPSBvYmpMZW5ndGg7XG4gIHdoaWxlIChpbmRleC0tKSB7XG4gICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICBpZiAoIShpc1BhcnRpYWwgPyBrZXkgaW4gb3RoZXIgOiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG90aGVyLCBrZXkpKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICAvLyBDaGVjayB0aGF0IGN5Y2xpYyB2YWx1ZXMgYXJlIGVxdWFsLlxuICB2YXIgb2JqU3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XG4gIGlmIChvYmpTdGFja2VkICYmIG90aFN0YWNrZWQpIHtcbiAgICByZXR1cm4gb2JqU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IG9iamVjdDtcbiAgfVxuICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICBzdGFjay5zZXQob3RoZXIsIG9iamVjdCk7XG5cbiAgdmFyIHNraXBDdG9yID0gaXNQYXJ0aWFsO1xuICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICB2YXIgb2JqVmFsdWUgPSBvYmplY3Rba2V5XSxcbiAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICA6IGN1c3RvbWl6ZXIob2JqVmFsdWUsIG90aFZhbHVlLCBrZXksIG9iamVjdCwgb3RoZXIsIHN0YWNrKTtcbiAgICB9XG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgaWYgKCEoY29tcGFyZWQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gKG9ialZhbHVlID09PSBvdGhWYWx1ZSB8fCBlcXVhbEZ1bmMob2JqVmFsdWUsIG90aFZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBzdGFjaykpXG4gICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICApKSB7XG4gICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBza2lwQ3RvciB8fCAoc2tpcEN0b3IgPSBrZXkgPT0gJ2NvbnN0cnVjdG9yJyk7XG4gIH1cbiAgaWYgKHJlc3VsdCAmJiAhc2tpcEN0b3IpIHtcbiAgICB2YXIgb2JqQ3RvciA9IG9iamVjdC5jb25zdHJ1Y3RvcixcbiAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgLy8gTm9uIGBPYmplY3RgIG9iamVjdCBpbnN0YW5jZXMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1YWwuXG4gICAgaWYgKG9iakN0b3IgIT0gb3RoQ3RvciAmJlxuICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgISh0eXBlb2Ygb2JqQ3RvciA9PSAnZnVuY3Rpb24nICYmIG9iakN0b3IgaW5zdGFuY2VvZiBvYmpDdG9yICYmXG4gICAgICAgICAgdHlwZW9mIG90aEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvdGhDdG9yIGluc3RhbmNlb2Ygb3RoQ3RvcikpIHtcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlcXVhbE9iamVjdHM7XG4iLCJ2YXIgZmxhdHRlbiA9IHJlcXVpcmUoJy4vZmxhdHRlbicpLFxuICAgIG92ZXJSZXN0ID0gcmVxdWlyZSgnLi9fb3ZlclJlc3QnKSxcbiAgICBzZXRUb1N0cmluZyA9IHJlcXVpcmUoJy4vX3NldFRvU3RyaW5nJyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUmVzdGAgd2hpY2ggZmxhdHRlbnMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gZmxhdFJlc3QoZnVuYykge1xuICByZXR1cm4gc2V0VG9TdHJpbmcob3ZlclJlc3QoZnVuYywgdW5kZWZpbmVkLCBmbGF0dGVuKSwgZnVuYyArICcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0UmVzdDtcbiIsIi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG52YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsICYmIGdsb2JhbC5PYmplY3QgPT09IE9iamVjdCAmJiBnbG9iYWw7XG5cbm1vZHVsZS5leHBvcnRzID0gZnJlZUdsb2JhbDtcbiIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9scyA9IHJlcXVpcmUoJy4vX2dldFN5bWJvbHMnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyBhbmQgc3ltYm9scy5cbiAqL1xuZnVuY3Rpb24gZ2V0QWxsS2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5cywgZ2V0U3ltYm9scyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWxsS2V5cztcbiIsInZhciBiYXNlR2V0QWxsS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRBbGxLZXlzJyksXG4gICAgZ2V0U3ltYm9sc0luID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9sc0luJyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gKiBzeW1ib2xzIG9mIGBvYmplY3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICovXG5mdW5jdGlvbiBnZXRBbGxLZXlzSW4ob2JqZWN0KSB7XG4gIHJldHVybiBiYXNlR2V0QWxsS2V5cyhvYmplY3QsIGtleXNJbiwgZ2V0U3ltYm9sc0luKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBbGxLZXlzSW47XG4iLCJ2YXIgaXNLZXlhYmxlID0gcmVxdWlyZSgnLi9faXNLZXlhYmxlJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIHJlZmVyZW5jZSBrZXkuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWFwIGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGdldE1hcERhdGEobWFwLCBrZXkpIHtcbiAgdmFyIGRhdGEgPSBtYXAuX19kYXRhX187XG4gIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgID8gZGF0YVt0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8gJ3N0cmluZycgOiAnaGFzaCddXG4gICAgOiBkYXRhLm1hcDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRNYXBEYXRhO1xuIiwidmFyIGlzU3RyaWN0Q29tcGFyYWJsZSA9IHJlcXVpcmUoJy4vX2lzU3RyaWN0Q29tcGFyYWJsZScpLFxuICAgIGtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICovXG5mdW5jdGlvbiBnZXRNYXRjaERhdGEob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gIHdoaWxlIChsZW5ndGgtLSkge1xuICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgIHJlc3VsdFtsZW5ndGhdID0gW2tleSwgdmFsdWUsIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWF0Y2hEYXRhO1xuIiwidmFyIGJhc2VJc05hdGl2ZSA9IHJlcXVpcmUoJy4vX2Jhc2VJc05hdGl2ZScpLFxuICAgIGdldFZhbHVlID0gcmVxdWlyZSgnLi9fZ2V0VmFsdWUnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBuYXRpdmUgZnVuY3Rpb24gYXQgYGtleWAgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBpZiBpdCdzIG5hdGl2ZSwgZWxzZSBgdW5kZWZpbmVkYC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gIHZhciB2YWx1ZSA9IGdldFZhbHVlKG9iamVjdCwga2V5KTtcbiAgcmV0dXJuIGJhc2VJc05hdGl2ZSh2YWx1ZSkgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROYXRpdmU7XG4iLCJ2YXIgb3ZlckFyZyA9IHJlcXVpcmUoJy4vX292ZXJBcmcnKTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgZ2V0UHJvdG90eXBlID0gb3ZlckFyZyhPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UHJvdG90eXBlO1xuIiwidmFyIFN5bWJvbCA9IHJlcXVpcmUoJy4vX1N5bWJvbCcpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAqIFtgdG9TdHJpbmdUYWdgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3QucHJvdG90eXBlLnRvc3RyaW5nKVxuICogb2YgdmFsdWVzLlxuICovXG52YXIgbmF0aXZlT2JqZWN0VG9TdHJpbmcgPSBvYmplY3RQcm90by50b1N0cmluZztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlR2V0VGFnYCB3aGljaCBpZ25vcmVzIGBTeW1ib2wudG9TdHJpbmdUYWdgIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSByYXcgYHRvU3RyaW5nVGFnYC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmF3VGFnKHZhbHVlKSB7XG4gIHZhciBpc093biA9IGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIHN5bVRvU3RyaW5nVGFnKSxcbiAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICB0cnkge1xuICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHVuZGVmaW5lZDtcbiAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICB9IGNhdGNoIChlKSB7fVxuXG4gIHZhciByZXN1bHQgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgaWYgKHVubWFza2VkKSB7XG4gICAgaWYgKGlzT3duKSB7XG4gICAgICB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ10gPSB0YWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB2YWx1ZVtzeW1Ub1N0cmluZ1RhZ107XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0UmF3VGFnO1xuIiwidmFyIGFycmF5RmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXlGaWx0ZXInKSxcbiAgICBzdHViQXJyYXkgPSByZXF1aXJlKCcuL3N0dWJBcnJheScpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IG9iamVjdFByb3RvLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBzeW1ib2xzLlxuICovXG52YXIgZ2V0U3ltYm9scyA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCBzeW1ib2wpO1xuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9scztcbiIsInZhciBhcnJheVB1c2ggPSByZXF1aXJlKCcuL19hcnJheVB1c2gnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBnZXRTeW1ib2xzID0gcmVxdWlyZSgnLi9fZ2V0U3ltYm9scycpLFxuICAgIHN0dWJBcnJheSA9IHJlcXVpcmUoJy4vc3R1YkFycmF5Jyk7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVHZXRTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2Ygc3ltYm9scy5cbiAqL1xudmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgd2hpbGUgKG9iamVjdCkge1xuICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgb2JqZWN0ID0gZ2V0UHJvdG90eXBlKG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0U3ltYm9sc0luO1xuIiwidmFyIERhdGFWaWV3ID0gcmVxdWlyZSgnLi9fRGF0YVZpZXcnKSxcbiAgICBNYXAgPSByZXF1aXJlKCcuL19NYXAnKSxcbiAgICBQcm9taXNlID0gcmVxdWlyZSgnLi9fUHJvbWlzZScpLFxuICAgIFNldCA9IHJlcXVpcmUoJy4vX1NldCcpLFxuICAgIFdlYWtNYXAgPSByZXF1aXJlKCcuL19XZWFrTWFwJyksXG4gICAgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICB0b1NvdXJjZSA9IHJlcXVpcmUoJy4vX3RvU291cmNlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICBwcm9taXNlVGFnID0gJ1tvYmplY3QgUHJvbWlzZV0nLFxuICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgIHdlYWtNYXBUYWcgPSAnW29iamVjdCBXZWFrTWFwXSc7XG5cbnZhciBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XSc7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG52YXIgZGF0YVZpZXdDdG9yU3RyaW5nID0gdG9Tb3VyY2UoRGF0YVZpZXcpLFxuICAgIG1hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShNYXApLFxuICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgc2V0Q3RvclN0cmluZyA9IHRvU291cmNlKFNldCksXG4gICAgd2Vha01hcEN0b3JTdHJpbmcgPSB0b1NvdXJjZShXZWFrTWFwKTtcblxuLyoqXG4gKiBHZXRzIHRoZSBgdG9TdHJpbmdUYWdgIG9mIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgYHRvU3RyaW5nVGFnYC5cbiAqL1xudmFyIGdldFRhZyA9IGJhc2VHZXRUYWc7XG5cbi8vIEZhbGxiYWNrIGZvciBkYXRhIHZpZXdzLCBtYXBzLCBzZXRzLCBhbmQgd2VhayBtYXBzIGluIElFIDExIGFuZCBwcm9taXNlcyBpbiBOb2RlLmpzIDwgNi5cbmlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAoTWFwICYmIGdldFRhZyhuZXcgTWFwKSAhPSBtYXBUYWcpIHx8XG4gICAgKFByb21pc2UgJiYgZ2V0VGFnKFByb21pc2UucmVzb2x2ZSgpKSAhPSBwcm9taXNlVGFnKSB8fFxuICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAoV2Vha01hcCAmJiBnZXRUYWcobmV3IFdlYWtNYXApICE9IHdlYWtNYXBUYWcpKSB7XG4gIGdldFRhZyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICBDdG9yID0gcmVzdWx0ID09IG9iamVjdFRhZyA/IHZhbHVlLmNvbnN0cnVjdG9yIDogdW5kZWZpbmVkLFxuICAgICAgICBjdG9yU3RyaW5nID0gQ3RvciA/IHRvU291cmNlKEN0b3IpIDogJyc7XG5cbiAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgc3dpdGNoIChjdG9yU3RyaW5nKSB7XG4gICAgICAgIGNhc2UgZGF0YVZpZXdDdG9yU3RyaW5nOiByZXR1cm4gZGF0YVZpZXdUYWc7XG4gICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgY2FzZSBwcm9taXNlQ3RvclN0cmluZzogcmV0dXJuIHByb21pc2VUYWc7XG4gICAgICAgIGNhc2Ugc2V0Q3RvclN0cmluZzogcmV0dXJuIHNldFRhZztcbiAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VGFnO1xuIiwiLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWUob2JqZWN0LCBrZXkpIHtcbiAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VmFsdWU7XG4iLCJ2YXIgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpLFxuICAgIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9pc0FyZ3VtZW50cycpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc0luZGV4ID0gcmVxdWlyZSgnLi9faXNJbmRleCcpLFxuICAgIGlzTGVuZ3RoID0gcmVxdWlyZSgnLi9pc0xlbmd0aCcpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHBhdGhgIGV4aXN0cyBvbiBgb2JqZWN0YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gY2hlY2suXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IGZhbHNlO1xuXG4gIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICBpZiAoIShyZXN1bHQgPSBvYmplY3QgIT0gbnVsbCAmJiBoYXNGdW5jKG9iamVjdCwga2V5KSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBvYmplY3QgPSBvYmplY3Rba2V5XTtcbiAgfVxuICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICByZXR1cm4gISFsZW5ndGggJiYgaXNMZW5ndGgobGVuZ3RoKSAmJiBpc0luZGV4KGtleSwgbGVuZ3RoKSAmJlxuICAgIChpc0FycmF5KG9iamVjdCkgfHwgaXNBcmd1bWVudHMob2JqZWN0KSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzUGF0aDtcbiIsIi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZic7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4vKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB3aXRoIFt6ZXJvLXdpZHRoIGpvaW5lcnMgb3IgY29kZSBwb2ludHMgZnJvbSB0aGUgYXN0cmFsIHBsYW5lc10oaHR0cDovL2Vldi5lZS9ibG9nLzIwMTUvMDkvMTIvZGFyay1jb3JuZXJzLW9mLXVuaWNvZGUvKS4gKi9cbnZhciByZUhhc1VuaWNvZGUgPSBSZWdFeHAoJ1snICsgcnNaV0ogKyByc0FzdHJhbFJhbmdlICArIHJzQ29tYm9SYW5nZSArIHJzVmFyUmFuZ2UgKyAnXScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBVbmljb2RlIHN5bWJvbHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGEgc3ltYm9sIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGhhc1VuaWNvZGUoc3RyaW5nKSB7XG4gIHJldHVybiByZUhhc1VuaWNvZGUudGVzdChzdHJpbmcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc1VuaWNvZGU7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgY2xlYXJcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKi9cbmZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5hdGl2ZUNyZWF0ZSA/IG5hdGl2ZUNyZWF0ZShudWxsKSA6IHt9O1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIEhhc2hcbiAqIEBwYXJhbSB7T2JqZWN0fSBoYXNoIFRoZSBoYXNoIHRvIG1vZGlmeS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICB2YXIgcmVzdWx0ID0gdGhpcy5oYXMoa2V5KSAmJiBkZWxldGUgdGhpcy5fX2RhdGFfX1trZXldO1xuICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzaERlbGV0ZTtcbiIsInZhciBuYXRpdmVDcmVhdGUgPSByZXF1aXJlKCcuL19uYXRpdmVDcmVhdGUnKTtcblxuLyoqIFVzZWQgdG8gc3RhbmQtaW4gZm9yIGB1bmRlZmluZWRgIGhhc2ggdmFsdWVzLiAqL1xudmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEdldHMgdGhlIGhhc2ggdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gaGFzaEdldChrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgdmFyIHJlc3VsdCA9IGRhdGFba2V5XTtcbiAgICByZXR1cm4gcmVzdWx0ID09PSBIQVNIX1VOREVGSU5FRCA/IHVuZGVmaW5lZCA6IHJlc3VsdDtcbiAgfVxuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpID8gZGF0YVtrZXldIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhc2hHZXQ7XG4iLCJ2YXIgbmF0aXZlQ3JlYXRlID0gcmVxdWlyZSgnLi9fbmF0aXZlQ3JlYXRlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgaGFzaCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaGFzaEhhcyhrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoSGFzO1xuIiwidmFyIG5hdGl2ZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX25hdGl2ZUNyZWF0ZScpO1xuXG4vKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogU2V0cyB0aGUgaGFzaCBga2V5YCB0byBgdmFsdWVgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBzZXRcbiAqIEBtZW1iZXJPZiBIYXNoXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGhhc2hTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gIHRoaXMuc2l6ZSArPSB0aGlzLmhhcyhrZXkpID8gMCA6IDE7XG4gIGRhdGFba2V5XSA9IChuYXRpdmVDcmVhdGUgJiYgdmFsdWUgPT09IHVuZGVmaW5lZCkgPyBIQVNIX1VOREVGSU5FRCA6IHZhbHVlO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoYXNoU2V0O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgIHJlc3VsdCA9IG5ldyBhcnJheS5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gIGlmIChsZW5ndGggJiYgdHlwZW9mIGFycmF5WzBdID09ICdzdHJpbmcnICYmIGhhc093blByb3BlcnR5LmNhbGwoYXJyYXksICdpbmRleCcpKSB7XG4gICAgcmVzdWx0LmluZGV4ID0gYXJyYXkuaW5kZXg7XG4gICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVBcnJheTtcbiIsInZhciBjbG9uZUFycmF5QnVmZmVyID0gcmVxdWlyZSgnLi9fY2xvbmVBcnJheUJ1ZmZlcicpLFxuICAgIGNsb25lRGF0YVZpZXcgPSByZXF1aXJlKCcuL19jbG9uZURhdGFWaWV3JyksXG4gICAgY2xvbmVSZWdFeHAgPSByZXF1aXJlKCcuL19jbG9uZVJlZ0V4cCcpLFxuICAgIGNsb25lU3ltYm9sID0gcmVxdWlyZSgnLi9fY2xvbmVTeW1ib2wnKSxcbiAgICBjbG9uZVR5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19jbG9uZVR5cGVkQXJyYXknKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGJvb2xUYWcgPSAnW29iamVjdCBCb29sZWFuXScsXG4gICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICBtYXBUYWcgPSAnW29iamVjdCBNYXBdJyxcbiAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICBzZXRUYWcgPSAnW29iamVjdCBTZXRdJyxcbiAgICBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJyxcbiAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJztcblxudmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICBkYXRhVmlld1RhZyA9ICdbb2JqZWN0IERhdGFWaWV3XScsXG4gICAgZmxvYXQzMlRhZyA9ICdbb2JqZWN0IEZsb2F0MzJBcnJheV0nLFxuICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICBpbnQ4VGFnID0gJ1tvYmplY3QgSW50OEFycmF5XScsXG4gICAgaW50MTZUYWcgPSAnW29iamVjdCBJbnQxNkFycmF5XScsXG4gICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgdWludDhUYWcgPSAnW29iamVjdCBVaW50OEFycmF5XScsXG4gICAgdWludDhDbGFtcGVkVGFnID0gJ1tvYmplY3QgVWludDhDbGFtcGVkQXJyYXldJyxcbiAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgIHVpbnQzMlRhZyA9ICdbb2JqZWN0IFVpbnQzMkFycmF5XSc7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIGZ1bmN0aW9uIG9ubHkgc3VwcG9ydHMgY2xvbmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE1hcGAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgYFNldGAsIG9yIGBTdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRoZSBgdG9TdHJpbmdUYWdgIG9mIHRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gKi9cbmZ1bmN0aW9uIGluaXRDbG9uZUJ5VGFnKG9iamVjdCwgdGFnLCBpc0RlZXApIHtcbiAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBhcnJheUJ1ZmZlclRhZzpcbiAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICBjYXNlIGJvb2xUYWc6XG4gICAgY2FzZSBkYXRlVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgIHJldHVybiBjbG9uZURhdGFWaWV3KG9iamVjdCwgaXNEZWVwKTtcblxuICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgIGNhc2UgaW50OFRhZzogY2FzZSBpbnQxNlRhZzogY2FzZSBpbnQzMlRhZzpcbiAgICBjYXNlIHVpbnQ4VGFnOiBjYXNlIHVpbnQ4Q2xhbXBlZFRhZzogY2FzZSB1aW50MTZUYWc6IGNhc2UgdWludDMyVGFnOlxuICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICBjYXNlIG1hcFRhZzpcbiAgICAgIHJldHVybiBuZXcgQ3RvcjtcblxuICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgcmV0dXJuIG5ldyBDdG9yKG9iamVjdCk7XG5cbiAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVJlZ0V4cChvYmplY3QpO1xuXG4gICAgY2FzZSBzZXRUYWc6XG4gICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgIHJldHVybiBjbG9uZVN5bWJvbChvYmplY3QpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5pdENsb25lQnlUYWc7XG4iLCJ2YXIgYmFzZUNyZWF0ZSA9IHJlcXVpcmUoJy4vX2Jhc2VDcmVhdGUnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc1Byb3RvdHlwZSA9IHJlcXVpcmUoJy4vX2lzUHJvdG90eXBlJyk7XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBpbml0aWFsaXplZCBjbG9uZS5cbiAqL1xuZnVuY3Rpb24gaW5pdENsb25lT2JqZWN0KG9iamVjdCkge1xuICByZXR1cm4gKHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNQcm90b3R5cGUob2JqZWN0KSlcbiAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgOiB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpbml0Q2xvbmVPYmplY3Q7XG4iLCJ2YXIgU3ltYm9sID0gcmVxdWlyZSgnLi9fU3ltYm9sJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpO1xuXG4vKiogQnVpbHQtaW4gdmFsdWUgcmVmZXJlbmNlcy4gKi9cbnZhciBzcHJlYWRhYmxlU3ltYm9sID0gU3ltYm9sID8gU3ltYm9sLmlzQ29uY2F0U3ByZWFkYWJsZSA6IHVuZGVmaW5lZDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZsYXR0ZW5hYmxlIGBhcmd1bWVudHNgIG9iamVjdCBvciBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmbGF0dGVuYWJsZSwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBpc0ZsYXR0ZW5hYmxlKHZhbHVlKSB7XG4gIHJldHVybiBpc0FycmF5KHZhbHVlKSB8fCBpc0FyZ3VtZW50cyh2YWx1ZSkgfHxcbiAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0ZsYXR0ZW5hYmxlO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCB1bnNpZ25lZCBpbnRlZ2VyIHZhbHVlcy4gKi9cbnZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGluZGV4LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdmFsaWQgaW5kZXgsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBsZW5ndGggPSBsZW5ndGggPT0gbnVsbCA/IE1BWF9TQUZFX0lOVEVHRVIgOiBsZW5ndGg7XG5cbiAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgKHR5cGUgPT0gJ251bWJlcicgfHxcbiAgICAgICh0eXBlICE9ICdzeW1ib2wnICYmIHJlSXNVaW50LnRlc3QodmFsdWUpKSkgJiZcbiAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSW5kZXg7XG4iLCJ2YXIgZXEgPSByZXF1aXJlKCcuL2VxJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyksXG4gICAgaXNJbmRleCA9IHJlcXVpcmUoJy4vX2lzSW5kZXgnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIGdpdmVuIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgdmFsdWUgYXJndW1lbnQuXG4gKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSBvYmplY3QgYXJndW1lbnQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFyZ3VtZW50cyBhcmUgZnJvbSBhbiBpdGVyYXRlZSBjYWxsLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNJdGVyYXRlZUNhbGwodmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJ1xuICAgICAgICA/IChpc0FycmF5TGlrZShvYmplY3QpICYmIGlzSW5kZXgoaW5kZXgsIG9iamVjdC5sZW5ndGgpKVxuICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICkge1xuICAgIHJldHVybiBlcShvYmplY3RbaW5kZXhdLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzSXRlcmF0ZWVDYWxsO1xuIiwidmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xudmFyIHJlSXNEZWVwUHJvcCA9IC9cXC58XFxbKD86W15bXFxdXSp8KFtcIiddKSg/Oig/IVxcMSlbXlxcXFxdfFxcXFwuKSo/XFwxKVxcXS8sXG4gICAgcmVJc1BsYWluUHJvcCA9IC9eXFx3KiQvO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcHJvcGVydHkgbmFtZSBhbmQgbm90IGEgcHJvcGVydHkgcGF0aC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeSBrZXlzIG9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5KHZhbHVlLCBvYmplY3QpIHtcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICBpZiAodHlwZSA9PSAnbnVtYmVyJyB8fCB0eXBlID09ICdzeW1ib2wnIHx8IHR5cGUgPT0gJ2Jvb2xlYW4nIHx8XG4gICAgICB2YWx1ZSA9PSBudWxsIHx8IGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiByZUlzUGxhaW5Qcm9wLnRlc3QodmFsdWUpIHx8ICFyZUlzRGVlcFByb3AudGVzdCh2YWx1ZSkgfHxcbiAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3IgdXNlIGFzIHVuaXF1ZSBvYmplY3Qga2V5LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5YWJsZSh2YWx1ZSkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgcmV0dXJuICh0eXBlID09ICdzdHJpbmcnIHx8IHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJylcbiAgICA/ICh2YWx1ZSAhPT0gJ19fcHJvdG9fXycpXG4gICAgOiAodmFsdWUgPT09IG51bGwpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzS2V5YWJsZTtcbiIsInZhciBjb3JlSnNEYXRhID0gcmVxdWlyZSgnLi9fY29yZUpzRGF0YScpO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgbWV0aG9kcyBtYXNxdWVyYWRpbmcgYXMgbmF0aXZlLiAqL1xudmFyIG1hc2tTcmNLZXkgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gIHJldHVybiB1aWQgPyAoJ1N5bWJvbChzcmMpXzEuJyArIHVpZCkgOiAnJztcbn0oKSk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBmdW5jYCBoYXMgaXRzIHNvdXJjZSBtYXNrZWQuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gaXNNYXNrZWQoZnVuYykge1xuICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTWFza2VkO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYSBwcm90b3R5cGUgb2JqZWN0LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcHJvdG90eXBlLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzUHJvdG90eXBlKHZhbHVlKSB7XG4gIHZhciBDdG9yID0gdmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IsXG4gICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICByZXR1cm4gdmFsdWUgPT09IHByb3RvO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUHJvdG90eXBlO1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciBzdHJpY3QgZXF1YWxpdHkgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaWYgc3VpdGFibGUgZm9yIHN0cmljdFxuICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaWN0Q29tcGFyYWJsZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNTdHJpY3RDb21wYXJhYmxlO1xuIiwiLyoqXG4gKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBsaXN0IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICB0aGlzLnNpemUgPSAwO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUNsZWFyO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZTtcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2U7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGRlbGV0ZVxuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsYXN0SW5kZXggPSBkYXRhLmxlbmd0aCAtIDE7XG4gIGlmIChpbmRleCA9PSBsYXN0SW5kZXgpIHtcbiAgICBkYXRhLnBvcCgpO1xuICB9IGVsc2Uge1xuICAgIHNwbGljZS5jYWxsKGRhdGEsIGluZGV4LCAxKTtcbiAgfVxuICAtLXRoaXMuc2l6ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlRGVsZXRlO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIEdldHMgdGhlIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpc3RDYWNoZUdldDtcbiIsInZhciBhc3NvY0luZGV4T2YgPSByZXF1aXJlKCcuL19hc3NvY0luZGV4T2YnKTtcblxuLyoqXG4gKiBDaGVja3MgaWYgYSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGhhc1xuICogQG1lbWJlck9mIExpc3RDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZUhhcyhrZXkpIHtcbiAgcmV0dXJuIGFzc29jSW5kZXhPZih0aGlzLl9fZGF0YV9fLCBrZXkpID4gLTE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlSGFzO1xuIiwidmFyIGFzc29jSW5kZXhPZiA9IHJlcXVpcmUoJy4vX2Fzc29jSW5kZXhPZicpO1xuXG4vKipcbiAqIFNldHMgdGhlIGxpc3QgY2FjaGUgYGtleWAgdG8gYHZhbHVlYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgc2V0XG4gKiBAbWVtYmVyT2YgTGlzdENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGxpc3QgY2FjaGUgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGxpc3RDYWNoZVNldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXyxcbiAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgaWYgKGluZGV4IDwgMCkge1xuICAgICsrdGhpcy5zaXplO1xuICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICB9IGVsc2Uge1xuICAgIGRhdGFbaW5kZXhdWzFdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbGlzdENhY2hlU2V0O1xuIiwidmFyIEhhc2ggPSByZXF1aXJlKCcuL19IYXNoJyksXG4gICAgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgbWFwLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBjbGVhclxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlQ2xlYXIoKSB7XG4gIHRoaXMuc2l6ZSA9IDA7XG4gIHRoaXMuX19kYXRhX18gPSB7XG4gICAgJ2hhc2gnOiBuZXcgSGFzaCxcbiAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAnc3RyaW5nJzogbmV3IEhhc2hcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUNsZWFyO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIG1hcC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZGVsZXRlXG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgdmFyIHJlc3VsdCA9IGdldE1hcERhdGEodGhpcywga2V5KVsnZGVsZXRlJ10oa2V5KTtcbiAgdGhpcy5zaXplIC09IHJlc3VsdCA/IDEgOiAwO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlRGVsZXRlO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgbWFwIHZhbHVlIGZvciBga2V5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgZ2V0XG4gKiBAbWVtYmVyT2YgTWFwQ2FjaGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgcmV0dXJuIGdldE1hcERhdGEodGhpcywga2V5KS5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZUdldDtcbiIsInZhciBnZXRNYXBEYXRhID0gcmVxdWlyZSgnLi9fZ2V0TWFwRGF0YScpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIG1hcCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIG1hcENhY2hlSGFzKGtleSkge1xuICByZXR1cm4gZ2V0TWFwRGF0YSh0aGlzLCBrZXkpLmhhcyhrZXkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcENhY2hlSGFzO1xuIiwidmFyIGdldE1hcERhdGEgPSByZXF1aXJlKCcuL19nZXRNYXBEYXRhJyk7XG5cbi8qKlxuICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIE1hcENhY2hlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjYWNoZSBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICB2YXIgZGF0YSA9IGdldE1hcERhdGEodGhpcywga2V5KSxcbiAgICAgIHNpemUgPSBkYXRhLnNpemU7XG5cbiAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gIHRoaXMuc2l6ZSArPSBkYXRhLnNpemUgPT0gc2l6ZSA/IDAgOiAxO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBDYWNoZVNldDtcbiIsIi8qKlxuICogQ29udmVydHMgYG1hcGAgdG8gaXRzIGtleS12YWx1ZSBwYWlycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG1hcCBUaGUgbWFwIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAqL1xuZnVuY3Rpb24gbWFwVG9BcnJheShtYXApIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShtYXAuc2l6ZSk7XG5cbiAgbWFwLmZvckVhY2goZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwVG9BcnJheTtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gKiBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUoa2V5LCBzcmNWYWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Rba2V5XSA9PT0gc3JjVmFsdWUgJiZcbiAgICAgIChzcmNWYWx1ZSAhPT0gdW5kZWZpbmVkIHx8IChrZXkgaW4gT2JqZWN0KG9iamVjdCkpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZTtcbiIsInZhciBtZW1vaXplID0gcmVxdWlyZSgnLi9tZW1vaXplJyk7XG5cbi8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbnZhciBNQVhfTUVNT0laRV9TSVpFID0gNTAwO1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tZW1vaXplYCB3aGljaCBjbGVhcnMgdGhlIG1lbW9pemVkIGZ1bmN0aW9uJ3NcbiAqIGNhY2hlIHdoZW4gaXQgZXhjZWVkcyBgTUFYX01FTU9JWkVfU0laRWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBtZW1vaXplQ2FwcGVkKGZ1bmMpIHtcbiAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKGNhY2hlLnNpemUgPT09IE1BWF9NRU1PSVpFX1NJWkUpIHtcbiAgICAgIGNhY2hlLmNsZWFyKCk7XG4gICAgfVxuICAgIHJldHVybiBrZXk7XG4gIH0pO1xuXG4gIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplQ2FwcGVkO1xuIiwidmFyIGdldE5hdGl2ZSA9IHJlcXVpcmUoJy4vX2dldE5hdGl2ZScpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyB0aGF0IGFyZSB2ZXJpZmllZCB0byBiZSBuYXRpdmUuICovXG52YXIgbmF0aXZlQ3JlYXRlID0gZ2V0TmF0aXZlKE9iamVjdCwgJ2NyZWF0ZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUNyZWF0ZTtcbiIsInZhciBvdmVyQXJnID0gcmVxdWlyZSgnLi9fb3ZlckFyZycpO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlS2V5cyA9IG92ZXJBcmcoT2JqZWN0LmtleXMsIE9iamVjdCk7XG5cbm1vZHVsZS5leHBvcnRzID0gbmF0aXZlS2V5cztcbiIsIi8qKlxuICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlXG4gKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gKiBleGNlcHQgdGhhdCBpdCBpbmNsdWRlcyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICovXG5mdW5jdGlvbiBuYXRpdmVLZXlzSW4ob2JqZWN0KSB7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgZm9yICh2YXIga2V5IGluIE9iamVjdChvYmplY3QpKSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5hdGl2ZUtleXNJbjtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgLiAqL1xudmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuICovXG52YXIgZnJlZU1vZHVsZSA9IGZyZWVFeHBvcnRzICYmIHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXG4vKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xudmFyIG1vZHVsZUV4cG9ydHMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUuZXhwb3J0cyA9PT0gZnJlZUV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgcHJvY2Vzc2AgZnJvbSBOb2RlLmpzLiAqL1xudmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbi8qKiBVc2VkIHRvIGFjY2VzcyBmYXN0ZXIgTm9kZS5qcyBoZWxwZXJzLiAqL1xudmFyIG5vZGVVdGlsID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIC8vIFVzZSBgdXRpbC50eXBlc2AgZm9yIE5vZGUuanMgMTArLlxuICAgIHZhciB0eXBlcyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5yZXF1aXJlICYmIGZyZWVNb2R1bGUucmVxdWlyZSgndXRpbCcpLnR5cGVzO1xuXG4gICAgaWYgKHR5cGVzKSB7XG4gICAgICByZXR1cm4gdHlwZXM7XG4gICAgfVxuXG4gICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICByZXR1cm4gZnJlZVByb2Nlc3MgJiYgZnJlZVByb2Nlc3MuYmluZGluZyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nKCd1dGlsJyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG5vZGVVdGlsO1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqXG4gKiBVc2VkIHRvIHJlc29sdmUgdGhlXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAqIG9mIHZhbHVlcy5cbiAqL1xudmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICByZXR1cm4gbmF0aXZlT2JqZWN0VG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gb2JqZWN0VG9TdHJpbmc7XG4iLCIvKipcbiAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyQXJnO1xuIiwidmFyIGFwcGx5ID0gcmVxdWlyZSgnLi9fYXBwbHknKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PWZ1bmMubGVuZ3RoLTFdIFRoZSBzdGFydCBwb3NpdGlvbiBvZiB0aGUgcmVzdCBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIHJlc3QgYXJyYXkgdHJhbnNmb3JtLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCB0cmFuc2Zvcm0pIHtcbiAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IG5hdGl2ZU1heChhcmdzLmxlbmd0aCAtIHN0YXJ0LCAwKSxcbiAgICAgICAgYXJyYXkgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFycmF5W2luZGV4XSA9IGFyZ3Nbc3RhcnQgKyBpbmRleF07XG4gICAgfVxuICAgIGluZGV4ID0gLTE7XG4gICAgdmFyIG90aGVyQXJncyA9IEFycmF5KHN0YXJ0ICsgMSk7XG4gICAgd2hpbGUgKCsraW5kZXggPCBzdGFydCkge1xuICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgIH1cbiAgICBvdGhlckFyZ3Nbc3RhcnRdID0gdHJhbnNmb3JtKGFycmF5KTtcbiAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBvdmVyUmVzdDtcbiIsInZhciBmcmVlR2xvYmFsID0gcmVxdWlyZSgnLi9fZnJlZUdsb2JhbCcpO1xuXG4vKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xudmFyIGZyZWVTZWxmID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZiAmJiBzZWxmLk9iamVjdCA9PT0gT2JqZWN0ICYmIHNlbGY7XG5cbi8qKiBVc2VkIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBnbG9iYWwgb2JqZWN0LiAqL1xudmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcm9vdDtcbiIsIi8qKlxuICogR2V0cyB0aGUgdmFsdWUgYXQgYGtleWAsIHVubGVzcyBga2V5YCBpcyBcIl9fcHJvdG9fX1wiIG9yIFwiY29uc3RydWN0b3JcIi5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcbiAgaWYgKGtleSA9PT0gJ2NvbnN0cnVjdG9yJyAmJiB0eXBlb2Ygb2JqZWN0W2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoa2V5ID09ICdfX3Byb3RvX18nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdFtrZXldO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNhZmVHZXQ7XG4iLCIvKiogVXNlZCB0byBzdGFuZC1pbiBmb3IgYHVuZGVmaW5lZGAgaGFzaCB2YWx1ZXMuICovXG52YXIgSEFTSF9VTkRFRklORUQgPSAnX19sb2Rhc2hfaGFzaF91bmRlZmluZWRfXyc7XG5cbi8qKlxuICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgYWRkXG4gKiBAbWVtYmVyT2YgU2V0Q2FjaGVcbiAqIEBhbGlhcyBwdXNoXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICB0aGlzLl9fZGF0YV9fLnNldCh2YWx1ZSwgSEFTSF9VTkRFRklORUQpO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUFkZDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgaW4gdGhlIGFycmF5IGNhY2hlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYXNcbiAqIEBtZW1iZXJPZiBTZXRDYWNoZVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRDYWNoZUhhcztcbiIsIi8qKlxuICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICByZXN1bHQgPSBBcnJheShzZXQuc2l6ZSk7XG5cbiAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXN1bHRbKytpbmRleF0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9BcnJheTtcbiIsInZhciBiYXNlU2V0VG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlU2V0VG9TdHJpbmcnKSxcbiAgICBzaG9ydE91dCA9IHJlcXVpcmUoJy4vX3Nob3J0T3V0Jyk7XG5cbi8qKlxuICogU2V0cyB0aGUgYHRvU3RyaW5nYCBtZXRob2Qgb2YgYGZ1bmNgIHRvIHJldHVybiBgc3RyaW5nYC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5nIFRoZSBgdG9TdHJpbmdgIHJlc3VsdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gKi9cbnZhciBzZXRUb1N0cmluZyA9IHNob3J0T3V0KGJhc2VTZXRUb1N0cmluZyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VG9TdHJpbmc7XG4iLCIvKiogVXNlZCB0byBkZXRlY3QgaG90IGZ1bmN0aW9ucyBieSBudW1iZXIgb2YgY2FsbHMgd2l0aGluIGEgc3BhbiBvZiBtaWxsaXNlY29uZHMuICovXG52YXIgSE9UX0NPVU5UID0gODAwLFxuICAgIEhPVF9TUEFOID0gMTY7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVOb3cgPSBEYXRlLm5vdztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAqIG9mIGBmdW5jYCB3aGVuIGl0J3MgY2FsbGVkIGBIT1RfQ09VTlRgIG9yIG1vcmUgdGltZXMgaW4gYEhPVF9TUEFOYFxuICogbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZXN0cmljdC5cbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gc2hvcnRPdXQoZnVuYykge1xuICB2YXIgY291bnQgPSAwLFxuICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICByZW1haW5pbmcgPSBIT1RfU1BBTiAtIChzdGFtcCAtIGxhc3RDYWxsZWQpO1xuXG4gICAgbGFzdENhbGxlZCA9IHN0YW1wO1xuICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICBpZiAoKytjb3VudCA+PSBIT1RfQ09VTlQpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3VtZW50c1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYy5hcHBseSh1bmRlZmluZWQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvcnRPdXQ7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyk7XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgc3RhY2suXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIGNsZWFyXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqL1xuZnVuY3Rpb24gc3RhY2tDbGVhcigpIHtcbiAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gIHRoaXMuc2l6ZSA9IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tDbGVhcjtcbiIsIi8qKlxuICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIHN0YWNrLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBkZWxldGVcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGVudHJ5IHdhcyByZW1vdmVkLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICByZXN1bHQgPSBkYXRhWydkZWxldGUnXShrZXkpO1xuXG4gIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0RlbGV0ZTtcbiIsIi8qKlxuICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBnZXRcbiAqIEBtZW1iZXJPZiBTdGFja1xuICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHN0YWNrR2V0KGtleSkge1xuICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja0dldDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGEgc3RhY2sgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQG5hbWUgaGFzXG4gKiBAbWVtYmVyT2YgU3RhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBzdGFja0hhcyhrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX19kYXRhX18uaGFzKGtleSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tIYXM7XG4iLCJ2YXIgTGlzdENhY2hlID0gcmVxdWlyZSgnLi9fTGlzdENhY2hlJyksXG4gICAgTWFwID0gcmVxdWlyZSgnLi9fTWFwJyksXG4gICAgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogVXNlZCBhcyB0aGUgc2l6ZSB0byBlbmFibGUgbGFyZ2UgYXJyYXkgb3B0aW1pemF0aW9ucy4gKi9cbnZhciBMQVJHRV9BUlJBWV9TSVpFID0gMjAwO1xuXG4vKipcbiAqIFNldHMgdGhlIHN0YWNrIGBrZXlgIHRvIGB2YWx1ZWAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBuYW1lIHNldFxuICogQG1lbWJlck9mIFN0YWNrXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHN0YWNrIGNhY2hlIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzdGFja1NldChrZXksIHZhbHVlKSB7XG4gIHZhciBkYXRhID0gdGhpcy5fX2RhdGFfXztcbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICB2YXIgcGFpcnMgPSBkYXRhLl9fZGF0YV9fO1xuICAgIGlmICghTWFwIHx8IChwYWlycy5sZW5ndGggPCBMQVJHRV9BUlJBWV9TSVpFIC0gMSkpIHtcbiAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgIHRoaXMuc2l6ZSA9ICsrZGF0YS5zaXplO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlKHBhaXJzKTtcbiAgfVxuICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgdGhpcy5zaXplID0gZGF0YS5zaXplO1xuICByZXR1cm4gdGhpcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja1NldDtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluZGV4T2ZgIHdoaWNoIHBlcmZvcm1zIHN0cmljdCBlcXVhbGl0eVxuICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gKi9cbmZ1bmN0aW9uIHN0cmljdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpY3RJbmRleE9mO1xuIiwidmFyIGFzY2lpU2l6ZSA9IHJlcXVpcmUoJy4vX2FzY2lpU2l6ZScpLFxuICAgIGhhc1VuaWNvZGUgPSByZXF1aXJlKCcuL19oYXNVbmljb2RlJyksXG4gICAgdW5pY29kZVNpemUgPSByZXF1aXJlKCcuL191bmljb2RlU2l6ZScpO1xuXG4vKipcbiAqIEdldHMgdGhlIG51bWJlciBvZiBzeW1ib2xzIGluIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICovXG5mdW5jdGlvbiBzdHJpbmdTaXplKHN0cmluZykge1xuICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgPyB1bmljb2RlU2l6ZShzdHJpbmcpXG4gICAgOiBhc2NpaVNpemUoc3RyaW5nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdTaXplO1xuIiwidmFyIG1lbW9pemVDYXBwZWQgPSByZXF1aXJlKCcuL19tZW1vaXplQ2FwcGVkJyk7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIHByb3BlcnR5IG5hbWVzIHdpdGhpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZVByb3BOYW1lID0gL1teLltcXF1dK3xcXFsoPzooLT9cXGQrKD86XFwuXFxkKyk/KXwoW1wiJ10pKCg/Oig/IVxcMilbXlxcXFxdfFxcXFwuKSo/KVxcMilcXF18KD89KD86XFwufFxcW1xcXSkoPzpcXC58XFxbXFxdfCQpKS9nO1xuXG4vKiogVXNlZCB0byBtYXRjaCBiYWNrc2xhc2hlcyBpbiBwcm9wZXJ0eSBwYXRocy4gKi9cbnZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICovXG52YXIgc3RyaW5nVG9QYXRoID0gbWVtb2l6ZUNhcHBlZChmdW5jdGlvbihzdHJpbmcpIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBpZiAoc3RyaW5nLmNoYXJDb2RlQXQoMCkgPT09IDQ2IC8qIC4gKi8pIHtcbiAgICByZXN1bHQucHVzaCgnJyk7XG4gIH1cbiAgc3RyaW5nLnJlcGxhY2UocmVQcm9wTmFtZSwgZnVuY3Rpb24obWF0Y2gsIG51bWJlciwgcXVvdGUsIHN1YlN0cmluZykge1xuICAgIHJlc3VsdC5wdXNoKHF1b3RlID8gc3ViU3RyaW5nLnJlcGxhY2UocmVFc2NhcGVDaGFyLCAnJDEnKSA6IChudW1iZXIgfHwgbWF0Y2gpKTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdHJpbmdUb1BhdGg7XG4iLCJ2YXIgaXNTeW1ib2wgPSByZXF1aXJlKCcuL2lzU3ltYm9sJyk7XG5cbi8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xudmFyIElORklOSVRZID0gMSAvIDA7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICogQHJldHVybnMge3N0cmluZ3xzeW1ib2x9IFJldHVybnMgdGhlIGtleS5cbiAqL1xuZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fCBpc1N5bWJvbCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgdmFyIHJlc3VsdCA9ICh2YWx1ZSArICcnKTtcbiAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvS2V5O1xuIiwiLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIGZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqXG4gKiBDb252ZXJ0cyBgZnVuY2AgdG8gaXRzIHNvdXJjZSBjb2RlLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjb252ZXJ0LlxuICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgc291cmNlIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIHRvU291cmNlKGZ1bmMpIHtcbiAgaWYgKGZ1bmMgIT0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZnVuY1RvU3RyaW5nLmNhbGwoZnVuYyk7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICB0cnkge1xuICAgICAgcmV0dXJuIChmdW5jICsgJycpO1xuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU291cmNlO1xuIiwiLyoqIFVzZWQgdG8gbWF0Y2ggYSBzaW5nbGUgd2hpdGVzcGFjZSBjaGFyYWN0ZXIuICovXG52YXIgcmVXaGl0ZXNwYWNlID0gL1xccy87XG5cbi8qKlxuICogVXNlZCBieSBgXy50cmltYCBhbmQgYF8udHJpbUVuZGAgdG8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBub24td2hpdGVzcGFjZVxuICogY2hhcmFjdGVyIG9mIGBzdHJpbmdgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBsYXN0IG5vbi13aGl0ZXNwYWNlIGNoYXJhY3Rlci5cbiAqL1xuZnVuY3Rpb24gdHJpbW1lZEVuZEluZGV4KHN0cmluZykge1xuICB2YXIgaW5kZXggPSBzdHJpbmcubGVuZ3RoO1xuXG4gIHdoaWxlIChpbmRleC0tICYmIHJlV2hpdGVzcGFjZS50ZXN0KHN0cmluZy5jaGFyQXQoaW5kZXgpKSkge31cbiAgcmV0dXJuIGluZGV4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyaW1tZWRFbmRJbmRleDtcbiIsIi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbnZhciByc0FzdHJhbFJhbmdlID0gJ1xcXFx1ZDgwMC1cXFxcdWRmZmYnLFxuICAgIHJzQ29tYm9NYXJrc1JhbmdlID0gJ1xcXFx1MDMwMC1cXFxcdTAzNmYnLFxuICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICByc0NvbWJvU3ltYm9sc1JhbmdlID0gJ1xcXFx1MjBkMC1cXFxcdTIwZmYnLFxuICAgIHJzQ29tYm9SYW5nZSA9IHJzQ29tYm9NYXJrc1JhbmdlICsgcmVDb21ib0hhbGZNYXJrc1JhbmdlICsgcnNDb21ib1N5bWJvbHNSYW5nZSxcbiAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZic7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjYXB0dXJlIGdyb3Vwcy4gKi9cbnZhciByc0FzdHJhbCA9ICdbJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9SYW5nZSArICddJyxcbiAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICByc01vZGlmaWVyID0gJyg/OicgKyByc0NvbWJvICsgJ3wnICsgcnNGaXR6ICsgJyknLFxuICAgIHJzTm9uQXN0cmFsID0gJ1teJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICByc1N1cnJQYWlyID0gJ1tcXFxcdWQ4MDAtXFxcXHVkYmZmXVtcXFxcdWRjMDAtXFxcXHVkZmZmXScsXG4gICAgcnNaV0ogPSAnXFxcXHUyMDBkJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIHJlZ2V4ZXMuICovXG52YXIgcmVPcHRNb2QgPSByc01vZGlmaWVyICsgJz8nLFxuICAgIHJzT3B0VmFyID0gJ1snICsgcnNWYXJSYW5nZSArICddPycsXG4gICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcbiAgICByc1NlcSA9IHJzT3B0VmFyICsgcmVPcHRNb2QgKyByc09wdEpvaW4sXG4gICAgcnNTeW1ib2wgPSAnKD86JyArIFtyc05vbkFzdHJhbCArIHJzQ29tYm8gKyAnPycsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JykgKyAnKSc7XG5cbi8qKiBVc2VkIHRvIG1hdGNoIFtzdHJpbmcgc3ltYm9sc10oaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtdW5pY29kZSkuICovXG52YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArICcoPz0nICsgcnNGaXR6ICsgJyl8JyArIHJzU3ltYm9sICsgcnNTZXEsICdnJyk7XG5cbi8qKlxuICogR2V0cyB0aGUgc2l6ZSBvZiBhIFVuaWNvZGUgYHN0cmluZ2AuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gKi9cbmZ1bmN0aW9uIHVuaWNvZGVTaXplKHN0cmluZykge1xuICB2YXIgcmVzdWx0ID0gcmVVbmljb2RlLmxhc3RJbmRleCA9IDA7XG4gIHdoaWxlIChyZVVuaWNvZGUudGVzdChzdHJpbmcpKSB7XG4gICAgKytyZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmljb2RlU2l6ZTtcbiIsInZhciBiYXNlQ2xvbmUgPSByZXF1aXJlKCcuL19iYXNlQ2xvbmUnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGB2YWx1ZWAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXG4gKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHBzOi8vbWRuLmlvL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtKVxuICogYW5kIHN1cHBvcnRzIGNsb25pbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucywgZGF0ZSBvYmplY3RzLCBtYXBzLFxuICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkXG4gKiBhcnJheXMuIFRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYXJlIGNsb25lZFxuICogYXMgcGxhaW4gb2JqZWN0cy4gQW4gZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaFxuICogYXMgZXJyb3Igb2JqZWN0cywgZnVuY3Rpb25zLCBET00gbm9kZXMsIGFuZCBXZWFrTWFwcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICogQHNlZSBfLmNsb25lRGVlcFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAqXG4gKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUob2JqZWN0cyk7XG4gKiBjb25zb2xlLmxvZyhzaGFsbG93WzBdID09PSBvYmplY3RzWzBdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcbiAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjbG9uZTtcbiIsInZhciBiYXNlQ2xvbmUgPSByZXF1aXJlKCcuL19iYXNlQ2xvbmUnKTtcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9ERUVQX0ZMQUcgPSAxLFxuICAgIENMT05FX1NZTUJPTFNfRkxBRyA9IDQ7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jbG9uZWAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAxLjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICogQHNlZSBfLmNsb25lXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICpcbiAqIHZhciBkZWVwID0gXy5jbG9uZURlZXAob2JqZWN0cyk7XG4gKiBjb25zb2xlLmxvZyhkZWVwWzBdID09PSBvYmplY3RzWzBdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSkge1xuICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb25lRGVlcDtcbiIsIi8qKlxuICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdmFsdWVgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi40LjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZXR1cm4gZnJvbSB0aGUgbmV3IGZ1bmN0aW9uLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICpcbiAqIGNvbnNvbGUubG9nKG9iamVjdHNbMF0gPT09IG9iamVjdHNbMV0pO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBjb25zdGFudCh2YWx1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnN0YW50O1xuIiwidmFyIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBlcSA9IHJlcXVpcmUoJy4vZXEnKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vX2lzSXRlcmF0ZWVDYWxsJyksXG4gICAga2V5c0luID0gcmVxdWlyZSgnLi9rZXlzSW4nKTtcblxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBBc3NpZ25zIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2Ygc291cmNlXG4gKiBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXRcbiAqIHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuIFNvdXJjZSBvYmplY3RzIGFyZSBhcHBsaWVkIGZyb20gbGVmdCB0byByaWdodC5cbiAqIE9uY2UgYSBwcm9wZXJ0eSBpcyBzZXQsIGFkZGl0aW9uYWwgdmFsdWVzIG9mIHRoZSBzYW1lIHByb3BlcnR5IGFyZSBpZ25vcmVkLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAqIEBwYXJhbSB7Li4uT2JqZWN0fSBbc291cmNlc10gVGhlIHNvdXJjZSBvYmplY3RzLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5kZWZhdWx0c0RlZXBcbiAqIEBleGFtcGxlXG4gKlxuICogXy5kZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICovXG52YXIgZGVmYXVsdHMgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIHNvdXJjZXMpIHtcbiAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG5cbiAgdmFyIGluZGV4ID0gLTE7XG4gIHZhciBsZW5ndGggPSBzb3VyY2VzLmxlbmd0aDtcbiAgdmFyIGd1YXJkID0gbGVuZ3RoID4gMiA/IHNvdXJjZXNbMl0gOiB1bmRlZmluZWQ7XG5cbiAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgIGxlbmd0aCA9IDE7XG4gIH1cblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzW2luZGV4XTtcbiAgICB2YXIgcHJvcHMgPSBrZXlzSW4oc291cmNlKTtcbiAgICB2YXIgcHJvcHNJbmRleCA9IC0xO1xuICAgIHZhciBwcm9wc0xlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK3Byb3BzSW5kZXggPCBwcm9wc0xlbmd0aCkge1xuICAgICAgdmFyIGtleSA9IHByb3BzW3Byb3BzSW5kZXhdO1xuICAgICAgdmFyIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgKGVxKHZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgICAgIG9iamVjdFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZvckVhY2gnKTtcbiIsIi8qKlxuICogUGVyZm9ybXMgYVxuICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAqIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZSBlcXVpdmFsZW50LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICogdmFyIG90aGVyID0geyAnYSc6IDEgfTtcbiAqXG4gKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKCdhJywgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmVxKE5hTiwgTmFOKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gIHJldHVybiB2YWx1ZSA9PT0gb3RoZXIgfHwgKHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVxO1xuIiwidmFyIGFycmF5RmlsdGVyID0gcmVxdWlyZSgnLi9fYXJyYXlGaWx0ZXInKSxcbiAgICBiYXNlRmlsdGVyID0gcmVxdWlyZSgnLi9fYmFzZUZpbHRlcicpLFxuICAgIGJhc2VJdGVyYXRlZSA9IHJlcXVpcmUoJy4vX2Jhc2VJdGVyYXRlZScpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogKipOb3RlOioqIFVubGlrZSBgXy5yZW1vdmVgLCB0aGlzIG1ldGhvZCByZXR1cm5zIGEgbmV3IGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqIEBzZWUgXy5yZWplY3RcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gKiBdO1xuICpcbiAqIF8uZmlsdGVyKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maWx0ZXIodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLmZpbHRlcih1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmlsdGVyKHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gKlxuICogLy8gQ29tYmluaW5nIHNldmVyYWwgcHJlZGljYXRlcyB1c2luZyBgXy5vdmVyRXZlcnlgIG9yIGBfLm92ZXJTb21lYC5cbiAqIF8uZmlsdGVyKHVzZXJzLCBfLm92ZXJTb21lKFt7ICdhZ2UnOiAzNiB9LCBbJ2FnZScsIDQwXV0pKTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCcsICdiYXJuZXknXVxuICovXG5mdW5jdGlvbiBmaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RmlsdGVyIDogYmFzZUZpbHRlcjtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZpbHRlcjtcbiIsInZhciBjcmVhdGVGaW5kID0gcmVxdWlyZSgnLi9fY3JlYXRlRmluZCcpLFxuICAgIGZpbmRJbmRleCA9IHJlcXVpcmUoJy4vZmluZEluZGV4Jyk7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudFxuICogYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0aHJlZVxuICogYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWF0Y2hlZCBlbGVtZW50LCBlbHNlIGB1bmRlZmluZWRgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSBbXG4gKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEsICAnYWN0aXZlJzogdHJ1ZSB9XG4gKiBdO1xuICpcbiAqIF8uZmluZCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2UgPCA0MDsgfSk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZCh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gKiAvLyA9PiBvYmplY3QgZm9yICdwZWJibGVzJ1xuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gb2JqZWN0IGZvciAnZnJlZCdcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZCh1c2VycywgJ2FjdGl2ZScpO1xuICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICovXG52YXIgZmluZCA9IGNyZWF0ZUZpbmQoZmluZEluZGV4KTtcblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kO1xuIiwidmFyIGJhc2VGaW5kSW5kZXggPSByZXF1aXJlKCcuL19iYXNlRmluZEluZGV4JyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi90b0ludGVnZXInKTtcblxuLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgZm9yIHRob3NlIHdpdGggdGhlIHNhbWUgbmFtZSBhcyBvdGhlciBgbG9kYXNoYCBtZXRob2RzLiAqL1xudmFyIG5hdGl2ZU1heCA9IE1hdGgubWF4O1xuXG4vKipcbiAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZGAgZXhjZXB0IHRoYXQgaXQgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0XG4gKiBlbGVtZW50IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAqIF07XG4gKlxuICogXy5maW5kSW5kZXgodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlciA9PSAnYmFybmV5JzsgfSk7XG4gKiAvLyA9PiAwXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gKiAvLyA9PiAxXG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5maW5kSW5kZXgodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IDBcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZmluZEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiAyXG4gKi9cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnJheSwgcHJlZGljYXRlLCBmcm9tSW5kZXgpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICBpZiAoIWxlbmd0aCkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICB2YXIgaW5kZXggPSBmcm9tSW5kZXggPT0gbnVsbCA/IDAgOiB0b0ludGVnZXIoZnJvbUluZGV4KTtcbiAgaWYgKGluZGV4IDwgMCkge1xuICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgfVxuICByZXR1cm4gYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGluZGV4KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmaW5kSW5kZXg7XG4iLCJ2YXIgYmFzZUZsYXR0ZW4gPSByZXF1aXJlKCcuL19iYXNlRmxhdHRlbicpO1xuXG4vKipcbiAqIEZsYXR0ZW5zIGBhcnJheWAgYSBzaW5nbGUgbGV2ZWwgZGVlcC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmZsYXR0ZW4oWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbihhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPyBiYXNlRmxhdHRlbihhcnJheSwgMSkgOiBbXTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuO1xuIiwidmFyIGFycmF5RWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5RWFjaCcpLFxuICAgIGJhc2VFYWNoID0gcmVxdWlyZSgnLi9fYmFzZUVhY2gnKSxcbiAgICBjYXN0RnVuY3Rpb24gPSByZXF1aXJlKCcuL19jYXN0RnVuY3Rpb24nKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBlbGVtZW50LlxuICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiAqKk5vdGU6KiogQXMgd2l0aCBvdGhlciBcIkNvbGxlY3Rpb25zXCIgbWV0aG9kcywgb2JqZWN0cyB3aXRoIGEgXCJsZW5ndGhcIlxuICogcHJvcGVydHkgYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIHVzZSBgXy5mb3JJbmBcbiAqIG9yIGBfLmZvck93bmAgZm9yIG9iamVjdCBpdGVyYXRpb24uXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGFsaWFzIGVhY2hcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICogQHNlZSBfLmZvckVhY2hSaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmZvckVhY2goWzEsIDJdLCBmdW5jdGlvbih2YWx1ZSkge1xuICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gKiB9KTtcbiAqIC8vID0+IExvZ3MgYDFgIHRoZW4gYDJgLlxuICpcbiAqIF8uZm9yRWFjaCh7ICdhJzogMSwgJ2InOiAyIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAqICAgY29uc29sZS5sb2coa2V5KTtcbiAqIH0pO1xuICogLy8gPT4gTG9ncyAnYScgdGhlbiAnYicgKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZCkuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2goY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFYWNoIDogYmFzZUVhY2g7XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGNhc3RGdW5jdGlvbihpdGVyYXRlZSkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvckVhY2g7XG4iLCJ2YXIgYmFzZUZvciA9IHJlcXVpcmUoJy4vX2Jhc2VGb3InKSxcbiAgICBjYXN0RnVuY3Rpb24gPSByZXF1aXJlKCcuL19jYXN0RnVuY3Rpb24nKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIEl0ZXJhdGVzIG92ZXIgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBhblxuICogb2JqZWN0IGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdFxuICogaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjMuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAqIEBzZWUgXy5mb3JJblJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqICAgdGhpcy5iID0gMjtcbiAqIH1cbiAqXG4gKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICpcbiAqIF8uZm9ySW4obmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICogICBjb25zb2xlLmxvZyhrZXkpO1xuICogfSk7XG4gKiAvLyA9PiBMb2dzICdhJywgJ2InLCB0aGVuICdjJyAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKS5cbiAqL1xuZnVuY3Rpb24gZm9ySW4ob2JqZWN0LCBpdGVyYXRlZSkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGxcbiAgICA/IG9iamVjdFxuICAgIDogYmFzZUZvcihvYmplY3QsIGNhc3RGdW5jdGlvbihpdGVyYXRlZSksIGtleXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9ySW47XG4iLCJ2YXIgYmFzZUdldCA9IHJlcXVpcmUoJy4vX2Jhc2VHZXQnKTtcblxuLyoqXG4gKiBHZXRzIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYG9iamVjdGAuIElmIHRoZSByZXNvbHZlZCB2YWx1ZSBpc1xuICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjcuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gKlxuICogXy5nZXQob2JqZWN0LCAnYVswXS5iLmMnKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IDNcbiAqXG4gKiBfLmdldChvYmplY3QsICdhLmIuYycsICdkZWZhdWx0Jyk7XG4gKiAvLyA9PiAnZGVmYXVsdCdcbiAqL1xuZnVuY3Rpb24gZ2V0KG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSB7XG4gIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gZGVmYXVsdFZhbHVlIDogcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldDtcbiIsInZhciBiYXNlSGFzID0gcmVxdWlyZSgnLi9fYmFzZUhhcycpLFxuICAgIGhhc1BhdGggPSByZXF1aXJlKCcuL19oYXNQYXRoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogeyAnYic6IDIgfSB9O1xuICogdmFyIG90aGVyID0gXy5jcmVhdGUoeyAnYSc6IF8uY3JlYXRlKHsgJ2InOiAyIH0pIH0pO1xuICpcbiAqIF8uaGFzKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhcyhvYmplY3QsICdhLmInKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhcyhvYmplY3QsIFsnYScsICdiJ10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzKG90aGVyLCAnYScpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaGFzKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXMpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGhhcztcbiIsInZhciBiYXNlSGFzSW4gPSByZXF1aXJlKCcuL19iYXNlSGFzSW4nKSxcbiAgICBoYXNQYXRoID0gcmVxdWlyZSgnLi9faGFzUGF0aCcpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcGF0aGAgaXMgYSBkaXJlY3Qgb3IgaW5oZXJpdGVkIHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBwYXRoYCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IF8uY3JlYXRlKHsgJ2EnOiBfLmNyZWF0ZSh7ICdiJzogMiB9KSB9KTtcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICByZXR1cm4gb2JqZWN0ICE9IG51bGwgJiYgaGFzUGF0aChvYmplY3QsIHBhdGgsIGJhc2VIYXNJbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaGFzSW47XG4iLCIvKipcbiAqIFRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IGl0IHJlY2VpdmVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0geyp9IHZhbHVlIEFueSB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICpcbiAqIGNvbnNvbGUubG9nKF8uaWRlbnRpdHkob2JqZWN0KSA9PT0gb2JqZWN0KTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuIiwidmFyIGJhc2VJc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vX2Jhc2VJc0FyZ3VtZW50cycpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKiBCdWlsdC1pbiB2YWx1ZSByZWZlcmVuY2VzLiAqL1xudmFyIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gb2JqZWN0UHJvdG8ucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGFuIGBhcmd1bWVudHNgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gKiAgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzQXJndW1lbnRzKGZ1bmN0aW9uKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcmd1bWVudHMoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0FyZ3VtZW50cyA9IGJhc2VJc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKSA/IGJhc2VJc0FyZ3VtZW50cyA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGhhc093blByb3BlcnR5LmNhbGwodmFsdWUsICdjYWxsZWUnKSAmJlxuICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJndW1lbnRzO1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheWAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0FycmF5KF8ubm9vcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNBcnJheTtcbiIsInZhciBpc0Z1bmN0aW9uID0gcmVxdWlyZSgnLi9pc0Z1bmN0aW9uJyksXG4gICAgaXNMZW5ndGggPSByZXF1aXJlKCcuL2lzTGVuZ3RoJyk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICogbm90IGEgZnVuY3Rpb24gYW5kIGhhcyBhIGB2YWx1ZS5sZW5ndGhgIHRoYXQncyBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBvclxuICogZXF1YWwgdG8gYDBgIGFuZCBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgIWlzRnVuY3Rpb24odmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzQXJyYXlMaWtlO1xuIiwidmFyIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc0FycmF5TGlrZWAgZXhjZXB0IHRoYXQgaXQgYWxzbyBjaGVja3MgaWYgYHZhbHVlYFxuICogaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LWxpa2Ugb2JqZWN0LFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdChbMSwgMiwgM10pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoZG9jdW1lbnQuYm9keS5jaGlsZHJlbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0FycmF5TGlrZU9iamVjdCgnYWJjJyk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNBcnJheUxpa2VPYmplY3QoXy5ub29wKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0FycmF5TGlrZU9iamVjdDtcbiIsInZhciByb290ID0gcmVxdWlyZSgnLi9fcm9vdCcpLFxuICAgIHN0dWJGYWxzZSA9IHJlcXVpcmUoJy4vc3R1YkZhbHNlJyk7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZXhwb3J0c2AuICovXG52YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmICFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cbi8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbnZhciBmcmVlTW9kdWxlID0gZnJlZUV4cG9ydHMgJiYgdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiBtb2R1bGU7XG5cbi8qKiBEZXRlY3QgdGhlIHBvcHVsYXIgQ29tbW9uSlMgZXh0ZW5zaW9uIGBtb2R1bGUuZXhwb3J0c2AuICovXG52YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG52YXIgQnVmZmVyID0gbW9kdWxlRXhwb3J0cyA/IHJvb3QuQnVmZmVyIDogdW5kZWZpbmVkO1xuXG4vKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG52YXIgbmF0aXZlSXNCdWZmZXIgPSBCdWZmZXIgPyBCdWZmZXIuaXNCdWZmZXIgOiB1bmRlZmluZWQ7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc0J1ZmZlcihuZXcgQnVmZmVyKDIpKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzQnVmZmVyKG5ldyBVaW50OEFycmF5KDIpKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc0J1ZmZlciA9IG5hdGl2ZUlzQnVmZmVyIHx8IHN0dWJGYWxzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc0J1ZmZlcjtcbiIsInZhciBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgZ2V0VGFnID0gcmVxdWlyZSgnLi9fZ2V0VGFnJyksXG4gICAgaXNBcmd1bWVudHMgPSByZXF1aXJlKCcuL2lzQXJndW1lbnRzJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpLFxuICAgIGlzQnVmZmVyID0gcmVxdWlyZSgnLi9pc0J1ZmZlcicpLFxuICAgIGlzUHJvdG90eXBlID0gcmVxdWlyZSgnLi9faXNQcm90b3R5cGUnKSxcbiAgICBpc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL2lzVHlwZWRBcnJheScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBjb2xsZWN0aW9uLCBtYXAsIG9yIHNldC5cbiAqXG4gKiBPYmplY3RzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBubyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWRcbiAqIHByb3BlcnRpZXMuXG4gKlxuICogQXJyYXktbGlrZSB2YWx1ZXMgc3VjaCBhcyBgYXJndW1lbnRzYCBvYmplY3RzLCBhcnJheXMsIGJ1ZmZlcnMsIHN0cmluZ3MsIG9yXG4gKiBqUXVlcnktbGlrZSBjb2xsZWN0aW9ucyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgbGVuZ3RoYCBvZiBgMGAuXG4gKiBTaW1pbGFybHksIG1hcHMgYW5kIHNldHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIGEgYHNpemVgIG9mIGAwYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBlbXB0eSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzRW1wdHkobnVsbCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc0VtcHR5KHRydWUpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNFbXB0eSgxKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRW1wdHkoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc0VtcHR5KHsgJ2EnOiAxIH0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgIChpc0FycmF5KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlLnNwbGljZSA9PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgIGlzQnVmZmVyKHZhbHVlKSB8fCBpc1R5cGVkQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgfVxuICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKTtcbiAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgIHJldHVybiAhdmFsdWUuc2l6ZTtcbiAgfVxuICBpZiAoaXNQcm90b3R5cGUodmFsdWUpKSB7XG4gICAgcmV0dXJuICFiYXNlS2V5cyh2YWx1ZSkubGVuZ3RoO1xuICB9XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRW1wdHk7XG4iLCJ2YXIgYmFzZUdldFRhZyA9IHJlcXVpcmUoJy4vX2Jhc2VHZXRUYWcnKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIGFzeW5jVGFnID0gJ1tvYmplY3QgQXN5bmNGdW5jdGlvbl0nLFxuICAgIGZ1bmNUYWcgPSAnW29iamVjdCBGdW5jdGlvbl0nLFxuICAgIGdlblRhZyA9ICdbb2JqZWN0IEdlbmVyYXRvckZ1bmN0aW9uXScsXG4gICAgcHJveHlUYWcgPSAnW29iamVjdCBQcm94eV0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgRnVuY3Rpb25gIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNGdW5jdGlvbihfKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBUaGUgdXNlIG9mIGBPYmplY3QjdG9TdHJpbmdgIGF2b2lkcyBpc3N1ZXMgd2l0aCB0aGUgYHR5cGVvZmAgb3BlcmF0b3JcbiAgLy8gaW4gU2FmYXJpIDkgd2hpY2ggcmV0dXJucyAnb2JqZWN0JyBmb3IgdHlwZWQgYXJyYXlzIGFuZCBvdGhlciBjb25zdHJ1Y3RvcnMuXG4gIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgcmV0dXJuIHRhZyA9PSBmdW5jVGFnIHx8IHRhZyA9PSBnZW5UYWcgfHwgdGFnID09IGFzeW5jVGFnIHx8IHRhZyA9PSBwcm94eVRhZztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc0Z1bmN0aW9uO1xuIiwiLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSB2YWxpZCBhcnJheS1saWtlIGxlbmd0aC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgbG9vc2VseSBiYXNlZCBvblxuICogW2BUb0xlbmd0aGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXRvbGVuZ3RoKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzTGVuZ3RoKDMpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzTGVuZ3RoKCczJyk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdudW1iZXInICYmXG4gICAgdmFsdWUgPiAtMSAmJiB2YWx1ZSAlIDEgPT0gMCAmJiB2YWx1ZSA8PSBNQVhfU0FGRV9JTlRFR0VSO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTGVuZ3RoO1xuIiwidmFyIGJhc2VJc01hcCA9IHJlcXVpcmUoJy4vX2Jhc2VJc01hcCcpLFxuICAgIGJhc2VVbmFyeSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmFyeScpLFxuICAgIG5vZGVVdGlsID0gcmVxdWlyZSgnLi9fbm9kZVV0aWwnKTtcblxuLyogTm9kZS5qcyBoZWxwZXIgcmVmZXJlbmNlcy4gKi9cbnZhciBub2RlSXNNYXAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc01hcDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE1hcGAgb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4zLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNNYXAobmV3IE1hcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc01hcChuZXcgV2Vha01hcCk7XG4gKiAvLyA9PiBmYWxzZVxuICovXG52YXIgaXNNYXAgPSBub2RlSXNNYXAgPyBiYXNlVW5hcnkobm9kZUlzTWFwKSA6IGJhc2VJc01hcDtcblxubW9kdWxlLmV4cG9ydHMgPSBpc01hcDtcbiIsIi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gKiBbbGFuZ3VhZ2UgdHlwZV0oaHR0cDovL3d3dy5lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLWVjbWFzY3JpcHQtbGFuZ3VhZ2UtdHlwZXMpXG4gKiBvZiBgT2JqZWN0YC4gKGUuZy4gYXJyYXlzLCBmdW5jdGlvbnMsIG9iamVjdHMsIHJlZ2V4ZXMsIGBuZXcgTnVtYmVyKDApYCwgYW5kIGBuZXcgU3RyaW5nKCcnKWApXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNPYmplY3Qoe30pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdChudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiAodHlwZSA9PSAnb2JqZWN0JyB8fCB0eXBlID09ICdmdW5jdGlvbicpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzT2JqZWN0O1xuIiwiLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXCJvYmplY3RcIi5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNPYmplY3RMaWtlO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgZ2V0UHJvdG90eXBlID0gcmVxdWlyZSgnLi9fZ2V0UHJvdG90eXBlJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIG9iamVjdFRhZyA9ICdbb2JqZWN0IE9iamVjdF0nO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcblxuLyoqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgZGVjb21waWxlZCBzb3VyY2Ugb2YgZnVuY3Rpb25zLiAqL1xudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcblxuLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqIFVzZWQgdG8gaW5mZXIgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLiAqL1xudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcbiAqIGBPYmplY3RgIGNvbnN0cnVjdG9yIG9yIG9uZSB3aXRoIGEgYFtbUHJvdG90eXBlXV1gIG9mIGBudWxsYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuOC4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBmdW5jdGlvbiBGb28oKSB7XG4gKiAgIHRoaXMuYSA9IDE7XG4gKiB9XG4gKlxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xuICogLy8gPT4gZmFsc2VcbiAqXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xuICogLy8gPT4gdHJ1ZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIGlmICghaXNPYmplY3RMaWtlKHZhbHVlKSB8fCBiYXNlR2V0VGFnKHZhbHVlKSAhPSBvYmplY3RUYWcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlKHZhbHVlKTtcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgcmV0dXJuIHR5cGVvZiBDdG9yID09ICdmdW5jdGlvbicgJiYgQ3RvciBpbnN0YW5jZW9mIEN0b3IgJiZcbiAgICBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzUGxhaW5PYmplY3Q7XG4iLCJ2YXIgYmFzZUlzU2V0ID0gcmVxdWlyZSgnLi9fYmFzZUlzU2V0JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1NldCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzU2V0O1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU2V0YCBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjMuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1NldChuZXcgU2V0KTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1NldCA9IG5vZGVJc1NldCA/IGJhc2VVbmFyeShub2RlSXNTZXQpIDogYmFzZUlzU2V0O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU2V0O1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNBcnJheSA9IHJlcXVpcmUoJy4vaXNBcnJheScpLFxuICAgIGlzT2JqZWN0TGlrZSA9IHJlcXVpcmUoJy4vaXNPYmplY3RMaWtlJyk7XG5cbi8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgcmVmZXJlbmNlcy4gKi9cbnZhciBzdHJpbmdUYWcgPSAnW29iamVjdCBTdHJpbmddJztcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHN0cmluZywgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzU3RyaW5nKCdhYmMnKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3RyaW5nKDEpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICghaXNBcnJheSh2YWx1ZSkgJiYgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaW5nO1xuIiwidmFyIGJhc2VHZXRUYWcgPSByZXF1aXJlKCcuL19iYXNlR2V0VGFnJyksXG4gICAgaXNPYmplY3RMaWtlID0gcmVxdWlyZSgnLi9pc09iamVjdExpa2UnKTtcblxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xudmFyIHN5bWJvbFRhZyA9ICdbb2JqZWN0IFN5bWJvbF0nO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgU3ltYm9sYCBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3ltYm9sLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNTeW1ib2woU3ltYm9sLml0ZXJhdG9yKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzU3ltYm9sKCdhYmMnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3ltYm9sKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAoaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBzeW1ib2xUYWcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3ltYm9sO1xuIiwidmFyIGJhc2VJc1R5cGVkQXJyYXkgPSByZXF1aXJlKCcuL19iYXNlSXNUeXBlZEFycmF5JyksXG4gICAgYmFzZVVuYXJ5ID0gcmVxdWlyZSgnLi9fYmFzZVVuYXJ5JyksXG4gICAgbm9kZVV0aWwgPSByZXF1aXJlKCcuL19ub2RlVXRpbCcpO1xuXG4vKiBOb2RlLmpzIGhlbHBlciByZWZlcmVuY2VzLiAqL1xudmFyIG5vZGVJc1R5cGVkQXJyYXkgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1R5cGVkQXJyYXk7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIHR5cGVkIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbnZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxubW9kdWxlLmV4cG9ydHMgPSBpc1R5cGVkQXJyYXk7XG4iLCIvKipcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaXNVbmRlZmluZWQodm9pZCAwKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzVW5kZWZpbmVkKG51bGwpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNVbmRlZmluZWQ7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5cyA9IHJlcXVpcmUoJy4vX2Jhc2VLZXlzJyksXG4gICAgaXNBcnJheUxpa2UgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAqIFtFUyBzcGVjXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1vYmplY3Qua2V5cylcbiAqIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzKG5ldyBGb28pO1xuICogLy8gPT4gWydhJywgJ2InXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIF8ua2V5cygnaGknKTtcbiAqIC8vID0+IFsnMCcsICcxJ11cbiAqL1xuZnVuY3Rpb24ga2V5cyhvYmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCkgOiBiYXNlS2V5cyhvYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGtleXM7XG4iLCJ2YXIgYXJyYXlMaWtlS2V5cyA9IHJlcXVpcmUoJy4vX2FycmF5TGlrZUtleXMnKSxcbiAgICBiYXNlS2V5c0luID0gcmVxdWlyZSgnLi9fYmFzZUtleXNJbicpLFxuICAgIGlzQXJyYXlMaWtlID0gcmVxdWlyZSgnLi9pc0FycmF5TGlrZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gKlxuICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAzLjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5rZXlzSW4obmV3IEZvbyk7XG4gKiAvLyA9PiBbJ2EnLCAnYicsICdjJ10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0LCB0cnVlKSA6IGJhc2VLZXlzSW4ob2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBrZXlzSW47XG4iLCIvKipcbiAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmxhc3QoWzEsIDIsIDNdKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gbGFzdChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsYXN0O1xuIiwidmFyIGFycmF5TWFwID0gcmVxdWlyZSgnLi9fYXJyYXlNYXAnKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBiYXNlTWFwID0gcmVxdWlyZSgnLi9fYmFzZU1hcCcpLFxuICAgIGlzQXJyYXkgPSByZXF1aXJlKCcuL2lzQXJyYXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydVxuICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gKiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gKiBgXy5ldmVyeWAsIGBfLmZpbHRlcmAsIGBfLm1hcGAsIGBfLm1hcFZhbHVlc2AsIGBfLnJlamVjdGAsIGFuZCBgXy5zb21lYC5cbiAqXG4gKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAqIGBhcnlgLCBgY2h1bmtgLCBgY3VycnlgLCBgY3VycnlSaWdodGAsIGBkcm9wYCwgYGRyb3BSaWdodGAsIGBldmVyeWAsXG4gKiBgZmlsbGAsIGBpbnZlcnRgLCBgcGFyc2VJbnRgLCBgcmFuZG9tYCwgYHJhbmdlYCwgYHJhbmdlUmlnaHRgLCBgcmVwZWF0YCxcbiAqIGBzYW1wbGVTaXplYCwgYHNsaWNlYCwgYHNvbWVgLCBgc29ydEJ5YCwgYHNwbGl0YCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAqIGB0ZW1wbGF0ZWAsIGB0cmltYCwgYHRyaW1FbmRgLCBgdHJpbVN0YXJ0YCwgYW5kIGB3b3Jkc2BcbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gKiAgIHJldHVybiBuICogbjtcbiAqIH1cbiAqXG4gKiBfLm1hcChbNCwgOF0sIHNxdWFyZSk7XG4gKiAvLyA9PiBbMTYsIDY0XVxuICpcbiAqIF8ubWFwKHsgJ2EnOiA0LCAnYic6IDggfSwgc3F1YXJlKTtcbiAqIC8vID0+IFsxNiwgNjRdIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gKiBdO1xuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5tYXAodXNlcnMsICd1c2VyJyk7XG4gKiAvLyA9PiBbJ2Jhcm5leScsICdmcmVkJ11cbiAqL1xuZnVuY3Rpb24gbWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5TWFwIDogYmFzZU1hcDtcbiAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gbWFwO1xuIiwidmFyIGJhc2VBc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Jhc2VBc3NpZ25WYWx1ZScpLFxuICAgIGJhc2VGb3JPd24gPSByZXF1aXJlKCcuL19iYXNlRm9yT3duJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZSBrZXlzIGFzIGBvYmplY3RgIGFuZCB2YWx1ZXMgZ2VuZXJhdGVkXG4gKiBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocnVcbiAqIGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICogKHZhbHVlLCBrZXksIG9iamVjdCkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gKiBAc2VlIF8ubWFwS2V5c1xuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgdXNlcnMgPSB7XG4gKiAgICdmcmVkJzogICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gKiAgICdwZWJibGVzJzogeyAndXNlcic6ICdwZWJibGVzJywgJ2FnZSc6IDEgfVxuICogfTtcbiAqXG4gKiBfLm1hcFZhbHVlcyh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby5hZ2U7IH0pO1xuICogLy8gPT4geyAnZnJlZCc6IDQwLCAncGViYmxlcyc6IDEgfSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5tYXBWYWx1ZXModXNlcnMsICdhZ2UnKTtcbiAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24gbWFwVmFsdWVzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBpdGVyYXRlZSA9IGJhc2VJdGVyYXRlZShpdGVyYXRlZSwgMyk7XG5cbiAgYmFzZUZvck93bihvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqZWN0KSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1hcFZhbHVlcztcbiIsInZhciBiYXNlRXh0cmVtdW0gPSByZXF1aXJlKCcuL19iYXNlRXh0cmVtdW0nKSxcbiAgICBiYXNlR3QgPSByZXF1aXJlKCcuL19iYXNlR3QnKSxcbiAgICBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBgYXJyYXlgLiBJZiBgYXJyYXlgIGlzIGVtcHR5IG9yIGZhbHNleSxcbiAqIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBNYXRoXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ubWF4KFs0LCAyLCA4LCA2XSk7XG4gKiAvLyA9PiA4XG4gKlxuICogXy5tYXgoW10pO1xuICogLy8gPT4gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIG1heChhcnJheSkge1xuICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgaWRlbnRpdHksIGJhc2VHdClcbiAgICA6IHVuZGVmaW5lZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXg7XG4iLCJ2YXIgTWFwQ2FjaGUgPSByZXF1aXJlKCcuL19NYXBDYWNoZScpO1xuXG4vKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG52YXIgRlVOQ19FUlJPUl9URVhUID0gJ0V4cGVjdGVkIGEgZnVuY3Rpb24nO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gKiBwcm92aWRlZCwgaXQgZGV0ZXJtaW5lcyB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHQgYmFzZWQgb24gdGhlXG4gKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAqIHByb3ZpZGVkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBtYXAgY2FjaGUga2V5LiBUaGUgYGZ1bmNgXG4gKiBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIHRoZSBtZW1vaXplZCBmdW5jdGlvbi5cbiAqXG4gKiAqKk5vdGU6KiogVGhlIGNhY2hlIGlzIGV4cG9zZWQgYXMgdGhlIGBjYWNoZWAgcHJvcGVydHkgb24gdGhlIG1lbW9pemVkXG4gKiBmdW5jdGlvbi4gSXRzIGNyZWF0aW9uIG1heSBiZSBjdXN0b21pemVkIGJ5IHJlcGxhY2luZyB0aGUgYF8ubWVtb2l6ZS5DYWNoZWBcbiAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gKiBbYE1hcGBdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXByb3BlcnRpZXMtb2YtdGhlLW1hcC1wcm90b3R5cGUtb2JqZWN0KVxuICogbWV0aG9kIGludGVyZmFjZSBvZiBgY2xlYXJgLCBgZGVsZXRlYCwgYGdldGAsIGBoYXNgLCBhbmQgYHNldGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBoYXZlIGl0cyBvdXRwdXQgbWVtb2l6ZWQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBtZW1vaXplZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAqIHZhciBvdGhlciA9IHsgJ2MnOiAzLCAnZCc6IDQgfTtcbiAqXG4gKiB2YXIgdmFsdWVzID0gXy5tZW1vaXplKF8udmFsdWVzKTtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogdmFsdWVzKG90aGVyKTtcbiAqIC8vID0+IFszLCA0XVxuICpcbiAqIG9iamVjdC5hID0gMjtcbiAqIHZhbHVlcyhvYmplY3QpO1xuICogLy8gPT4gWzEsIDJdXG4gKlxuICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gKiB2YWx1ZXMuY2FjaGUuc2V0KG9iamVjdCwgWydhJywgJ2InXSk7XG4gKiB2YWx1ZXMob2JqZWN0KTtcbiAqIC8vID0+IFsnYScsICdiJ11cbiAqXG4gKiAvLyBSZXBsYWNlIGBfLm1lbW9pemUuQ2FjaGVgLlxuICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZShmdW5jLCByZXNvbHZlcikge1xuICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIGtleSA9IHJlc29sdmVyID8gcmVzb2x2ZXIuYXBwbHkodGhpcywgYXJncykgOiBhcmdzWzBdLFxuICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgaWYgKGNhY2hlLmhhcyhrZXkpKSB7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIG1lbW9pemVkLmNhY2hlID0gY2FjaGUuc2V0KGtleSwgcmVzdWx0KSB8fCBjYWNoZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBtZW1vaXplZC5jYWNoZSA9IG5ldyAobWVtb2l6ZS5DYWNoZSB8fCBNYXBDYWNoZSk7XG4gIHJldHVybiBtZW1vaXplZDtcbn1cblxuLy8gRXhwb3NlIGBNYXBDYWNoZWAuXG5tZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbm1vZHVsZS5leHBvcnRzID0gbWVtb2l6ZTtcbiIsInZhciBiYXNlTWVyZ2UgPSByZXF1aXJlKCcuL19iYXNlTWVyZ2UnKSxcbiAgICBjcmVhdGVBc3NpZ25lciA9IHJlcXVpcmUoJy4vX2NyZWF0ZUFzc2lnbmVyJyk7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IG1lcmdlcyBvd24gYW5kXG4gKiBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyBpbnRvIHRoZVxuICogZGVzdGluYXRpb24gb2JqZWN0LiBTb3VyY2UgcHJvcGVydGllcyB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAgYXJlXG4gKiBza2lwcGVkIGlmIGEgZGVzdGluYXRpb24gdmFsdWUgZXhpc3RzLiBBcnJheSBhbmQgcGxhaW4gb2JqZWN0IHByb3BlcnRpZXNcbiAqIGFyZSBtZXJnZWQgcmVjdXJzaXZlbHkuIE90aGVyIG9iamVjdHMgYW5kIHZhbHVlIHR5cGVzIGFyZSBvdmVycmlkZGVuIGJ5XG4gKiBhc3NpZ25tZW50LiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuIFN1YnNlcXVlbnRcbiAqIHNvdXJjZXMgb3ZlcndyaXRlIHByb3BlcnR5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzIHNvdXJjZXMuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjUuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0ID0ge1xuICogICAnYSc6IFt7ICdiJzogMiB9LCB7ICdkJzogNCB9XVxuICogfTtcbiAqXG4gKiB2YXIgb3RoZXIgPSB7XG4gKiAgICdhJzogW3sgJ2MnOiAzIH0sIHsgJ2UnOiA1IH1dXG4gKiB9O1xuICpcbiAqIF8ubWVyZ2Uob2JqZWN0LCBvdGhlcik7XG4gKiAvLyA9PiB7ICdhJzogW3sgJ2InOiAyLCAnYyc6IDMgfSwgeyAnZCc6IDQsICdlJzogNSB9XSB9XG4gKi9cbnZhciBtZXJnZSA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCkge1xuICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IG1lcmdlO1xuIiwidmFyIGJhc2VFeHRyZW11bSA9IHJlcXVpcmUoJy4vX2Jhc2VFeHRyZW11bScpLFxuICAgIGJhc2VMdCA9IHJlcXVpcmUoJy4vX2Jhc2VMdCcpLFxuICAgIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBtaW5pbXVtIHZhbHVlIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgZW1wdHkgb3IgZmFsc2V5LFxuICogYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IE1hdGhcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5taW4oWzQsIDIsIDgsIDZdKTtcbiAqIC8vID0+IDJcbiAqXG4gKiBfLm1pbihbXSk7XG4gKiAvLyA9PiB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gbWluKGFycmF5KSB7XG4gIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgID8gYmFzZUV4dHJlbXVtKGFycmF5LCBpZGVudGl0eSwgYmFzZUx0KVxuICAgIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1pbjtcbiIsInZhciBiYXNlRXh0cmVtdW0gPSByZXF1aXJlKCcuL19iYXNlRXh0cmVtdW0nKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBiYXNlTHQgPSByZXF1aXJlKCcuL19iYXNlTHQnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLm1pbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gKiB0aGUgdmFsdWUgaXMgcmFua2VkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgTWF0aFxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogMSB9LCB7ICduJzogMiB9XTtcbiAqXG4gKiBfLm1pbkJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gKiAvLyA9PiB7ICduJzogMSB9XG4gKlxuICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLm1pbkJ5KG9iamVjdHMsICduJyk7XG4gKiAvLyA9PiB7ICduJzogMSB9XG4gKi9cbmZ1bmN0aW9uIG1pbkJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYmFzZUx0KVxuICAgIDogdW5kZWZpbmVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG1pbkJ5O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGB1bmRlZmluZWRgLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMi4zLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAqIC8vID0+IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAqL1xuZnVuY3Rpb24gbm9vcCgpIHtcbiAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBub29wO1xuIiwidmFyIHJvb3QgPSByZXF1aXJlKCcuL19yb290Jyk7XG5cbi8qKlxuICogR2V0cyB0aGUgdGltZXN0YW1wIG9mIHRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRoYXQgaGF2ZSBlbGFwc2VkIHNpbmNlXG4gKiB0aGUgVW5peCBlcG9jaCAoMSBKYW51YXJ5IDE5NzAgMDA6MDA6MDAgVVRDKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDIuNC4wXG4gKiBAY2F0ZWdvcnkgRGF0ZVxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgdGltZXN0YW1wLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRlZmVyKGZ1bmN0aW9uKHN0YW1wKSB7XG4gKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gKiB9LCBfLm5vdygpKTtcbiAqIC8vID0+IExvZ3MgdGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgaXQgdG9vayBmb3IgdGhlIGRlZmVycmVkIGludm9jYXRpb24uXG4gKi9cbnZhciBub3cgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbm93O1xuIiwidmFyIGJhc2VQaWNrID0gcmVxdWlyZSgnLi9fYmFzZVBpY2snKSxcbiAgICBmbGF0UmVzdCA9IHJlcXVpcmUoJy4vX2ZsYXRSZXN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAqL1xudmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2sob2JqZWN0LCBwYXRocyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwaWNrO1xuIiwidmFyIGJhc2VQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vX2Jhc2VQcm9wZXJ0eScpLFxuICAgIGJhc2VQcm9wZXJ0eURlZXAgPSByZXF1aXJlKCcuL19iYXNlUHJvcGVydHlEZWVwJyksXG4gICAgaXNLZXkgPSByZXF1aXJlKCcuL19pc0tleScpLFxuICAgIHRvS2V5ID0gcmVxdWlyZSgnLi9fdG9LZXknKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZSB2YWx1ZSBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAyLjQuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdHMgPSBbXG4gKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gKiAgIHsgJ2EnOiB7ICdiJzogMSB9IH1cbiAqIF07XG4gKlxuICogXy5tYXAob2JqZWN0cywgXy5wcm9wZXJ0eSgnYS5iJykpO1xuICogLy8gPT4gWzIsIDFdXG4gKlxuICogXy5tYXAoXy5zb3J0Qnkob2JqZWN0cywgXy5wcm9wZXJ0eShbJ2EnLCAnYiddKSksICdhLmInKTtcbiAqIC8vID0+IFsxLCAyXVxuICovXG5mdW5jdGlvbiBwcm9wZXJ0eShwYXRoKSB7XG4gIHJldHVybiBpc0tleShwYXRoKSA/IGJhc2VQcm9wZXJ0eSh0b0tleShwYXRoKSkgOiBiYXNlUHJvcGVydHlEZWVwKHBhdGgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHByb3BlcnR5O1xuIiwidmFyIGNyZWF0ZVJhbmdlID0gcmVxdWlyZSgnLi9fY3JlYXRlUmFuZ2UnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIG51bWJlcnMgKHBvc2l0aXZlIGFuZC9vciBuZWdhdGl2ZSkgcHJvZ3Jlc3NpbmcgZnJvbVxuICogYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBBIHN0ZXAgb2YgYC0xYCBpcyB1c2VkIGlmIGEgbmVnYXRpdmVcbiAqIGBzdGFydGAgaXMgc3BlY2lmaWVkIHdpdGhvdXQgYW4gYGVuZGAgb3IgYHN0ZXBgLiBJZiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkLFxuICogaXQncyBzZXQgdG8gYHN0YXJ0YCB3aXRoIGBzdGFydGAgdGhlbiBzZXQgdG8gYDBgLlxuICpcbiAqICoqTm90ZToqKiBKYXZhU2NyaXB0IGZvbGxvd3MgdGhlIElFRUUtNzU0IHN0YW5kYXJkIGZvciByZXNvbHZpbmdcbiAqIGZsb2F0aW5nLXBvaW50IHZhbHVlcyB3aGljaCBjYW4gcHJvZHVjZSB1bmV4cGVjdGVkIHJlc3VsdHMuXG4gKlxuICogQHN0YXRpY1xuICogQHNpbmNlIDAuMS4wXG4gKiBAbWVtYmVyT2YgX1xuICogQGNhdGVnb3J5IFV0aWxcbiAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gKiBAcGFyYW0ge251bWJlcn0gW3N0ZXA9MV0gVGhlIHZhbHVlIHRvIGluY3JlbWVudCBvciBkZWNyZW1lbnQgYnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gKiBAc2VlIF8uaW5SYW5nZSwgXy5yYW5nZVJpZ2h0XG4gKiBAZXhhbXBsZVxuICpcbiAqIF8ucmFuZ2UoNCk7XG4gKiAvLyA9PiBbMCwgMSwgMiwgM11cbiAqXG4gKiBfLnJhbmdlKC00KTtcbiAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICpcbiAqIF8ucmFuZ2UoMSwgNSk7XG4gKiAvLyA9PiBbMSwgMiwgMywgNF1cbiAqXG4gKiBfLnJhbmdlKDAsIDIwLCA1KTtcbiAqIC8vID0+IFswLCA1LCAxMCwgMTVdXG4gKlxuICogXy5yYW5nZSgwLCAtNCwgLTEpO1xuICogLy8gPT4gWzAsIC0xLCAtMiwgLTNdXG4gKlxuICogXy5yYW5nZSgxLCA0LCAwKTtcbiAqIC8vID0+IFsxLCAxLCAxXVxuICpcbiAqIF8ucmFuZ2UoMCk7XG4gKiAvLyA9PiBbXVxuICovXG52YXIgcmFuZ2UgPSBjcmVhdGVSYW5nZSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJhbmdlO1xuIiwidmFyIGFycmF5UmVkdWNlID0gcmVxdWlyZSgnLi9fYXJyYXlSZWR1Y2UnKSxcbiAgICBiYXNlRWFjaCA9IHJlcXVpcmUoJy4vX2Jhc2VFYWNoJyksXG4gICAgYmFzZUl0ZXJhdGVlID0gcmVxdWlyZSgnLi9fYmFzZUl0ZXJhdGVlJyksXG4gICAgYmFzZVJlZHVjZSA9IHJlcXVpcmUoJy4vX2Jhc2VSZWR1Y2UnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5Jyk7XG5cbi8qKlxuICogUmVkdWNlcyBgY29sbGVjdGlvbmAgdG8gYSB2YWx1ZSB3aGljaCBpcyB0aGUgYWNjdW11bGF0ZWQgcmVzdWx0IG9mIHJ1bm5pbmdcbiAqIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAqIGludm9jYXRpb24gaXMgc3VwcGxpZWQgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcHJldmlvdXMuIElmIGBhY2N1bXVsYXRvcmBcbiAqIGlzIG5vdCBnaXZlbiwgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIGlzIHVzZWQgYXMgdGhlIGluaXRpYWxcbiAqIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuICogKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAqIGBfLnJlZHVjZWAsIGBfLnJlZHVjZVJpZ2h0YCwgYW5kIGBfLnRyYW5zZm9ybWAuXG4gKlxuICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gKiBgYXNzaWduYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBpbmNsdWRlc2AsIGBtZXJnZWAsIGBvcmRlckJ5YCxcbiAqIGFuZCBgc29ydEJ5YFxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqIEBzZWUgXy5yZWR1Y2VSaWdodFxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnJlZHVjZShbMSwgMl0sIGZ1bmN0aW9uKHN1bSwgbikge1xuICogICByZXR1cm4gc3VtICsgbjtcbiAqIH0sIDApO1xuICogLy8gPT4gM1xuICpcbiAqIF8ucmVkdWNlKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAqICAgcmV0dXJuIHJlc3VsdDtcbiAqIH0sIHt9KTtcbiAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqL1xuZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZSA6IGJhc2VSZWR1Y2UsXG4gICAgICBpbml0QWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcblxuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDQpLCBhY2N1bXVsYXRvciwgaW5pdEFjY3VtLCBiYXNlRWFjaCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVkdWNlO1xuIiwidmFyIGJhc2VLZXlzID0gcmVxdWlyZSgnLi9fYmFzZUtleXMnKSxcbiAgICBnZXRUYWcgPSByZXF1aXJlKCcuL19nZXRUYWcnKSxcbiAgICBpc0FycmF5TGlrZSA9IHJlcXVpcmUoJy4vaXNBcnJheUxpa2UnKSxcbiAgICBpc1N0cmluZyA9IHJlcXVpcmUoJy4vaXNTdHJpbmcnKSxcbiAgICBzdHJpbmdTaXplID0gcmVxdWlyZSgnLi9fc3RyaW5nU2l6ZScpO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgc2V0VGFnID0gJ1tvYmplY3QgU2V0XSc7XG5cbi8qKlxuICogR2V0cyB0aGUgc2l6ZSBvZiBgY29sbGVjdGlvbmAgYnkgcmV0dXJuaW5nIGl0cyBsZW5ndGggZm9yIGFycmF5LWxpa2VcbiAqIHZhbHVlcyBvciB0aGUgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIGZvciBvYmplY3RzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbGxlY3Rpb24gc2l6ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5zaXplKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAzXG4gKlxuICogXy5zaXplKHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gKiAvLyA9PiAyXG4gKlxuICogXy5zaXplKCdwZWJibGVzJyk7XG4gKiAvLyA9PiA3XG4gKi9cbmZ1bmN0aW9uIHNpemUoY29sbGVjdGlvbikge1xuICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKGlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pID8gc3RyaW5nU2l6ZShjb2xsZWN0aW9uKSA6IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICB9XG4gIHZhciB0YWcgPSBnZXRUYWcoY29sbGVjdGlvbik7XG4gIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICByZXR1cm4gY29sbGVjdGlvbi5zaXplO1xuICB9XG4gIHJldHVybiBiYXNlS2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2l6ZTtcbiIsInZhciBiYXNlRmxhdHRlbiA9IHJlcXVpcmUoJy4vX2Jhc2VGbGF0dGVuJyksXG4gICAgYmFzZU9yZGVyQnkgPSByZXF1aXJlKCcuL19iYXNlT3JkZXJCeScpLFxuICAgIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBpc0l0ZXJhdGVlQ2FsbCA9IHJlcXVpcmUoJy4vX2lzSXRlcmF0ZWVDYWxsJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiBlbGVtZW50cywgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgcmVzdWx0cyBvZlxuICogcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYSBjb2xsZWN0aW9uIHRocnUgZWFjaCBpdGVyYXRlZS4gVGhpcyBtZXRob2RcbiAqIHBlcmZvcm1zIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHByZXNlcnZlcyB0aGUgb3JpZ2luYWwgc29ydCBvcmRlciBvZlxuICogZXF1YWwgZWxlbWVudHMuIFRoZSBpdGVyYXRlZXMgYXJlIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBzb3J0ZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciB1c2VycyA9IFtcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogMzAgfSxcbiAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzQgfVxuICogXTtcbiAqXG4gKiBfLnNvcnRCeSh1c2VycywgW2Z1bmN0aW9uKG8pIHsgcmV0dXJuIG8udXNlcjsgfV0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCAzMF1dXG4gKlxuICogXy5zb3J0QnkodXNlcnMsIFsndXNlcicsICdhZ2UnXSk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNF0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCAzMF0sIFsnZnJlZCcsIDQ4XV1cbiAqL1xudmFyIHNvcnRCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlcykge1xuICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHZhciBsZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoO1xuICBpZiAobGVuZ3RoID4gMSAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBpdGVyYXRlZXNbMF0sIGl0ZXJhdGVlc1sxXSkpIHtcbiAgICBpdGVyYXRlZXMgPSBbXTtcbiAgfSBlbHNlIGlmIChsZW5ndGggPiAyICYmIGlzSXRlcmF0ZWVDYWxsKGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdLCBpdGVyYXRlZXNbMl0pKSB7XG4gICAgaXRlcmF0ZWVzID0gW2l0ZXJhdGVlc1swXV07XG4gIH1cbiAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuKGl0ZXJhdGVlcywgMSksIFtdKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNvcnRCeTtcbiIsIi8qKlxuICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBlbXB0eSBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMTMuMFxuICogQGNhdGVnb3J5IFV0aWxcbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IGFycmF5LlxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgYXJyYXlzID0gXy50aW1lcygyLCBfLnN0dWJBcnJheSk7XG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAqIC8vID0+IFtbXSwgW11dXG4gKlxuICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICogLy8gPT4gZmFsc2VcbiAqL1xuZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICByZXR1cm4gW107XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc3R1YkFycmF5O1xuIiwiLyoqXG4gKiBUaGlzIG1ldGhvZCByZXR1cm5zIGBmYWxzZWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjEzLjBcbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRpbWVzKDIsIF8uc3R1YkZhbHNlKTtcbiAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gKi9cbmZ1bmN0aW9uIHN0dWJGYWxzZSgpIHtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHN0dWJGYWxzZTtcbiIsInZhciB0b051bWJlciA9IHJlcXVpcmUoJy4vdG9OdW1iZXInKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICBNQVhfSU5URUdFUiA9IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4O1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBmaW5pdGUgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4xMi4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBudW1iZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9GaW5pdGUoMy4yKTtcbiAqIC8vID0+IDMuMlxuICpcbiAqIF8udG9GaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiA1ZS0zMjRcbiAqXG4gKiBfLnRvRmluaXRlKEluZmluaXR5KTtcbiAqIC8vID0+IDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4XG4gKlxuICogXy50b0Zpbml0ZSgnMy4yJyk7XG4gKiAvLyA9PiAzLjJcbiAqL1xuZnVuY3Rpb24gdG9GaW5pdGUodmFsdWUpIHtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMDtcbiAgfVxuICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgaWYgKHZhbHVlID09PSBJTkZJTklUWSB8fCB2YWx1ZSA9PT0gLUlORklOSVRZKSB7XG4gICAgdmFyIHNpZ24gPSAodmFsdWUgPCAwID8gLTEgOiAxKTtcbiAgICByZXR1cm4gc2lnbiAqIE1BWF9JTlRFR0VSO1xuICB9XG4gIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSA6IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9GaW5pdGU7XG4iLCJ2YXIgdG9GaW5pdGUgPSByZXF1aXJlKCcuL3RvRmluaXRlJyk7XG5cbi8qKlxuICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYFRvSW50ZWdlcmBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2ludGVnZXIpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8udG9JbnRlZ2VyKDMuMik7XG4gKiAvLyA9PiAzXG4gKlxuICogXy50b0ludGVnZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gKiAvLyA9PiAwXG4gKlxuICogXy50b0ludGVnZXIoSW5maW5pdHkpO1xuICogLy8gPT4gMS43OTc2OTMxMzQ4NjIzMTU3ZSszMDhcbiAqXG4gKiBfLnRvSW50ZWdlcignMy4yJyk7XG4gKiAvLyA9PiAzXG4gKi9cbmZ1bmN0aW9uIHRvSW50ZWdlcih2YWx1ZSkge1xuICB2YXIgcmVzdWx0ID0gdG9GaW5pdGUodmFsdWUpLFxuICAgICAgcmVtYWluZGVyID0gcmVzdWx0ICUgMTtcblxuICByZXR1cm4gcmVzdWx0ID09PSByZXN1bHQgPyAocmVtYWluZGVyID8gcmVzdWx0IC0gcmVtYWluZGVyIDogcmVzdWx0KSA6IDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9JbnRlZ2VyO1xuIiwidmFyIGJhc2VUcmltID0gcmVxdWlyZSgnLi9fYmFzZVRyaW0nKSxcbiAgICBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXNPYmplY3QnKSxcbiAgICBpc1N5bWJvbCA9IHJlcXVpcmUoJy4vaXNTeW1ib2wnKTtcblxuLyoqIFVzZWQgYXMgcmVmZXJlbmNlcyBmb3IgdmFyaW91cyBgTnVtYmVyYCBjb25zdGFudHMuICovXG52YXIgTkFOID0gMCAvIDA7XG5cbi8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JhZEhleCA9IC9eWy0rXTB4WzAtOWEtZl0rJC9pO1xuXG4vKiogVXNlZCB0byBkZXRlY3QgYmluYXJ5IHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuLyoqIFVzZWQgdG8gZGV0ZWN0IG9jdGFsIHN0cmluZyB2YWx1ZXMuICovXG52YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbnZhciBmcmVlUGFyc2VJbnQgPSBwYXJzZUludDtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbnVtYmVyLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvTnVtYmVyKDMuMik7XG4gKiAvLyA9PiAzLjJcbiAqXG4gKiBfLnRvTnVtYmVyKE51bWJlci5NSU5fVkFMVUUpO1xuICogLy8gPT4gNWUtMzI0XG4gKlxuICogXy50b051bWJlcihJbmZpbml0eSk7XG4gKiAvLyA9PiBJbmZpbml0eVxuICpcbiAqIF8udG9OdW1iZXIoJzMuMicpO1xuICogLy8gPT4gMy4yXG4gKi9cbmZ1bmN0aW9uIHRvTnVtYmVyKHZhbHVlKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgIHJldHVybiBOQU47XG4gIH1cbiAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICB2YWx1ZSA9IGlzT2JqZWN0KG90aGVyKSA/IChvdGhlciArICcnKSA6IG90aGVyO1xuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICt2YWx1ZTtcbiAgfVxuICB2YWx1ZSA9IGJhc2VUcmltKHZhbHVlKTtcbiAgdmFyIGlzQmluYXJ5ID0gcmVJc0JpbmFyeS50ZXN0KHZhbHVlKTtcbiAgcmV0dXJuIChpc0JpbmFyeSB8fCByZUlzT2N0YWwudGVzdCh2YWx1ZSkpXG4gICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgOiAocmVJc0JhZEhleC50ZXN0KHZhbHVlKSA/IE5BTiA6ICt2YWx1ZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9OdW1iZXI7XG4iLCJ2YXIgY29weU9iamVjdCA9IHJlcXVpcmUoJy4vX2NvcHlPYmplY3QnKSxcbiAgICBrZXlzSW4gPSByZXF1aXJlKCcuL2tleXNJbicpO1xuXG4vKipcbiAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAqIGtleWVkIHByb3BlcnRpZXMgb2YgYHZhbHVlYCB0byBvd24gcHJvcGVydGllcyBvZiB0aGUgcGxhaW4gb2JqZWN0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBMYW5nXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udmVydGVkIHBsYWluIG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDEgfSwgbmV3IEZvbyk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAqXG4gKiBfLmFzc2lnbih7ICdhJzogMSB9LCBfLnRvUGxhaW5PYmplY3QobmV3IEZvbykpO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAqL1xuZnVuY3Rpb24gdG9QbGFpbk9iamVjdCh2YWx1ZSkge1xuICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdG9QbGFpbk9iamVjdDtcbiIsInZhciBiYXNlVG9TdHJpbmcgPSByZXF1aXJlKCcuL19iYXNlVG9TdHJpbmcnKTtcblxuLyoqXG4gKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgc3RyaW5nLiBBbiBlbXB0eSBzdHJpbmcgaXMgcmV0dXJuZWQgZm9yIGBudWxsYFxuICogYW5kIGB1bmRlZmluZWRgIHZhbHVlcy4gVGhlIHNpZ24gb2YgYC0wYCBpcyBwcmVzZXJ2ZWQuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IExhbmdcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnRvU3RyaW5nKG51bGwpO1xuICogLy8gPT4gJydcbiAqXG4gKiBfLnRvU3RyaW5nKC0wKTtcbiAqIC8vID0+ICctMCdcbiAqXG4gKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAnMSwyLDMnXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBiYXNlVG9TdHJpbmcodmFsdWUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRvU3RyaW5nO1xuIiwidmFyIGFycmF5RWFjaCA9IHJlcXVpcmUoJy4vX2FycmF5RWFjaCcpLFxuICAgIGJhc2VDcmVhdGUgPSByZXF1aXJlKCcuL19iYXNlQ3JlYXRlJyksXG4gICAgYmFzZUZvck93biA9IHJlcXVpcmUoJy4vX2Jhc2VGb3JPd24nKSxcbiAgICBiYXNlSXRlcmF0ZWUgPSByZXF1aXJlKCcuL19iYXNlSXRlcmF0ZWUnKSxcbiAgICBnZXRQcm90b3R5cGUgPSByZXF1aXJlKCcuL19nZXRQcm90b3R5cGUnKSxcbiAgICBpc0FycmF5ID0gcmVxdWlyZSgnLi9pc0FycmF5JyksXG4gICAgaXNCdWZmZXIgPSByZXF1aXJlKCcuL2lzQnVmZmVyJyksXG4gICAgaXNGdW5jdGlvbiA9IHJlcXVpcmUoJy4vaXNGdW5jdGlvbicpLFxuICAgIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi9pc09iamVjdCcpLFxuICAgIGlzVHlwZWRBcnJheSA9IHJlcXVpcmUoJy4vaXNUeXBlZEFycmF5Jyk7XG5cbi8qKlxuICogQW4gYWx0ZXJuYXRpdmUgdG8gYF8ucmVkdWNlYDsgdGhpcyBtZXRob2QgdHJhbnNmb3JtcyBgb2JqZWN0YCB0byBhIG5ld1xuICogYGFjY3VtdWxhdG9yYCBvYmplY3Qgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBydW5uaW5nIGVhY2ggb2YgaXRzIG93blxuICogZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyB0aHJ1IGBpdGVyYXRlZWAsIHdpdGggZWFjaCBpbnZvY2F0aW9uXG4gKiBwb3RlbnRpYWxseSBtdXRhdGluZyB0aGUgYGFjY3VtdWxhdG9yYCBvYmplY3QuIElmIGBhY2N1bXVsYXRvcmAgaXMgbm90XG4gKiBwcm92aWRlZCwgYSBuZXcgb2JqZWN0IHdpdGggdGhlIHNhbWUgYFtbUHJvdG90eXBlXV1gIHdpbGwgYmUgdXNlZC4gVGhlXG4gKiBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggZm91ciBhcmd1bWVudHM6IChhY2N1bXVsYXRvciwgdmFsdWUsIGtleSwgb2JqZWN0KS5cbiAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDEuMy4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGN1c3RvbSBhY2N1bXVsYXRvciB2YWx1ZS5cbiAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy50cmFuc2Zvcm0oWzIsIDMsIDRdLCBmdW5jdGlvbihyZXN1bHQsIG4pIHtcbiAqICAgcmVzdWx0LnB1c2gobiAqPSBuKTtcbiAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gKiB9LCBbXSk7XG4gKiAvLyA9PiBbNCwgOV1cbiAqXG4gKiBfLnRyYW5zZm9ybSh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfSwgZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gKiB9LCB7fSk7XG4gKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybShvYmplY3QsIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICB2YXIgaXNBcnIgPSBpc0FycmF5KG9iamVjdCksXG4gICAgICBpc0Fyckxpa2UgPSBpc0FyciB8fCBpc0J1ZmZlcihvYmplY3QpIHx8IGlzVHlwZWRBcnJheShvYmplY3QpO1xuXG4gIGl0ZXJhdGVlID0gYmFzZUl0ZXJhdGVlKGl0ZXJhdGVlLCA0KTtcbiAgaWYgKGFjY3VtdWxhdG9yID09IG51bGwpIHtcbiAgICB2YXIgQ3RvciA9IG9iamVjdCAmJiBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgaWYgKGlzQXJyTGlrZSkge1xuICAgICAgYWNjdW11bGF0b3IgPSBpc0FyciA/IG5ldyBDdG9yIDogW107XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaXNGdW5jdGlvbihDdG9yKSA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpIDoge307XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgYWNjdW11bGF0b3IgPSB7fTtcbiAgICB9XG4gIH1cbiAgKGlzQXJyTGlrZSA/IGFycmF5RWFjaCA6IGJhc2VGb3JPd24pKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICByZXR1cm4gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgb2JqZWN0KTtcbiAgfSk7XG4gIHJldHVybiBhY2N1bXVsYXRvcjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0cmFuc2Zvcm07XG4iLCJ2YXIgYmFzZUZsYXR0ZW4gPSByZXF1aXJlKCcuL19iYXNlRmxhdHRlbicpLFxuICAgIGJhc2VSZXN0ID0gcmVxdWlyZSgnLi9fYmFzZVJlc3QnKSxcbiAgICBiYXNlVW5pcSA9IHJlcXVpcmUoJy4vX2Jhc2VVbmlxJyksXG4gICAgaXNBcnJheUxpa2VPYmplY3QgPSByZXF1aXJlKCcuL2lzQXJyYXlMaWtlT2JqZWN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB1bmlxdWUgdmFsdWVzLCBpbiBvcmRlciwgZnJvbSBhbGwgZ2l2ZW4gYXJyYXlzIHVzaW5nXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tYmluZWQgdmFsdWVzLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnVuaW9uKFsyXSwgWzEsIDJdKTtcbiAqIC8vID0+IFsyLCAxXVxuICovXG52YXIgdW5pb24gPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKGFycmF5cywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVuaW9uO1xuIiwidmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi90b1N0cmluZycpO1xuXG4vKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzLiAqL1xudmFyIGlkQ291bnRlciA9IDA7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgdW5pcXVlIElELiBJZiBgcHJlZml4YCBpcyBnaXZlbiwgdGhlIElEIGlzIGFwcGVuZGVkIHRvIGl0LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBVdGlsXG4gKiBAcGFyYW0ge3N0cmluZ30gW3ByZWZpeD0nJ10gVGhlIHZhbHVlIHRvIHByZWZpeCB0aGUgSUQgd2l0aC5cbiAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuaXF1ZSBJRC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51bmlxdWVJZCgnY29udGFjdF8nKTtcbiAqIC8vID0+ICdjb250YWN0XzEwNCdcbiAqXG4gKiBfLnVuaXF1ZUlkKCk7XG4gKiAvLyA9PiAnMTA1J1xuICovXG5mdW5jdGlvbiB1bmlxdWVJZChwcmVmaXgpIHtcbiAgdmFyIGlkID0gKytpZENvdW50ZXI7XG4gIHJldHVybiB0b1N0cmluZyhwcmVmaXgpICsgaWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pcXVlSWQ7XG4iLCJ2YXIgYmFzZVZhbHVlcyA9IHJlcXVpcmUoJy4vX2Jhc2VWYWx1ZXMnKSxcbiAgICBrZXlzID0gcmVxdWlyZSgnLi9rZXlzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBtZW1iZXJPZiBfXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gRm9vKCkge1xuICogICB0aGlzLmEgPSAxO1xuICogICB0aGlzLmIgPSAyO1xuICogfVxuICpcbiAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gKlxuICogXy52YWx1ZXMobmV3IEZvbyk7XG4gKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAqXG4gKiBfLnZhbHVlcygnaGknKTtcbiAqIC8vID0+IFsnaCcsICdpJ11cbiAqL1xuZnVuY3Rpb24gdmFsdWVzKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbHVlcztcbiIsInZhciBhc3NpZ25WYWx1ZSA9IHJlcXVpcmUoJy4vX2Fzc2lnblZhbHVlJyksXG4gICAgYmFzZVppcE9iamVjdCA9IHJlcXVpcmUoJy4vX2Jhc2VaaXBPYmplY3QnKTtcblxuLyoqXG4gKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZyb21QYWlyc2AgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyB0d28gYXJyYXlzLFxuICogb25lIG9mIHByb3BlcnR5IGlkZW50aWZpZXJzIGFuZCBvbmUgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjQuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBbcHJvcHM9W11dIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXM9W11dIFRoZSBwcm9wZXJ0eSB2YWx1ZXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnppcE9iamVjdChbJ2EnLCAnYiddLCBbMSwgMl0pO1xuICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gKi9cbmZ1bmN0aW9uIHppcE9iamVjdChwcm9wcywgdmFsdWVzKSB7XG4gIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMgfHwgW10sIGFzc2lnblZhbHVlKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB6aXBPYmplY3Q7XG4iLCJpbXBvcnQgeyBpc0FueUFycmF5IH0gZnJvbSAnaXMtYW55LWFycmF5JztcblxuZnVuY3Rpb24gbWF4KGlucHV0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICBpZiAoIWlzQW55QXJyYXkoaW5wdXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5wdXQgbXVzdCBiZSBhbiBhcnJheScpO1xuICB9XG5cbiAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lucHV0IG11c3Qgbm90IGJlIGVtcHR5Jyk7XG4gIH1cblxuICB2YXIgX29wdGlvbnMkZnJvbUluZGV4ID0gb3B0aW9ucy5mcm9tSW5kZXgsXG4gICAgICBmcm9tSW5kZXggPSBfb3B0aW9ucyRmcm9tSW5kZXggPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRmcm9tSW5kZXgsXG4gICAgICBfb3B0aW9ucyR0b0luZGV4ID0gb3B0aW9ucy50b0luZGV4LFxuICAgICAgdG9JbmRleCA9IF9vcHRpb25zJHRvSW5kZXggPT09IHZvaWQgMCA/IGlucHV0Lmxlbmd0aCA6IF9vcHRpb25zJHRvSW5kZXg7XG5cbiAgaWYgKGZyb21JbmRleCA8IDAgfHwgZnJvbUluZGV4ID49IGlucHV0Lmxlbmd0aCB8fCAhTnVtYmVyLmlzSW50ZWdlcihmcm9tSW5kZXgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmcm9tSW5kZXggbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgc21hbGxlciB0aGFuIGxlbmd0aCcpO1xuICB9XG5cbiAgaWYgKHRvSW5kZXggPD0gZnJvbUluZGV4IHx8IHRvSW5kZXggPiBpbnB1dC5sZW5ndGggfHwgIU51bWJlci5pc0ludGVnZXIodG9JbmRleCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvSW5kZXggbXVzdCBiZSBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBmcm9tSW5kZXggYW5kIGF0IG1vc3QgZXF1YWwgdG8gbGVuZ3RoJyk7XG4gIH1cblxuICB2YXIgbWF4VmFsdWUgPSBpbnB1dFtmcm9tSW5kZXhdO1xuXG4gIGZvciAodmFyIGkgPSBmcm9tSW5kZXggKyAxOyBpIDwgdG9JbmRleDsgaSsrKSB7XG4gICAgaWYgKGlucHV0W2ldID4gbWF4VmFsdWUpIG1heFZhbHVlID0gaW5wdXRbaV07XG4gIH1cblxuICByZXR1cm4gbWF4VmFsdWU7XG59XG5cbmV4cG9ydCB7IG1heCBhcyBkZWZhdWx0IH07XG4iLCJpbXBvcnQgeyBpc0FueUFycmF5IH0gZnJvbSAnaXMtYW55LWFycmF5JztcblxuZnVuY3Rpb24gbWluKGlucHV0KSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcblxuICBpZiAoIWlzQW55QXJyYXkoaW5wdXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5wdXQgbXVzdCBiZSBhbiBhcnJheScpO1xuICB9XG5cbiAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lucHV0IG11c3Qgbm90IGJlIGVtcHR5Jyk7XG4gIH1cblxuICB2YXIgX29wdGlvbnMkZnJvbUluZGV4ID0gb3B0aW9ucy5mcm9tSW5kZXgsXG4gICAgICBmcm9tSW5kZXggPSBfb3B0aW9ucyRmcm9tSW5kZXggPT09IHZvaWQgMCA/IDAgOiBfb3B0aW9ucyRmcm9tSW5kZXgsXG4gICAgICBfb3B0aW9ucyR0b0luZGV4ID0gb3B0aW9ucy50b0luZGV4LFxuICAgICAgdG9JbmRleCA9IF9vcHRpb25zJHRvSW5kZXggPT09IHZvaWQgMCA/IGlucHV0Lmxlbmd0aCA6IF9vcHRpb25zJHRvSW5kZXg7XG5cbiAgaWYgKGZyb21JbmRleCA8IDAgfHwgZnJvbUluZGV4ID49IGlucHV0Lmxlbmd0aCB8fCAhTnVtYmVyLmlzSW50ZWdlcihmcm9tSW5kZXgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdmcm9tSW5kZXggbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgc21hbGxlciB0aGFuIGxlbmd0aCcpO1xuICB9XG5cbiAgaWYgKHRvSW5kZXggPD0gZnJvbUluZGV4IHx8IHRvSW5kZXggPiBpbnB1dC5sZW5ndGggfHwgIU51bWJlci5pc0ludGVnZXIodG9JbmRleCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvSW5kZXggbXVzdCBiZSBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBmcm9tSW5kZXggYW5kIGF0IG1vc3QgZXF1YWwgdG8gbGVuZ3RoJyk7XG4gIH1cblxuICB2YXIgbWluVmFsdWUgPSBpbnB1dFtmcm9tSW5kZXhdO1xuXG4gIGZvciAodmFyIGkgPSBmcm9tSW5kZXggKyAxOyBpIDwgdG9JbmRleDsgaSsrKSB7XG4gICAgaWYgKGlucHV0W2ldIDwgbWluVmFsdWUpIG1pblZhbHVlID0gaW5wdXRbaV07XG4gIH1cblxuICByZXR1cm4gbWluVmFsdWU7XG59XG5cbmV4cG9ydCB7IG1pbiBhcyBkZWZhdWx0IH07XG4iLCJpbXBvcnQgeyBpc0FueUFycmF5IH0gZnJvbSAnaXMtYW55LWFycmF5JztcbmltcG9ydCBtYXggZnJvbSAnbWwtYXJyYXktbWF4JztcbmltcG9ydCBtaW4gZnJvbSAnbWwtYXJyYXktbWluJztcblxuZnVuY3Rpb24gcmVzY2FsZShpbnB1dCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgaWYgKCFpc0FueUFycmF5KGlucHV0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2lucHV0IG11c3QgYmUgYW4gYXJyYXknKTtcbiAgfSBlbHNlIGlmIChpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnB1dCBtdXN0IG5vdCBiZSBlbXB0eScpO1xuICB9XG5cbiAgdmFyIG91dHB1dDtcblxuICBpZiAob3B0aW9ucy5vdXRwdXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICghaXNBbnlBcnJheShvcHRpb25zLm91dHB1dCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ291dHB1dCBvcHRpb24gbXVzdCBiZSBhbiBhcnJheSBpZiBzcGVjaWZpZWQnKTtcbiAgICB9XG5cbiAgICBvdXRwdXQgPSBvcHRpb25zLm91dHB1dDtcbiAgfSBlbHNlIHtcbiAgICBvdXRwdXQgPSBuZXcgQXJyYXkoaW5wdXQubGVuZ3RoKTtcbiAgfVxuXG4gIHZhciBjdXJyZW50TWluID0gbWluKGlucHV0KTtcbiAgdmFyIGN1cnJlbnRNYXggPSBtYXgoaW5wdXQpO1xuXG4gIGlmIChjdXJyZW50TWluID09PSBjdXJyZW50TWF4KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ21pbmltdW0gYW5kIG1heGltdW0gaW5wdXQgdmFsdWVzIGFyZSBlcXVhbC4gQ2Fubm90IHJlc2NhbGUgYSBjb25zdGFudCBhcnJheScpO1xuICB9XG5cbiAgdmFyIF9vcHRpb25zJG1pbiA9IG9wdGlvbnMubWluLFxuICAgICAgbWluVmFsdWUgPSBfb3B0aW9ucyRtaW4gPT09IHZvaWQgMCA/IG9wdGlvbnMuYXV0b01pbk1heCA/IGN1cnJlbnRNaW4gOiAwIDogX29wdGlvbnMkbWluLFxuICAgICAgX29wdGlvbnMkbWF4ID0gb3B0aW9ucy5tYXgsXG4gICAgICBtYXhWYWx1ZSA9IF9vcHRpb25zJG1heCA9PT0gdm9pZCAwID8gb3B0aW9ucy5hdXRvTWluTWF4ID8gY3VycmVudE1heCA6IDEgOiBfb3B0aW9ucyRtYXg7XG5cbiAgaWYgKG1pblZhbHVlID49IG1heFZhbHVlKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ21pbiBvcHRpb24gbXVzdCBiZSBzbWFsbGVyIHRoYW4gbWF4IG9wdGlvbicpO1xuICB9XG5cbiAgdmFyIGZhY3RvciA9IChtYXhWYWx1ZSAtIG1pblZhbHVlKSAvIChjdXJyZW50TWF4IC0gY3VycmVudE1pbik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFtpXSA9IChpbnB1dFtpXSAtIGN1cnJlbnRNaW4pICogZmFjdG9yICsgbWluVmFsdWU7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5leHBvcnQgeyByZXNjYWxlIGFzIGRlZmF1bHQgfTtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGlzQW55QXJyYXkgPSByZXF1aXJlKCdpcy1hbnktYXJyYXknKTtcbnZhciByZXNjYWxlID0gcmVxdWlyZSgnbWwtYXJyYXktcmVzY2FsZScpO1xuXG5jb25zdCBpbmRlbnQgPSAnICcucmVwZWF0KDIpO1xuY29uc3QgaW5kZW50RGF0YSA9ICcgJy5yZXBlYXQoNCk7XG5cbi8qKlxuICogQHRoaXMge01hdHJpeH1cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGluc3BlY3RNYXRyaXgoKSB7XG4gIHJldHVybiBpbnNwZWN0TWF0cml4V2l0aE9wdGlvbnModGhpcyk7XG59XG5cbmZ1bmN0aW9uIGluc3BlY3RNYXRyaXhXaXRoT3B0aW9ucyhtYXRyaXgsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgbWF4Um93cyA9IDE1LFxuICAgIG1heENvbHVtbnMgPSAxMCxcbiAgICBtYXhOdW1TaXplID0gOCxcbiAgICBwYWRNaW51cyA9ICdhdXRvJyxcbiAgfSA9IG9wdGlvbnM7XG4gIHJldHVybiBgJHttYXRyaXguY29uc3RydWN0b3IubmFtZX0ge1xuJHtpbmRlbnR9W1xuJHtpbmRlbnREYXRhfSR7aW5zcGVjdERhdGEobWF0cml4LCBtYXhSb3dzLCBtYXhDb2x1bW5zLCBtYXhOdW1TaXplLCBwYWRNaW51cyl9XG4ke2luZGVudH1dXG4ke2luZGVudH1yb3dzOiAke21hdHJpeC5yb3dzfVxuJHtpbmRlbnR9Y29sdW1uczogJHttYXRyaXguY29sdW1uc31cbn1gO1xufVxuXG5mdW5jdGlvbiBpbnNwZWN0RGF0YShtYXRyaXgsIG1heFJvd3MsIG1heENvbHVtbnMsIG1heE51bVNpemUsIHBhZE1pbnVzKSB7XG4gIGNvbnN0IHsgcm93cywgY29sdW1ucyB9ID0gbWF0cml4O1xuICBjb25zdCBtYXhJID0gTWF0aC5taW4ocm93cywgbWF4Um93cyk7XG4gIGNvbnN0IG1heEogPSBNYXRoLm1pbihjb2x1bW5zLCBtYXhDb2x1bW5zKTtcbiAgY29uc3QgcmVzdWx0ID0gW107XG5cbiAgaWYgKHBhZE1pbnVzID09PSAnYXV0bycpIHtcbiAgICBwYWRNaW51cyA9IGZhbHNlO1xuICAgIGxvb3A6IGZvciAobGV0IGkgPSAwOyBpIDwgbWF4STsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1heEo7IGorKykge1xuICAgICAgICBpZiAobWF0cml4LmdldChpLCBqKSA8IDApIHtcbiAgICAgICAgICBwYWRNaW51cyA9IHRydWU7XG4gICAgICAgICAgYnJlYWsgbG9vcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4STsgaSsrKSB7XG4gICAgbGV0IGxpbmUgPSBbXTtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1heEo7IGorKykge1xuICAgICAgbGluZS5wdXNoKGZvcm1hdE51bWJlcihtYXRyaXguZ2V0KGksIGopLCBtYXhOdW1TaXplLCBwYWRNaW51cykpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChgJHtsaW5lLmpvaW4oJyAnKX1gKTtcbiAgfVxuICBpZiAobWF4SiAhPT0gY29sdW1ucykge1xuICAgIHJlc3VsdFtyZXN1bHQubGVuZ3RoIC0gMV0gKz0gYCAuLi4gJHtjb2x1bW5zIC0gbWF4Q29sdW1uc30gbW9yZSBjb2x1bW5zYDtcbiAgfVxuICBpZiAobWF4SSAhPT0gcm93cykge1xuICAgIHJlc3VsdC5wdXNoKGAuLi4gJHtyb3dzIC0gbWF4Um93c30gbW9yZSByb3dzYCk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdC5qb2luKGBcXG4ke2luZGVudERhdGF9YCk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcihudW0sIG1heE51bVNpemUsIHBhZE1pbnVzKSB7XG4gIHJldHVybiAoXG4gICAgbnVtID49IDAgJiYgcGFkTWludXNcbiAgICAgID8gYCAke2Zvcm1hdE51bWJlcjIobnVtLCBtYXhOdW1TaXplIC0gMSl9YFxuICAgICAgOiBmb3JtYXROdW1iZXIyKG51bSwgbWF4TnVtU2l6ZSlcbiAgKS5wYWRFbmQobWF4TnVtU2l6ZSk7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE51bWJlcjIobnVtLCBsZW4pIHtcbiAgLy8gc21hbGwubGVuZ3RoIG51bWJlcnMgc2hvdWxkIGJlIGFzIGlzXG4gIGxldCBzdHIgPSBudW0udG9TdHJpbmcoKTtcbiAgaWYgKHN0ci5sZW5ndGggPD0gbGVuKSByZXR1cm4gc3RyO1xuXG4gIC8vICg3KScwLjAwMTIzJyBpcyBiZXR0ZXIgdGhlbiAoNyknMS4yM2UtMidcbiAgLy8gKDgpJzAuMDAwMTIzJyBpcyB3b3JzZSB0aGVuICg3KScxLjIzZS0zJyxcbiAgbGV0IGZpeCA9IG51bS50b0ZpeGVkKGxlbik7XG4gIGlmIChmaXgubGVuZ3RoID4gbGVuKSB7XG4gICAgZml4ID0gbnVtLnRvRml4ZWQoTWF0aC5tYXgoMCwgbGVuIC0gKGZpeC5sZW5ndGggLSBsZW4pKSk7XG4gIH1cbiAgaWYgKFxuICAgIGZpeC5sZW5ndGggPD0gbGVuICYmXG4gICAgIWZpeC5zdGFydHNXaXRoKCcwLjAwMCcpICYmXG4gICAgIWZpeC5zdGFydHNXaXRoKCctMC4wMDAnKVxuICApIHtcbiAgICByZXR1cm4gZml4O1xuICB9XG5cbiAgLy8gd2VsbCwgaWYgaXQncyBzdGlsbCB0b28gbG9uZyB0aGUgdXNlciBzaG91bGQndmUgdXNlZCBsb25nZXIgbnVtYmVyc1xuICBsZXQgZXhwID0gbnVtLnRvRXhwb25lbnRpYWwobGVuKTtcbiAgaWYgKGV4cC5sZW5ndGggPiBsZW4pIHtcbiAgICBleHAgPSBudW0udG9FeHBvbmVudGlhbChNYXRoLm1heCgwLCBsZW4gLSAoZXhwLmxlbmd0aCAtIGxlbikpKTtcbiAgfVxuICByZXR1cm4gZXhwLnNsaWNlKDApO1xufVxuXG5mdW5jdGlvbiBpbnN0YWxsTWF0aE9wZXJhdGlvbnMoQWJzdHJhY3RNYXRyaXgsIE1hdHJpeCkge1xuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHJldHVybiB0aGlzLmFkZFModmFsdWUpO1xuICAgIHJldHVybiB0aGlzLmFkZE0odmFsdWUpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5hZGRTID0gZnVuY3Rpb24gYWRkUyh2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgdGhpcy5nZXQoaSwgaikgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5hZGRNID0gZnVuY3Rpb24gYWRkTShtYXRyaXgpIHtcbiAgICBtYXRyaXggPSBNYXRyaXguY2hlY2tNYXRyaXgobWF0cml4KTtcbiAgICBpZiAodGhpcy5yb3dzICE9PSBtYXRyaXgucm93cyB8fFxuICAgICAgdGhpcy5jb2x1bW5zICE9PSBtYXRyaXguY29sdW1ucykge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCcpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopICsgbWF0cml4LmdldChpLCBqKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LmFkZCA9IGZ1bmN0aW9uIGFkZChtYXRyaXgsIHZhbHVlKSB7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXguYWRkKHZhbHVlKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHJldHVybiB0aGlzLnN1YlModmFsdWUpO1xuICAgIHJldHVybiB0aGlzLnN1Yk0odmFsdWUpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5zdWJTID0gZnVuY3Rpb24gc3ViUyh2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgdGhpcy5nZXQoaSwgaikgLSB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5zdWJNID0gZnVuY3Rpb24gc3ViTShtYXRyaXgpIHtcbiAgICBtYXRyaXggPSBNYXRyaXguY2hlY2tNYXRyaXgobWF0cml4KTtcbiAgICBpZiAodGhpcy5yb3dzICE9PSBtYXRyaXgucm93cyB8fFxuICAgICAgdGhpcy5jb2x1bW5zICE9PSBtYXRyaXguY29sdW1ucykge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCcpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopIC0gbWF0cml4LmdldChpLCBqKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnN1YiA9IGZ1bmN0aW9uIHN1YihtYXRyaXgsIHZhbHVlKSB7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXguc3ViKHZhbHVlKTtcbiAgfTtcbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLnN1YnRyYWN0ID0gQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLnN1YjtcbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLnN1YnRyYWN0UyA9IEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5zdWJTO1xuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuc3VidHJhY3RNID0gQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLnN1Yk07XG4gIEFic3RyYWN0TWF0cml4LnN1YnRyYWN0ID0gQWJzdHJhY3RNYXRyaXguc3ViO1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgcmV0dXJuIHRoaXMubXVsUyh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMubXVsTSh2YWx1ZSk7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLm11bFMgPSBmdW5jdGlvbiBtdWxTKHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSAqIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLm11bE0gPSBmdW5jdGlvbiBtdWxNKG1hdHJpeCkge1xuICAgIG1hdHJpeCA9IE1hdHJpeC5jaGVja01hdHJpeChtYXRyaXgpO1xuICAgIGlmICh0aGlzLnJvd3MgIT09IG1hdHJpeC5yb3dzIHx8XG4gICAgICB0aGlzLmNvbHVtbnMgIT09IG1hdHJpeC5jb2x1bW5zKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsJyk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgdGhpcy5nZXQoaSwgaikgKiBtYXRyaXguZ2V0KGksIGopKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgubXVsID0gZnVuY3Rpb24gbXVsKG1hdHJpeCwgdmFsdWUpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5tdWwodmFsdWUpO1xuICB9O1xuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUubXVsdGlwbHkgPSBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUubXVsO1xuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUubXVsdGlwbHlTID0gQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLm11bFM7XG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5tdWx0aXBseU0gPSBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUubXVsTTtcbiAgQWJzdHJhY3RNYXRyaXgubXVsdGlwbHkgPSBBYnN0cmFjdE1hdHJpeC5tdWw7XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uIGRpdih2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSByZXR1cm4gdGhpcy5kaXZTKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5kaXZNKHZhbHVlKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuZGl2UyA9IGZ1bmN0aW9uIGRpdlModmFsdWUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopIC8gdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuZGl2TSA9IGZ1bmN0aW9uIGRpdk0obWF0cml4KSB7XG4gICAgbWF0cml4ID0gTWF0cml4LmNoZWNrTWF0cml4KG1hdHJpeCk7XG4gICAgaWYgKHRoaXMucm93cyAhPT0gbWF0cml4LnJvd3MgfHxcbiAgICAgIHRoaXMuY29sdW1ucyAhPT0gbWF0cml4LmNvbHVtbnMpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXRyaWNlcyBkaW1lbnNpb25zIG11c3QgYmUgZXF1YWwnKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSAvIG1hdHJpeC5nZXQoaSwgaikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5kaXYgPSBmdW5jdGlvbiBkaXYobWF0cml4LCB2YWx1ZSkge1xuICAgIGNvbnN0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgobWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4LmRpdih2YWx1ZSk7XG4gIH07XG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5kaXZpZGUgPSBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuZGl2O1xuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuZGl2aWRlUyA9IEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5kaXZTO1xuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuZGl2aWRlTSA9IEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5kaXZNO1xuICBBYnN0cmFjdE1hdHJpeC5kaXZpZGUgPSBBYnN0cmFjdE1hdHJpeC5kaXY7XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIG1vZCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSByZXR1cm4gdGhpcy5tb2RTKHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcy5tb2RNKHZhbHVlKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUubW9kUyA9IGZ1bmN0aW9uIG1vZFModmFsdWUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopICUgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUubW9kTSA9IGZ1bmN0aW9uIG1vZE0obWF0cml4KSB7XG4gICAgbWF0cml4ID0gTWF0cml4LmNoZWNrTWF0cml4KG1hdHJpeCk7XG4gICAgaWYgKHRoaXMucm93cyAhPT0gbWF0cml4LnJvd3MgfHxcbiAgICAgIHRoaXMuY29sdW1ucyAhPT0gbWF0cml4LmNvbHVtbnMpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXRyaWNlcyBkaW1lbnNpb25zIG11c3QgYmUgZXF1YWwnKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSAlIG1hdHJpeC5nZXQoaSwgaikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5tb2QgPSBmdW5jdGlvbiBtb2QobWF0cml4LCB2YWx1ZSkge1xuICAgIGNvbnN0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgobWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4Lm1vZCh2YWx1ZSk7XG4gIH07XG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5tb2R1bHVzID0gQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLm1vZDtcbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLm1vZHVsdXNTID0gQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLm1vZFM7XG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5tb2R1bHVzTSA9IEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5tb2RNO1xuICBBYnN0cmFjdE1hdHJpeC5tb2R1bHVzID0gQWJzdHJhY3RNYXRyaXgubW9kO1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgcmV0dXJuIHRoaXMuYW5kUyh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuYW5kTSh2YWx1ZSk7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLmFuZFMgPSBmdW5jdGlvbiBhbmRTKHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSAmIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLmFuZE0gPSBmdW5jdGlvbiBhbmRNKG1hdHJpeCkge1xuICAgIG1hdHJpeCA9IE1hdHJpeC5jaGVja01hdHJpeChtYXRyaXgpO1xuICAgIGlmICh0aGlzLnJvd3MgIT09IG1hdHJpeC5yb3dzIHx8XG4gICAgICB0aGlzLmNvbHVtbnMgIT09IG1hdHJpeC5jb2x1bW5zKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsJyk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgdGhpcy5nZXQoaSwgaikgJiBtYXRyaXguZ2V0KGksIGopKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXguYW5kID0gZnVuY3Rpb24gYW5kKG1hdHJpeCwgdmFsdWUpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5hbmQodmFsdWUpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIG9yKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHJldHVybiB0aGlzLm9yUyh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMub3JNKHZhbHVlKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUub3JTID0gZnVuY3Rpb24gb3JTKHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSB8IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLm9yTSA9IGZ1bmN0aW9uIG9yTShtYXRyaXgpIHtcbiAgICBtYXRyaXggPSBNYXRyaXguY2hlY2tNYXRyaXgobWF0cml4KTtcbiAgICBpZiAodGhpcy5yb3dzICE9PSBtYXRyaXgucm93cyB8fFxuICAgICAgdGhpcy5jb2x1bW5zICE9PSBtYXRyaXguY29sdW1ucykge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCcpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopIHwgbWF0cml4LmdldChpLCBqKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4Lm9yID0gZnVuY3Rpb24gb3IobWF0cml4LCB2YWx1ZSkge1xuICAgIGNvbnN0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgobWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4Lm9yKHZhbHVlKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHJldHVybiB0aGlzLnhvclModmFsdWUpO1xuICAgIHJldHVybiB0aGlzLnhvck0odmFsdWUpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS54b3JTID0gZnVuY3Rpb24geG9yUyh2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgdGhpcy5nZXQoaSwgaikgXiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS54b3JNID0gZnVuY3Rpb24geG9yTShtYXRyaXgpIHtcbiAgICBtYXRyaXggPSBNYXRyaXguY2hlY2tNYXRyaXgobWF0cml4KTtcbiAgICBpZiAodGhpcy5yb3dzICE9PSBtYXRyaXgucm93cyB8fFxuICAgICAgdGhpcy5jb2x1bW5zICE9PSBtYXRyaXguY29sdW1ucykge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ01hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCcpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopIF4gbWF0cml4LmdldChpLCBqKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnhvciA9IGZ1bmN0aW9uIHhvcihtYXRyaXgsIHZhbHVlKSB7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXgueG9yKHZhbHVlKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUubGVmdFNoaWZ0ID0gZnVuY3Rpb24gbGVmdFNoaWZ0KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHJldHVybiB0aGlzLmxlZnRTaGlmdFModmFsdWUpO1xuICAgIHJldHVybiB0aGlzLmxlZnRTaGlmdE0odmFsdWUpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5sZWZ0U2hpZnRTID0gZnVuY3Rpb24gbGVmdFNoaWZ0Uyh2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgdGhpcy5nZXQoaSwgaikgPDwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUubGVmdFNoaWZ0TSA9IGZ1bmN0aW9uIGxlZnRTaGlmdE0obWF0cml4KSB7XG4gICAgbWF0cml4ID0gTWF0cml4LmNoZWNrTWF0cml4KG1hdHJpeCk7XG4gICAgaWYgKHRoaXMucm93cyAhPT0gbWF0cml4LnJvd3MgfHxcbiAgICAgIHRoaXMuY29sdW1ucyAhPT0gbWF0cml4LmNvbHVtbnMpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXRyaWNlcyBkaW1lbnNpb25zIG11c3QgYmUgZXF1YWwnKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSA8PCBtYXRyaXguZ2V0KGksIGopKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgubGVmdFNoaWZ0ID0gZnVuY3Rpb24gbGVmdFNoaWZ0KG1hdHJpeCwgdmFsdWUpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5sZWZ0U2hpZnQodmFsdWUpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5zaWduUHJvcGFnYXRpbmdSaWdodFNoaWZ0ID0gZnVuY3Rpb24gc2lnblByb3BhZ2F0aW5nUmlnaHRTaGlmdCh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSByZXR1cm4gdGhpcy5zaWduUHJvcGFnYXRpbmdSaWdodFNoaWZ0Uyh2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXMuc2lnblByb3BhZ2F0aW5nUmlnaHRTaGlmdE0odmFsdWUpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5zaWduUHJvcGFnYXRpbmdSaWdodFNoaWZ0UyA9IGZ1bmN0aW9uIHNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnRTKHZhbHVlKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSA+PiB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5zaWduUHJvcGFnYXRpbmdSaWdodFNoaWZ0TSA9IGZ1bmN0aW9uIHNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnRNKG1hdHJpeCkge1xuICAgIG1hdHJpeCA9IE1hdHJpeC5jaGVja01hdHJpeChtYXRyaXgpO1xuICAgIGlmICh0aGlzLnJvd3MgIT09IG1hdHJpeC5yb3dzIHx8XG4gICAgICB0aGlzLmNvbHVtbnMgIT09IG1hdHJpeC5jb2x1bW5zKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsJyk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgdGhpcy5nZXQoaSwgaikgPj4gbWF0cml4LmdldChpLCBqKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnQgPSBmdW5jdGlvbiBzaWduUHJvcGFnYXRpbmdSaWdodFNoaWZ0KG1hdHJpeCwgdmFsdWUpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5zaWduUHJvcGFnYXRpbmdSaWdodFNoaWZ0KHZhbHVlKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUucmlnaHRTaGlmdCA9IGZ1bmN0aW9uIHJpZ2h0U2hpZnQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykgcmV0dXJuIHRoaXMucmlnaHRTaGlmdFModmFsdWUpO1xuICAgIHJldHVybiB0aGlzLnJpZ2h0U2hpZnRNKHZhbHVlKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUucmlnaHRTaGlmdFMgPSBmdW5jdGlvbiByaWdodFNoaWZ0Uyh2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgdGhpcy5nZXQoaSwgaikgPj4+IHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLnJpZ2h0U2hpZnRNID0gZnVuY3Rpb24gcmlnaHRTaGlmdE0obWF0cml4KSB7XG4gICAgbWF0cml4ID0gTWF0cml4LmNoZWNrTWF0cml4KG1hdHJpeCk7XG4gICAgaWYgKHRoaXMucm93cyAhPT0gbWF0cml4LnJvd3MgfHxcbiAgICAgIHRoaXMuY29sdW1ucyAhPT0gbWF0cml4LmNvbHVtbnMpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXRyaWNlcyBkaW1lbnNpb25zIG11c3QgYmUgZXF1YWwnKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSA+Pj4gbWF0cml4LmdldChpLCBqKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnJpZ2h0U2hpZnQgPSBmdW5jdGlvbiByaWdodFNoaWZ0KG1hdHJpeCwgdmFsdWUpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5yaWdodFNoaWZ0KHZhbHVlKTtcbiAgfTtcbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLnplcm9GaWxsUmlnaHRTaGlmdCA9IEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5yaWdodFNoaWZ0O1xuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuemVyb0ZpbGxSaWdodFNoaWZ0UyA9IEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5yaWdodFNoaWZ0UztcbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLnplcm9GaWxsUmlnaHRTaGlmdE0gPSBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUucmlnaHRTaGlmdE07XG4gIEFic3RyYWN0TWF0cml4Lnplcm9GaWxsUmlnaHRTaGlmdCA9IEFic3RyYWN0TWF0cml4LnJpZ2h0U2hpZnQ7XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLm5vdCA9IGZ1bmN0aW9uIG5vdCgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIH4odGhpcy5nZXQoaSwgaikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgubm90ID0gZnVuY3Rpb24gbm90KG1hdHJpeCkge1xuICAgIGNvbnN0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgobWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4Lm5vdCgpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5hYnMgPSBmdW5jdGlvbiBhYnMoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCBNYXRoLmFicyh0aGlzLmdldChpLCBqKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5hYnMgPSBmdW5jdGlvbiBhYnMobWF0cml4KSB7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXguYWJzKCk7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLmFjb3MgPSBmdW5jdGlvbiBhY29zKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgTWF0aC5hY29zKHRoaXMuZ2V0KGksIGopKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LmFjb3MgPSBmdW5jdGlvbiBhY29zKG1hdHJpeCkge1xuICAgIGNvbnN0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgobWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4LmFjb3MoKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuYWNvc2ggPSBmdW5jdGlvbiBhY29zaCgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIE1hdGguYWNvc2godGhpcy5nZXQoaSwgaikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXguYWNvc2ggPSBmdW5jdGlvbiBhY29zaChtYXRyaXgpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5hY29zaCgpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5hc2luID0gZnVuY3Rpb24gYXNpbigpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIE1hdGguYXNpbih0aGlzLmdldChpLCBqKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5hc2luID0gZnVuY3Rpb24gYXNpbihtYXRyaXgpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5hc2luKCk7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLmFzaW5oID0gZnVuY3Rpb24gYXNpbmgoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCBNYXRoLmFzaW5oKHRoaXMuZ2V0KGksIGopKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LmFzaW5oID0gZnVuY3Rpb24gYXNpbmgobWF0cml4KSB7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXguYXNpbmgoKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuYXRhbiA9IGZ1bmN0aW9uIGF0YW4oKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCBNYXRoLmF0YW4odGhpcy5nZXQoaSwgaikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXguYXRhbiA9IGZ1bmN0aW9uIGF0YW4obWF0cml4KSB7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXguYXRhbigpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5hdGFuaCA9IGZ1bmN0aW9uIGF0YW5oKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgTWF0aC5hdGFuaCh0aGlzLmdldChpLCBqKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5hdGFuaCA9IGZ1bmN0aW9uIGF0YW5oKG1hdHJpeCkge1xuICAgIGNvbnN0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgobWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4LmF0YW5oKCk7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLmNicnQgPSBmdW5jdGlvbiBjYnJ0KCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgTWF0aC5jYnJ0KHRoaXMuZ2V0KGksIGopKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LmNicnQgPSBmdW5jdGlvbiBjYnJ0KG1hdHJpeCkge1xuICAgIGNvbnN0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgobWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4LmNicnQoKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuY2VpbCA9IGZ1bmN0aW9uIGNlaWwoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCBNYXRoLmNlaWwodGhpcy5nZXQoaSwgaikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXguY2VpbCA9IGZ1bmN0aW9uIGNlaWwobWF0cml4KSB7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXguY2VpbCgpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5jbHozMiA9IGZ1bmN0aW9uIGNsejMyKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgTWF0aC5jbHozMih0aGlzLmdldChpLCBqKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5jbHozMiA9IGZ1bmN0aW9uIGNsejMyKG1hdHJpeCkge1xuICAgIGNvbnN0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgobWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4LmNsejMyKCk7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLmNvcyA9IGZ1bmN0aW9uIGNvcygpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIE1hdGguY29zKHRoaXMuZ2V0KGksIGopKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LmNvcyA9IGZ1bmN0aW9uIGNvcyhtYXRyaXgpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5jb3MoKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuY29zaCA9IGZ1bmN0aW9uIGNvc2goKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCBNYXRoLmNvc2godGhpcy5nZXQoaSwgaikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXguY29zaCA9IGZ1bmN0aW9uIGNvc2gobWF0cml4KSB7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXguY29zaCgpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5leHAgPSBmdW5jdGlvbiBleHAoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCBNYXRoLmV4cCh0aGlzLmdldChpLCBqKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5leHAgPSBmdW5jdGlvbiBleHAobWF0cml4KSB7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXguZXhwKCk7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLmV4cG0xID0gZnVuY3Rpb24gZXhwbTEoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCBNYXRoLmV4cG0xKHRoaXMuZ2V0KGksIGopKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LmV4cG0xID0gZnVuY3Rpb24gZXhwbTEobWF0cml4KSB7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXguZXhwbTEoKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuZmxvb3IgPSBmdW5jdGlvbiBmbG9vcigpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIE1hdGguZmxvb3IodGhpcy5nZXQoaSwgaikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXguZmxvb3IgPSBmdW5jdGlvbiBmbG9vcihtYXRyaXgpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5mbG9vcigpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5mcm91bmQgPSBmdW5jdGlvbiBmcm91bmQoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCBNYXRoLmZyb3VuZCh0aGlzLmdldChpLCBqKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5mcm91bmQgPSBmdW5jdGlvbiBmcm91bmQobWF0cml4KSB7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXguZnJvdW5kKCk7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLmxvZyA9IGZ1bmN0aW9uIGxvZygpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIE1hdGgubG9nKHRoaXMuZ2V0KGksIGopKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LmxvZyA9IGZ1bmN0aW9uIGxvZyhtYXRyaXgpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5sb2coKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUubG9nMXAgPSBmdW5jdGlvbiBsb2cxcCgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIE1hdGgubG9nMXAodGhpcy5nZXQoaSwgaikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgubG9nMXAgPSBmdW5jdGlvbiBsb2cxcChtYXRyaXgpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5sb2cxcCgpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5sb2cxMCA9IGZ1bmN0aW9uIGxvZzEwKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgTWF0aC5sb2cxMCh0aGlzLmdldChpLCBqKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5sb2cxMCA9IGZ1bmN0aW9uIGxvZzEwKG1hdHJpeCkge1xuICAgIGNvbnN0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgobWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4LmxvZzEwKCk7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLmxvZzIgPSBmdW5jdGlvbiBsb2cyKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgTWF0aC5sb2cyKHRoaXMuZ2V0KGksIGopKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LmxvZzIgPSBmdW5jdGlvbiBsb2cyKG1hdHJpeCkge1xuICAgIGNvbnN0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgobWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4LmxvZzIoKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUucm91bmQgPSBmdW5jdGlvbiByb3VuZCgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIE1hdGgucm91bmQodGhpcy5nZXQoaSwgaikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucm91bmQgPSBmdW5jdGlvbiByb3VuZChtYXRyaXgpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5yb3VuZCgpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbigpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIE1hdGguc2lnbih0aGlzLmdldChpLCBqKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5zaWduID0gZnVuY3Rpb24gc2lnbihtYXRyaXgpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5zaWduKCk7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLnNpbiA9IGZ1bmN0aW9uIHNpbigpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIE1hdGguc2luKHRoaXMuZ2V0KGksIGopKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnNpbiA9IGZ1bmN0aW9uIHNpbihtYXRyaXgpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5zaW4oKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUuc2luaCA9IGZ1bmN0aW9uIHNpbmgoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCBNYXRoLnNpbmgodGhpcy5nZXQoaSwgaikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXguc2luaCA9IGZ1bmN0aW9uIHNpbmgobWF0cml4KSB7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXguc2luaCgpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24gc3FydCgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIE1hdGguc3FydCh0aGlzLmdldChpLCBqKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5zcXJ0ID0gZnVuY3Rpb24gc3FydChtYXRyaXgpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC5zcXJ0KCk7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLnRhbiA9IGZ1bmN0aW9uIHRhbigpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIE1hdGgudGFuKHRoaXMuZ2V0KGksIGopKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnRhbiA9IGZ1bmN0aW9uIHRhbihtYXRyaXgpIHtcbiAgICBjb25zdCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KG1hdHJpeCk7XG4gICAgcmV0dXJuIG5ld01hdHJpeC50YW4oKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUudGFuaCA9IGZ1bmN0aW9uIHRhbmgoKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCBNYXRoLnRhbmgodGhpcy5nZXQoaSwgaikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgudGFuaCA9IGZ1bmN0aW9uIHRhbmgobWF0cml4KSB7XG4gICAgY29uc3QgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChtYXRyaXgpO1xuICAgIHJldHVybiBuZXdNYXRyaXgudGFuaCgpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS50cnVuYyA9IGZ1bmN0aW9uIHRydW5jKCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgTWF0aC50cnVuYyh0aGlzLmdldChpLCBqKSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC50cnVuYyA9IGZ1bmN0aW9uIHRydW5jKG1hdHJpeCkge1xuICAgIGNvbnN0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgobWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4LnRydW5jKCk7XG4gIH07XG5cbiAgQWJzdHJhY3RNYXRyaXgucG93ID0gZnVuY3Rpb24gcG93KG1hdHJpeCwgYXJnMCkge1xuICAgIGNvbnN0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgobWF0cml4KTtcbiAgICByZXR1cm4gbmV3TWF0cml4LnBvdyhhcmcwKTtcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHJldHVybiB0aGlzLnBvd1ModmFsdWUpO1xuICAgIHJldHVybiB0aGlzLnBvd00odmFsdWUpO1xuICB9O1xuXG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5wb3dTID0gZnVuY3Rpb24gcG93Uyh2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgdGhpcy5nZXQoaSwgaikgKiogdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBBYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUucG93TSA9IGZ1bmN0aW9uIHBvd00obWF0cml4KSB7XG4gICAgbWF0cml4ID0gTWF0cml4LmNoZWNrTWF0cml4KG1hdHJpeCk7XG4gICAgaWYgKHRoaXMucm93cyAhPT0gbWF0cml4LnJvd3MgfHxcbiAgICAgIHRoaXMuY29sdW1ucyAhPT0gbWF0cml4LmNvbHVtbnMpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXRyaWNlcyBkaW1lbnNpb25zIG11c3QgYmUgZXF1YWwnKTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICB0aGlzLnNldChpLCBqLCB0aGlzLmdldChpLCBqKSAqKiBtYXRyaXguZ2V0KGksIGopKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIENoZWNrIHRoYXQgYSByb3cgaW5kZXggaXMgbm90IG91dCBvZiBib3VuZHNcbiAqIEBwYXJhbSB7TWF0cml4fSBtYXRyaXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtib29sZWFufSBbb3V0ZXJdXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUm93SW5kZXgobWF0cml4LCBpbmRleCwgb3V0ZXIpIHtcbiAgbGV0IG1heCA9IG91dGVyID8gbWF0cml4LnJvd3MgOiBtYXRyaXgucm93cyAtIDE7XG4gIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiBtYXgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignUm93IGluZGV4IG91dCBvZiByYW5nZScpO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIENoZWNrIHRoYXQgYSBjb2x1bW4gaW5kZXggaXMgbm90IG91dCBvZiBib3VuZHNcbiAqIEBwYXJhbSB7TWF0cml4fSBtYXRyaXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtib29sZWFufSBbb3V0ZXJdXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ29sdW1uSW5kZXgobWF0cml4LCBpbmRleCwgb3V0ZXIpIHtcbiAgbGV0IG1heCA9IG91dGVyID8gbWF0cml4LmNvbHVtbnMgOiBtYXRyaXguY29sdW1ucyAtIDE7XG4gIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPiBtYXgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ29sdW1uIGluZGV4IG91dCBvZiByYW5nZScpO1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqIENoZWNrIHRoYXQgdGhlIHByb3ZpZGVkIHZlY3RvciBpcyBhbiBhcnJheSB3aXRoIHRoZSByaWdodCBsZW5ndGhcbiAqIEBwYXJhbSB7TWF0cml4fSBtYXRyaXhcbiAqIEBwYXJhbSB7QXJyYXl8TWF0cml4fSB2ZWN0b3JcbiAqIEByZXR1cm4ge0FycmF5fVxuICogQHRocm93cyB7UmFuZ2VFcnJvcn1cbiAqL1xuZnVuY3Rpb24gY2hlY2tSb3dWZWN0b3IobWF0cml4LCB2ZWN0b3IpIHtcbiAgaWYgKHZlY3Rvci50bzFEQXJyYXkpIHtcbiAgICB2ZWN0b3IgPSB2ZWN0b3IudG8xREFycmF5KCk7XG4gIH1cbiAgaWYgKHZlY3Rvci5sZW5ndGggIT09IG1hdHJpeC5jb2x1bW5zKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICAndmVjdG9yIHNpemUgbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMnLFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIHZlY3Rvcjtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQ2hlY2sgdGhhdCB0aGUgcHJvdmlkZWQgdmVjdG9yIGlzIGFuIGFycmF5IHdpdGggdGhlIHJpZ2h0IGxlbmd0aFxuICogQHBhcmFtIHtNYXRyaXh9IG1hdHJpeFxuICogQHBhcmFtIHtBcnJheXxNYXRyaXh9IHZlY3RvclxuICogQHJldHVybiB7QXJyYXl9XG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfVxuICovXG5mdW5jdGlvbiBjaGVja0NvbHVtblZlY3RvcihtYXRyaXgsIHZlY3Rvcikge1xuICBpZiAodmVjdG9yLnRvMURBcnJheSkge1xuICAgIHZlY3RvciA9IHZlY3Rvci50bzFEQXJyYXkoKTtcbiAgfVxuICBpZiAodmVjdG9yLmxlbmd0aCAhPT0gbWF0cml4LnJvd3MpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndmVjdG9yIHNpemUgbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgbnVtYmVyIG9mIHJvd3MnKTtcbiAgfVxuICByZXR1cm4gdmVjdG9yO1xufVxuXG5mdW5jdGlvbiBjaGVja1Jvd0luZGljZXMobWF0cml4LCByb3dJbmRpY2VzKSB7XG4gIGlmICghaXNBbnlBcnJheS5pc0FueUFycmF5KHJvd0luZGljZXMpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncm93IGluZGljZXMgbXVzdCBiZSBhbiBhcnJheScpO1xuICB9XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHJvd0luZGljZXNbaV0gPCAwIHx8IHJvd0luZGljZXNbaV0gPj0gbWF0cml4LnJvd3MpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdyb3cgaW5kaWNlcyBhcmUgb3V0IG9mIHJhbmdlJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrQ29sdW1uSW5kaWNlcyhtYXRyaXgsIGNvbHVtbkluZGljZXMpIHtcbiAgaWYgKCFpc0FueUFycmF5LmlzQW55QXJyYXkoY29sdW1uSW5kaWNlcykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjb2x1bW4gaW5kaWNlcyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gIH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbHVtbkluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY29sdW1uSW5kaWNlc1tpXSA8IDAgfHwgY29sdW1uSW5kaWNlc1tpXSA+PSBtYXRyaXguY29sdW1ucykge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2NvbHVtbiBpbmRpY2VzIGFyZSBvdXQgb2YgcmFuZ2UnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tSYW5nZShtYXRyaXgsIHN0YXJ0Um93LCBlbmRSb3csIHN0YXJ0Q29sdW1uLCBlbmRDb2x1bW4pIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDUpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZXhwZWN0ZWQgNCBhcmd1bWVudHMnKTtcbiAgfVxuICBjaGVja051bWJlcignc3RhcnRSb3cnLCBzdGFydFJvdyk7XG4gIGNoZWNrTnVtYmVyKCdlbmRSb3cnLCBlbmRSb3cpO1xuICBjaGVja051bWJlcignc3RhcnRDb2x1bW4nLCBzdGFydENvbHVtbik7XG4gIGNoZWNrTnVtYmVyKCdlbmRDb2x1bW4nLCBlbmRDb2x1bW4pO1xuICBpZiAoXG4gICAgc3RhcnRSb3cgPiBlbmRSb3cgfHxcbiAgICBzdGFydENvbHVtbiA+IGVuZENvbHVtbiB8fFxuICAgIHN0YXJ0Um93IDwgMCB8fFxuICAgIHN0YXJ0Um93ID49IG1hdHJpeC5yb3dzIHx8XG4gICAgZW5kUm93IDwgMCB8fFxuICAgIGVuZFJvdyA+PSBtYXRyaXgucm93cyB8fFxuICAgIHN0YXJ0Q29sdW1uIDwgMCB8fFxuICAgIHN0YXJ0Q29sdW1uID49IG1hdHJpeC5jb2x1bW5zIHx8XG4gICAgZW5kQ29sdW1uIDwgMCB8fFxuICAgIGVuZENvbHVtbiA+PSBtYXRyaXguY29sdW1uc1xuICApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignU3VibWF0cml4IGluZGljZXMgYXJlIG91dCBvZiByYW5nZScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5ld0FycmF5KGxlbmd0aCwgdmFsdWUgPSAwKSB7XG4gIGxldCBhcnJheSA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgYXJyYXkucHVzaCh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5mdW5jdGlvbiBjaGVja051bWJlcihuYW1lLCB2YWx1ZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7bmFtZX0gbXVzdCBiZSBhIG51bWJlcmApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrTm9uRW1wdHkobWF0cml4KSB7XG4gIGlmIChtYXRyaXguaXNFbXB0eSgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbXB0eSBtYXRyaXggaGFzIG5vIGVsZW1lbnRzIHRvIGluZGV4Jyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3VtQnlSb3cobWF0cml4KSB7XG4gIGxldCBzdW0gPSBuZXdBcnJheShtYXRyaXgucm93cyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0cml4LnJvd3M7ICsraSkge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWF0cml4LmNvbHVtbnM7ICsraikge1xuICAgICAgc3VtW2ldICs9IG1hdHJpeC5nZXQoaSwgaik7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdW07XG59XG5cbmZ1bmN0aW9uIHN1bUJ5Q29sdW1uKG1hdHJpeCkge1xuICBsZXQgc3VtID0gbmV3QXJyYXkobWF0cml4LmNvbHVtbnMpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdHJpeC5yb3dzOyArK2kpIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hdHJpeC5jb2x1bW5zOyArK2opIHtcbiAgICAgIHN1bVtqXSArPSBtYXRyaXguZ2V0KGksIGopO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3VtO1xufVxuXG5mdW5jdGlvbiBzdW1BbGwobWF0cml4KSB7XG4gIGxldCB2ID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRyaXgucm93czsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRyaXguY29sdW1uczsgaisrKSB7XG4gICAgICB2ICs9IG1hdHJpeC5nZXQoaSwgaik7XG4gICAgfVxuICB9XG4gIHJldHVybiB2O1xufVxuXG5mdW5jdGlvbiBwcm9kdWN0QnlSb3cobWF0cml4KSB7XG4gIGxldCBzdW0gPSBuZXdBcnJheShtYXRyaXgucm93cywgMSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0cml4LnJvd3M7ICsraSkge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWF0cml4LmNvbHVtbnM7ICsraikge1xuICAgICAgc3VtW2ldICo9IG1hdHJpeC5nZXQoaSwgaik7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdW07XG59XG5cbmZ1bmN0aW9uIHByb2R1Y3RCeUNvbHVtbihtYXRyaXgpIHtcbiAgbGV0IHN1bSA9IG5ld0FycmF5KG1hdHJpeC5jb2x1bW5zLCAxKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRyaXgucm93czsgKytpKSB7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRyaXguY29sdW1uczsgKytqKSB7XG4gICAgICBzdW1bal0gKj0gbWF0cml4LmdldChpLCBqKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1bTtcbn1cblxuZnVuY3Rpb24gcHJvZHVjdEFsbChtYXRyaXgpIHtcbiAgbGV0IHYgPSAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdHJpeC5yb3dzOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hdHJpeC5jb2x1bW5zOyBqKyspIHtcbiAgICAgIHYgKj0gbWF0cml4LmdldChpLCBqKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHY7XG59XG5cbmZ1bmN0aW9uIHZhcmlhbmNlQnlSb3cobWF0cml4LCB1bmJpYXNlZCwgbWVhbikge1xuICBjb25zdCByb3dzID0gbWF0cml4LnJvd3M7XG4gIGNvbnN0IGNvbHMgPSBtYXRyaXguY29sdW1ucztcbiAgY29uc3QgdmFyaWFuY2UgPSBbXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgIGxldCBzdW0xID0gMDtcbiAgICBsZXQgc3VtMiA9IDA7XG4gICAgbGV0IHggPSAwO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sczsgaisrKSB7XG4gICAgICB4ID0gbWF0cml4LmdldChpLCBqKSAtIG1lYW5baV07XG4gICAgICBzdW0xICs9IHg7XG4gICAgICBzdW0yICs9IHggKiB4O1xuICAgIH1cbiAgICBpZiAodW5iaWFzZWQpIHtcbiAgICAgIHZhcmlhbmNlLnB1c2goKHN1bTIgLSAoc3VtMSAqIHN1bTEpIC8gY29scykgLyAoY29scyAtIDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyaWFuY2UucHVzaCgoc3VtMiAtIChzdW0xICogc3VtMSkgLyBjb2xzKSAvIGNvbHMpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFyaWFuY2U7XG59XG5cbmZ1bmN0aW9uIHZhcmlhbmNlQnlDb2x1bW4obWF0cml4LCB1bmJpYXNlZCwgbWVhbikge1xuICBjb25zdCByb3dzID0gbWF0cml4LnJvd3M7XG4gIGNvbnN0IGNvbHMgPSBtYXRyaXguY29sdW1ucztcbiAgY29uc3QgdmFyaWFuY2UgPSBbXTtcblxuICBmb3IgKGxldCBqID0gMDsgaiA8IGNvbHM7IGorKykge1xuICAgIGxldCBzdW0xID0gMDtcbiAgICBsZXQgc3VtMiA9IDA7XG4gICAgbGV0IHggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICB4ID0gbWF0cml4LmdldChpLCBqKSAtIG1lYW5bal07XG4gICAgICBzdW0xICs9IHg7XG4gICAgICBzdW0yICs9IHggKiB4O1xuICAgIH1cbiAgICBpZiAodW5iaWFzZWQpIHtcbiAgICAgIHZhcmlhbmNlLnB1c2goKHN1bTIgLSAoc3VtMSAqIHN1bTEpIC8gcm93cykgLyAocm93cyAtIDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyaWFuY2UucHVzaCgoc3VtMiAtIChzdW0xICogc3VtMSkgLyByb3dzKSAvIHJvd3MpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFyaWFuY2U7XG59XG5cbmZ1bmN0aW9uIHZhcmlhbmNlQWxsKG1hdHJpeCwgdW5iaWFzZWQsIG1lYW4pIHtcbiAgY29uc3Qgcm93cyA9IG1hdHJpeC5yb3dzO1xuICBjb25zdCBjb2xzID0gbWF0cml4LmNvbHVtbnM7XG4gIGNvbnN0IHNpemUgPSByb3dzICogY29scztcblxuICBsZXQgc3VtMSA9IDA7XG4gIGxldCBzdW0yID0gMDtcbiAgbGV0IHggPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sczsgaisrKSB7XG4gICAgICB4ID0gbWF0cml4LmdldChpLCBqKSAtIG1lYW47XG4gICAgICBzdW0xICs9IHg7XG4gICAgICBzdW0yICs9IHggKiB4O1xuICAgIH1cbiAgfVxuICBpZiAodW5iaWFzZWQpIHtcbiAgICByZXR1cm4gKHN1bTIgLSAoc3VtMSAqIHN1bTEpIC8gc2l6ZSkgLyAoc2l6ZSAtIDEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAoc3VtMiAtIChzdW0xICogc3VtMSkgLyBzaXplKSAvIHNpemU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2VudGVyQnlSb3cobWF0cml4LCBtZWFuKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0cml4LnJvd3M7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWF0cml4LmNvbHVtbnM7IGorKykge1xuICAgICAgbWF0cml4LnNldChpLCBqLCBtYXRyaXguZ2V0KGksIGopIC0gbWVhbltpXSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNlbnRlckJ5Q29sdW1uKG1hdHJpeCwgbWVhbikge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdHJpeC5yb3dzOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hdHJpeC5jb2x1bW5zOyBqKyspIHtcbiAgICAgIG1hdHJpeC5zZXQoaSwgaiwgbWF0cml4LmdldChpLCBqKSAtIG1lYW5bal0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjZW50ZXJBbGwobWF0cml4LCBtZWFuKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0cml4LnJvd3M7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWF0cml4LmNvbHVtbnM7IGorKykge1xuICAgICAgbWF0cml4LnNldChpLCBqLCBtYXRyaXguZ2V0KGksIGopIC0gbWVhbik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNjYWxlQnlSb3cobWF0cml4KSB7XG4gIGNvbnN0IHNjYWxlID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0cml4LnJvd3M7IGkrKykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWF0cml4LmNvbHVtbnM7IGorKykge1xuICAgICAgc3VtICs9IG1hdHJpeC5nZXQoaSwgaikgKiogMiAvIChtYXRyaXguY29sdW1ucyAtIDEpO1xuICAgIH1cbiAgICBzY2FsZS5wdXNoKE1hdGguc3FydChzdW0pKTtcbiAgfVxuICByZXR1cm4gc2NhbGU7XG59XG5cbmZ1bmN0aW9uIHNjYWxlQnlSb3cobWF0cml4LCBzY2FsZSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdHJpeC5yb3dzOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hdHJpeC5jb2x1bW5zOyBqKyspIHtcbiAgICAgIG1hdHJpeC5zZXQoaSwgaiwgbWF0cml4LmdldChpLCBqKSAvIHNjYWxlW2ldKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2NhbGVCeUNvbHVtbihtYXRyaXgpIHtcbiAgY29uc3Qgc2NhbGUgPSBbXTtcbiAgZm9yIChsZXQgaiA9IDA7IGogPCBtYXRyaXguY29sdW1uczsgaisrKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRyaXgucm93czsgaSsrKSB7XG4gICAgICBzdW0gKz0gbWF0cml4LmdldChpLCBqKSAqKiAyIC8gKG1hdHJpeC5yb3dzIC0gMSk7XG4gICAgfVxuICAgIHNjYWxlLnB1c2goTWF0aC5zcXJ0KHN1bSkpO1xuICB9XG4gIHJldHVybiBzY2FsZTtcbn1cblxuZnVuY3Rpb24gc2NhbGVCeUNvbHVtbihtYXRyaXgsIHNjYWxlKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0cml4LnJvd3M7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWF0cml4LmNvbHVtbnM7IGorKykge1xuICAgICAgbWF0cml4LnNldChpLCBqLCBtYXRyaXguZ2V0KGksIGopIC8gc2NhbGVbal0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTY2FsZUFsbChtYXRyaXgpIHtcbiAgY29uc3QgZGl2aWRlciA9IG1hdHJpeC5zaXplIC0gMTtcbiAgbGV0IHN1bSA9IDA7XG4gIGZvciAobGV0IGogPSAwOyBqIDwgbWF0cml4LmNvbHVtbnM7IGorKykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF0cml4LnJvd3M7IGkrKykge1xuICAgICAgc3VtICs9IG1hdHJpeC5nZXQoaSwgaikgKiogMiAvIGRpdmlkZXI7XG4gICAgfVxuICB9XG4gIHJldHVybiBNYXRoLnNxcnQoc3VtKTtcbn1cblxuZnVuY3Rpb24gc2NhbGVBbGwobWF0cml4LCBzY2FsZSkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG1hdHJpeC5yb3dzOyBpKyspIHtcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hdHJpeC5jb2x1bW5zOyBqKyspIHtcbiAgICAgIG1hdHJpeC5zZXQoaSwgaiwgbWF0cml4LmdldChpLCBqKSAvIHNjYWxlKTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgQWJzdHJhY3RNYXRyaXgge1xuICBzdGF0aWMgZnJvbTFEQXJyYXkobmV3Um93cywgbmV3Q29sdW1ucywgbmV3RGF0YSkge1xuICAgIGxldCBsZW5ndGggPSBuZXdSb3dzICogbmV3Q29sdW1ucztcbiAgICBpZiAobGVuZ3RoICE9PSBuZXdEYXRhLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2RhdGEgbGVuZ3RoIGRvZXMgbm90IG1hdGNoIGdpdmVuIGRpbWVuc2lvbnMnKTtcbiAgICB9XG4gICAgbGV0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgobmV3Um93cywgbmV3Q29sdW1ucyk7XG4gICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgbmV3Um93czsgcm93KyspIHtcbiAgICAgIGZvciAobGV0IGNvbHVtbiA9IDA7IGNvbHVtbiA8IG5ld0NvbHVtbnM7IGNvbHVtbisrKSB7XG4gICAgICAgIG5ld01hdHJpeC5zZXQocm93LCBjb2x1bW4sIG5ld0RhdGFbcm93ICogbmV3Q29sdW1ucyArIGNvbHVtbl0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3TWF0cml4O1xuICB9XG5cbiAgc3RhdGljIHJvd1ZlY3RvcihuZXdEYXRhKSB7XG4gICAgbGV0IHZlY3RvciA9IG5ldyBNYXRyaXgoMSwgbmV3RGF0YS5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3RGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgdmVjdG9yLnNldCgwLCBpLCBuZXdEYXRhW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHZlY3RvcjtcbiAgfVxuXG4gIHN0YXRpYyBjb2x1bW5WZWN0b3IobmV3RGF0YSkge1xuICAgIGxldCB2ZWN0b3IgPSBuZXcgTWF0cml4KG5ld0RhdGEubGVuZ3RoLCAxKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5ld0RhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZlY3Rvci5zZXQoaSwgMCwgbmV3RGF0YVtpXSk7XG4gICAgfVxuICAgIHJldHVybiB2ZWN0b3I7XG4gIH1cblxuICBzdGF0aWMgemVyb3Mocm93cywgY29sdW1ucykge1xuICAgIHJldHVybiBuZXcgTWF0cml4KHJvd3MsIGNvbHVtbnMpO1xuICB9XG5cbiAgc3RhdGljIG9uZXMocm93cywgY29sdW1ucykge1xuICAgIHJldHVybiBuZXcgTWF0cml4KHJvd3MsIGNvbHVtbnMpLmZpbGwoMSk7XG4gIH1cblxuICBzdGF0aWMgcmFuZChyb3dzLCBjb2x1bW5zLCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIGNvbnN0IHsgcmFuZG9tID0gTWF0aC5yYW5kb20gfSA9IG9wdGlvbnM7XG4gICAgbGV0IG1hdHJpeCA9IG5ldyBNYXRyaXgocm93cywgY29sdW1ucyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAgIG1hdHJpeC5zZXQoaSwgaiwgcmFuZG9tKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF0cml4O1xuICB9XG5cbiAgc3RhdGljIHJhbmRJbnQocm93cywgY29sdW1ucywgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgIH1cbiAgICBjb25zdCB7IG1pbiA9IDAsIG1heCA9IDEwMDAsIHJhbmRvbSA9IE1hdGgucmFuZG9tIH0gPSBvcHRpb25zO1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtaW4pKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaW4gbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heCBtdXN0IGJlIGFuIGludGVnZXInKTtcbiAgICBpZiAobWluID49IG1heCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ21pbiBtdXN0IGJlIHNtYWxsZXIgdGhhbiBtYXgnKTtcbiAgICBsZXQgaW50ZXJ2YWwgPSBtYXggLSBtaW47XG4gICAgbGV0IG1hdHJpeCA9IG5ldyBNYXRyaXgocm93cywgY29sdW1ucyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IG1pbiArIE1hdGgucm91bmQocmFuZG9tKCkgKiBpbnRlcnZhbCk7XG4gICAgICAgIG1hdHJpeC5zZXQoaSwgaiwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWF0cml4O1xuICB9XG5cbiAgc3RhdGljIGV5ZShyb3dzLCBjb2x1bW5zLCB2YWx1ZSkge1xuICAgIGlmIChjb2x1bW5zID09PSB1bmRlZmluZWQpIGNvbHVtbnMgPSByb3dzO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB2YWx1ZSA9IDE7XG4gICAgbGV0IG1pbiA9IE1hdGgubWluKHJvd3MsIGNvbHVtbnMpO1xuICAgIGxldCBtYXRyaXggPSB0aGlzLnplcm9zKHJvd3MsIGNvbHVtbnMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWluOyBpKyspIHtcbiAgICAgIG1hdHJpeC5zZXQoaSwgaSwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gbWF0cml4O1xuICB9XG5cbiAgc3RhdGljIGRpYWcoZGF0YSwgcm93cywgY29sdW1ucykge1xuICAgIGxldCBsID0gZGF0YS5sZW5ndGg7XG4gICAgaWYgKHJvd3MgPT09IHVuZGVmaW5lZCkgcm93cyA9IGw7XG4gICAgaWYgKGNvbHVtbnMgPT09IHVuZGVmaW5lZCkgY29sdW1ucyA9IHJvd3M7XG4gICAgbGV0IG1pbiA9IE1hdGgubWluKGwsIHJvd3MsIGNvbHVtbnMpO1xuICAgIGxldCBtYXRyaXggPSB0aGlzLnplcm9zKHJvd3MsIGNvbHVtbnMpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWluOyBpKyspIHtcbiAgICAgIG1hdHJpeC5zZXQoaSwgaSwgZGF0YVtpXSk7XG4gICAgfVxuICAgIHJldHVybiBtYXRyaXg7XG4gIH1cblxuICBzdGF0aWMgbWluKG1hdHJpeDEsIG1hdHJpeDIpIHtcbiAgICBtYXRyaXgxID0gdGhpcy5jaGVja01hdHJpeChtYXRyaXgxKTtcbiAgICBtYXRyaXgyID0gdGhpcy5jaGVja01hdHJpeChtYXRyaXgyKTtcbiAgICBsZXQgcm93cyA9IG1hdHJpeDEucm93cztcbiAgICBsZXQgY29sdW1ucyA9IG1hdHJpeDEuY29sdW1ucztcbiAgICBsZXQgcmVzdWx0ID0gbmV3IE1hdHJpeChyb3dzLCBjb2x1bW5zKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgICAgcmVzdWx0LnNldChpLCBqLCBNYXRoLm1pbihtYXRyaXgxLmdldChpLCBqKSwgbWF0cml4Mi5nZXQoaSwgaikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHN0YXRpYyBtYXgobWF0cml4MSwgbWF0cml4Mikge1xuICAgIG1hdHJpeDEgPSB0aGlzLmNoZWNrTWF0cml4KG1hdHJpeDEpO1xuICAgIG1hdHJpeDIgPSB0aGlzLmNoZWNrTWF0cml4KG1hdHJpeDIpO1xuICAgIGxldCByb3dzID0gbWF0cml4MS5yb3dzO1xuICAgIGxldCBjb2x1bW5zID0gbWF0cml4MS5jb2x1bW5zO1xuICAgIGxldCByZXN1bHQgPSBuZXcgdGhpcyhyb3dzLCBjb2x1bW5zKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgICAgcmVzdWx0LnNldChpLCBqLCBNYXRoLm1heChtYXRyaXgxLmdldChpLCBqKSwgbWF0cml4Mi5nZXQoaSwgaikpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHN0YXRpYyBjaGVja01hdHJpeCh2YWx1ZSkge1xuICAgIHJldHVybiBBYnN0cmFjdE1hdHJpeC5pc01hdHJpeCh2YWx1ZSkgPyB2YWx1ZSA6IG5ldyBNYXRyaXgodmFsdWUpO1xuICB9XG5cbiAgc3RhdGljIGlzTWF0cml4KHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdmFsdWUua2xhc3MgPT09ICdNYXRyaXgnO1xuICB9XG5cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMucm93cyAqIHRoaXMuY29sdW1ucztcbiAgfVxuXG4gIGFwcGx5KGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh0aGlzLCBpLCBqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB0bzFEQXJyYXkoKSB7XG4gICAgbGV0IGFycmF5ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICBhcnJheS5wdXNoKHRoaXMuZ2V0KGksIGopKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgdG8yREFycmF5KCkge1xuICAgIGxldCBjb3B5ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgY29weS5wdXNoKFtdKTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGhpcy5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgY29weVtpXS5wdXNoKHRoaXMuZ2V0KGksIGopKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvcHk7XG4gIH1cblxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG8yREFycmF5KCk7XG4gIH1cblxuICBpc1Jvd1ZlY3RvcigpIHtcbiAgICByZXR1cm4gdGhpcy5yb3dzID09PSAxO1xuICB9XG5cbiAgaXNDb2x1bW5WZWN0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29sdW1ucyA9PT0gMTtcbiAgfVxuXG4gIGlzVmVjdG9yKCkge1xuICAgIHJldHVybiB0aGlzLnJvd3MgPT09IDEgfHwgdGhpcy5jb2x1bW5zID09PSAxO1xuICB9XG5cbiAgaXNTcXVhcmUoKSB7XG4gICAgcmV0dXJuIHRoaXMucm93cyA9PT0gdGhpcy5jb2x1bW5zO1xuICB9XG5cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5yb3dzID09PSAwIHx8IHRoaXMuY29sdW1ucyA9PT0gMDtcbiAgfVxuXG4gIGlzU3ltbWV0cmljKCkge1xuICAgIGlmICh0aGlzLmlzU3F1YXJlKCkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPD0gaTsgaisrKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZ2V0KGksIGopICE9PSB0aGlzLmdldChqLCBpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlzRGlzdGFuY2UoKSB7XG4gICAgaWYgKCF0aGlzLmlzU3ltbWV0cmljKCkpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmdldChpLCBpKSAhPT0gMCkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaXNFY2hlbG9uRm9ybSgpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGogPSAwO1xuICAgIGxldCBwcmV2aW91c0NvbHVtbiA9IC0xO1xuICAgIGxldCBpc0VjaGVsb25Gb3JtID0gdHJ1ZTtcbiAgICBsZXQgY2hlY2tlZCA9IGZhbHNlO1xuICAgIHdoaWxlIChpIDwgdGhpcy5yb3dzICYmIGlzRWNoZWxvbkZvcm0pIHtcbiAgICAgIGogPSAwO1xuICAgICAgY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgd2hpbGUgKGogPCB0aGlzLmNvbHVtbnMgJiYgY2hlY2tlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0KGksIGopID09PSAwKSB7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZ2V0KGksIGopID09PSAxICYmIGogPiBwcmV2aW91c0NvbHVtbikge1xuICAgICAgICAgIGNoZWNrZWQgPSB0cnVlO1xuICAgICAgICAgIHByZXZpb3VzQ29sdW1uID0gajtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpc0VjaGVsb25Gb3JtID0gZmFsc2U7XG4gICAgICAgICAgY2hlY2tlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIGlzRWNoZWxvbkZvcm07XG4gIH1cblxuICBpc1JlZHVjZWRFY2hlbG9uRm9ybSgpIHtcbiAgICBsZXQgaSA9IDA7XG4gICAgbGV0IGogPSAwO1xuICAgIGxldCBwcmV2aW91c0NvbHVtbiA9IC0xO1xuICAgIGxldCBpc1JlZHVjZWRFY2hlbG9uRm9ybSA9IHRydWU7XG4gICAgbGV0IGNoZWNrZWQgPSBmYWxzZTtcbiAgICB3aGlsZSAoaSA8IHRoaXMucm93cyAmJiBpc1JlZHVjZWRFY2hlbG9uRm9ybSkge1xuICAgICAgaiA9IDA7XG4gICAgICBjaGVja2VkID0gZmFsc2U7XG4gICAgICB3aGlsZSAoaiA8IHRoaXMuY29sdW1ucyAmJiBjaGVja2VkID09PSBmYWxzZSkge1xuICAgICAgICBpZiAodGhpcy5nZXQoaSwgaikgPT09IDApIHtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5nZXQoaSwgaikgPT09IDEgJiYgaiA+IHByZXZpb3VzQ29sdW1uKSB7XG4gICAgICAgICAgY2hlY2tlZCA9IHRydWU7XG4gICAgICAgICAgcHJldmlvdXNDb2x1bW4gPSBqO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlzUmVkdWNlZEVjaGVsb25Gb3JtID0gZmFsc2U7XG4gICAgICAgICAgY2hlY2tlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGsgPSBqICsgMTsgayA8IHRoaXMucm93czsgaysrKSB7XG4gICAgICAgIGlmICh0aGlzLmdldChpLCBrKSAhPT0gMCkge1xuICAgICAgICAgIGlzUmVkdWNlZEVjaGVsb25Gb3JtID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIGlzUmVkdWNlZEVjaGVsb25Gb3JtO1xuICB9XG5cbiAgZWNoZWxvbkZvcm0oKSB7XG4gICAgbGV0IHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICBsZXQgaCA9IDA7XG4gICAgbGV0IGsgPSAwO1xuICAgIHdoaWxlIChoIDwgcmVzdWx0LnJvd3MgJiYgayA8IHJlc3VsdC5jb2x1bW5zKSB7XG4gICAgICBsZXQgaU1heCA9IGg7XG4gICAgICBmb3IgKGxldCBpID0gaDsgaSA8IHJlc3VsdC5yb3dzOyBpKyspIHtcbiAgICAgICAgaWYgKHJlc3VsdC5nZXQoaSwgaykgPiByZXN1bHQuZ2V0KGlNYXgsIGspKSB7XG4gICAgICAgICAgaU1heCA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQuZ2V0KGlNYXgsIGspID09PSAwKSB7XG4gICAgICAgIGsrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5zd2FwUm93cyhoLCBpTWF4KTtcbiAgICAgICAgbGV0IHRtcCA9IHJlc3VsdC5nZXQoaCwgayk7XG4gICAgICAgIGZvciAobGV0IGogPSBrOyBqIDwgcmVzdWx0LmNvbHVtbnM7IGorKykge1xuICAgICAgICAgIHJlc3VsdC5zZXQoaCwgaiwgcmVzdWx0LmdldChoLCBqKSAvIHRtcCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IGggKyAxOyBpIDwgcmVzdWx0LnJvd3M7IGkrKykge1xuICAgICAgICAgIGxldCBmYWN0b3IgPSByZXN1bHQuZ2V0KGksIGspIC8gcmVzdWx0LmdldChoLCBrKTtcbiAgICAgICAgICByZXN1bHQuc2V0KGksIGssIDApO1xuICAgICAgICAgIGZvciAobGV0IGogPSBrICsgMTsgaiA8IHJlc3VsdC5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoaSwgaiwgcmVzdWx0LmdldChpLCBqKSAtIHJlc3VsdC5nZXQoaCwgaikgKiBmYWN0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBoKys7XG4gICAgICAgIGsrKztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHJlZHVjZWRFY2hlbG9uRm9ybSgpIHtcbiAgICBsZXQgcmVzdWx0ID0gdGhpcy5lY2hlbG9uRm9ybSgpO1xuICAgIGxldCBtID0gcmVzdWx0LmNvbHVtbnM7XG4gICAgbGV0IG4gPSByZXN1bHQucm93cztcbiAgICBsZXQgaCA9IG4gLSAxO1xuICAgIHdoaWxlIChoID49IDApIHtcbiAgICAgIGlmIChyZXN1bHQubWF4Um93KGgpID09PSAwKSB7XG4gICAgICAgIGgtLTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBwID0gMDtcbiAgICAgICAgbGV0IHBpdm90ID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChwIDwgbiAmJiBwaXZvdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBpZiAocmVzdWx0LmdldChoLCBwKSA9PT0gMSkge1xuICAgICAgICAgICAgcGl2b3QgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaDsgaSsrKSB7XG4gICAgICAgICAgbGV0IGZhY3RvciA9IHJlc3VsdC5nZXQoaSwgcCk7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IHA7IGogPCBtOyBqKyspIHtcbiAgICAgICAgICAgIGxldCB0bXAgPSByZXN1bHQuZ2V0KGksIGopIC0gZmFjdG9yICogcmVzdWx0LmdldChoLCBqKTtcbiAgICAgICAgICAgIHJlc3VsdC5zZXQoaSwgaiwgdG1wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaC0tO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgc2V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0IG1ldGhvZCBpcyB1bmltcGxlbWVudGVkJyk7XG4gIH1cblxuICBnZXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnZXQgbWV0aG9kIGlzIHVuaW1wbGVtZW50ZWQnKTtcbiAgfVxuXG4gIHJlcGVhdChvcHRpb25zID0ge30pIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIGNvbnN0IHsgcm93cyA9IDEsIGNvbHVtbnMgPSAxIH0gPSBvcHRpb25zO1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihyb3dzKSB8fCByb3dzIDw9IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Jvd3MgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICB9XG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGNvbHVtbnMpIHx8IGNvbHVtbnMgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY29sdW1ucyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuICAgIH1cbiAgICBsZXQgbWF0cml4ID0gbmV3IE1hdHJpeCh0aGlzLnJvd3MgKiByb3dzLCB0aGlzLmNvbHVtbnMgKiBjb2x1bW5zKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgICAgbWF0cml4LnNldFN1Yk1hdHJpeCh0aGlzLCB0aGlzLnJvd3MgKiBpLCB0aGlzLmNvbHVtbnMgKiBqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgfVxuXG4gIGZpbGwodmFsdWUpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBuZWcoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsUygtMSk7XG4gIH1cblxuICBnZXRSb3coaW5kZXgpIHtcbiAgICBjaGVja1Jvd0luZGV4KHRoaXMsIGluZGV4KTtcbiAgICBsZXQgcm93ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbHVtbnM7IGkrKykge1xuICAgICAgcm93LnB1c2godGhpcy5nZXQoaW5kZXgsIGkpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvdztcbiAgfVxuXG4gIGdldFJvd1ZlY3RvcihpbmRleCkge1xuICAgIHJldHVybiBNYXRyaXgucm93VmVjdG9yKHRoaXMuZ2V0Um93KGluZGV4KSk7XG4gIH1cblxuICBzZXRSb3coaW5kZXgsIGFycmF5KSB7XG4gICAgY2hlY2tSb3dJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgYXJyYXkgPSBjaGVja1Jvd1ZlY3Rvcih0aGlzLCBhcnJheSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbHVtbnM7IGkrKykge1xuICAgICAgdGhpcy5zZXQoaW5kZXgsIGksIGFycmF5W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzd2FwUm93cyhyb3cxLCByb3cyKSB7XG4gICAgY2hlY2tSb3dJbmRleCh0aGlzLCByb3cxKTtcbiAgICBjaGVja1Jvd0luZGV4KHRoaXMsIHJvdzIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jb2x1bW5zOyBpKyspIHtcbiAgICAgIGxldCB0ZW1wID0gdGhpcy5nZXQocm93MSwgaSk7XG4gICAgICB0aGlzLnNldChyb3cxLCBpLCB0aGlzLmdldChyb3cyLCBpKSk7XG4gICAgICB0aGlzLnNldChyb3cyLCBpLCB0ZW1wKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXRDb2x1bW4oaW5kZXgpIHtcbiAgICBjaGVja0NvbHVtbkluZGV4KHRoaXMsIGluZGV4KTtcbiAgICBsZXQgY29sdW1uID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgY29sdW1uLnB1c2godGhpcy5nZXQoaSwgaW5kZXgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbHVtbjtcbiAgfVxuXG4gIGdldENvbHVtblZlY3RvcihpbmRleCkge1xuICAgIHJldHVybiBNYXRyaXguY29sdW1uVmVjdG9yKHRoaXMuZ2V0Q29sdW1uKGluZGV4KSk7XG4gIH1cblxuICBzZXRDb2x1bW4oaW5kZXgsIGFycmF5KSB7XG4gICAgY2hlY2tDb2x1bW5JbmRleCh0aGlzLCBpbmRleCk7XG4gICAgYXJyYXkgPSBjaGVja0NvbHVtblZlY3Rvcih0aGlzLCBhcnJheSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgdGhpcy5zZXQoaSwgaW5kZXgsIGFycmF5W2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzd2FwQ29sdW1ucyhjb2x1bW4xLCBjb2x1bW4yKSB7XG4gICAgY2hlY2tDb2x1bW5JbmRleCh0aGlzLCBjb2x1bW4xKTtcbiAgICBjaGVja0NvbHVtbkluZGV4KHRoaXMsIGNvbHVtbjIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGxldCB0ZW1wID0gdGhpcy5nZXQoaSwgY29sdW1uMSk7XG4gICAgICB0aGlzLnNldChpLCBjb2x1bW4xLCB0aGlzLmdldChpLCBjb2x1bW4yKSk7XG4gICAgICB0aGlzLnNldChpLCBjb2x1bW4yLCB0ZW1wKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhZGRSb3dWZWN0b3IodmVjdG9yKSB7XG4gICAgdmVjdG9yID0gY2hlY2tSb3dWZWN0b3IodGhpcywgdmVjdG9yKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopICsgdmVjdG9yW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzdWJSb3dWZWN0b3IodmVjdG9yKSB7XG4gICAgdmVjdG9yID0gY2hlY2tSb3dWZWN0b3IodGhpcywgdmVjdG9yKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopIC0gdmVjdG9yW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBtdWxSb3dWZWN0b3IodmVjdG9yKSB7XG4gICAgdmVjdG9yID0gY2hlY2tSb3dWZWN0b3IodGhpcywgdmVjdG9yKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopICogdmVjdG9yW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkaXZSb3dWZWN0b3IodmVjdG9yKSB7XG4gICAgdmVjdG9yID0gY2hlY2tSb3dWZWN0b3IodGhpcywgdmVjdG9yKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopIC8gdmVjdG9yW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhZGRDb2x1bW5WZWN0b3IodmVjdG9yKSB7XG4gICAgdmVjdG9yID0gY2hlY2tDb2x1bW5WZWN0b3IodGhpcywgdmVjdG9yKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopICsgdmVjdG9yW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzdWJDb2x1bW5WZWN0b3IodmVjdG9yKSB7XG4gICAgdmVjdG9yID0gY2hlY2tDb2x1bW5WZWN0b3IodGhpcywgdmVjdG9yKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopIC0gdmVjdG9yW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBtdWxDb2x1bW5WZWN0b3IodmVjdG9yKSB7XG4gICAgdmVjdG9yID0gY2hlY2tDb2x1bW5WZWN0b3IodGhpcywgdmVjdG9yKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopICogdmVjdG9yW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkaXZDb2x1bW5WZWN0b3IodmVjdG9yKSB7XG4gICAgdmVjdG9yID0gY2hlY2tDb2x1bW5WZWN0b3IodGhpcywgdmVjdG9yKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIHRoaXMuZ2V0KGksIGopIC8gdmVjdG9yW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBtdWxSb3coaW5kZXgsIHZhbHVlKSB7XG4gICAgY2hlY2tSb3dJbmRleCh0aGlzLCBpbmRleCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbHVtbnM7IGkrKykge1xuICAgICAgdGhpcy5zZXQoaW5kZXgsIGksIHRoaXMuZ2V0KGluZGV4LCBpKSAqIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBtdWxDb2x1bW4oaW5kZXgsIHZhbHVlKSB7XG4gICAgY2hlY2tDb2x1bW5JbmRleCh0aGlzLCBpbmRleCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgdGhpcy5zZXQoaSwgaW5kZXgsIHRoaXMuZ2V0KGksIGluZGV4KSAqIHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBtYXgoYnkpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIHN3aXRjaCAoYnkpIHtcbiAgICAgIGNhc2UgJ3Jvdyc6IHtcbiAgICAgICAgY29uc3QgbWF4ID0gbmV3IEFycmF5KHRoaXMucm93cykuZmlsbChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCB0aGlzLnJvd3M7IHJvdysrKSB7XG4gICAgICAgICAgZm9yIChsZXQgY29sdW1uID0gMDsgY29sdW1uIDwgdGhpcy5jb2x1bW5zOyBjb2x1bW4rKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KHJvdywgY29sdW1uKSA+IG1heFtyb3ddKSB7XG4gICAgICAgICAgICAgIG1heFtyb3ddID0gdGhpcy5nZXQocm93LCBjb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgfVxuICAgICAgY2FzZSAnY29sdW1uJzoge1xuICAgICAgICBjb25zdCBtYXggPSBuZXcgQXJyYXkodGhpcy5jb2x1bW5zKS5maWxsKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRoaXMucm93czsgcm93KyspIHtcbiAgICAgICAgICBmb3IgKGxldCBjb2x1bW4gPSAwOyBjb2x1bW4gPCB0aGlzLmNvbHVtbnM7IGNvbHVtbisrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXQocm93LCBjb2x1bW4pID4gbWF4W2NvbHVtbl0pIHtcbiAgICAgICAgICAgICAgbWF4W2NvbHVtbl0gPSB0aGlzLmdldChyb3csIGNvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgICB9XG4gICAgICBjYXNlIHVuZGVmaW5lZDoge1xuICAgICAgICBsZXQgbWF4ID0gdGhpcy5nZXQoMCwgMCk7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRoaXMucm93czsgcm93KyspIHtcbiAgICAgICAgICBmb3IgKGxldCBjb2x1bW4gPSAwOyBjb2x1bW4gPCB0aGlzLmNvbHVtbnM7IGNvbHVtbisrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXQocm93LCBjb2x1bW4pID4gbWF4KSB7XG4gICAgICAgICAgICAgIG1heCA9IHRoaXMuZ2V0KHJvdywgY29sdW1uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvcHRpb246ICR7Ynl9YCk7XG4gICAgfVxuICB9XG5cbiAgbWF4SW5kZXgoKSB7XG4gICAgY2hlY2tOb25FbXB0eSh0aGlzKTtcbiAgICBsZXQgdiA9IHRoaXMuZ2V0KDAsIDApO1xuICAgIGxldCBpZHggPSBbMCwgMF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICBpZiAodGhpcy5nZXQoaSwgaikgPiB2KSB7XG4gICAgICAgICAgdiA9IHRoaXMuZ2V0KGksIGopO1xuICAgICAgICAgIGlkeFswXSA9IGk7XG4gICAgICAgICAgaWR4WzFdID0gajtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaWR4O1xuICB9XG5cbiAgbWluKGJ5KSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cblxuICAgIHN3aXRjaCAoYnkpIHtcbiAgICAgIGNhc2UgJ3Jvdyc6IHtcbiAgICAgICAgY29uc3QgbWluID0gbmV3IEFycmF5KHRoaXMucm93cykuZmlsbChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCB0aGlzLnJvd3M7IHJvdysrKSB7XG4gICAgICAgICAgZm9yIChsZXQgY29sdW1uID0gMDsgY29sdW1uIDwgdGhpcy5jb2x1bW5zOyBjb2x1bW4rKykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZ2V0KHJvdywgY29sdW1uKSA8IG1pbltyb3ddKSB7XG4gICAgICAgICAgICAgIG1pbltyb3ddID0gdGhpcy5nZXQocm93LCBjb2x1bW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgICAgfVxuICAgICAgY2FzZSAnY29sdW1uJzoge1xuICAgICAgICBjb25zdCBtaW4gPSBuZXcgQXJyYXkodGhpcy5jb2x1bW5zKS5maWxsKE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRoaXMucm93czsgcm93KyspIHtcbiAgICAgICAgICBmb3IgKGxldCBjb2x1bW4gPSAwOyBjb2x1bW4gPCB0aGlzLmNvbHVtbnM7IGNvbHVtbisrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXQocm93LCBjb2x1bW4pIDwgbWluW2NvbHVtbl0pIHtcbiAgICAgICAgICAgICAgbWluW2NvbHVtbl0gPSB0aGlzLmdldChyb3csIGNvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgICB9XG4gICAgICBjYXNlIHVuZGVmaW5lZDoge1xuICAgICAgICBsZXQgbWluID0gdGhpcy5nZXQoMCwgMCk7XG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRoaXMucm93czsgcm93KyspIHtcbiAgICAgICAgICBmb3IgKGxldCBjb2x1bW4gPSAwOyBjb2x1bW4gPCB0aGlzLmNvbHVtbnM7IGNvbHVtbisrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nZXQocm93LCBjb2x1bW4pIDwgbWluKSB7XG4gICAgICAgICAgICAgIG1pbiA9IHRoaXMuZ2V0KHJvdywgY29sdW1uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvcHRpb246ICR7Ynl9YCk7XG4gICAgfVxuICB9XG5cbiAgbWluSW5kZXgoKSB7XG4gICAgY2hlY2tOb25FbXB0eSh0aGlzKTtcbiAgICBsZXQgdiA9IHRoaXMuZ2V0KDAsIDApO1xuICAgIGxldCBpZHggPSBbMCwgMF07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICBpZiAodGhpcy5nZXQoaSwgaikgPCB2KSB7XG4gICAgICAgICAgdiA9IHRoaXMuZ2V0KGksIGopO1xuICAgICAgICAgIGlkeFswXSA9IGk7XG4gICAgICAgICAgaWR4WzFdID0gajtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaWR4O1xuICB9XG5cbiAgbWF4Um93KHJvdykge1xuICAgIGNoZWNrUm93SW5kZXgodGhpcywgcm93KTtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGxldCB2ID0gdGhpcy5nZXQocm93LCAwKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuY29sdW1uczsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5nZXQocm93LCBpKSA+IHYpIHtcbiAgICAgICAgdiA9IHRoaXMuZ2V0KHJvdywgaSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9XG5cbiAgbWF4Um93SW5kZXgocm93KSB7XG4gICAgY2hlY2tSb3dJbmRleCh0aGlzLCByb3cpO1xuICAgIGNoZWNrTm9uRW1wdHkodGhpcyk7XG4gICAgbGV0IHYgPSB0aGlzLmdldChyb3csIDApO1xuICAgIGxldCBpZHggPSBbcm93LCAwXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMuY29sdW1uczsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5nZXQocm93LCBpKSA+IHYpIHtcbiAgICAgICAgdiA9IHRoaXMuZ2V0KHJvdywgaSk7XG4gICAgICAgIGlkeFsxXSA9IGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpZHg7XG4gIH1cblxuICBtaW5Sb3cocm93KSB7XG4gICAgY2hlY2tSb3dJbmRleCh0aGlzLCByb3cpO1xuICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gICAgbGV0IHYgPSB0aGlzLmdldChyb3csIDApO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5jb2x1bW5zOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmdldChyb3csIGkpIDwgdikge1xuICAgICAgICB2ID0gdGhpcy5nZXQocm93LCBpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHY7XG4gIH1cblxuICBtaW5Sb3dJbmRleChyb3cpIHtcbiAgICBjaGVja1Jvd0luZGV4KHRoaXMsIHJvdyk7XG4gICAgY2hlY2tOb25FbXB0eSh0aGlzKTtcbiAgICBsZXQgdiA9IHRoaXMuZ2V0KHJvdywgMCk7XG4gICAgbGV0IGlkeCA9IFtyb3csIDBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgdGhpcy5jb2x1bW5zOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLmdldChyb3csIGkpIDwgdikge1xuICAgICAgICB2ID0gdGhpcy5nZXQocm93LCBpKTtcbiAgICAgICAgaWR4WzFdID0gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlkeDtcbiAgfVxuXG4gIG1heENvbHVtbihjb2x1bW4pIHtcbiAgICBjaGVja0NvbHVtbkluZGV4KHRoaXMsIGNvbHVtbik7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gTmFOO1xuICAgIH1cbiAgICBsZXQgdiA9IHRoaXMuZ2V0KDAsIGNvbHVtbik7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgaWYgKHRoaXMuZ2V0KGksIGNvbHVtbikgPiB2KSB7XG4gICAgICAgIHYgPSB0aGlzLmdldChpLCBjb2x1bW4pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdjtcbiAgfVxuXG4gIG1heENvbHVtbkluZGV4KGNvbHVtbikge1xuICAgIGNoZWNrQ29sdW1uSW5kZXgodGhpcywgY29sdW1uKTtcbiAgICBjaGVja05vbkVtcHR5KHRoaXMpO1xuICAgIGxldCB2ID0gdGhpcy5nZXQoMCwgY29sdW1uKTtcbiAgICBsZXQgaWR4ID0gWzAsIGNvbHVtbl07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgaWYgKHRoaXMuZ2V0KGksIGNvbHVtbikgPiB2KSB7XG4gICAgICAgIHYgPSB0aGlzLmdldChpLCBjb2x1bW4pO1xuICAgICAgICBpZHhbMF0gPSBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaWR4O1xuICB9XG5cbiAgbWluQ29sdW1uKGNvbHVtbikge1xuICAgIGNoZWNrQ29sdW1uSW5kZXgodGhpcywgY29sdW1uKTtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBOYU47XG4gICAgfVxuICAgIGxldCB2ID0gdGhpcy5nZXQoMCwgY29sdW1uKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5nZXQoaSwgY29sdW1uKSA8IHYpIHtcbiAgICAgICAgdiA9IHRoaXMuZ2V0KGksIGNvbHVtbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9XG5cbiAgbWluQ29sdW1uSW5kZXgoY29sdW1uKSB7XG4gICAgY2hlY2tDb2x1bW5JbmRleCh0aGlzLCBjb2x1bW4pO1xuICAgIGNoZWNrTm9uRW1wdHkodGhpcyk7XG4gICAgbGV0IHYgPSB0aGlzLmdldCgwLCBjb2x1bW4pO1xuICAgIGxldCBpZHggPSBbMCwgY29sdW1uXTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5nZXQoaSwgY29sdW1uKSA8IHYpIHtcbiAgICAgICAgdiA9IHRoaXMuZ2V0KGksIGNvbHVtbik7XG4gICAgICAgIGlkeFswXSA9IGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpZHg7XG4gIH1cblxuICBkaWFnKCkge1xuICAgIGxldCBtaW4gPSBNYXRoLm1pbih0aGlzLnJvd3MsIHRoaXMuY29sdW1ucyk7XG4gICAgbGV0IGRpYWcgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1pbjsgaSsrKSB7XG4gICAgICBkaWFnLnB1c2godGhpcy5nZXQoaSwgaSkpO1xuICAgIH1cbiAgICByZXR1cm4gZGlhZztcbiAgfVxuXG4gIG5vcm0odHlwZSA9ICdmcm9iZW5pdXMnKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdtYXgnOlxuICAgICAgICByZXR1cm4gdGhpcy5tYXgoKTtcbiAgICAgIGNhc2UgJ2Zyb2Jlbml1cyc6XG4gICAgICAgIHJldHVybiBNYXRoLnNxcnQodGhpcy5kb3QodGhpcykpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYHVua25vd24gbm9ybSB0eXBlOiAke3R5cGV9YCk7XG4gICAgfVxuICB9XG5cbiAgY3VtdWxhdGl2ZVN1bSgpIHtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHN1bSArPSB0aGlzLmdldChpLCBqKTtcbiAgICAgICAgdGhpcy5zZXQoaSwgaiwgc3VtKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBkb3QodmVjdG9yMikge1xuICAgIGlmIChBYnN0cmFjdE1hdHJpeC5pc01hdHJpeCh2ZWN0b3IyKSkgdmVjdG9yMiA9IHZlY3RvcjIudG8xREFycmF5KCk7XG4gICAgbGV0IHZlY3RvcjEgPSB0aGlzLnRvMURBcnJheSgpO1xuICAgIGlmICh2ZWN0b3IxLmxlbmd0aCAhPT0gdmVjdG9yMi5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd2ZWN0b3JzIGRvIG5vdCBoYXZlIHRoZSBzYW1lIHNpemUnKTtcbiAgICB9XG4gICAgbGV0IGRvdCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2ZWN0b3IxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkb3QgKz0gdmVjdG9yMVtpXSAqIHZlY3RvcjJbaV07XG4gICAgfVxuICAgIHJldHVybiBkb3Q7XG4gIH1cblxuICBtbXVsKG90aGVyKSB7XG4gICAgb3RoZXIgPSBNYXRyaXguY2hlY2tNYXRyaXgob3RoZXIpO1xuXG4gICAgbGV0IG0gPSB0aGlzLnJvd3M7XG4gICAgbGV0IG4gPSB0aGlzLmNvbHVtbnM7XG4gICAgbGV0IHAgPSBvdGhlci5jb2x1bW5zO1xuXG4gICAgbGV0IHJlc3VsdCA9IG5ldyBNYXRyaXgobSwgcCk7XG5cbiAgICBsZXQgQmNvbGogPSBuZXcgRmxvYXQ2NEFycmF5KG4pO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgcDsgaisrKSB7XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IG47IGsrKykge1xuICAgICAgICBCY29saltrXSA9IG90aGVyLmdldChrLCBqKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgbGV0IHMgPSAwO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IG47IGsrKykge1xuICAgICAgICAgIHMgKz0gdGhpcy5nZXQoaSwgaykgKiBCY29saltrXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlc3VsdC5zZXQoaSwgaiwgcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBtcG93KHNjYWxhcikge1xuICAgIGlmICghdGhpcy5pc1NxdWFyZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignTWF0cml4IG11c3QgYmUgc3F1YXJlJyk7XG4gICAgfVxuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzY2FsYXIpIHx8IHNjYWxhciA8IDApIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdFeHBvbmVudCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIGludGVnZXInKTtcbiAgICB9XG4gICAgLy8gUnVzc2lhbiBQZWFzYW50IGV4cG9uZW50aWF0aW9uLCBpLmUuIGV4cG9uZW50aWF0aW9uIGJ5IHNxdWFyaW5nXG4gICAgbGV0IHJlc3VsdCA9IE1hdHJpeC5leWUodGhpcy5yb3dzKTtcbiAgICBsZXQgYmIgPSB0aGlzO1xuICAgIC8vIE5vdGU6IERvbid0IGJpdCBzaGlmdC4gSW4gSlMsIHRoYXQgd291bGQgdHJ1bmNhdGUgYXQgMzIgYml0c1xuICAgIGZvciAobGV0IGUgPSBzY2FsYXI7IGUgPj0gMTsgZSAvPSAyKSB7XG4gICAgICBpZiAoKGUgJiAxKSAhPT0gMCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQubW11bChiYik7XG4gICAgICB9XG4gICAgICBiYiA9IGJiLm1tdWwoYmIpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgc3RyYXNzZW4yeDIob3RoZXIpIHtcbiAgICBvdGhlciA9IE1hdHJpeC5jaGVja01hdHJpeChvdGhlcik7XG4gICAgbGV0IHJlc3VsdCA9IG5ldyBNYXRyaXgoMiwgMik7XG4gICAgY29uc3QgYTExID0gdGhpcy5nZXQoMCwgMCk7XG4gICAgY29uc3QgYjExID0gb3RoZXIuZ2V0KDAsIDApO1xuICAgIGNvbnN0IGExMiA9IHRoaXMuZ2V0KDAsIDEpO1xuICAgIGNvbnN0IGIxMiA9IG90aGVyLmdldCgwLCAxKTtcbiAgICBjb25zdCBhMjEgPSB0aGlzLmdldCgxLCAwKTtcbiAgICBjb25zdCBiMjEgPSBvdGhlci5nZXQoMSwgMCk7XG4gICAgY29uc3QgYTIyID0gdGhpcy5nZXQoMSwgMSk7XG4gICAgY29uc3QgYjIyID0gb3RoZXIuZ2V0KDEsIDEpO1xuXG4gICAgLy8gQ29tcHV0ZSBpbnRlcm1lZGlhdGUgdmFsdWVzLlxuICAgIGNvbnN0IG0xID0gKGExMSArIGEyMikgKiAoYjExICsgYjIyKTtcbiAgICBjb25zdCBtMiA9IChhMjEgKyBhMjIpICogYjExO1xuICAgIGNvbnN0IG0zID0gYTExICogKGIxMiAtIGIyMik7XG4gICAgY29uc3QgbTQgPSBhMjIgKiAoYjIxIC0gYjExKTtcbiAgICBjb25zdCBtNSA9IChhMTEgKyBhMTIpICogYjIyO1xuICAgIGNvbnN0IG02ID0gKGEyMSAtIGExMSkgKiAoYjExICsgYjEyKTtcbiAgICBjb25zdCBtNyA9IChhMTIgLSBhMjIpICogKGIyMSArIGIyMik7XG5cbiAgICAvLyBDb21iaW5lIGludGVybWVkaWF0ZSB2YWx1ZXMgaW50byB0aGUgb3V0cHV0LlxuICAgIGNvbnN0IGMwMCA9IG0xICsgbTQgLSBtNSArIG03O1xuICAgIGNvbnN0IGMwMSA9IG0zICsgbTU7XG4gICAgY29uc3QgYzEwID0gbTIgKyBtNDtcbiAgICBjb25zdCBjMTEgPSBtMSAtIG0yICsgbTMgKyBtNjtcblxuICAgIHJlc3VsdC5zZXQoMCwgMCwgYzAwKTtcbiAgICByZXN1bHQuc2V0KDAsIDEsIGMwMSk7XG4gICAgcmVzdWx0LnNldCgxLCAwLCBjMTApO1xuICAgIHJlc3VsdC5zZXQoMSwgMSwgYzExKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgc3RyYXNzZW4zeDMob3RoZXIpIHtcbiAgICBvdGhlciA9IE1hdHJpeC5jaGVja01hdHJpeChvdGhlcik7XG4gICAgbGV0IHJlc3VsdCA9IG5ldyBNYXRyaXgoMywgMyk7XG5cbiAgICBjb25zdCBhMDAgPSB0aGlzLmdldCgwLCAwKTtcbiAgICBjb25zdCBhMDEgPSB0aGlzLmdldCgwLCAxKTtcbiAgICBjb25zdCBhMDIgPSB0aGlzLmdldCgwLCAyKTtcbiAgICBjb25zdCBhMTAgPSB0aGlzLmdldCgxLCAwKTtcbiAgICBjb25zdCBhMTEgPSB0aGlzLmdldCgxLCAxKTtcbiAgICBjb25zdCBhMTIgPSB0aGlzLmdldCgxLCAyKTtcbiAgICBjb25zdCBhMjAgPSB0aGlzLmdldCgyLCAwKTtcbiAgICBjb25zdCBhMjEgPSB0aGlzLmdldCgyLCAxKTtcbiAgICBjb25zdCBhMjIgPSB0aGlzLmdldCgyLCAyKTtcblxuICAgIGNvbnN0IGIwMCA9IG90aGVyLmdldCgwLCAwKTtcbiAgICBjb25zdCBiMDEgPSBvdGhlci5nZXQoMCwgMSk7XG4gICAgY29uc3QgYjAyID0gb3RoZXIuZ2V0KDAsIDIpO1xuICAgIGNvbnN0IGIxMCA9IG90aGVyLmdldCgxLCAwKTtcbiAgICBjb25zdCBiMTEgPSBvdGhlci5nZXQoMSwgMSk7XG4gICAgY29uc3QgYjEyID0gb3RoZXIuZ2V0KDEsIDIpO1xuICAgIGNvbnN0IGIyMCA9IG90aGVyLmdldCgyLCAwKTtcbiAgICBjb25zdCBiMjEgPSBvdGhlci5nZXQoMiwgMSk7XG4gICAgY29uc3QgYjIyID0gb3RoZXIuZ2V0KDIsIDIpO1xuXG4gICAgY29uc3QgbTEgPSAoYTAwICsgYTAxICsgYTAyIC0gYTEwIC0gYTExIC0gYTIxIC0gYTIyKSAqIGIxMTtcbiAgICBjb25zdCBtMiA9IChhMDAgLSBhMTApICogKC1iMDEgKyBiMTEpO1xuICAgIGNvbnN0IG0zID0gYTExICogKC1iMDAgKyBiMDEgKyBiMTAgLSBiMTEgLSBiMTIgLSBiMjAgKyBiMjIpO1xuICAgIGNvbnN0IG00ID0gKC1hMDAgKyBhMTAgKyBhMTEpICogKGIwMCAtIGIwMSArIGIxMSk7XG4gICAgY29uc3QgbTUgPSAoYTEwICsgYTExKSAqICgtYjAwICsgYjAxKTtcbiAgICBjb25zdCBtNiA9IGEwMCAqIGIwMDtcbiAgICBjb25zdCBtNyA9ICgtYTAwICsgYTIwICsgYTIxKSAqIChiMDAgLSBiMDIgKyBiMTIpO1xuICAgIGNvbnN0IG04ID0gKC1hMDAgKyBhMjApICogKGIwMiAtIGIxMik7XG4gICAgY29uc3QgbTkgPSAoYTIwICsgYTIxKSAqICgtYjAwICsgYjAyKTtcbiAgICBjb25zdCBtMTAgPSAoYTAwICsgYTAxICsgYTAyIC0gYTExIC0gYTEyIC0gYTIwIC0gYTIxKSAqIGIxMjtcbiAgICBjb25zdCBtMTEgPSBhMjEgKiAoLWIwMCArIGIwMiArIGIxMCAtIGIxMSAtIGIxMiAtIGIyMCArIGIyMSk7XG4gICAgY29uc3QgbTEyID0gKC1hMDIgKyBhMjEgKyBhMjIpICogKGIxMSArIGIyMCAtIGIyMSk7XG4gICAgY29uc3QgbTEzID0gKGEwMiAtIGEyMikgKiAoYjExIC0gYjIxKTtcbiAgICBjb25zdCBtMTQgPSBhMDIgKiBiMjA7XG4gICAgY29uc3QgbTE1ID0gKGEyMSArIGEyMikgKiAoLWIyMCArIGIyMSk7XG4gICAgY29uc3QgbTE2ID0gKC1hMDIgKyBhMTEgKyBhMTIpICogKGIxMiArIGIyMCAtIGIyMik7XG4gICAgY29uc3QgbTE3ID0gKGEwMiAtIGExMikgKiAoYjEyIC0gYjIyKTtcbiAgICBjb25zdCBtMTggPSAoYTExICsgYTEyKSAqICgtYjIwICsgYjIyKTtcbiAgICBjb25zdCBtMTkgPSBhMDEgKiBiMTA7XG4gICAgY29uc3QgbTIwID0gYTEyICogYjIxO1xuICAgIGNvbnN0IG0yMSA9IGExMCAqIGIwMjtcbiAgICBjb25zdCBtMjIgPSBhMjAgKiBiMDE7XG4gICAgY29uc3QgbTIzID0gYTIyICogYjIyO1xuXG4gICAgY29uc3QgYzAwID0gbTYgKyBtMTQgKyBtMTk7XG4gICAgY29uc3QgYzAxID0gbTEgKyBtNCArIG01ICsgbTYgKyBtMTIgKyBtMTQgKyBtMTU7XG4gICAgY29uc3QgYzAyID0gbTYgKyBtNyArIG05ICsgbTEwICsgbTE0ICsgbTE2ICsgbTE4O1xuICAgIGNvbnN0IGMxMCA9IG0yICsgbTMgKyBtNCArIG02ICsgbTE0ICsgbTE2ICsgbTE3O1xuICAgIGNvbnN0IGMxMSA9IG0yICsgbTQgKyBtNSArIG02ICsgbTIwO1xuICAgIGNvbnN0IGMxMiA9IG0xNCArIG0xNiArIG0xNyArIG0xOCArIG0yMTtcbiAgICBjb25zdCBjMjAgPSBtNiArIG03ICsgbTggKyBtMTEgKyBtMTIgKyBtMTMgKyBtMTQ7XG4gICAgY29uc3QgYzIxID0gbTEyICsgbTEzICsgbTE0ICsgbTE1ICsgbTIyO1xuICAgIGNvbnN0IGMyMiA9IG02ICsgbTcgKyBtOCArIG05ICsgbTIzO1xuXG4gICAgcmVzdWx0LnNldCgwLCAwLCBjMDApO1xuICAgIHJlc3VsdC5zZXQoMCwgMSwgYzAxKTtcbiAgICByZXN1bHQuc2V0KDAsIDIsIGMwMik7XG4gICAgcmVzdWx0LnNldCgxLCAwLCBjMTApO1xuICAgIHJlc3VsdC5zZXQoMSwgMSwgYzExKTtcbiAgICByZXN1bHQuc2V0KDEsIDIsIGMxMik7XG4gICAgcmVzdWx0LnNldCgyLCAwLCBjMjApO1xuICAgIHJlc3VsdC5zZXQoMiwgMSwgYzIxKTtcbiAgICByZXN1bHQuc2V0KDIsIDIsIGMyMik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIG1tdWxTdHJhc3Nlbih5KSB7XG4gICAgeSA9IE1hdHJpeC5jaGVja01hdHJpeCh5KTtcbiAgICBsZXQgeCA9IHRoaXMuY2xvbmUoKTtcbiAgICBsZXQgcjEgPSB4LnJvd3M7XG4gICAgbGV0IGMxID0geC5jb2x1bW5zO1xuICAgIGxldCByMiA9IHkucm93cztcbiAgICBsZXQgYzIgPSB5LmNvbHVtbnM7XG4gICAgaWYgKGMxICE9PSByMikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgYE11bHRpcGx5aW5nICR7cjF9IHggJHtjMX0gYW5kICR7cjJ9IHggJHtjMn0gbWF0cml4OiBkaW1lbnNpb25zIGRvIG5vdCBtYXRjaC5gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBQdXQgYSBtYXRyaXggaW50byB0aGUgdG9wIGxlZnQgb2YgYSBtYXRyaXggb2YgemVyb3MuXG4gICAgLy8gYHJvd3NgIGFuZCBgY29sc2AgYXJlIHRoZSBkaW1lbnNpb25zIG9mIHRoZSBvdXRwdXQgbWF0cml4LlxuICAgIGZ1bmN0aW9uIGVtYmVkKG1hdCwgcm93cywgY29scykge1xuICAgICAgbGV0IHIgPSBtYXQucm93cztcbiAgICAgIGxldCBjID0gbWF0LmNvbHVtbnM7XG4gICAgICBpZiAociA9PT0gcm93cyAmJiBjID09PSBjb2xzKSB7XG4gICAgICAgIHJldHVybiBtYXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcmVzdWx0YXQgPSBBYnN0cmFjdE1hdHJpeC56ZXJvcyhyb3dzLCBjb2xzKTtcbiAgICAgICAgcmVzdWx0YXQgPSByZXN1bHRhdC5zZXRTdWJNYXRyaXgobWF0LCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdGF0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSBib3RoIG1hdHJpY2VzIGFyZSB0aGUgc2FtZSBzaXplLlxuICAgIC8vIFRoaXMgaXMgZXhjbHVzaXZlbHkgZm9yIHNpbXBsaWNpdHk6XG4gICAgLy8gdGhpcyBhbGdvcml0aG0gY2FuIGJlIGltcGxlbWVudGVkIHdpdGggbWF0cmljZXMgb2YgZGlmZmVyZW50IHNpemVzLlxuXG4gICAgbGV0IHIgPSBNYXRoLm1heChyMSwgcjIpO1xuICAgIGxldCBjID0gTWF0aC5tYXgoYzEsIGMyKTtcbiAgICB4ID0gZW1iZWQoeCwgciwgYyk7XG4gICAgeSA9IGVtYmVkKHksIHIsIGMpO1xuXG4gICAgLy8gT3VyIHJlY3Vyc2l2ZSBtdWx0aXBsaWNhdGlvbiBmdW5jdGlvbi5cbiAgICBmdW5jdGlvbiBibG9ja011bHQoYSwgYiwgcm93cywgY29scykge1xuICAgICAgLy8gRm9yIHNtYWxsIG1hdHJpY2VzLCByZXNvcnQgdG8gbmFpdmUgbXVsdGlwbGljYXRpb24uXG4gICAgICBpZiAocm93cyA8PSA1MTIgfHwgY29scyA8PSA1MTIpIHtcbiAgICAgICAgcmV0dXJuIGEubW11bChiKTsgLy8gYSBpcyBlcXVpdmFsZW50IHRvIHRoaXNcbiAgICAgIH1cblxuICAgICAgLy8gQXBwbHkgZHluYW1pYyBwYWRkaW5nLlxuICAgICAgaWYgKHJvd3MgJSAyID09PSAxICYmIGNvbHMgJSAyID09PSAxKSB7XG4gICAgICAgIGEgPSBlbWJlZChhLCByb3dzICsgMSwgY29scyArIDEpO1xuICAgICAgICBiID0gZW1iZWQoYiwgcm93cyArIDEsIGNvbHMgKyAxKTtcbiAgICAgIH0gZWxzZSBpZiAocm93cyAlIDIgPT09IDEpIHtcbiAgICAgICAgYSA9IGVtYmVkKGEsIHJvd3MgKyAxLCBjb2xzKTtcbiAgICAgICAgYiA9IGVtYmVkKGIsIHJvd3MgKyAxLCBjb2xzKTtcbiAgICAgIH0gZWxzZSBpZiAoY29scyAlIDIgPT09IDEpIHtcbiAgICAgICAgYSA9IGVtYmVkKGEsIHJvd3MsIGNvbHMgKyAxKTtcbiAgICAgICAgYiA9IGVtYmVkKGIsIHJvd3MsIGNvbHMgKyAxKTtcbiAgICAgIH1cblxuICAgICAgbGV0IGhhbGZSb3dzID0gcGFyc2VJbnQoYS5yb3dzIC8gMiwgMTApO1xuICAgICAgbGV0IGhhbGZDb2xzID0gcGFyc2VJbnQoYS5jb2x1bW5zIC8gMiwgMTApO1xuICAgICAgLy8gU3ViZGl2aWRlIGlucHV0IG1hdHJpY2VzLlxuICAgICAgbGV0IGExMSA9IGEuc3ViTWF0cml4KDAsIGhhbGZSb3dzIC0gMSwgMCwgaGFsZkNvbHMgLSAxKTtcbiAgICAgIGxldCBiMTEgPSBiLnN1Yk1hdHJpeCgwLCBoYWxmUm93cyAtIDEsIDAsIGhhbGZDb2xzIC0gMSk7XG5cbiAgICAgIGxldCBhMTIgPSBhLnN1Yk1hdHJpeCgwLCBoYWxmUm93cyAtIDEsIGhhbGZDb2xzLCBhLmNvbHVtbnMgLSAxKTtcbiAgICAgIGxldCBiMTIgPSBiLnN1Yk1hdHJpeCgwLCBoYWxmUm93cyAtIDEsIGhhbGZDb2xzLCBiLmNvbHVtbnMgLSAxKTtcblxuICAgICAgbGV0IGEyMSA9IGEuc3ViTWF0cml4KGhhbGZSb3dzLCBhLnJvd3MgLSAxLCAwLCBoYWxmQ29scyAtIDEpO1xuICAgICAgbGV0IGIyMSA9IGIuc3ViTWF0cml4KGhhbGZSb3dzLCBiLnJvd3MgLSAxLCAwLCBoYWxmQ29scyAtIDEpO1xuXG4gICAgICBsZXQgYTIyID0gYS5zdWJNYXRyaXgoaGFsZlJvd3MsIGEucm93cyAtIDEsIGhhbGZDb2xzLCBhLmNvbHVtbnMgLSAxKTtcbiAgICAgIGxldCBiMjIgPSBiLnN1Yk1hdHJpeChoYWxmUm93cywgYi5yb3dzIC0gMSwgaGFsZkNvbHMsIGIuY29sdW1ucyAtIDEpO1xuXG4gICAgICAvLyBDb21wdXRlIGludGVybWVkaWF0ZSB2YWx1ZXMuXG4gICAgICBsZXQgbTEgPSBibG9ja011bHQoXG4gICAgICAgIEFic3RyYWN0TWF0cml4LmFkZChhMTEsIGEyMiksXG4gICAgICAgIEFic3RyYWN0TWF0cml4LmFkZChiMTEsIGIyMiksXG4gICAgICAgIGhhbGZSb3dzLFxuICAgICAgICBoYWxmQ29scyxcbiAgICAgICk7XG4gICAgICBsZXQgbTIgPSBibG9ja011bHQoQWJzdHJhY3RNYXRyaXguYWRkKGEyMSwgYTIyKSwgYjExLCBoYWxmUm93cywgaGFsZkNvbHMpO1xuICAgICAgbGV0IG0zID0gYmxvY2tNdWx0KGExMSwgQWJzdHJhY3RNYXRyaXguc3ViKGIxMiwgYjIyKSwgaGFsZlJvd3MsIGhhbGZDb2xzKTtcbiAgICAgIGxldCBtNCA9IGJsb2NrTXVsdChhMjIsIEFic3RyYWN0TWF0cml4LnN1YihiMjEsIGIxMSksIGhhbGZSb3dzLCBoYWxmQ29scyk7XG4gICAgICBsZXQgbTUgPSBibG9ja011bHQoQWJzdHJhY3RNYXRyaXguYWRkKGExMSwgYTEyKSwgYjIyLCBoYWxmUm93cywgaGFsZkNvbHMpO1xuICAgICAgbGV0IG02ID0gYmxvY2tNdWx0KFxuICAgICAgICBBYnN0cmFjdE1hdHJpeC5zdWIoYTIxLCBhMTEpLFxuICAgICAgICBBYnN0cmFjdE1hdHJpeC5hZGQoYjExLCBiMTIpLFxuICAgICAgICBoYWxmUm93cyxcbiAgICAgICAgaGFsZkNvbHMsXG4gICAgICApO1xuICAgICAgbGV0IG03ID0gYmxvY2tNdWx0KFxuICAgICAgICBBYnN0cmFjdE1hdHJpeC5zdWIoYTEyLCBhMjIpLFxuICAgICAgICBBYnN0cmFjdE1hdHJpeC5hZGQoYjIxLCBiMjIpLFxuICAgICAgICBoYWxmUm93cyxcbiAgICAgICAgaGFsZkNvbHMsXG4gICAgICApO1xuXG4gICAgICAvLyBDb21iaW5lIGludGVybWVkaWF0ZSB2YWx1ZXMgaW50byB0aGUgb3V0cHV0LlxuICAgICAgbGV0IGMxMSA9IEFic3RyYWN0TWF0cml4LmFkZChtMSwgbTQpO1xuICAgICAgYzExLnN1YihtNSk7XG4gICAgICBjMTEuYWRkKG03KTtcbiAgICAgIGxldCBjMTIgPSBBYnN0cmFjdE1hdHJpeC5hZGQobTMsIG01KTtcbiAgICAgIGxldCBjMjEgPSBBYnN0cmFjdE1hdHJpeC5hZGQobTIsIG00KTtcbiAgICAgIGxldCBjMjIgPSBBYnN0cmFjdE1hdHJpeC5zdWIobTEsIG0yKTtcbiAgICAgIGMyMi5hZGQobTMpO1xuICAgICAgYzIyLmFkZChtNik7XG5cbiAgICAgIC8vIENyb3Agb3V0cHV0IHRvIHRoZSBkZXNpcmVkIHNpemUgKHVuZG8gZHluYW1pYyBwYWRkaW5nKS5cbiAgICAgIGxldCByZXN1bHQgPSBBYnN0cmFjdE1hdHJpeC56ZXJvcygyICogYzExLnJvd3MsIDIgKiBjMTEuY29sdW1ucyk7XG4gICAgICByZXN1bHQgPSByZXN1bHQuc2V0U3ViTWF0cml4KGMxMSwgMCwgMCk7XG4gICAgICByZXN1bHQgPSByZXN1bHQuc2V0U3ViTWF0cml4KGMxMiwgYzExLnJvd3MsIDApO1xuICAgICAgcmVzdWx0ID0gcmVzdWx0LnNldFN1Yk1hdHJpeChjMjEsIDAsIGMxMS5jb2x1bW5zKTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5zZXRTdWJNYXRyaXgoYzIyLCBjMTEucm93cywgYzExLmNvbHVtbnMpO1xuICAgICAgcmV0dXJuIHJlc3VsdC5zdWJNYXRyaXgoMCwgcm93cyAtIDEsIDAsIGNvbHMgLSAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYmxvY2tNdWx0KHgsIHksIHIsIGMpO1xuICB9XG5cbiAgc2NhbGVSb3dzKG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgY29uc3QgeyBtaW4gPSAwLCBtYXggPSAxIH0gPSBvcHRpb25zO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG1pbikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobWF4KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4IG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAobWluID49IG1heCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ21pbiBtdXN0IGJlIHNtYWxsZXIgdGhhbiBtYXgnKTtcbiAgICBsZXQgbmV3TWF0cml4ID0gbmV3IE1hdHJpeCh0aGlzLnJvd3MsIHRoaXMuY29sdW1ucyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgY29uc3Qgcm93ID0gdGhpcy5nZXRSb3coaSk7XG4gICAgICBpZiAocm93Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmVzY2FsZShyb3csIHsgbWluLCBtYXgsIG91dHB1dDogcm93IH0pO1xuICAgICAgfVxuICAgICAgbmV3TWF0cml4LnNldFJvdyhpLCByb3cpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3TWF0cml4O1xuICB9XG5cbiAgc2NhbGVDb2x1bW5zKG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgY29uc3QgeyBtaW4gPSAwLCBtYXggPSAxIH0gPSBvcHRpb25zO1xuICAgIGlmICghTnVtYmVyLmlzRmluaXRlKG1pbikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobWF4KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4IG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAobWluID49IG1heCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ21pbiBtdXN0IGJlIHNtYWxsZXIgdGhhbiBtYXgnKTtcbiAgICBsZXQgbmV3TWF0cml4ID0gbmV3IE1hdHJpeCh0aGlzLnJvd3MsIHRoaXMuY29sdW1ucyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbHVtbnM7IGkrKykge1xuICAgICAgY29uc3QgY29sdW1uID0gdGhpcy5nZXRDb2x1bW4oaSk7XG4gICAgICBpZiAoY29sdW1uLmxlbmd0aCkge1xuICAgICAgICByZXNjYWxlKGNvbHVtbiwge1xuICAgICAgICAgIG1pbixcbiAgICAgICAgICBtYXgsXG4gICAgICAgICAgb3V0cHV0OiBjb2x1bW4sXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgbmV3TWF0cml4LnNldENvbHVtbihpLCBjb2x1bW4pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3TWF0cml4O1xuICB9XG5cbiAgZmxpcFJvd3MoKSB7XG4gICAgY29uc3QgbWlkZGxlID0gTWF0aC5jZWlsKHRoaXMuY29sdW1ucyAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbWlkZGxlOyBqKyspIHtcbiAgICAgICAgbGV0IGZpcnN0ID0gdGhpcy5nZXQoaSwgaik7XG4gICAgICAgIGxldCBsYXN0ID0gdGhpcy5nZXQoaSwgdGhpcy5jb2x1bW5zIC0gMSAtIGopO1xuICAgICAgICB0aGlzLnNldChpLCBqLCBsYXN0KTtcbiAgICAgICAgdGhpcy5zZXQoaSwgdGhpcy5jb2x1bW5zIC0gMSAtIGosIGZpcnN0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBmbGlwQ29sdW1ucygpIHtcbiAgICBjb25zdCBtaWRkbGUgPSBNYXRoLmNlaWwodGhpcy5yb3dzIC8gMik7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtaWRkbGU7IGkrKykge1xuICAgICAgICBsZXQgZmlyc3QgPSB0aGlzLmdldChpLCBqKTtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmdldCh0aGlzLnJvd3MgLSAxIC0gaSwgaik7XG4gICAgICAgIHRoaXMuc2V0KGksIGosIGxhc3QpO1xuICAgICAgICB0aGlzLnNldCh0aGlzLnJvd3MgLSAxIC0gaSwgaiwgZmlyc3QpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGtyb25lY2tlclByb2R1Y3Qob3RoZXIpIHtcbiAgICBvdGhlciA9IE1hdHJpeC5jaGVja01hdHJpeChvdGhlcik7XG5cbiAgICBsZXQgbSA9IHRoaXMucm93cztcbiAgICBsZXQgbiA9IHRoaXMuY29sdW1ucztcbiAgICBsZXQgcCA9IG90aGVyLnJvd3M7XG4gICAgbGV0IHEgPSBvdGhlci5jb2x1bW5zO1xuXG4gICAgbGV0IHJlc3VsdCA9IG5ldyBNYXRyaXgobSAqIHAsIG4gKiBxKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBwOyBrKyspIHtcbiAgICAgICAgICBmb3IgKGxldCBsID0gMDsgbCA8IHE7IGwrKykge1xuICAgICAgICAgICAgcmVzdWx0LnNldChwICogaSArIGssIHEgKiBqICsgbCwgdGhpcy5nZXQoaSwgaikgKiBvdGhlci5nZXQoaywgbCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAga3JvbmVja2VyU3VtKG90aGVyKSB7XG4gICAgb3RoZXIgPSBNYXRyaXguY2hlY2tNYXRyaXgob3RoZXIpO1xuICAgIGlmICghdGhpcy5pc1NxdWFyZSgpIHx8ICFvdGhlci5pc1NxdWFyZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0tyb25lY2tlciBTdW0gbmVlZHMgdHdvIFNxdWFyZSBNYXRyaWNlcycpO1xuICAgIH1cbiAgICBsZXQgbSA9IHRoaXMucm93cztcbiAgICBsZXQgbiA9IG90aGVyLnJvd3M7XG4gICAgbGV0IEF4SSA9IHRoaXMua3JvbmVja2VyUHJvZHVjdChNYXRyaXguZXllKG4sIG4pKTtcbiAgICBsZXQgSXhCID0gTWF0cml4LmV5ZShtLCBtKS5rcm9uZWNrZXJQcm9kdWN0KG90aGVyKTtcbiAgICByZXR1cm4gQXhJLmFkZChJeEIpO1xuICB9XG5cbiAgdHJhbnNwb3NlKCkge1xuICAgIGxldCByZXN1bHQgPSBuZXcgTWF0cml4KHRoaXMuY29sdW1ucywgdGhpcy5yb3dzKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMuY29sdW1uczsgaisrKSB7XG4gICAgICAgIHJlc3VsdC5zZXQoaiwgaSwgdGhpcy5nZXQoaSwgaikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgc29ydFJvd3MoY29tcGFyZUZ1bmN0aW9uID0gY29tcGFyZU51bWJlcnMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICB0aGlzLnNldFJvdyhpLCB0aGlzLmdldFJvdyhpKS5zb3J0KGNvbXBhcmVGdW5jdGlvbikpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNvcnRDb2x1bW5zKGNvbXBhcmVGdW5jdGlvbiA9IGNvbXBhcmVOdW1iZXJzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbHVtbnM7IGkrKykge1xuICAgICAgdGhpcy5zZXRDb2x1bW4oaSwgdGhpcy5nZXRDb2x1bW4oaSkuc29ydChjb21wYXJlRnVuY3Rpb24pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBzdWJNYXRyaXgoc3RhcnRSb3csIGVuZFJvdywgc3RhcnRDb2x1bW4sIGVuZENvbHVtbikge1xuICAgIGNoZWNrUmFuZ2UodGhpcywgc3RhcnRSb3csIGVuZFJvdywgc3RhcnRDb2x1bW4sIGVuZENvbHVtbik7XG4gICAgbGV0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgoXG4gICAgICBlbmRSb3cgLSBzdGFydFJvdyArIDEsXG4gICAgICBlbmRDb2x1bW4gLSBzdGFydENvbHVtbiArIDEsXG4gICAgKTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnRSb3c7IGkgPD0gZW5kUm93OyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSBzdGFydENvbHVtbjsgaiA8PSBlbmRDb2x1bW47IGorKykge1xuICAgICAgICBuZXdNYXRyaXguc2V0KGkgLSBzdGFydFJvdywgaiAtIHN0YXJ0Q29sdW1uLCB0aGlzLmdldChpLCBqKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdNYXRyaXg7XG4gIH1cblxuICBzdWJNYXRyaXhSb3coaW5kaWNlcywgc3RhcnRDb2x1bW4sIGVuZENvbHVtbikge1xuICAgIGlmIChzdGFydENvbHVtbiA9PT0gdW5kZWZpbmVkKSBzdGFydENvbHVtbiA9IDA7XG4gICAgaWYgKGVuZENvbHVtbiA9PT0gdW5kZWZpbmVkKSBlbmRDb2x1bW4gPSB0aGlzLmNvbHVtbnMgLSAxO1xuICAgIGlmIChcbiAgICAgIHN0YXJ0Q29sdW1uID4gZW5kQ29sdW1uIHx8XG4gICAgICBzdGFydENvbHVtbiA8IDAgfHxcbiAgICAgIHN0YXJ0Q29sdW1uID49IHRoaXMuY29sdW1ucyB8fFxuICAgICAgZW5kQ29sdW1uIDwgMCB8fFxuICAgICAgZW5kQ29sdW1uID49IHRoaXMuY29sdW1uc1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0FyZ3VtZW50IG91dCBvZiByYW5nZScpO1xuICAgIH1cblxuICAgIGxldCBuZXdNYXRyaXggPSBuZXcgTWF0cml4KGluZGljZXMubGVuZ3RoLCBlbmRDb2x1bW4gLSBzdGFydENvbHVtbiArIDEpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IHN0YXJ0Q29sdW1uOyBqIDw9IGVuZENvbHVtbjsgaisrKSB7XG4gICAgICAgIGlmIChpbmRpY2VzW2ldIDwgMCB8fCBpbmRpY2VzW2ldID49IHRoaXMucm93cykge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBSb3cgaW5kZXggb3V0IG9mIHJhbmdlOiAke2luZGljZXNbaV19YCk7XG4gICAgICAgIH1cbiAgICAgICAgbmV3TWF0cml4LnNldChpLCBqIC0gc3RhcnRDb2x1bW4sIHRoaXMuZ2V0KGluZGljZXNbaV0sIGopKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld01hdHJpeDtcbiAgfVxuXG4gIHN1Yk1hdHJpeENvbHVtbihpbmRpY2VzLCBzdGFydFJvdywgZW5kUm93KSB7XG4gICAgaWYgKHN0YXJ0Um93ID09PSB1bmRlZmluZWQpIHN0YXJ0Um93ID0gMDtcbiAgICBpZiAoZW5kUm93ID09PSB1bmRlZmluZWQpIGVuZFJvdyA9IHRoaXMucm93cyAtIDE7XG4gICAgaWYgKFxuICAgICAgc3RhcnRSb3cgPiBlbmRSb3cgfHxcbiAgICAgIHN0YXJ0Um93IDwgMCB8fFxuICAgICAgc3RhcnRSb3cgPj0gdGhpcy5yb3dzIHx8XG4gICAgICBlbmRSb3cgPCAwIHx8XG4gICAgICBlbmRSb3cgPj0gdGhpcy5yb3dzXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXJndW1lbnQgb3V0IG9mIHJhbmdlJyk7XG4gICAgfVxuXG4gICAgbGV0IG5ld01hdHJpeCA9IG5ldyBNYXRyaXgoZW5kUm93IC0gc3RhcnRSb3cgKyAxLCBpbmRpY2VzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gc3RhcnRSb3c7IGogPD0gZW5kUm93OyBqKyspIHtcbiAgICAgICAgaWYgKGluZGljZXNbaV0gPCAwIHx8IGluZGljZXNbaV0gPj0gdGhpcy5jb2x1bW5zKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYENvbHVtbiBpbmRleCBvdXQgb2YgcmFuZ2U6ICR7aW5kaWNlc1tpXX1gKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdNYXRyaXguc2V0KGogLSBzdGFydFJvdywgaSwgdGhpcy5nZXQoaiwgaW5kaWNlc1tpXSkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3TWF0cml4O1xuICB9XG5cbiAgc2V0U3ViTWF0cml4KG1hdHJpeCwgc3RhcnRSb3csIHN0YXJ0Q29sdW1uKSB7XG4gICAgbWF0cml4ID0gTWF0cml4LmNoZWNrTWF0cml4KG1hdHJpeCk7XG4gICAgaWYgKG1hdHJpeC5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBsZXQgZW5kUm93ID0gc3RhcnRSb3cgKyBtYXRyaXgucm93cyAtIDE7XG4gICAgbGV0IGVuZENvbHVtbiA9IHN0YXJ0Q29sdW1uICsgbWF0cml4LmNvbHVtbnMgLSAxO1xuICAgIGNoZWNrUmFuZ2UodGhpcywgc3RhcnRSb3csIGVuZFJvdywgc3RhcnRDb2x1bW4sIGVuZENvbHVtbik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRyaXgucm93czsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG1hdHJpeC5jb2x1bW5zOyBqKyspIHtcbiAgICAgICAgdGhpcy5zZXQoc3RhcnRSb3cgKyBpLCBzdGFydENvbHVtbiArIGosIG1hdHJpeC5nZXQoaSwgaikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHNlbGVjdGlvbihyb3dJbmRpY2VzLCBjb2x1bW5JbmRpY2VzKSB7XG4gICAgY2hlY2tSb3dJbmRpY2VzKHRoaXMsIHJvd0luZGljZXMpO1xuICAgIGNoZWNrQ29sdW1uSW5kaWNlcyh0aGlzLCBjb2x1bW5JbmRpY2VzKTtcbiAgICBsZXQgbmV3TWF0cml4ID0gbmV3IE1hdHJpeChyb3dJbmRpY2VzLmxlbmd0aCwgY29sdW1uSW5kaWNlcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcm93SW5kaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHJvd0luZGV4ID0gcm93SW5kaWNlc1tpXTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sdW1uSW5kaWNlcy5sZW5ndGg7IGorKykge1xuICAgICAgICBsZXQgY29sdW1uSW5kZXggPSBjb2x1bW5JbmRpY2VzW2pdO1xuICAgICAgICBuZXdNYXRyaXguc2V0KGksIGosIHRoaXMuZ2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3TWF0cml4O1xuICB9XG5cbiAgdHJhY2UoKSB7XG4gICAgbGV0IG1pbiA9IE1hdGgubWluKHRoaXMucm93cywgdGhpcy5jb2x1bW5zKTtcbiAgICBsZXQgdHJhY2UgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWluOyBpKyspIHtcbiAgICAgIHRyYWNlICs9IHRoaXMuZ2V0KGksIGkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhY2U7XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5jb3B5KHRoaXMsIG5ldyBNYXRyaXgodGhpcy5yb3dzLCB0aGlzLmNvbHVtbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdGVtcGxhdGUge0Fic3RyYWN0TWF0cml4fSBNXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RNYXRyaXh9IGZyb21cbiAgICogQHBhcmFtIHtNfSB0b1xuICAgKiBAcmV0dXJuIHtNfVxuICAgKi9cbiAgc3RhdGljIGNvcHkoZnJvbSwgdG8pIHtcbiAgICBmb3IgKGNvbnN0IFtyb3csIGNvbHVtbiwgdmFsdWVdIG9mIGZyb20uZW50cmllcygpKSB7XG4gICAgICB0by5zZXQocm93LCBjb2x1bW4sIHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdG87XG4gIH1cblxuICBzdW0oYnkpIHtcbiAgICBzd2l0Y2ggKGJ5KSB7XG4gICAgICBjYXNlICdyb3cnOlxuICAgICAgICByZXR1cm4gc3VtQnlSb3codGhpcyk7XG4gICAgICBjYXNlICdjb2x1bW4nOlxuICAgICAgICByZXR1cm4gc3VtQnlDb2x1bW4odGhpcyk7XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHN1bUFsbCh0aGlzKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvcHRpb246ICR7Ynl9YCk7XG4gICAgfVxuICB9XG5cbiAgcHJvZHVjdChieSkge1xuICAgIHN3aXRjaCAoYnkpIHtcbiAgICAgIGNhc2UgJ3Jvdyc6XG4gICAgICAgIHJldHVybiBwcm9kdWN0QnlSb3codGhpcyk7XG4gICAgICBjYXNlICdjb2x1bW4nOlxuICAgICAgICByZXR1cm4gcHJvZHVjdEJ5Q29sdW1uKHRoaXMpO1xuICAgICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiBwcm9kdWN0QWxsKHRoaXMpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG9wdGlvbjogJHtieX1gKTtcbiAgICB9XG4gIH1cblxuICBtZWFuKGJ5KSB7XG4gICAgY29uc3Qgc3VtID0gdGhpcy5zdW0oYnkpO1xuICAgIHN3aXRjaCAoYnkpIHtcbiAgICAgIGNhc2UgJ3Jvdyc6IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnJvd3M7IGkrKykge1xuICAgICAgICAgIHN1bVtpXSAvPSB0aGlzLmNvbHVtbnM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2NvbHVtbic6IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNvbHVtbnM7IGkrKykge1xuICAgICAgICAgIHN1bVtpXSAvPSB0aGlzLnJvd3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgIH1cbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gc3VtIC8gdGhpcy5zaXplO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG9wdGlvbjogJHtieX1gKTtcbiAgICB9XG4gIH1cblxuICB2YXJpYW5jZShieSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgaWYgKHR5cGVvZiBieSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG9wdGlvbnMgPSBieTtcbiAgICAgIGJ5ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gICAgfVxuICAgIGNvbnN0IHsgdW5iaWFzZWQgPSB0cnVlLCBtZWFuID0gdGhpcy5tZWFuKGJ5KSB9ID0gb3B0aW9ucztcbiAgICBpZiAodHlwZW9mIHVuYmlhc2VkICE9PSAnYm9vbGVhbicpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VuYmlhc2VkIG11c3QgYmUgYSBib29sZWFuJyk7XG4gICAgfVxuICAgIHN3aXRjaCAoYnkpIHtcbiAgICAgIGNhc2UgJ3Jvdyc6IHtcbiAgICAgICAgaWYgKCFpc0FueUFycmF5LmlzQW55QXJyYXkobWVhbikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtZWFuIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFyaWFuY2VCeVJvdyh0aGlzLCB1bmJpYXNlZCwgbWVhbik7XG4gICAgICB9XG4gICAgICBjYXNlICdjb2x1bW4nOiB7XG4gICAgICAgIGlmICghaXNBbnlBcnJheS5pc0FueUFycmF5KG1lYW4pKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWVhbiBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhcmlhbmNlQnlDb2x1bW4odGhpcywgdW5iaWFzZWQsIG1lYW4pO1xuICAgICAgfVxuICAgICAgY2FzZSB1bmRlZmluZWQ6IHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZWFuICE9PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21lYW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YXJpYW5jZUFsbCh0aGlzLCB1bmJpYXNlZCwgbWVhbik7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3B0aW9uOiAke2J5fWApO1xuICAgIH1cbiAgfVxuXG4gIHN0YW5kYXJkRGV2aWF0aW9uKGJ5LCBvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBieSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG9wdGlvbnMgPSBieTtcbiAgICAgIGJ5ID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCB2YXJpYW5jZSA9IHRoaXMudmFyaWFuY2UoYnksIG9wdGlvbnMpO1xuICAgIGlmIChieSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gTWF0aC5zcXJ0KHZhcmlhbmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YXJpYW5jZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXJpYW5jZVtpXSA9IE1hdGguc3FydCh2YXJpYW5jZVtpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFyaWFuY2U7XG4gICAgfVxuICB9XG5cbiAgY2VudGVyKGJ5LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodHlwZW9mIGJ5ID09PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9ucyA9IGJ5O1xuICAgICAgYnkgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgY29uc3QgeyBjZW50ZXIgPSB0aGlzLm1lYW4oYnkpIH0gPSBvcHRpb25zO1xuICAgIHN3aXRjaCAoYnkpIHtcbiAgICAgIGNhc2UgJ3Jvdyc6IHtcbiAgICAgICAgaWYgKCFpc0FueUFycmF5LmlzQW55QXJyYXkoY2VudGVyKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NlbnRlciBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY2VudGVyQnlSb3codGhpcywgY2VudGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBjYXNlICdjb2x1bW4nOiB7XG4gICAgICAgIGlmICghaXNBbnlBcnJheS5pc0FueUFycmF5KGNlbnRlcikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjZW50ZXIgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIGNlbnRlckJ5Q29sdW1uKHRoaXMsIGNlbnRlcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgY2FzZSB1bmRlZmluZWQ6IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjZW50ZXIgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2VudGVyIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjZW50ZXJBbGwodGhpcywgY2VudGVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3B0aW9uOiAke2J5fWApO1xuICAgIH1cbiAgfVxuXG4gIHNjYWxlKGJ5LCBvcHRpb25zID0ge30pIHtcbiAgICBpZiAodHlwZW9mIGJ5ID09PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9ucyA9IGJ5O1xuICAgICAgYnkgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICB9XG4gICAgbGV0IHNjYWxlID0gb3B0aW9ucy5zY2FsZTtcbiAgICBzd2l0Y2ggKGJ5KSB7XG4gICAgICBjYXNlICdyb3cnOiB7XG4gICAgICAgIGlmIChzY2FsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2NhbGUgPSBnZXRTY2FsZUJ5Um93KHRoaXMpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc0FueUFycmF5LmlzQW55QXJyYXkoc2NhbGUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc2NhbGUgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIHNjYWxlQnlSb3codGhpcywgc2NhbGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGNhc2UgJ2NvbHVtbic6IHtcbiAgICAgICAgaWYgKHNjYWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzY2FsZSA9IGdldFNjYWxlQnlDb2x1bW4odGhpcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzQW55QXJyYXkuaXNBbnlBcnJheShzY2FsZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzY2FsZSBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgc2NhbGVCeUNvbHVtbih0aGlzLCBzY2FsZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgY2FzZSB1bmRlZmluZWQ6IHtcbiAgICAgICAgaWYgKHNjYWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBzY2FsZSA9IGdldFNjYWxlQWxsKHRoaXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBzY2FsZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzY2FsZSBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgc2NhbGVBbGwodGhpcywgc2NhbGUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvcHRpb246ICR7Ynl9YCk7XG4gICAgfVxuICB9XG5cbiAgdG9TdHJpbmcob3B0aW9ucykge1xuICAgIHJldHVybiBpbnNwZWN0TWF0cml4V2l0aE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gIH1cblxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCk7XG4gIH1cblxuICAvKipcbiAgICogaXRlcmF0b3IgZnJvbSBsZWZ0IHRvIHJpZ2h0LCBmcm9tIHRvcCB0byBib3R0b21cbiAgICogeWllbGQgW3JvdywgY29sdW1uLCB2YWx1ZV1cbiAgICogQHJldHVybnMge0dlbmVyYXRvcjxbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIHZvaWQsIHZvaWQ+fVxuICAgKi9cbiAgKmVudHJpZXMoKSB7XG4gICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgdGhpcy5yb3dzOyByb3crKykge1xuICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgdGhpcy5jb2x1bW5zOyBjb2wrKykge1xuICAgICAgICB5aWVsZCBbcm93LCBjb2wsIHRoaXMuZ2V0KHJvdywgY29sKV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGl0ZXJhdG9yIGZyb20gbGVmdCB0byByaWdodCwgZnJvbSB0b3AgdG8gYm90dG9tXG4gICAqIHlpZWxkIHZhbHVlXG4gICAqIEByZXR1cm5zIHtHZW5lcmF0b3I8bnVtYmVyLCB2b2lkLCB2b2lkPn1cbiAgICovXG4gICp2YWx1ZXMoKSB7XG4gICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgdGhpcy5yb3dzOyByb3crKykge1xuICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgdGhpcy5jb2x1bW5zOyBjb2wrKykge1xuICAgICAgICB5aWVsZCB0aGlzLmdldChyb3csIGNvbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbkFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5rbGFzcyA9ICdNYXRyaXgnO1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnKSB7XG4gIEFic3RyYWN0TWF0cml4LnByb3RvdHlwZVtTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXSA9XG4gICAgaW5zcGVjdE1hdHJpeDtcbn1cblxuZnVuY3Rpb24gY29tcGFyZU51bWJlcnMoYSwgYikge1xuICByZXR1cm4gYSAtIGI7XG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlPZk51bWJlcnMoYXJyYXkpIHtcbiAgcmV0dXJuIGFycmF5LmV2ZXJ5KChlbGVtZW50KSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJztcbiAgfSk7XG59XG5cbi8vIFN5bm9ueW1zXG5BYnN0cmFjdE1hdHJpeC5yYW5kb20gPSBBYnN0cmFjdE1hdHJpeC5yYW5kO1xuQWJzdHJhY3RNYXRyaXgucmFuZG9tSW50ID0gQWJzdHJhY3RNYXRyaXgucmFuZEludDtcbkFic3RyYWN0TWF0cml4LmRpYWdvbmFsID0gQWJzdHJhY3RNYXRyaXguZGlhZztcbkFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5kaWFnb25hbCA9IEFic3RyYWN0TWF0cml4LnByb3RvdHlwZS5kaWFnO1xuQWJzdHJhY3RNYXRyaXguaWRlbnRpdHkgPSBBYnN0cmFjdE1hdHJpeC5leWU7XG5BYnN0cmFjdE1hdHJpeC5wcm90b3R5cGUubmVnYXRlID0gQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLm5lZztcbkFic3RyYWN0TWF0cml4LnByb3RvdHlwZS50ZW5zb3JQcm9kdWN0ID1cbiAgQWJzdHJhY3RNYXRyaXgucHJvdG90eXBlLmtyb25lY2tlclByb2R1Y3Q7XG5cbmNsYXNzIE1hdHJpeCBleHRlbmRzIEFic3RyYWN0TWF0cml4IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtGbG9hdDY0QXJyYXlbXX1cbiAgICovXG4gIGRhdGE7XG5cbiAgLyoqXG4gICAqIEluaXQgYW4gZW1wdHkgbWF0cml4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuUm93c1xuICAgKiBAcGFyYW0ge251bWJlcn0gbkNvbHVtbnNcbiAgICovXG4gICNpbml0RGF0YShuUm93cywgbkNvbHVtbnMpIHtcbiAgICB0aGlzLmRhdGEgPSBbXTtcblxuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKG5Db2x1bW5zKSAmJiBuQ29sdW1ucyA+PSAwKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5Sb3dzOyBpKyspIHtcbiAgICAgICAgdGhpcy5kYXRhLnB1c2gobmV3IEZsb2F0NjRBcnJheShuQ29sdW1ucykpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCduQ29sdW1ucyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlcicpO1xuICAgIH1cblxuICAgIHRoaXMucm93cyA9IG5Sb3dzO1xuICAgIHRoaXMuY29sdW1ucyA9IG5Db2x1bW5zO1xuICB9XG5cbiAgY29uc3RydWN0b3IoblJvd3MsIG5Db2x1bW5zKSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZiAoTWF0cml4LmlzTWF0cml4KG5Sb3dzKSkge1xuICAgICAgdGhpcy4jaW5pdERhdGEoblJvd3Mucm93cywgblJvd3MuY29sdW1ucyk7XG4gICAgICBNYXRyaXguY29weShuUm93cywgdGhpcyk7XG4gICAgfSBlbHNlIGlmIChOdW1iZXIuaXNJbnRlZ2VyKG5Sb3dzKSAmJiBuUm93cyA+PSAwKSB7XG4gICAgICB0aGlzLiNpbml0RGF0YShuUm93cywgbkNvbHVtbnMpO1xuICAgIH0gZWxzZSBpZiAoaXNBbnlBcnJheS5pc0FueUFycmF5KG5Sb3dzKSkge1xuICAgICAgLy8gQ29weSB0aGUgdmFsdWVzIGZyb20gdGhlIDJEIGFycmF5XG4gICAgICBjb25zdCBhcnJheURhdGEgPSBuUm93cztcbiAgICAgIG5Sb3dzID0gYXJyYXlEYXRhLmxlbmd0aDtcbiAgICAgIG5Db2x1bW5zID0gblJvd3MgPyBhcnJheURhdGFbMF0ubGVuZ3RoIDogMDtcbiAgICAgIGlmICh0eXBlb2YgbkNvbHVtbnMgIT09ICdudW1iZXInKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ0RhdGEgbXVzdCBiZSBhIDJEIGFycmF5IHdpdGggYXQgbGVhc3Qgb25lIGVsZW1lbnQnLFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdGhpcy5kYXRhID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgblJvd3M7IGkrKykge1xuICAgICAgICBpZiAoYXJyYXlEYXRhW2ldLmxlbmd0aCAhPT0gbkNvbHVtbnMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5jb25zaXN0ZW50IGFycmF5IGRpbWVuc2lvbnMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQXJyYXlPZk51bWJlcnMoYXJyYXlEYXRhW2ldKSkge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0lucHV0IGRhdGEgY29udGFpbnMgbm9uLW51bWVyaWMgdmFsdWVzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhLnB1c2goRmxvYXQ2NEFycmF5LmZyb20oYXJyYXlEYXRhW2ldKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucm93cyA9IG5Sb3dzO1xuICAgICAgdGhpcy5jb2x1bW5zID0gbkNvbHVtbnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyIG9yIGFuIGFycmF5JyxcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgc2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCwgdmFsdWUpIHtcbiAgICB0aGlzLmRhdGFbcm93SW5kZXhdW2NvbHVtbkluZGV4XSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCkge1xuICAgIHJldHVybiB0aGlzLmRhdGFbcm93SW5kZXhdW2NvbHVtbkluZGV4XTtcbiAgfVxuXG4gIHJlbW92ZVJvdyhpbmRleCkge1xuICAgIGNoZWNrUm93SW5kZXgodGhpcywgaW5kZXgpO1xuICAgIHRoaXMuZGF0YS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHRoaXMucm93cyAtPSAxO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgYWRkUm93KGluZGV4LCBhcnJheSkge1xuICAgIGlmIChhcnJheSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhcnJheSA9IGluZGV4O1xuICAgICAgaW5kZXggPSB0aGlzLnJvd3M7XG4gICAgfVxuICAgIGNoZWNrUm93SW5kZXgodGhpcywgaW5kZXgsIHRydWUpO1xuICAgIGFycmF5ID0gRmxvYXQ2NEFycmF5LmZyb20oY2hlY2tSb3dWZWN0b3IodGhpcywgYXJyYXkpKTtcbiAgICB0aGlzLmRhdGEuc3BsaWNlKGluZGV4LCAwLCBhcnJheSk7XG4gICAgdGhpcy5yb3dzICs9IDE7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZW1vdmVDb2x1bW4oaW5kZXgpIHtcbiAgICBjaGVja0NvbHVtbkluZGV4KHRoaXMsIGluZGV4KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBjb25zdCBuZXdSb3cgPSBuZXcgRmxvYXQ2NEFycmF5KHRoaXMuY29sdW1ucyAtIDEpO1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBpbmRleDsgaisrKSB7XG4gICAgICAgIG5ld1Jvd1tqXSA9IHRoaXMuZGF0YVtpXVtqXTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGogPSBpbmRleCArIDE7IGogPCB0aGlzLmNvbHVtbnM7IGorKykge1xuICAgICAgICBuZXdSb3dbaiAtIDFdID0gdGhpcy5kYXRhW2ldW2pdO1xuICAgICAgfVxuICAgICAgdGhpcy5kYXRhW2ldID0gbmV3Um93O1xuICAgIH1cbiAgICB0aGlzLmNvbHVtbnMgLT0gMTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGFkZENvbHVtbihpbmRleCwgYXJyYXkpIHtcbiAgICBpZiAodHlwZW9mIGFycmF5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgYXJyYXkgPSBpbmRleDtcbiAgICAgIGluZGV4ID0gdGhpcy5jb2x1bW5zO1xuICAgIH1cbiAgICBjaGVja0NvbHVtbkluZGV4KHRoaXMsIGluZGV4LCB0cnVlKTtcbiAgICBhcnJheSA9IGNoZWNrQ29sdW1uVmVjdG9yKHRoaXMsIGFycmF5KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucm93czsgaSsrKSB7XG4gICAgICBjb25zdCBuZXdSb3cgPSBuZXcgRmxvYXQ2NEFycmF5KHRoaXMuY29sdW1ucyArIDEpO1xuICAgICAgbGV0IGogPSAwO1xuICAgICAgZm9yICg7IGogPCBpbmRleDsgaisrKSB7XG4gICAgICAgIG5ld1Jvd1tqXSA9IHRoaXMuZGF0YVtpXVtqXTtcbiAgICAgIH1cbiAgICAgIG5ld1Jvd1tqKytdID0gYXJyYXlbaV07XG4gICAgICBmb3IgKDsgaiA8IHRoaXMuY29sdW1ucyArIDE7IGorKykge1xuICAgICAgICBuZXdSb3dbal0gPSB0aGlzLmRhdGFbaV1baiAtIDFdO1xuICAgICAgfVxuICAgICAgdGhpcy5kYXRhW2ldID0gbmV3Um93O1xuICAgIH1cbiAgICB0aGlzLmNvbHVtbnMgKz0gMTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5pbnN0YWxsTWF0aE9wZXJhdGlvbnMoQWJzdHJhY3RNYXRyaXgsIE1hdHJpeCk7XG5cbi8qKlxuICogQHR5cGVkZWYgezAgfCAxIHwgbnVtYmVyIHwgYm9vbGVhbn0gTWFza1xuICovXG5cbmNsYXNzIFN5bW1ldHJpY01hdHJpeCBleHRlbmRzIEFic3RyYWN0TWF0cml4IHtcbiAgLyoqIEB0eXBlIHtNYXRyaXh9ICovXG4gICNtYXRyaXg7XG5cbiAgZ2V0IHNpemUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21hdHJpeC5zaXplO1xuICB9XG5cbiAgZ2V0IHJvd3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21hdHJpeC5yb3dzO1xuICB9XG5cbiAgZ2V0IGNvbHVtbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21hdHJpeC5jb2x1bW5zO1xuICB9XG5cbiAgZ2V0IGRpYWdvbmFsU2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5yb3dzO1xuICB9XG5cbiAgLyoqXG4gICAqIG5vdCB0aGUgc2FtZSBhcyBtYXRyaXguaXNTeW1tZXRyaWMoKVxuICAgKiBIZXJlIGlzIHRvIGNoZWNrIGlmIGl0J3MgaW5zdGFuY2VvZiBTeW1tZXRyaWNNYXRyaXggd2l0aG91dCBidW5kbGluZyBpc3N1ZXNcbiAgICpcbiAgICogQHBhcmFtIHZhbHVlXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgc3RhdGljIGlzU3ltbWV0cmljTWF0cml4KHZhbHVlKSB7XG4gICAgcmV0dXJuIE1hdHJpeC5pc01hdHJpeCh2YWx1ZSkgJiYgdmFsdWUua2xhc3NUeXBlID09PSAnU3ltbWV0cmljTWF0cml4JztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gZGlhZ29uYWxTaXplXG4gICAqIEByZXR1cm4ge1N5bW1ldHJpY01hdHJpeH1cbiAgICovXG4gIHN0YXRpYyB6ZXJvcyhkaWFnb25hbFNpemUpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMoZGlhZ29uYWxTaXplKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gZGlhZ29uYWxTaXplXG4gICAqIEByZXR1cm4ge1N5bW1ldHJpY01hdHJpeH1cbiAgICovXG4gIHN0YXRpYyBvbmVzKGRpYWdvbmFsU2l6ZSkge1xuICAgIHJldHVybiBuZXcgdGhpcyhkaWFnb25hbFNpemUpLmZpbGwoMSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXIgfCBBYnN0cmFjdE1hdHJpeCB8IEFycmF5TGlrZTxBcnJheUxpa2U8bnVtYmVyPj59IGRpYWdvbmFsU2l6ZVxuICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgKi9cbiAgY29uc3RydWN0b3IoZGlhZ29uYWxTaXplKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGlmIChNYXRyaXguaXNNYXRyaXgoZGlhZ29uYWxTaXplKSkge1xuICAgICAgaWYgKCFkaWFnb25hbFNpemUuaXNTeW1tZXRyaWMoKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3Qgc3ltbWV0cmljIGRhdGEnKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy4jbWF0cml4ID0gTWF0cml4LmNvcHkoXG4gICAgICAgIGRpYWdvbmFsU2l6ZSxcbiAgICAgICAgbmV3IE1hdHJpeChkaWFnb25hbFNpemUucm93cywgZGlhZ29uYWxTaXplLnJvd3MpLFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKE51bWJlci5pc0ludGVnZXIoZGlhZ29uYWxTaXplKSAmJiBkaWFnb25hbFNpemUgPj0gMCkge1xuICAgICAgdGhpcy4jbWF0cml4ID0gbmV3IE1hdHJpeChkaWFnb25hbFNpemUsIGRpYWdvbmFsU2l6ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI21hdHJpeCA9IG5ldyBNYXRyaXgoZGlhZ29uYWxTaXplKTtcblxuICAgICAgaWYgKCF0aGlzLmlzU3ltbWV0cmljKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm90IHN5bW1ldHJpYyBkYXRhJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgbWF0cml4ID0gbmV3IFN5bW1ldHJpY01hdHJpeCh0aGlzLmRpYWdvbmFsU2l6ZSk7XG5cbiAgICBmb3IgKGNvbnN0IFtyb3csIGNvbCwgdmFsdWVdIG9mIHRoaXMudXBwZXJSaWdodEVudHJpZXMoKSkge1xuICAgICAgbWF0cml4LnNldChyb3csIGNvbCwgdmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRyaXg7XG4gIH1cblxuICB0b01hdHJpeCgpIHtcbiAgICByZXR1cm4gbmV3IE1hdHJpeCh0aGlzKTtcbiAgfVxuXG4gIGdldChyb3dJbmRleCwgY29sdW1uSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy4jbWF0cml4LmdldChyb3dJbmRleCwgY29sdW1uSW5kZXgpO1xuICB9XG4gIHNldChyb3dJbmRleCwgY29sdW1uSW5kZXgsIHZhbHVlKSB7XG4gICAgLy8gc3ltbWV0cmljIHNldFxuICAgIHRoaXMuI21hdHJpeC5zZXQocm93SW5kZXgsIGNvbHVtbkluZGV4LCB2YWx1ZSk7XG4gICAgdGhpcy4jbWF0cml4LnNldChjb2x1bW5JbmRleCwgcm93SW5kZXgsIHZhbHVlKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgcmVtb3ZlQ3Jvc3MoaW5kZXgpIHtcbiAgICAvLyBzeW1tZXRyaWMgcmVtb3ZlIHNpZGVcbiAgICB0aGlzLiNtYXRyaXgucmVtb3ZlUm93KGluZGV4KTtcbiAgICB0aGlzLiNtYXRyaXgucmVtb3ZlQ29sdW1uKGluZGV4KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgYWRkQ3Jvc3MoaW5kZXgsIGFycmF5KSB7XG4gICAgaWYgKGFycmF5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFycmF5ID0gaW5kZXg7XG4gICAgICBpbmRleCA9IHRoaXMuZGlhZ29uYWxTaXplO1xuICAgIH1cblxuICAgIGNvbnN0IHJvdyA9IGFycmF5LnNsaWNlKCk7XG4gICAgcm93LnNwbGljZShpbmRleCwgMSk7XG5cbiAgICB0aGlzLiNtYXRyaXguYWRkUm93KGluZGV4LCByb3cpO1xuICAgIHRoaXMuI21hdHJpeC5hZGRDb2x1bW4oaW5kZXgsIGFycmF5KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TWFza1tdfSBtYXNrXG4gICAqL1xuICBhcHBseU1hc2sobWFzaykge1xuICAgIGlmIChtYXNrLmxlbmd0aCAhPT0gdGhpcy5kaWFnb25hbFNpemUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdNYXNrIHNpemUgZG8gbm90IG1hdGNoIHdpdGggbWF0cml4IHNpemUnKTtcbiAgICB9XG5cbiAgICAvLyBwcmVwYXJlIHNpZGVzIHRvIHJlbW92ZSBmcm9tIG1hdHJpeCBmcm9tIG1hc2tcbiAgICAvKiogQHR5cGUge251bWJlcltdfSAqL1xuICAgIGNvbnN0IHNpZGVzVG9SZW1vdmUgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtpbmRleCwgcGFzc3Rocm91Z2hzXSBvZiBtYXNrLmVudHJpZXMoKSkge1xuICAgICAgaWYgKHBhc3N0aHJvdWdocykgY29udGludWU7XG4gICAgICBzaWRlc1RvUmVtb3ZlLnB1c2goaW5kZXgpO1xuICAgIH1cbiAgICAvLyB0byByZW1vdmUgZnJvbSBoaWdoZXN0IHRvIGxvd2VzdCBmb3Igbm8gbXV0YXRpb24gc2hpZnRpbmdcbiAgICBzaWRlc1RvUmVtb3ZlLnJldmVyc2UoKTtcblxuICAgIC8vIHJlbW92ZSBzaWRlc1xuICAgIGZvciAoY29uc3Qgc2lkZUluZGV4IG9mIHNpZGVzVG9SZW1vdmUpIHtcbiAgICAgIHRoaXMucmVtb3ZlQ3Jvc3Moc2lkZUluZGV4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYWN0IGZvcm1hdCB1cHBlci1yaWdodCBjb3JuZXIgb2YgbWF0cml4XG4gICAqIGl0ZXJhdGUgZnJvbSBsZWZ0IHRvIHJpZ2h0LCBmcm9tIHRvcCB0byBib3R0b20uXG4gICAqXG4gICAqIGBgYFxuICAgKiAgIEEgQiBDIERcbiAgICogQSAxIDIgMyA0XG4gICAqIEIgMiA1IDYgN1xuICAgKiBDIDMgNiA4IDlcbiAgICogRCA0IDcgOSAxMFxuICAgKiBgYGBcbiAgICpcbiAgICogd2lsbCByZXR1cm4gY29tcGFjdCAxRCBhcnJheSBgWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwXWBcbiAgICpcbiAgICogbGVuZ3RoIGlzIFMoaT0wLCBuPXNpZGVTaXplKSA9PiAxMCBmb3IgYSA0IHNpZGVTaXplZCBtYXRyaXhcbiAgICpcbiAgICogQHJldHVybnMge251bWJlcltdfVxuICAgKi9cbiAgdG9Db21wYWN0KCkge1xuICAgIGNvbnN0IHsgZGlhZ29uYWxTaXplIH0gPSB0aGlzO1xuXG4gICAgLyoqIEB0eXBlIHtudW1iZXJbXX0gKi9cbiAgICBjb25zdCBjb21wYWN0ID0gbmV3IEFycmF5KChkaWFnb25hbFNpemUgKiAoZGlhZ29uYWxTaXplICsgMSkpIC8gMik7XG4gICAgZm9yIChsZXQgY29sID0gMCwgcm93ID0gMCwgaW5kZXggPSAwOyBpbmRleCA8IGNvbXBhY3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb21wYWN0W2luZGV4XSA9IHRoaXMuZ2V0KHJvdywgY29sKTtcblxuICAgICAgaWYgKCsrY29sID49IGRpYWdvbmFsU2l6ZSkgY29sID0gKytyb3c7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBhY3Q7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJbXX0gY29tcGFjdFxuICAgKiBAcmV0dXJuIHtTeW1tZXRyaWNNYXRyaXh9XG4gICAqL1xuICBzdGF0aWMgZnJvbUNvbXBhY3QoY29tcGFjdCkge1xuICAgIGNvbnN0IGNvbXBhY3RTaXplID0gY29tcGFjdC5sZW5ndGg7XG4gICAgLy8gY29tcGFjdFNpemUgPSAoc2lkZVNpemUgKiAoc2lkZVNpemUgKyAxKSkgLyAyXG4gICAgLy8gaHR0cHM6Ly9tYXRoc29sdmVyLm1pY3Jvc29mdC5jb20vZnIvc29sdmUtcHJvYmxlbS95JTIwJTNEJTIwJTIweCUyMCU2MGNkb3QlMjAlMjAlMjAlNjBmcmFjJTdCJTIwJTIwJTYwbGVmdCglMjB4JTJCMSUyMCUyMCU2MHJpZ2h0KSUyMCUyMCUyMCUyMCU3RCU3QiUyMDIlMjAlMjAlN0RcbiAgICAvLyBzaWRlU2l6ZSA9IChTcXJ0KDggw5cgY29tcGFjdFNpemUgKyAxKSAtIDEpIC8gMlxuICAgIGNvbnN0IGRpYWdvbmFsU2l6ZSA9IChNYXRoLnNxcnQoOCAqIGNvbXBhY3RTaXplICsgMSkgLSAxKSAvIDI7XG5cbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoZGlhZ29uYWxTaXplKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgYFRoaXMgYXJyYXkgaXMgbm90IGEgY29tcGFjdCByZXByZXNlbnRhdGlvbiBvZiBhIFN5bW1ldHJpYyBNYXRyaXgsICR7SlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgY29tcGFjdCxcbiAgICAgICAgKX1gLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXRyaXggPSBuZXcgU3ltbWV0cmljTWF0cml4KGRpYWdvbmFsU2l6ZSk7XG4gICAgZm9yIChsZXQgY29sID0gMCwgcm93ID0gMCwgaW5kZXggPSAwOyBpbmRleCA8IGNvbXBhY3RTaXplOyBpbmRleCsrKSB7XG4gICAgICBtYXRyaXguc2V0KGNvbCwgcm93LCBjb21wYWN0W2luZGV4XSk7XG4gICAgICBpZiAoKytjb2wgPj0gZGlhZ29uYWxTaXplKSBjb2wgPSArK3JvdztcbiAgICB9XG5cbiAgICByZXR1cm4gbWF0cml4O1xuICB9XG5cbiAgLyoqXG4gICAqIGhhbGYgaXRlcmF0b3IgdXBwZXItcmlnaHQtY29ybmVyIGZyb20gbGVmdCB0byByaWdodCwgZnJvbSB0b3AgdG8gYm90dG9tXG4gICAqIHlpZWxkIFtyb3csIGNvbHVtbiwgdmFsdWVdXG4gICAqXG4gICAqIEByZXR1cm5zIHtHZW5lcmF0b3I8W251bWJlciwgbnVtYmVyLCBudW1iZXJdLCB2b2lkLCB2b2lkPn1cbiAgICovXG4gICp1cHBlclJpZ2h0RW50cmllcygpIHtcbiAgICBmb3IgKGxldCByb3cgPSAwLCBjb2wgPSAwOyByb3cgPCB0aGlzLmRpYWdvbmFsU2l6ZTsgdm9pZCAwKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0KHJvdywgY29sKTtcblxuICAgICAgeWllbGQgW3JvdywgY29sLCB2YWx1ZV07XG5cbiAgICAgIC8vIGF0IHRoZSBlbmQgb2Ygcm93LCBtb3ZlIGN1cnNvciB0byBuZXh0IHJvdyBhdCBkaWFnb25hbCBwb3NpdGlvblxuICAgICAgaWYgKCsrY29sID49IHRoaXMuZGlhZ29uYWxTaXplKSBjb2wgPSArK3JvdztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogaGFsZiBpdGVyYXRvciB1cHBlci1yaWdodC1jb3JuZXIgZnJvbSBsZWZ0IHRvIHJpZ2h0LCBmcm9tIHRvcCB0byBib3R0b21cbiAgICogeWllbGQgdmFsdWVcbiAgICpcbiAgICogQHJldHVybnMge0dlbmVyYXRvcjxbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIHZvaWQsIHZvaWQ+fVxuICAgKi9cbiAgKnVwcGVyUmlnaHRWYWx1ZXMoKSB7XG4gICAgZm9yIChsZXQgcm93ID0gMCwgY29sID0gMDsgcm93IDwgdGhpcy5kaWFnb25hbFNpemU7IHZvaWQgMCkge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldChyb3csIGNvbCk7XG5cbiAgICAgIHlpZWxkIHZhbHVlO1xuXG4gICAgICAvLyBhdCB0aGUgZW5kIG9mIHJvdywgbW92ZSBjdXJzb3IgdG8gbmV4dCByb3cgYXQgZGlhZ29uYWwgcG9zaXRpb25cbiAgICAgIGlmICgrK2NvbCA+PSB0aGlzLmRpYWdvbmFsU2l6ZSkgY29sID0gKytyb3c7XG4gICAgfVxuICB9XG59XG5TeW1tZXRyaWNNYXRyaXgucHJvdG90eXBlLmtsYXNzVHlwZSA9ICdTeW1tZXRyaWNNYXRyaXgnO1xuXG5jbGFzcyBEaXN0YW5jZU1hdHJpeCBleHRlbmRzIFN5bW1ldHJpY01hdHJpeCB7XG4gIC8qKlxuICAgKiBub3QgdGhlIHNhbWUgYXMgbWF0cml4LmlzU3ltbWV0cmljKClcbiAgICogSGVyZSBpcyB0byBjaGVjayBpZiBpdCdzIGluc3RhbmNlb2YgU3ltbWV0cmljTWF0cml4IHdpdGhvdXQgYnVuZGxpbmcgaXNzdWVzXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHN0YXRpYyBpc0Rpc3RhbmNlTWF0cml4KHZhbHVlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIFN5bW1ldHJpY01hdHJpeC5pc1N5bW1ldHJpY01hdHJpeCh2YWx1ZSkgJiZcbiAgICAgIHZhbHVlLmtsYXNzU3ViVHlwZSA9PT0gJ0Rpc3RhbmNlTWF0cml4J1xuICAgICk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihzaWRlU2l6ZSkge1xuICAgIHN1cGVyKHNpZGVTaXplKTtcblxuICAgIGlmICghdGhpcy5pc0Rpc3RhbmNlKCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb3ZpZGVkIGFyZ3VtZW50cyBkbyBubyBwcm9kdWNlIGEgZGlzdGFuY2UgbWF0cml4Jyk7XG4gICAgfVxuICB9XG5cbiAgc2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCwgdmFsdWUpIHtcbiAgICAvLyBkaXN0YW5jZSBtYXRyaXggZGlhZ29uYWwgaXMgMFxuICAgIGlmIChyb3dJbmRleCA9PT0gY29sdW1uSW5kZXgpIHZhbHVlID0gMDtcblxuICAgIHJldHVybiBzdXBlci5zZXQocm93SW5kZXgsIGNvbHVtbkluZGV4LCB2YWx1ZSk7XG4gIH1cblxuICBhZGRDcm9zcyhpbmRleCwgYXJyYXkpIHtcbiAgICBpZiAoYXJyYXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYXJyYXkgPSBpbmRleDtcbiAgICAgIGluZGV4ID0gdGhpcy5kaWFnb25hbFNpemU7XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGRpc3RhbmNlXG4gICAgYXJyYXkgPSBhcnJheS5zbGljZSgpO1xuICAgIGFycmF5W2luZGV4XSA9IDA7XG5cbiAgICByZXR1cm4gc3VwZXIuYWRkQ3Jvc3MoaW5kZXgsIGFycmF5KTtcbiAgfVxuXG4gIHRvU3ltbWV0cmljTWF0cml4KCkge1xuICAgIHJldHVybiBuZXcgU3ltbWV0cmljTWF0cml4KHRoaXMpO1xuICB9XG5cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgbWF0cml4ID0gbmV3IERpc3RhbmNlTWF0cml4KHRoaXMuZGlhZ29uYWxTaXplKTtcblxuICAgIGZvciAoY29uc3QgW3JvdywgY29sLCB2YWx1ZV0gb2YgdGhpcy51cHBlclJpZ2h0RW50cmllcygpKSB7XG4gICAgICBpZiAocm93ID09PSBjb2wpIGNvbnRpbnVlO1xuICAgICAgbWF0cml4LnNldChyb3csIGNvbCwgdmFsdWUpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRyaXg7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGFjdCBmb3JtYXQgdXBwZXItcmlnaHQgY29ybmVyIG9mIG1hdHJpeFxuICAgKiBubyBkaWFnb25hbCAob25seSB6ZXJvcylcbiAgICogaXRlcmFibGUgZnJvbSBsZWZ0IHRvIHJpZ2h0LCBmcm9tIHRvcCB0byBib3R0b20uXG4gICAqXG4gICAqIGBgYFxuICAgKiAgIEEgQiBDIERcbiAgICogQSAwIDEgMiAzXG4gICAqIEIgMSAwIDQgNVxuICAgKiBDIDIgNCAwIDZcbiAgICogRCAzIDUgNiAwXG4gICAqIGBgYFxuICAgKlxuICAgKiB3aWxsIHJldHVybiBjb21wYWN0IDFEIGFycmF5IGBbMSwgMiwgMywgNCwgNSwgNl1gXG4gICAqXG4gICAqIGxlbmd0aCBpcyBTKGk9MCwgbj1zaWRlU2l6ZS0xKSA9PiA2IGZvciBhIDQgc2lkZSBzaXplZCBtYXRyaXhcbiAgICpcbiAgICogQHJldHVybnMge251bWJlcltdfVxuICAgKi9cbiAgdG9Db21wYWN0KCkge1xuICAgIGNvbnN0IHsgZGlhZ29uYWxTaXplIH0gPSB0aGlzO1xuICAgIGNvbnN0IGNvbXBhY3RMZW5ndGggPSAoKGRpYWdvbmFsU2l6ZSAtIDEpICogZGlhZ29uYWxTaXplKSAvIDI7XG5cbiAgICAvKiogQHR5cGUge251bWJlcltdfSAqL1xuICAgIGNvbnN0IGNvbXBhY3QgPSBuZXcgQXJyYXkoY29tcGFjdExlbmd0aCk7XG4gICAgZm9yIChsZXQgY29sID0gMSwgcm93ID0gMCwgaW5kZXggPSAwOyBpbmRleCA8IGNvbXBhY3QubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb21wYWN0W2luZGV4XSA9IHRoaXMuZ2V0KHJvdywgY29sKTtcblxuICAgICAgaWYgKCsrY29sID49IGRpYWdvbmFsU2l6ZSkgY29sID0gKytyb3cgKyAxO1xuICAgIH1cblxuICAgIHJldHVybiBjb21wYWN0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IGNvbXBhY3RcbiAgICovXG4gIHN0YXRpYyBmcm9tQ29tcGFjdChjb21wYWN0KSB7XG4gICAgY29uc3QgY29tcGFjdFNpemUgPSBjb21wYWN0Lmxlbmd0aDtcblxuICAgIGlmIChjb21wYWN0U2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIG5ldyB0aGlzKDApO1xuICAgIH1cblxuICAgIC8vIGNvbXBhY3RTaXplIGluIE5hdHVyYWwgaW50ZWdlciByYW5nZSBdMDviiJ5dXG4gICAgLy8gY29tcGFjdFNpemUgPSAoc2lkZVNpemUgKiAoc2lkZVNpemUgLSAxKSkgLyAyXG4gICAgLy8gc2lkZVNpemUgPSAoU3FydCg4IMOXIGNvbXBhY3RTaXplICsgMSkgKyAxKSAvIDJcbiAgICBjb25zdCBkaWFnb25hbFNpemUgPSAoTWF0aC5zcXJ0KDggKiBjb21wYWN0U2l6ZSArIDEpICsgMSkgLyAyO1xuXG4gICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGRpYWdvbmFsU2l6ZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIGBUaGlzIGFycmF5IGlzIG5vdCBhIGNvbXBhY3QgcmVwcmVzZW50YXRpb24gb2YgYSBEaXN0YW5jZU1hdHJpeCwgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICBjb21wYWN0LFxuICAgICAgICApfWAsXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IG1hdHJpeCA9IG5ldyB0aGlzKGRpYWdvbmFsU2l6ZSk7XG4gICAgZm9yIChsZXQgY29sID0gMSwgcm93ID0gMCwgaW5kZXggPSAwOyBpbmRleCA8IGNvbXBhY3RTaXplOyBpbmRleCsrKSB7XG4gICAgICBtYXRyaXguc2V0KGNvbCwgcm93LCBjb21wYWN0W2luZGV4XSk7XG4gICAgICBpZiAoKytjb2wgPj0gZGlhZ29uYWxTaXplKSBjb2wgPSArK3JvdyArIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hdHJpeDtcbiAgfVxufVxuRGlzdGFuY2VNYXRyaXgucHJvdG90eXBlLmtsYXNzU3ViVHlwZSA9ICdEaXN0YW5jZU1hdHJpeCc7XG5cbmNsYXNzIEJhc2VWaWV3IGV4dGVuZHMgQWJzdHJhY3RNYXRyaXgge1xuICBjb25zdHJ1Y3RvcihtYXRyaXgsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubWF0cml4ID0gbWF0cml4O1xuICAgIHRoaXMucm93cyA9IHJvd3M7XG4gICAgdGhpcy5jb2x1bW5zID0gY29sdW1ucztcbiAgfVxufVxuXG5jbGFzcyBNYXRyaXhDb2x1bW5WaWV3IGV4dGVuZHMgQmFzZVZpZXcge1xuICBjb25zdHJ1Y3RvcihtYXRyaXgsIGNvbHVtbikge1xuICAgIGNoZWNrQ29sdW1uSW5kZXgobWF0cml4LCBjb2x1bW4pO1xuICAgIHN1cGVyKG1hdHJpeCwgbWF0cml4LnJvd3MsIDEpO1xuICAgIHRoaXMuY29sdW1uID0gY29sdW1uO1xuICB9XG5cbiAgc2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCwgdmFsdWUpIHtcbiAgICB0aGlzLm1hdHJpeC5zZXQocm93SW5kZXgsIHRoaXMuY29sdW1uLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQocm93SW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRyaXguZ2V0KHJvd0luZGV4LCB0aGlzLmNvbHVtbik7XG4gIH1cbn1cblxuY2xhc3MgTWF0cml4Q29sdW1uU2VsZWN0aW9uVmlldyBleHRlbmRzIEJhc2VWaWV3IHtcbiAgY29uc3RydWN0b3IobWF0cml4LCBjb2x1bW5JbmRpY2VzKSB7XG4gICAgY2hlY2tDb2x1bW5JbmRpY2VzKG1hdHJpeCwgY29sdW1uSW5kaWNlcyk7XG4gICAgc3VwZXIobWF0cml4LCBtYXRyaXgucm93cywgY29sdW1uSW5kaWNlcy5sZW5ndGgpO1xuICAgIHRoaXMuY29sdW1uSW5kaWNlcyA9IGNvbHVtbkluZGljZXM7XG4gIH1cblxuICBzZXQocm93SW5kZXgsIGNvbHVtbkluZGV4LCB2YWx1ZSkge1xuICAgIHRoaXMubWF0cml4LnNldChyb3dJbmRleCwgdGhpcy5jb2x1bW5JbmRpY2VzW2NvbHVtbkluZGV4XSwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCkge1xuICAgIHJldHVybiB0aGlzLm1hdHJpeC5nZXQocm93SW5kZXgsIHRoaXMuY29sdW1uSW5kaWNlc1tjb2x1bW5JbmRleF0pO1xuICB9XG59XG5cbmNsYXNzIE1hdHJpeEZsaXBDb2x1bW5WaWV3IGV4dGVuZHMgQmFzZVZpZXcge1xuICBjb25zdHJ1Y3RvcihtYXRyaXgpIHtcbiAgICBzdXBlcihtYXRyaXgsIG1hdHJpeC5yb3dzLCBtYXRyaXguY29sdW1ucyk7XG4gIH1cblxuICBzZXQocm93SW5kZXgsIGNvbHVtbkluZGV4LCB2YWx1ZSkge1xuICAgIHRoaXMubWF0cml4LnNldChyb3dJbmRleCwgdGhpcy5jb2x1bW5zIC0gY29sdW1uSW5kZXggLSAxLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQocm93SW5kZXgsIGNvbHVtbkluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMubWF0cml4LmdldChyb3dJbmRleCwgdGhpcy5jb2x1bW5zIC0gY29sdW1uSW5kZXggLSAxKTtcbiAgfVxufVxuXG5jbGFzcyBNYXRyaXhGbGlwUm93VmlldyBleHRlbmRzIEJhc2VWaWV3IHtcbiAgY29uc3RydWN0b3IobWF0cml4KSB7XG4gICAgc3VwZXIobWF0cml4LCBtYXRyaXgucm93cywgbWF0cml4LmNvbHVtbnMpO1xuICB9XG5cbiAgc2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCwgdmFsdWUpIHtcbiAgICB0aGlzLm1hdHJpeC5zZXQodGhpcy5yb3dzIC0gcm93SW5kZXggLSAxLCBjb2x1bW5JbmRleCwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCkge1xuICAgIHJldHVybiB0aGlzLm1hdHJpeC5nZXQodGhpcy5yb3dzIC0gcm93SW5kZXggLSAxLCBjb2x1bW5JbmRleCk7XG4gIH1cbn1cblxuY2xhc3MgTWF0cml4Um93VmlldyBleHRlbmRzIEJhc2VWaWV3IHtcbiAgY29uc3RydWN0b3IobWF0cml4LCByb3cpIHtcbiAgICBjaGVja1Jvd0luZGV4KG1hdHJpeCwgcm93KTtcbiAgICBzdXBlcihtYXRyaXgsIDEsIG1hdHJpeC5jb2x1bW5zKTtcbiAgICB0aGlzLnJvdyA9IHJvdztcbiAgfVxuXG4gIHNldChyb3dJbmRleCwgY29sdW1uSW5kZXgsIHZhbHVlKSB7XG4gICAgdGhpcy5tYXRyaXguc2V0KHRoaXMucm93LCBjb2x1bW5JbmRleCwgdmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCkge1xuICAgIHJldHVybiB0aGlzLm1hdHJpeC5nZXQodGhpcy5yb3csIGNvbHVtbkluZGV4KTtcbiAgfVxufVxuXG5jbGFzcyBNYXRyaXhSb3dTZWxlY3Rpb25WaWV3IGV4dGVuZHMgQmFzZVZpZXcge1xuICBjb25zdHJ1Y3RvcihtYXRyaXgsIHJvd0luZGljZXMpIHtcbiAgICBjaGVja1Jvd0luZGljZXMobWF0cml4LCByb3dJbmRpY2VzKTtcbiAgICBzdXBlcihtYXRyaXgsIHJvd0luZGljZXMubGVuZ3RoLCBtYXRyaXguY29sdW1ucyk7XG4gICAgdGhpcy5yb3dJbmRpY2VzID0gcm93SW5kaWNlcztcbiAgfVxuXG4gIHNldChyb3dJbmRleCwgY29sdW1uSW5kZXgsIHZhbHVlKSB7XG4gICAgdGhpcy5tYXRyaXguc2V0KHRoaXMucm93SW5kaWNlc1tyb3dJbmRleF0sIGNvbHVtbkluZGV4LCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQocm93SW5kZXgsIGNvbHVtbkluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMubWF0cml4LmdldCh0aGlzLnJvd0luZGljZXNbcm93SW5kZXhdLCBjb2x1bW5JbmRleCk7XG4gIH1cbn1cblxuY2xhc3MgTWF0cml4U2VsZWN0aW9uVmlldyBleHRlbmRzIEJhc2VWaWV3IHtcbiAgY29uc3RydWN0b3IobWF0cml4LCByb3dJbmRpY2VzLCBjb2x1bW5JbmRpY2VzKSB7XG4gICAgY2hlY2tSb3dJbmRpY2VzKG1hdHJpeCwgcm93SW5kaWNlcyk7XG4gICAgY2hlY2tDb2x1bW5JbmRpY2VzKG1hdHJpeCwgY29sdW1uSW5kaWNlcyk7XG4gICAgc3VwZXIobWF0cml4LCByb3dJbmRpY2VzLmxlbmd0aCwgY29sdW1uSW5kaWNlcy5sZW5ndGgpO1xuICAgIHRoaXMucm93SW5kaWNlcyA9IHJvd0luZGljZXM7XG4gICAgdGhpcy5jb2x1bW5JbmRpY2VzID0gY29sdW1uSW5kaWNlcztcbiAgfVxuXG4gIHNldChyb3dJbmRleCwgY29sdW1uSW5kZXgsIHZhbHVlKSB7XG4gICAgdGhpcy5tYXRyaXguc2V0KFxuICAgICAgdGhpcy5yb3dJbmRpY2VzW3Jvd0luZGV4XSxcbiAgICAgIHRoaXMuY29sdW1uSW5kaWNlc1tjb2x1bW5JbmRleF0sXG4gICAgICB2YWx1ZSxcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCkge1xuICAgIHJldHVybiB0aGlzLm1hdHJpeC5nZXQoXG4gICAgICB0aGlzLnJvd0luZGljZXNbcm93SW5kZXhdLFxuICAgICAgdGhpcy5jb2x1bW5JbmRpY2VzW2NvbHVtbkluZGV4XSxcbiAgICApO1xuICB9XG59XG5cbmNsYXNzIE1hdHJpeFN1YlZpZXcgZXh0ZW5kcyBCYXNlVmlldyB7XG4gIGNvbnN0cnVjdG9yKG1hdHJpeCwgc3RhcnRSb3csIGVuZFJvdywgc3RhcnRDb2x1bW4sIGVuZENvbHVtbikge1xuICAgIGNoZWNrUmFuZ2UobWF0cml4LCBzdGFydFJvdywgZW5kUm93LCBzdGFydENvbHVtbiwgZW5kQ29sdW1uKTtcbiAgICBzdXBlcihtYXRyaXgsIGVuZFJvdyAtIHN0YXJ0Um93ICsgMSwgZW5kQ29sdW1uIC0gc3RhcnRDb2x1bW4gKyAxKTtcbiAgICB0aGlzLnN0YXJ0Um93ID0gc3RhcnRSb3c7XG4gICAgdGhpcy5zdGFydENvbHVtbiA9IHN0YXJ0Q29sdW1uO1xuICB9XG5cbiAgc2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCwgdmFsdWUpIHtcbiAgICB0aGlzLm1hdHJpeC5zZXQoXG4gICAgICB0aGlzLnN0YXJ0Um93ICsgcm93SW5kZXgsXG4gICAgICB0aGlzLnN0YXJ0Q29sdW1uICsgY29sdW1uSW5kZXgsXG4gICAgICB2YWx1ZSxcbiAgICApO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCkge1xuICAgIHJldHVybiB0aGlzLm1hdHJpeC5nZXQoXG4gICAgICB0aGlzLnN0YXJ0Um93ICsgcm93SW5kZXgsXG4gICAgICB0aGlzLnN0YXJ0Q29sdW1uICsgY29sdW1uSW5kZXgsXG4gICAgKTtcbiAgfVxufVxuXG5jbGFzcyBNYXRyaXhUcmFuc3Bvc2VWaWV3IGV4dGVuZHMgQmFzZVZpZXcge1xuICBjb25zdHJ1Y3RvcihtYXRyaXgpIHtcbiAgICBzdXBlcihtYXRyaXgsIG1hdHJpeC5jb2x1bW5zLCBtYXRyaXgucm93cyk7XG4gIH1cblxuICBzZXQocm93SW5kZXgsIGNvbHVtbkluZGV4LCB2YWx1ZSkge1xuICAgIHRoaXMubWF0cml4LnNldChjb2x1bW5JbmRleCwgcm93SW5kZXgsIHZhbHVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldChyb3dJbmRleCwgY29sdW1uSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXRyaXguZ2V0KGNvbHVtbkluZGV4LCByb3dJbmRleCk7XG4gIH1cbn1cblxuY2xhc3MgV3JhcHBlck1hdHJpeDFEIGV4dGVuZHMgQWJzdHJhY3RNYXRyaXgge1xuICBjb25zdHJ1Y3RvcihkYXRhLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IHJvd3MgPSAxIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKGRhdGEubGVuZ3RoICUgcm93cyAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCd0aGUgZGF0YSBsZW5ndGggaXMgbm90IGRpdmlzaWJsZSBieSB0aGUgbnVtYmVyIG9mIHJvd3MnKTtcbiAgICB9XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnJvd3MgPSByb3dzO1xuICAgIHRoaXMuY29sdW1ucyA9IGRhdGEubGVuZ3RoIC8gcm93cztcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICB9XG5cbiAgc2V0KHJvd0luZGV4LCBjb2x1bW5JbmRleCwgdmFsdWUpIHtcbiAgICBsZXQgaW5kZXggPSB0aGlzLl9jYWxjdWxhdGVJbmRleChyb3dJbmRleCwgY29sdW1uSW5kZXgpO1xuICAgIHRoaXMuZGF0YVtpbmRleF0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldChyb3dJbmRleCwgY29sdW1uSW5kZXgpIHtcbiAgICBsZXQgaW5kZXggPSB0aGlzLl9jYWxjdWxhdGVJbmRleChyb3dJbmRleCwgY29sdW1uSW5kZXgpO1xuICAgIHJldHVybiB0aGlzLmRhdGFbaW5kZXhdO1xuICB9XG5cbiAgX2NhbGN1bGF0ZUluZGV4KHJvdywgY29sdW1uKSB7XG4gICAgcmV0dXJuIHJvdyAqIHRoaXMuY29sdW1ucyArIGNvbHVtbjtcbiAgfVxufVxuXG5jbGFzcyBXcmFwcGVyTWF0cml4MkQgZXh0ZW5kcyBBYnN0cmFjdE1hdHJpeCB7XG4gIGNvbnN0cnVjdG9yKGRhdGEpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy5yb3dzID0gZGF0YS5sZW5ndGg7XG4gICAgdGhpcy5jb2x1bW5zID0gZGF0YVswXS5sZW5ndGg7XG4gIH1cblxuICBzZXQocm93SW5kZXgsIGNvbHVtbkluZGV4LCB2YWx1ZSkge1xuICAgIHRoaXMuZGF0YVtyb3dJbmRleF1bY29sdW1uSW5kZXhdID0gdmFsdWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBnZXQocm93SW5kZXgsIGNvbHVtbkluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMuZGF0YVtyb3dJbmRleF1bY29sdW1uSW5kZXhdO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdyYXAoYXJyYXksIG9wdGlvbnMpIHtcbiAgaWYgKGlzQW55QXJyYXkuaXNBbnlBcnJheShhcnJheSkpIHtcbiAgICBpZiAoYXJyYXlbMF0gJiYgaXNBbnlBcnJheS5pc0FueUFycmF5KGFycmF5WzBdKSkge1xuICAgICAgcmV0dXJuIG5ldyBXcmFwcGVyTWF0cml4MkQoYXJyYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbmV3IFdyYXBwZXJNYXRyaXgxRChhcnJheSwgb3B0aW9ucyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcigndGhlIGFyZ3VtZW50IGlzIG5vdCBhbiBhcnJheScpO1xuICB9XG59XG5cbmNsYXNzIEx1RGVjb21wb3NpdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1hdHJpeCkge1xuICAgIG1hdHJpeCA9IFdyYXBwZXJNYXRyaXgyRC5jaGVja01hdHJpeChtYXRyaXgpO1xuXG4gICAgbGV0IGx1ID0gbWF0cml4LmNsb25lKCk7XG4gICAgbGV0IHJvd3MgPSBsdS5yb3dzO1xuICAgIGxldCBjb2x1bW5zID0gbHUuY29sdW1ucztcbiAgICBsZXQgcGl2b3RWZWN0b3IgPSBuZXcgRmxvYXQ2NEFycmF5KHJvd3MpO1xuICAgIGxldCBwaXZvdFNpZ24gPSAxO1xuICAgIGxldCBpLCBqLCBrLCBwLCBzLCB0LCB2O1xuICAgIGxldCBMVWNvbGosIGttYXg7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICBwaXZvdFZlY3RvcltpXSA9IGk7XG4gICAgfVxuXG4gICAgTFVjb2xqID0gbmV3IEZsb2F0NjRBcnJheShyb3dzKTtcblxuICAgIGZvciAoaiA9IDA7IGogPCBjb2x1bW5zOyBqKyspIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgTFVjb2xqW2ldID0gbHUuZ2V0KGksIGopO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgIGttYXggPSBNYXRoLm1pbihpLCBqKTtcbiAgICAgICAgcyA9IDA7XG4gICAgICAgIGZvciAoayA9IDA7IGsgPCBrbWF4OyBrKyspIHtcbiAgICAgICAgICBzICs9IGx1LmdldChpLCBrKSAqIExVY29saltrXTtcbiAgICAgICAgfVxuICAgICAgICBMVWNvbGpbaV0gLT0gcztcbiAgICAgICAgbHUuc2V0KGksIGosIExVY29saltpXSk7XG4gICAgICB9XG5cbiAgICAgIHAgPSBqO1xuICAgICAgZm9yIChpID0gaiArIDE7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKExVY29saltpXSkgPiBNYXRoLmFicyhMVWNvbGpbcF0pKSB7XG4gICAgICAgICAgcCA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHAgIT09IGopIHtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGNvbHVtbnM7IGsrKykge1xuICAgICAgICAgIHQgPSBsdS5nZXQocCwgayk7XG4gICAgICAgICAgbHUuc2V0KHAsIGssIGx1LmdldChqLCBrKSk7XG4gICAgICAgICAgbHUuc2V0KGosIGssIHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdiA9IHBpdm90VmVjdG9yW3BdO1xuICAgICAgICBwaXZvdFZlY3RvcltwXSA9IHBpdm90VmVjdG9yW2pdO1xuICAgICAgICBwaXZvdFZlY3RvcltqXSA9IHY7XG5cbiAgICAgICAgcGl2b3RTaWduID0gLXBpdm90U2lnbjtcbiAgICAgIH1cblxuICAgICAgaWYgKGogPCByb3dzICYmIGx1LmdldChqLCBqKSAhPT0gMCkge1xuICAgICAgICBmb3IgKGkgPSBqICsgMTsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgIGx1LnNldChpLCBqLCBsdS5nZXQoaSwgaikgLyBsdS5nZXQoaiwgaikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5MVSA9IGx1O1xuICAgIHRoaXMucGl2b3RWZWN0b3IgPSBwaXZvdFZlY3RvcjtcbiAgICB0aGlzLnBpdm90U2lnbiA9IHBpdm90U2lnbjtcbiAgfVxuXG4gIGlzU2luZ3VsYXIoKSB7XG4gICAgbGV0IGRhdGEgPSB0aGlzLkxVO1xuICAgIGxldCBjb2wgPSBkYXRhLmNvbHVtbnM7XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2w7IGorKykge1xuICAgICAgaWYgKGRhdGEuZ2V0KGosIGopID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBzb2x2ZSh2YWx1ZSkge1xuICAgIHZhbHVlID0gTWF0cml4LmNoZWNrTWF0cml4KHZhbHVlKTtcblxuICAgIGxldCBsdSA9IHRoaXMuTFU7XG4gICAgbGV0IHJvd3MgPSBsdS5yb3dzO1xuXG4gICAgaWYgKHJvd3MgIT09IHZhbHVlLnJvd3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBtYXRyaXggZGltZW5zaW9ucycpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1Npbmd1bGFyKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTFUgbWF0cml4IGlzIHNpbmd1bGFyJyk7XG4gICAgfVxuXG4gICAgbGV0IGNvdW50ID0gdmFsdWUuY29sdW1ucztcbiAgICBsZXQgWCA9IHZhbHVlLnN1Yk1hdHJpeFJvdyh0aGlzLnBpdm90VmVjdG9yLCAwLCBjb3VudCAtIDEpO1xuICAgIGxldCBjb2x1bW5zID0gbHUuY29sdW1ucztcbiAgICBsZXQgaSwgaiwgaztcblxuICAgIGZvciAoayA9IDA7IGsgPCBjb2x1bW5zOyBrKyspIHtcbiAgICAgIGZvciAoaSA9IGsgKyAxOyBpIDwgY29sdW1uczsgaSsrKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgICAgWC5zZXQoaSwgaiwgWC5nZXQoaSwgaikgLSBYLmdldChrLCBqKSAqIGx1LmdldChpLCBrKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChrID0gY29sdW1ucyAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgICBYLnNldChrLCBqLCBYLmdldChrLCBqKSAvIGx1LmdldChrLCBrKSk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgazsgaSsrKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgICAgWC5zZXQoaSwgaiwgWC5nZXQoaSwgaikgLSBYLmdldChrLCBqKSAqIGx1LmdldChpLCBrKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFg7XG4gIH1cblxuICBnZXQgZGV0ZXJtaW5hbnQoKSB7XG4gICAgbGV0IGRhdGEgPSB0aGlzLkxVO1xuICAgIGlmICghZGF0YS5pc1NxdWFyZSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdHJpeCBtdXN0IGJlIHNxdWFyZScpO1xuICAgIH1cbiAgICBsZXQgZGV0ZXJtaW5hbnQgPSB0aGlzLnBpdm90U2lnbjtcbiAgICBsZXQgY29sID0gZGF0YS5jb2x1bW5zO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sOyBqKyspIHtcbiAgICAgIGRldGVybWluYW50ICo9IGRhdGEuZ2V0KGosIGopO1xuICAgIH1cbiAgICByZXR1cm4gZGV0ZXJtaW5hbnQ7XG4gIH1cblxuICBnZXQgbG93ZXJUcmlhbmd1bGFyTWF0cml4KCkge1xuICAgIGxldCBkYXRhID0gdGhpcy5MVTtcbiAgICBsZXQgcm93cyA9IGRhdGEucm93cztcbiAgICBsZXQgY29sdW1ucyA9IGRhdGEuY29sdW1ucztcbiAgICBsZXQgWCA9IG5ldyBNYXRyaXgocm93cywgY29sdW1ucyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAgIGlmIChpID4gaikge1xuICAgICAgICAgIFguc2V0KGksIGosIGRhdGEuZ2V0KGksIGopKTtcbiAgICAgICAgfSBlbHNlIGlmIChpID09PSBqKSB7XG4gICAgICAgICAgWC5zZXQoaSwgaiwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgWC5zZXQoaSwgaiwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFg7XG4gIH1cblxuICBnZXQgdXBwZXJUcmlhbmd1bGFyTWF0cml4KCkge1xuICAgIGxldCBkYXRhID0gdGhpcy5MVTtcbiAgICBsZXQgcm93cyA9IGRhdGEucm93cztcbiAgICBsZXQgY29sdW1ucyA9IGRhdGEuY29sdW1ucztcbiAgICBsZXQgWCA9IG5ldyBNYXRyaXgocm93cywgY29sdW1ucyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByb3dzOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29sdW1uczsgaisrKSB7XG4gICAgICAgIGlmIChpIDw9IGopIHtcbiAgICAgICAgICBYLnNldChpLCBqLCBkYXRhLmdldChpLCBqKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgWC5zZXQoaSwgaiwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFg7XG4gIH1cblxuICBnZXQgcGl2b3RQZXJtdXRhdGlvblZlY3RvcigpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnBpdm90VmVjdG9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoeXBvdGVudXNlKGEsIGIpIHtcbiAgbGV0IHIgPSAwO1xuICBpZiAoTWF0aC5hYnMoYSkgPiBNYXRoLmFicyhiKSkge1xuICAgIHIgPSBiIC8gYTtcbiAgICByZXR1cm4gTWF0aC5hYnMoYSkgKiBNYXRoLnNxcnQoMSArIHIgKiByKTtcbiAgfVxuICBpZiAoYiAhPT0gMCkge1xuICAgIHIgPSBhIC8gYjtcbiAgICByZXR1cm4gTWF0aC5hYnMoYikgKiBNYXRoLnNxcnQoMSArIHIgKiByKTtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuY2xhc3MgUXJEZWNvbXBvc2l0aW9uIHtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICB2YWx1ZSA9IFdyYXBwZXJNYXRyaXgyRC5jaGVja01hdHJpeCh2YWx1ZSk7XG5cbiAgICBsZXQgcXIgPSB2YWx1ZS5jbG9uZSgpO1xuICAgIGxldCBtID0gdmFsdWUucm93cztcbiAgICBsZXQgbiA9IHZhbHVlLmNvbHVtbnM7XG4gICAgbGV0IHJkaWFnID0gbmV3IEZsb2F0NjRBcnJheShuKTtcbiAgICBsZXQgaSwgaiwgaywgcztcblxuICAgIGZvciAoayA9IDA7IGsgPCBuOyBrKyspIHtcbiAgICAgIGxldCBucm0gPSAwO1xuICAgICAgZm9yIChpID0gazsgaSA8IG07IGkrKykge1xuICAgICAgICBucm0gPSBoeXBvdGVudXNlKG5ybSwgcXIuZ2V0KGksIGspKTtcbiAgICAgIH1cbiAgICAgIGlmIChucm0gIT09IDApIHtcbiAgICAgICAgaWYgKHFyLmdldChrLCBrKSA8IDApIHtcbiAgICAgICAgICBucm0gPSAtbnJtO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaSA9IGs7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICBxci5zZXQoaSwgaywgcXIuZ2V0KGksIGspIC8gbnJtKTtcbiAgICAgICAgfVxuICAgICAgICBxci5zZXQoaywgaywgcXIuZ2V0KGssIGspICsgMSk7XG4gICAgICAgIGZvciAoaiA9IGsgKyAxOyBqIDwgbjsgaisrKSB7XG4gICAgICAgICAgcyA9IDA7XG4gICAgICAgICAgZm9yIChpID0gazsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgcyArPSBxci5nZXQoaSwgaykgKiBxci5nZXQoaSwgaik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHMgPSAtcyAvIHFyLmdldChrLCBrKTtcbiAgICAgICAgICBmb3IgKGkgPSBrOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICBxci5zZXQoaSwgaiwgcXIuZ2V0KGksIGopICsgcyAqIHFyLmdldChpLCBrKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZGlhZ1trXSA9IC1ucm07XG4gICAgfVxuXG4gICAgdGhpcy5RUiA9IHFyO1xuICAgIHRoaXMuUmRpYWcgPSByZGlhZztcbiAgfVxuXG4gIHNvbHZlKHZhbHVlKSB7XG4gICAgdmFsdWUgPSBNYXRyaXguY2hlY2tNYXRyaXgodmFsdWUpO1xuXG4gICAgbGV0IHFyID0gdGhpcy5RUjtcbiAgICBsZXQgbSA9IHFyLnJvd3M7XG5cbiAgICBpZiAodmFsdWUucm93cyAhPT0gbSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXRyaXggcm93IGRpbWVuc2lvbnMgbXVzdCBhZ3JlZScpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuaXNGdWxsUmFuaygpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdHJpeCBpcyByYW5rIGRlZmljaWVudCcpO1xuICAgIH1cblxuICAgIGxldCBjb3VudCA9IHZhbHVlLmNvbHVtbnM7XG4gICAgbGV0IFggPSB2YWx1ZS5jbG9uZSgpO1xuICAgIGxldCBuID0gcXIuY29sdW1ucztcbiAgICBsZXQgaSwgaiwgaywgcztcblxuICAgIGZvciAoayA9IDA7IGsgPCBuOyBrKyspIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgIHMgPSAwO1xuICAgICAgICBmb3IgKGkgPSBrOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgcyArPSBxci5nZXQoaSwgaykgKiBYLmdldChpLCBqKTtcbiAgICAgICAgfVxuICAgICAgICBzID0gLXMgLyBxci5nZXQoaywgayk7XG4gICAgICAgIGZvciAoaSA9IGs7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICBYLnNldChpLCBqLCBYLmdldChpLCBqKSArIHMgKiBxci5nZXQoaSwgaykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAoayA9IG4gLSAxOyBrID49IDA7IGstLSkge1xuICAgICAgZm9yIChqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgICAgWC5zZXQoaywgaiwgWC5nZXQoaywgaikgLyB0aGlzLlJkaWFnW2tdKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgICAgICBYLnNldChpLCBqLCBYLmdldChpLCBqKSAtIFguZ2V0KGssIGopICogcXIuZ2V0KGksIGspKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBYLnN1Yk1hdHJpeCgwLCBuIC0gMSwgMCwgY291bnQgLSAxKTtcbiAgfVxuXG4gIGlzRnVsbFJhbmsoKSB7XG4gICAgbGV0IGNvbHVtbnMgPSB0aGlzLlFSLmNvbHVtbnM7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb2x1bW5zOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLlJkaWFnW2ldID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBnZXQgdXBwZXJUcmlhbmd1bGFyTWF0cml4KCkge1xuICAgIGxldCBxciA9IHRoaXMuUVI7XG4gICAgbGV0IG4gPSBxci5jb2x1bW5zO1xuICAgIGxldCBYID0gbmV3IE1hdHJpeChuLCBuKTtcbiAgICBsZXQgaSwgajtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgIGlmIChpIDwgaikge1xuICAgICAgICAgIFguc2V0KGksIGosIHFyLmdldChpLCBqKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaSA9PT0gaikge1xuICAgICAgICAgIFguc2V0KGksIGosIHRoaXMuUmRpYWdbaV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIFguc2V0KGksIGosIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBYO1xuICB9XG5cbiAgZ2V0IG9ydGhvZ29uYWxNYXRyaXgoKSB7XG4gICAgbGV0IHFyID0gdGhpcy5RUjtcbiAgICBsZXQgcm93cyA9IHFyLnJvd3M7XG4gICAgbGV0IGNvbHVtbnMgPSBxci5jb2x1bW5zO1xuICAgIGxldCBYID0gbmV3IE1hdHJpeChyb3dzLCBjb2x1bW5zKTtcbiAgICBsZXQgaSwgaiwgaywgcztcblxuICAgIGZvciAoayA9IGNvbHVtbnMgLSAxOyBrID49IDA7IGstLSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICBYLnNldChpLCBrLCAwKTtcbiAgICAgIH1cbiAgICAgIFguc2V0KGssIGssIDEpO1xuICAgICAgZm9yIChqID0gazsgaiA8IGNvbHVtbnM7IGorKykge1xuICAgICAgICBpZiAocXIuZ2V0KGssIGspICE9PSAwKSB7XG4gICAgICAgICAgcyA9IDA7XG4gICAgICAgICAgZm9yIChpID0gazsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICAgICAgcyArPSBxci5nZXQoaSwgaykgKiBYLmdldChpLCBqKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzID0gLXMgLyBxci5nZXQoaywgayk7XG5cbiAgICAgICAgICBmb3IgKGkgPSBrOyBpIDwgcm93czsgaSsrKSB7XG4gICAgICAgICAgICBYLnNldChpLCBqLCBYLmdldChpLCBqKSArIHMgKiBxci5nZXQoaSwgaykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gWDtcbiAgfVxufVxuXG5jbGFzcyBTaW5ndWxhclZhbHVlRGVjb21wb3NpdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICB2YWx1ZSA9IFdyYXBwZXJNYXRyaXgyRC5jaGVja01hdHJpeCh2YWx1ZSk7XG5cbiAgICBpZiAodmFsdWUuaXNFbXB0eSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdHJpeCBtdXN0IGJlIG5vbi1lbXB0eScpO1xuICAgIH1cblxuICAgIGxldCBtID0gdmFsdWUucm93cztcbiAgICBsZXQgbiA9IHZhbHVlLmNvbHVtbnM7XG5cbiAgICBjb25zdCB7XG4gICAgICBjb21wdXRlTGVmdFNpbmd1bGFyVmVjdG9ycyA9IHRydWUsXG4gICAgICBjb21wdXRlUmlnaHRTaW5ndWxhclZlY3RvcnMgPSB0cnVlLFxuICAgICAgYXV0b1RyYW5zcG9zZSA9IGZhbHNlLFxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgbGV0IHdhbnR1ID0gQm9vbGVhbihjb21wdXRlTGVmdFNpbmd1bGFyVmVjdG9ycyk7XG4gICAgbGV0IHdhbnR2ID0gQm9vbGVhbihjb21wdXRlUmlnaHRTaW5ndWxhclZlY3RvcnMpO1xuXG4gICAgbGV0IHN3YXBwZWQgPSBmYWxzZTtcbiAgICBsZXQgYTtcbiAgICBpZiAobSA8IG4pIHtcbiAgICAgIGlmICghYXV0b1RyYW5zcG9zZSkge1xuICAgICAgICBhID0gdmFsdWUuY2xvbmUoKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdDb21wdXRpbmcgU1ZEIG9uIGEgbWF0cml4IHdpdGggbW9yZSBjb2x1bW5zIHRoYW4gcm93cy4gQ29uc2lkZXIgZW5hYmxpbmcgYXV0b1RyYW5zcG9zZScsXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhID0gdmFsdWUudHJhbnNwb3NlKCk7XG4gICAgICAgIG0gPSBhLnJvd3M7XG4gICAgICAgIG4gPSBhLmNvbHVtbnM7XG4gICAgICAgIHN3YXBwZWQgPSB0cnVlO1xuICAgICAgICBsZXQgYXV4ID0gd2FudHU7XG4gICAgICAgIHdhbnR1ID0gd2FudHY7XG4gICAgICAgIHdhbnR2ID0gYXV4O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhID0gdmFsdWUuY2xvbmUoKTtcbiAgICB9XG5cbiAgICBsZXQgbnUgPSBNYXRoLm1pbihtLCBuKTtcbiAgICBsZXQgbmkgPSBNYXRoLm1pbihtICsgMSwgbik7XG4gICAgbGV0IHMgPSBuZXcgRmxvYXQ2NEFycmF5KG5pKTtcbiAgICBsZXQgVSA9IG5ldyBNYXRyaXgobSwgbnUpO1xuICAgIGxldCBWID0gbmV3IE1hdHJpeChuLCBuKTtcblxuICAgIGxldCBlID0gbmV3IEZsb2F0NjRBcnJheShuKTtcbiAgICBsZXQgd29yayA9IG5ldyBGbG9hdDY0QXJyYXkobSk7XG5cbiAgICBsZXQgc2kgPSBuZXcgRmxvYXQ2NEFycmF5KG5pKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5pOyBpKyspIHNpW2ldID0gaTtcblxuICAgIGxldCBuY3QgPSBNYXRoLm1pbihtIC0gMSwgbik7XG4gICAgbGV0IG5ydCA9IE1hdGgubWF4KDAsIE1hdGgubWluKG4gLSAyLCBtKSk7XG4gICAgbGV0IG1yYyA9IE1hdGgubWF4KG5jdCwgbnJ0KTtcblxuICAgIGZvciAobGV0IGsgPSAwOyBrIDwgbXJjOyBrKyspIHtcbiAgICAgIGlmIChrIDwgbmN0KSB7XG4gICAgICAgIHNba10gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gazsgaSA8IG07IGkrKykge1xuICAgICAgICAgIHNba10gPSBoeXBvdGVudXNlKHNba10sIGEuZ2V0KGksIGspKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc1trXSAhPT0gMCkge1xuICAgICAgICAgIGlmIChhLmdldChrLCBrKSA8IDApIHtcbiAgICAgICAgICAgIHNba10gPSAtc1trXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgaSA9IGs7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgIGEuc2V0KGksIGssIGEuZ2V0KGksIGspIC8gc1trXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGEuc2V0KGssIGssIGEuZ2V0KGssIGspICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgc1trXSA9IC1zW2tdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGxldCBqID0gayArIDE7IGogPCBuOyBqKyspIHtcbiAgICAgICAgaWYgKGsgPCBuY3QgJiYgc1trXSAhPT0gMCkge1xuICAgICAgICAgIGxldCB0ID0gMDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gazsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgdCArPSBhLmdldChpLCBrKSAqIGEuZ2V0KGksIGopO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0ID0gLXQgLyBhLmdldChrLCBrKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gazsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgYS5zZXQoaSwgaiwgYS5nZXQoaSwgaikgKyB0ICogYS5nZXQoaSwgaykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlW2pdID0gYS5nZXQoaywgaik7XG4gICAgICB9XG5cbiAgICAgIGlmICh3YW50dSAmJiBrIDwgbmN0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBrOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgVS5zZXQoaSwgaywgYS5nZXQoaSwgaykpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChrIDwgbnJ0KSB7XG4gICAgICAgIGVba10gPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gayArIDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICBlW2tdID0gaHlwb3RlbnVzZShlW2tdLCBlW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZVtrXSAhPT0gMCkge1xuICAgICAgICAgIGlmIChlW2sgKyAxXSA8IDApIHtcbiAgICAgICAgICAgIGVba10gPSAwIC0gZVtrXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgaSA9IGsgKyAxOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgICBlW2ldIC89IGVba107XG4gICAgICAgICAgfVxuICAgICAgICAgIGVbayArIDFdICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZVtrXSA9IC1lW2tdO1xuICAgICAgICBpZiAoayArIDEgPCBtICYmIGVba10gIT09IDApIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gayArIDE7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgIHdvcmtbaV0gPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGxldCBpID0gayArIDE7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSBrICsgMTsgaiA8IG47IGorKykge1xuICAgICAgICAgICAgICB3b3JrW2ldICs9IGVbal0gKiBhLmdldChpLCBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChsZXQgaiA9IGsgKyAxOyBqIDwgbjsgaisrKSB7XG4gICAgICAgICAgICBsZXQgdCA9IC1lW2pdIC8gZVtrICsgMV07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gayArIDE7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgYS5zZXQoaSwgaiwgYS5nZXQoaSwgaikgKyB0ICogd29ya1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh3YW50dikge1xuICAgICAgICAgIGZvciAobGV0IGkgPSBrICsgMTsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgVi5zZXQoaSwgaywgZVtpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IHAgPSBNYXRoLm1pbihuLCBtICsgMSk7XG4gICAgaWYgKG5jdCA8IG4pIHtcbiAgICAgIHNbbmN0XSA9IGEuZ2V0KG5jdCwgbmN0KTtcbiAgICB9XG4gICAgaWYgKG0gPCBwKSB7XG4gICAgICBzW3AgLSAxXSA9IDA7XG4gICAgfVxuICAgIGlmIChucnQgKyAxIDwgcCkge1xuICAgICAgZVtucnRdID0gYS5nZXQobnJ0LCBwIC0gMSk7XG4gICAgfVxuICAgIGVbcCAtIDFdID0gMDtcblxuICAgIGlmICh3YW50dSkge1xuICAgICAgZm9yIChsZXQgaiA9IG5jdDsgaiA8IG51OyBqKyspIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICBVLnNldChpLCBqLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBVLnNldChqLCBqLCAxKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGsgPSBuY3QgLSAxOyBrID49IDA7IGstLSkge1xuICAgICAgICBpZiAoc1trXSAhPT0gMCkge1xuICAgICAgICAgIGZvciAobGV0IGogPSBrICsgMTsgaiA8IG51OyBqKyspIHtcbiAgICAgICAgICAgIGxldCB0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBrOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICAgIHQgKz0gVS5nZXQoaSwgaykgKiBVLmdldChpLCBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQgPSAtdCAvIFUuZ2V0KGssIGspO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IGs7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgVS5zZXQoaSwgaiwgVS5nZXQoaSwgaikgKyB0ICogVS5nZXQoaSwgaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGxldCBpID0gazsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgVS5zZXQoaSwgaywgLVUuZ2V0KGksIGspKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgVS5zZXQoaywgaywgMSArIFUuZ2V0KGssIGspKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGsgLSAxOyBpKyspIHtcbiAgICAgICAgICAgIFUuc2V0KGksIGssIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgVS5zZXQoaSwgaywgMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIFUuc2V0KGssIGssIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdhbnR2KSB7XG4gICAgICBmb3IgKGxldCBrID0gbiAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICAgIGlmIChrIDwgbnJ0ICYmIGVba10gIT09IDApIHtcbiAgICAgICAgICBmb3IgKGxldCBqID0gayArIDE7IGogPCBuOyBqKyspIHtcbiAgICAgICAgICAgIGxldCB0ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBrICsgMTsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICB0ICs9IFYuZ2V0KGksIGspICogVi5nZXQoaSwgaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ID0gLXQgLyBWLmdldChrICsgMSwgayk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gayArIDE7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgVi5zZXQoaSwgaiwgVi5nZXQoaSwgaikgKyB0ICogVi5nZXQoaSwgaykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIFYuc2V0KGksIGssIDApO1xuICAgICAgICB9XG4gICAgICAgIFYuc2V0KGssIGssIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBwcCA9IHAgLSAxO1xuICAgIGxldCBlcHMgPSBOdW1iZXIuRVBTSUxPTjtcbiAgICB3aGlsZSAocCA+IDApIHtcbiAgICAgIGxldCBrLCBrYXNlO1xuICAgICAgZm9yIChrID0gcCAtIDI7IGsgPj0gLTE7IGstLSkge1xuICAgICAgICBpZiAoayA9PT0gLTEpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbHBoYSA9XG4gICAgICAgICAgTnVtYmVyLk1JTl9WQUxVRSArIGVwcyAqIE1hdGguYWJzKHNba10gKyBNYXRoLmFicyhzW2sgKyAxXSkpO1xuICAgICAgICBpZiAoTWF0aC5hYnMoZVtrXSkgPD0gYWxwaGEgfHwgTnVtYmVyLmlzTmFOKGVba10pKSB7XG4gICAgICAgICAgZVtrXSA9IDA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChrID09PSBwIC0gMikge1xuICAgICAgICBrYXNlID0gNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBrcztcbiAgICAgICAgZm9yIChrcyA9IHAgLSAxOyBrcyA+PSBrOyBrcy0tKSB7XG4gICAgICAgICAgaWYgKGtzID09PSBrKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IHQgPVxuICAgICAgICAgICAgKGtzICE9PSBwID8gTWF0aC5hYnMoZVtrc10pIDogMCkgK1xuICAgICAgICAgICAgKGtzICE9PSBrICsgMSA/IE1hdGguYWJzKGVba3MgLSAxXSkgOiAwKTtcbiAgICAgICAgICBpZiAoTWF0aC5hYnMoc1trc10pIDw9IGVwcyAqIHQpIHtcbiAgICAgICAgICAgIHNba3NdID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoa3MgPT09IGspIHtcbiAgICAgICAgICBrYXNlID0gMztcbiAgICAgICAgfSBlbHNlIGlmIChrcyA9PT0gcCAtIDEpIHtcbiAgICAgICAgICBrYXNlID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBrYXNlID0gMjtcbiAgICAgICAgICBrID0ga3M7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaysrO1xuXG4gICAgICBzd2l0Y2ggKGthc2UpIHtcbiAgICAgICAgY2FzZSAxOiB7XG4gICAgICAgICAgbGV0IGYgPSBlW3AgLSAyXTtcbiAgICAgICAgICBlW3AgLSAyXSA9IDA7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IHAgLSAyOyBqID49IGs7IGotLSkge1xuICAgICAgICAgICAgbGV0IHQgPSBoeXBvdGVudXNlKHNbal0sIGYpO1xuICAgICAgICAgICAgbGV0IGNzID0gc1tqXSAvIHQ7XG4gICAgICAgICAgICBsZXQgc24gPSBmIC8gdDtcbiAgICAgICAgICAgIHNbal0gPSB0O1xuICAgICAgICAgICAgaWYgKGogIT09IGspIHtcbiAgICAgICAgICAgICAgZiA9IC1zbiAqIGVbaiAtIDFdO1xuICAgICAgICAgICAgICBlW2ogLSAxXSA9IGNzICogZVtqIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2FudHYpIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0ID0gY3MgKiBWLmdldChpLCBqKSArIHNuICogVi5nZXQoaSwgcCAtIDEpO1xuICAgICAgICAgICAgICAgIFYuc2V0KGksIHAgLSAxLCAtc24gKiBWLmdldChpLCBqKSArIGNzICogVi5nZXQoaSwgcCAtIDEpKTtcbiAgICAgICAgICAgICAgICBWLnNldChpLCBqLCB0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIDI6IHtcbiAgICAgICAgICBsZXQgZiA9IGVbayAtIDFdO1xuICAgICAgICAgIGVbayAtIDFdID0gMDtcbiAgICAgICAgICBmb3IgKGxldCBqID0gazsgaiA8IHA7IGorKykge1xuICAgICAgICAgICAgbGV0IHQgPSBoeXBvdGVudXNlKHNbal0sIGYpO1xuICAgICAgICAgICAgbGV0IGNzID0gc1tqXSAvIHQ7XG4gICAgICAgICAgICBsZXQgc24gPSBmIC8gdDtcbiAgICAgICAgICAgIHNbal0gPSB0O1xuICAgICAgICAgICAgZiA9IC1zbiAqIGVbal07XG4gICAgICAgICAgICBlW2pdID0gY3MgKiBlW2pdO1xuICAgICAgICAgICAgaWYgKHdhbnR1KSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdCA9IGNzICogVS5nZXQoaSwgaikgKyBzbiAqIFUuZ2V0KGksIGsgLSAxKTtcbiAgICAgICAgICAgICAgICBVLnNldChpLCBrIC0gMSwgLXNuICogVS5nZXQoaSwgaikgKyBjcyAqIFUuZ2V0KGksIGsgLSAxKSk7XG4gICAgICAgICAgICAgICAgVS5zZXQoaSwgaiwgdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAzOiB7XG4gICAgICAgICAgY29uc3Qgc2NhbGUgPSBNYXRoLm1heChcbiAgICAgICAgICAgIE1hdGguYWJzKHNbcCAtIDFdKSxcbiAgICAgICAgICAgIE1hdGguYWJzKHNbcCAtIDJdKSxcbiAgICAgICAgICAgIE1hdGguYWJzKGVbcCAtIDJdKSxcbiAgICAgICAgICAgIE1hdGguYWJzKHNba10pLFxuICAgICAgICAgICAgTWF0aC5hYnMoZVtrXSksXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb25zdCBzcCA9IHNbcCAtIDFdIC8gc2NhbGU7XG4gICAgICAgICAgY29uc3Qgc3BtMSA9IHNbcCAtIDJdIC8gc2NhbGU7XG4gICAgICAgICAgY29uc3QgZXBtMSA9IGVbcCAtIDJdIC8gc2NhbGU7XG4gICAgICAgICAgY29uc3Qgc2sgPSBzW2tdIC8gc2NhbGU7XG4gICAgICAgICAgY29uc3QgZWsgPSBlW2tdIC8gc2NhbGU7XG4gICAgICAgICAgY29uc3QgYiA9ICgoc3BtMSArIHNwKSAqIChzcG0xIC0gc3ApICsgZXBtMSAqIGVwbTEpIC8gMjtcbiAgICAgICAgICBjb25zdCBjID0gc3AgKiBlcG0xICogKHNwICogZXBtMSk7XG4gICAgICAgICAgbGV0IHNoaWZ0ID0gMDtcbiAgICAgICAgICBpZiAoYiAhPT0gMCB8fCBjICE9PSAwKSB7XG4gICAgICAgICAgICBpZiAoYiA8IDApIHtcbiAgICAgICAgICAgICAgc2hpZnQgPSAwIC0gTWF0aC5zcXJ0KGIgKiBiICsgYyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzaGlmdCA9IE1hdGguc3FydChiICogYiArIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2hpZnQgPSBjIC8gKGIgKyBzaGlmdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBmID0gKHNrICsgc3ApICogKHNrIC0gc3ApICsgc2hpZnQ7XG4gICAgICAgICAgbGV0IGcgPSBzayAqIGVrO1xuICAgICAgICAgIGZvciAobGV0IGogPSBrOyBqIDwgcCAtIDE7IGorKykge1xuICAgICAgICAgICAgbGV0IHQgPSBoeXBvdGVudXNlKGYsIGcpO1xuICAgICAgICAgICAgaWYgKHQgPT09IDApIHQgPSBOdW1iZXIuTUlOX1ZBTFVFO1xuICAgICAgICAgICAgbGV0IGNzID0gZiAvIHQ7XG4gICAgICAgICAgICBsZXQgc24gPSBnIC8gdDtcbiAgICAgICAgICAgIGlmIChqICE9PSBrKSB7XG4gICAgICAgICAgICAgIGVbaiAtIDFdID0gdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGYgPSBjcyAqIHNbal0gKyBzbiAqIGVbal07XG4gICAgICAgICAgICBlW2pdID0gY3MgKiBlW2pdIC0gc24gKiBzW2pdO1xuICAgICAgICAgICAgZyA9IHNuICogc1tqICsgMV07XG4gICAgICAgICAgICBzW2ogKyAxXSA9IGNzICogc1tqICsgMV07XG4gICAgICAgICAgICBpZiAod2FudHYpIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0ID0gY3MgKiBWLmdldChpLCBqKSArIHNuICogVi5nZXQoaSwgaiArIDEpO1xuICAgICAgICAgICAgICAgIFYuc2V0KGksIGogKyAxLCAtc24gKiBWLmdldChpLCBqKSArIGNzICogVi5nZXQoaSwgaiArIDEpKTtcbiAgICAgICAgICAgICAgICBWLnNldChpLCBqLCB0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdCA9IGh5cG90ZW51c2UoZiwgZyk7XG4gICAgICAgICAgICBpZiAodCA9PT0gMCkgdCA9IE51bWJlci5NSU5fVkFMVUU7XG4gICAgICAgICAgICBjcyA9IGYgLyB0O1xuICAgICAgICAgICAgc24gPSBnIC8gdDtcbiAgICAgICAgICAgIHNbal0gPSB0O1xuICAgICAgICAgICAgZiA9IGNzICogZVtqXSArIHNuICogc1tqICsgMV07XG4gICAgICAgICAgICBzW2ogKyAxXSA9IC1zbiAqIGVbal0gKyBjcyAqIHNbaiArIDFdO1xuICAgICAgICAgICAgZyA9IHNuICogZVtqICsgMV07XG4gICAgICAgICAgICBlW2ogKyAxXSA9IGNzICogZVtqICsgMV07XG4gICAgICAgICAgICBpZiAod2FudHUgJiYgaiA8IG0gLSAxKSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdCA9IGNzICogVS5nZXQoaSwgaikgKyBzbiAqIFUuZ2V0KGksIGogKyAxKTtcbiAgICAgICAgICAgICAgICBVLnNldChpLCBqICsgMSwgLXNuICogVS5nZXQoaSwgaikgKyBjcyAqIFUuZ2V0KGksIGogKyAxKSk7XG4gICAgICAgICAgICAgICAgVS5zZXQoaSwgaiwgdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZVtwIC0gMl0gPSBmO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgIGlmIChzW2tdIDw9IDApIHtcbiAgICAgICAgICAgIHNba10gPSBzW2tdIDwgMCA/IC1zW2tdIDogMDtcbiAgICAgICAgICAgIGlmICh3YW50dikge1xuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBwcDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgVi5zZXQoaSwgaywgLVYuZ2V0KGksIGspKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoayA8IHBwKSB7XG4gICAgICAgICAgICBpZiAoc1trXSA+PSBzW2sgKyAxXSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB0ID0gc1trXTtcbiAgICAgICAgICAgIHNba10gPSBzW2sgKyAxXTtcbiAgICAgICAgICAgIHNbayArIDFdID0gdDtcbiAgICAgICAgICAgIGlmICh3YW50diAmJiBrIDwgbiAtIDEpIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0ID0gVi5nZXQoaSwgayArIDEpO1xuICAgICAgICAgICAgICAgIFYuc2V0KGksIGsgKyAxLCBWLmdldChpLCBrKSk7XG4gICAgICAgICAgICAgICAgVi5zZXQoaSwgaywgdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3YW50dSAmJiBrIDwgbSAtIDEpIHtcbiAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0ID0gVS5nZXQoaSwgayArIDEpO1xuICAgICAgICAgICAgICAgIFUuc2V0KGksIGsgKyAxLCBVLmdldChpLCBrKSk7XG4gICAgICAgICAgICAgICAgVS5zZXQoaSwgaywgdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGsrKztcbiAgICAgICAgICB9XG4gICAgICAgICAgcC0tO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vIGRlZmF1bHRcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc3dhcHBlZCkge1xuICAgICAgbGV0IHRtcCA9IFY7XG4gICAgICBWID0gVTtcbiAgICAgIFUgPSB0bXA7XG4gICAgfVxuXG4gICAgdGhpcy5tID0gbTtcbiAgICB0aGlzLm4gPSBuO1xuICAgIHRoaXMucyA9IHM7XG4gICAgdGhpcy5VID0gVTtcbiAgICB0aGlzLlYgPSBWO1xuICB9XG5cbiAgc29sdmUodmFsdWUpIHtcbiAgICBsZXQgWSA9IHZhbHVlO1xuICAgIGxldCBlID0gdGhpcy50aHJlc2hvbGQ7XG4gICAgbGV0IHNjb2xzID0gdGhpcy5zLmxlbmd0aDtcbiAgICBsZXQgTHMgPSBNYXRyaXguemVyb3Moc2NvbHMsIHNjb2xzKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2NvbHM7IGkrKykge1xuICAgICAgaWYgKE1hdGguYWJzKHRoaXMuc1tpXSkgPD0gZSkge1xuICAgICAgICBMcy5zZXQoaSwgaSwgMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBMcy5zZXQoaSwgaSwgMSAvIHRoaXMuc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGV0IFUgPSB0aGlzLlU7XG4gICAgbGV0IFYgPSB0aGlzLnJpZ2h0U2luZ3VsYXJWZWN0b3JzO1xuXG4gICAgbGV0IFZMID0gVi5tbXVsKExzKTtcbiAgICBsZXQgdnJvd3MgPSBWLnJvd3M7XG4gICAgbGV0IHVyb3dzID0gVS5yb3dzO1xuICAgIGxldCBWTFUgPSBNYXRyaXguemVyb3ModnJvd3MsIHVyb3dzKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB1cm93czsgaisrKSB7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHNjb2xzOyBrKyspIHtcbiAgICAgICAgICBzdW0gKz0gVkwuZ2V0KGksIGspICogVS5nZXQoaiwgayk7XG4gICAgICAgIH1cbiAgICAgICAgVkxVLnNldChpLCBqLCBzdW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBWTFUubW11bChZKTtcbiAgfVxuXG4gIHNvbHZlRm9yRGlhZ29uYWwodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5zb2x2ZShNYXRyaXguZGlhZyh2YWx1ZSkpO1xuICB9XG5cbiAgaW52ZXJzZSgpIHtcbiAgICBsZXQgViA9IHRoaXMuVjtcbiAgICBsZXQgZSA9IHRoaXMudGhyZXNob2xkO1xuICAgIGxldCB2cm93cyA9IFYucm93cztcbiAgICBsZXQgdmNvbHMgPSBWLmNvbHVtbnM7XG4gICAgbGV0IFggPSBuZXcgTWF0cml4KHZyb3dzLCB0aGlzLnMubGVuZ3RoKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2Y29sczsgaisrKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyh0aGlzLnNbal0pID4gZSkge1xuICAgICAgICAgIFguc2V0KGksIGosIFYuZ2V0KGksIGopIC8gdGhpcy5zW2pdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBVID0gdGhpcy5VO1xuXG4gICAgbGV0IHVyb3dzID0gVS5yb3dzO1xuICAgIGxldCB1Y29scyA9IFUuY29sdW1ucztcbiAgICBsZXQgWSA9IG5ldyBNYXRyaXgodnJvd3MsIHVyb3dzKTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdnJvd3M7IGkrKykge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB1cm93czsgaisrKSB7XG4gICAgICAgIGxldCBzdW0gPSAwO1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHVjb2xzOyBrKyspIHtcbiAgICAgICAgICBzdW0gKz0gWC5nZXQoaSwgaykgKiBVLmdldChqLCBrKTtcbiAgICAgICAgfVxuICAgICAgICBZLnNldChpLCBqLCBzdW0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBZO1xuICB9XG5cbiAgZ2V0IGNvbmRpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zWzBdIC8gdGhpcy5zW01hdGgubWluKHRoaXMubSwgdGhpcy5uKSAtIDFdO1xuICB9XG5cbiAgZ2V0IG5vcm0yKCkge1xuICAgIHJldHVybiB0aGlzLnNbMF07XG4gIH1cblxuICBnZXQgcmFuaygpIHtcbiAgICBsZXQgdG9sID0gTWF0aC5tYXgodGhpcy5tLCB0aGlzLm4pICogdGhpcy5zWzBdICogTnVtYmVyLkVQU0lMT047XG4gICAgbGV0IHIgPSAwO1xuICAgIGxldCBzID0gdGhpcy5zO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHMubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgaWYgKHNbaV0gPiB0b2wpIHtcbiAgICAgICAgcisrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIGdldCBkaWFnb25hbCgpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnMpO1xuICB9XG5cbiAgZ2V0IHRocmVzaG9sZCgpIHtcbiAgICByZXR1cm4gKE51bWJlci5FUFNJTE9OIC8gMikgKiBNYXRoLm1heCh0aGlzLm0sIHRoaXMubikgKiB0aGlzLnNbMF07XG4gIH1cblxuICBnZXQgbGVmdFNpbmd1bGFyVmVjdG9ycygpIHtcbiAgICByZXR1cm4gdGhpcy5VO1xuICB9XG5cbiAgZ2V0IHJpZ2h0U2luZ3VsYXJWZWN0b3JzKCkge1xuICAgIHJldHVybiB0aGlzLlY7XG4gIH1cblxuICBnZXQgZGlhZ29uYWxNYXRyaXgoKSB7XG4gICAgcmV0dXJuIE1hdHJpeC5kaWFnKHRoaXMucyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW52ZXJzZShtYXRyaXgsIHVzZVNWRCA9IGZhbHNlKSB7XG4gIG1hdHJpeCA9IFdyYXBwZXJNYXRyaXgyRC5jaGVja01hdHJpeChtYXRyaXgpO1xuICBpZiAodXNlU1ZEKSB7XG4gICAgcmV0dXJuIG5ldyBTaW5ndWxhclZhbHVlRGVjb21wb3NpdGlvbihtYXRyaXgpLmludmVyc2UoKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc29sdmUobWF0cml4LCBNYXRyaXguZXllKG1hdHJpeC5yb3dzKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc29sdmUobGVmdEhhbmRTaWRlLCByaWdodEhhbmRTaWRlLCB1c2VTVkQgPSBmYWxzZSkge1xuICBsZWZ0SGFuZFNpZGUgPSBXcmFwcGVyTWF0cml4MkQuY2hlY2tNYXRyaXgobGVmdEhhbmRTaWRlKTtcbiAgcmlnaHRIYW5kU2lkZSA9IFdyYXBwZXJNYXRyaXgyRC5jaGVja01hdHJpeChyaWdodEhhbmRTaWRlKTtcbiAgaWYgKHVzZVNWRCkge1xuICAgIHJldHVybiBuZXcgU2luZ3VsYXJWYWx1ZURlY29tcG9zaXRpb24obGVmdEhhbmRTaWRlKS5zb2x2ZShyaWdodEhhbmRTaWRlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGVmdEhhbmRTaWRlLmlzU3F1YXJlKClcbiAgICAgID8gbmV3IEx1RGVjb21wb3NpdGlvbihsZWZ0SGFuZFNpZGUpLnNvbHZlKHJpZ2h0SGFuZFNpZGUpXG4gICAgICA6IG5ldyBRckRlY29tcG9zaXRpb24obGVmdEhhbmRTaWRlKS5zb2x2ZShyaWdodEhhbmRTaWRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmFudChtYXRyaXgpIHtcbiAgbWF0cml4ID0gTWF0cml4LmNoZWNrTWF0cml4KG1hdHJpeCk7XG4gIGlmIChtYXRyaXguaXNTcXVhcmUoKSkge1xuICAgIGlmIChtYXRyaXguY29sdW1ucyA9PT0gMCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuXG4gICAgbGV0IGEsIGIsIGMsIGQ7XG4gICAgaWYgKG1hdHJpeC5jb2x1bW5zID09PSAyKSB7XG4gICAgICAvLyAyIHggMiBtYXRyaXhcbiAgICAgIGEgPSBtYXRyaXguZ2V0KDAsIDApO1xuICAgICAgYiA9IG1hdHJpeC5nZXQoMCwgMSk7XG4gICAgICBjID0gbWF0cml4LmdldCgxLCAwKTtcbiAgICAgIGQgPSBtYXRyaXguZ2V0KDEsIDEpO1xuXG4gICAgICByZXR1cm4gYSAqIGQgLSBiICogYztcbiAgICB9IGVsc2UgaWYgKG1hdHJpeC5jb2x1bW5zID09PSAzKSB7XG4gICAgICAvLyAzIHggMyBtYXRyaXhcbiAgICAgIGxldCBzdWJNYXRyaXgwLCBzdWJNYXRyaXgxLCBzdWJNYXRyaXgyO1xuICAgICAgc3ViTWF0cml4MCA9IG5ldyBNYXRyaXhTZWxlY3Rpb25WaWV3KG1hdHJpeCwgWzEsIDJdLCBbMSwgMl0pO1xuICAgICAgc3ViTWF0cml4MSA9IG5ldyBNYXRyaXhTZWxlY3Rpb25WaWV3KG1hdHJpeCwgWzEsIDJdLCBbMCwgMl0pO1xuICAgICAgc3ViTWF0cml4MiA9IG5ldyBNYXRyaXhTZWxlY3Rpb25WaWV3KG1hdHJpeCwgWzEsIDJdLCBbMCwgMV0pO1xuICAgICAgYSA9IG1hdHJpeC5nZXQoMCwgMCk7XG4gICAgICBiID0gbWF0cml4LmdldCgwLCAxKTtcbiAgICAgIGMgPSBtYXRyaXguZ2V0KDAsIDIpO1xuXG4gICAgICByZXR1cm4gKFxuICAgICAgICBhICogZGV0ZXJtaW5hbnQoc3ViTWF0cml4MCkgLVxuICAgICAgICBiICogZGV0ZXJtaW5hbnQoc3ViTWF0cml4MSkgK1xuICAgICAgICBjICogZGV0ZXJtaW5hbnQoc3ViTWF0cml4MilcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGdlbmVyYWwgcHVycG9zZSBkZXRlcm1pbmFudCB1c2luZyB0aGUgTFUgZGVjb21wb3NpdGlvblxuICAgICAgcmV0dXJuIG5ldyBMdURlY29tcG9zaXRpb24obWF0cml4KS5kZXRlcm1pbmFudDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoJ2RldGVybWluYW50IGNhbiBvbmx5IGJlIGNhbGN1bGF0ZWQgZm9yIGEgc3F1YXJlIG1hdHJpeCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHhyYW5nZShuLCBleGNlcHRpb24pIHtcbiAgbGV0IHJhbmdlID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgaWYgKGkgIT09IGV4Y2VwdGlvbikge1xuICAgICAgcmFuZ2UucHVzaChpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJhbmdlO1xufVxuXG5mdW5jdGlvbiBkZXBlbmRlbmNpZXNPbmVSb3coXG4gIGVycm9yLFxuICBtYXRyaXgsXG4gIGluZGV4LFxuICB0aHJlc2hvbGRWYWx1ZSA9IDEwZS0xMCxcbiAgdGhyZXNob2xkRXJyb3IgPSAxMGUtMTAsXG4pIHtcbiAgaWYgKGVycm9yID4gdGhyZXNob2xkRXJyb3IpIHtcbiAgICByZXR1cm4gbmV3IEFycmF5KG1hdHJpeC5yb3dzICsgMSkuZmlsbCgwKTtcbiAgfSBlbHNlIHtcbiAgICBsZXQgcmV0dXJuQXJyYXkgPSBtYXRyaXguYWRkUm93KGluZGV4LCBbMF0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmV0dXJuQXJyYXkucm93czsgaSsrKSB7XG4gICAgICBpZiAoTWF0aC5hYnMocmV0dXJuQXJyYXkuZ2V0KGksIDApKSA8IHRocmVzaG9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybkFycmF5LnNldChpLCAwLCAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldHVybkFycmF5LnRvMURBcnJheSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxpbmVhckRlcGVuZGVuY2llcyhtYXRyaXgsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7IHRocmVzaG9sZFZhbHVlID0gMTBlLTEwLCB0aHJlc2hvbGRFcnJvciA9IDEwZS0xMCB9ID0gb3B0aW9ucztcbiAgbWF0cml4ID0gTWF0cml4LmNoZWNrTWF0cml4KG1hdHJpeCk7XG5cbiAgbGV0IG4gPSBtYXRyaXgucm93cztcbiAgbGV0IHJlc3VsdHMgPSBuZXcgTWF0cml4KG4sIG4pO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgaSsrKSB7XG4gICAgbGV0IGIgPSBNYXRyaXguY29sdW1uVmVjdG9yKG1hdHJpeC5nZXRSb3coaSkpO1xuICAgIGxldCBBYmlzID0gbWF0cml4LnN1Yk1hdHJpeFJvdyh4cmFuZ2UobiwgaSkpLnRyYW5zcG9zZSgpO1xuICAgIGxldCBzdmQgPSBuZXcgU2luZ3VsYXJWYWx1ZURlY29tcG9zaXRpb24oQWJpcyk7XG4gICAgbGV0IHggPSBzdmQuc29sdmUoYik7XG4gICAgbGV0IGVycm9yID0gTWF0cml4LnN1YihiLCBBYmlzLm1tdWwoeCkpLmFicygpLm1heCgpO1xuICAgIHJlc3VsdHMuc2V0Um93KFxuICAgICAgaSxcbiAgICAgIGRlcGVuZGVuY2llc09uZVJvdyhlcnJvciwgeCwgaSwgdGhyZXNob2xkVmFsdWUsIHRocmVzaG9sZEVycm9yKSxcbiAgICApO1xuICB9XG4gIHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBwc2V1ZG9JbnZlcnNlKG1hdHJpeCwgdGhyZXNob2xkID0gTnVtYmVyLkVQU0lMT04pIHtcbiAgbWF0cml4ID0gTWF0cml4LmNoZWNrTWF0cml4KG1hdHJpeCk7XG4gIGlmIChtYXRyaXguaXNFbXB0eSgpKSB7XG4gICAgLy8gd2l0aCBhIHplcm8gZGltZW5zaW9uLCB0aGUgcHNldWRvLWludmVyc2UgaXMgdGhlIHRyYW5zcG9zZSwgc2luY2UgYWxsIDB4biBhbmQgbngwIG1hdHJpY2VzIGFyZSBzaW5ndWxhclxuICAgIC8vICgweG4pKihueDApKigweG4pID0gMHhuXG4gICAgLy8gKG54MCkqKDB4bikqKG54MCkgPSBueDBcbiAgICByZXR1cm4gbWF0cml4LnRyYW5zcG9zZSgpO1xuICB9XG4gIGxldCBzdmRTb2x1dGlvbiA9IG5ldyBTaW5ndWxhclZhbHVlRGVjb21wb3NpdGlvbihtYXRyaXgsIHsgYXV0b1RyYW5zcG9zZTogdHJ1ZSB9KTtcblxuICBsZXQgVSA9IHN2ZFNvbHV0aW9uLmxlZnRTaW5ndWxhclZlY3RvcnM7XG4gIGxldCBWID0gc3ZkU29sdXRpb24ucmlnaHRTaW5ndWxhclZlY3RvcnM7XG4gIGxldCBzID0gc3ZkU29sdXRpb24uZGlhZ29uYWw7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKE1hdGguYWJzKHNbaV0pID4gdGhyZXNob2xkKSB7XG4gICAgICBzW2ldID0gMS4wIC8gc1tpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgc1tpXSA9IDAuMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gVi5tbXVsKE1hdHJpeC5kaWFnKHMpLm1tdWwoVS50cmFuc3Bvc2UoKSkpO1xufVxuXG5mdW5jdGlvbiBjb3ZhcmlhbmNlKHhNYXRyaXgsIHlNYXRyaXggPSB4TWF0cml4LCBvcHRpb25zID0ge30pIHtcbiAgeE1hdHJpeCA9IG5ldyBNYXRyaXgoeE1hdHJpeCk7XG4gIGxldCB5SXNTYW1lID0gZmFsc2U7XG4gIGlmIChcbiAgICB0eXBlb2YgeU1hdHJpeCA9PT0gJ29iamVjdCcgJiZcbiAgICAhTWF0cml4LmlzTWF0cml4KHlNYXRyaXgpICYmXG4gICAgIWlzQW55QXJyYXkuaXNBbnlBcnJheSh5TWF0cml4KVxuICApIHtcbiAgICBvcHRpb25zID0geU1hdHJpeDtcbiAgICB5TWF0cml4ID0geE1hdHJpeDtcbiAgICB5SXNTYW1lID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB5TWF0cml4ID0gbmV3IE1hdHJpeCh5TWF0cml4KTtcbiAgfVxuICBpZiAoeE1hdHJpeC5yb3dzICE9PSB5TWF0cml4LnJvd3MpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb3RoIG1hdHJpY2VzIG11c3QgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2Ygcm93cycpO1xuICB9XG4gIGNvbnN0IHsgY2VudGVyID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgaWYgKGNlbnRlcikge1xuICAgIHhNYXRyaXggPSB4TWF0cml4LmNlbnRlcignY29sdW1uJyk7XG4gICAgaWYgKCF5SXNTYW1lKSB7XG4gICAgICB5TWF0cml4ID0geU1hdHJpeC5jZW50ZXIoJ2NvbHVtbicpO1xuICAgIH1cbiAgfVxuICBjb25zdCBjb3YgPSB4TWF0cml4LnRyYW5zcG9zZSgpLm1tdWwoeU1hdHJpeCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY292LnJvd3M7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY292LmNvbHVtbnM7IGorKykge1xuICAgICAgY292LnNldChpLCBqLCBjb3YuZ2V0KGksIGopICogKDEgLyAoeE1hdHJpeC5yb3dzIC0gMSkpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvdjtcbn1cblxuZnVuY3Rpb24gY29ycmVsYXRpb24oeE1hdHJpeCwgeU1hdHJpeCA9IHhNYXRyaXgsIG9wdGlvbnMgPSB7fSkge1xuICB4TWF0cml4ID0gbmV3IE1hdHJpeCh4TWF0cml4KTtcbiAgbGV0IHlJc1NhbWUgPSBmYWxzZTtcbiAgaWYgKFxuICAgIHR5cGVvZiB5TWF0cml4ID09PSAnb2JqZWN0JyAmJlxuICAgICFNYXRyaXguaXNNYXRyaXgoeU1hdHJpeCkgJiZcbiAgICAhaXNBbnlBcnJheS5pc0FueUFycmF5KHlNYXRyaXgpXG4gICkge1xuICAgIG9wdGlvbnMgPSB5TWF0cml4O1xuICAgIHlNYXRyaXggPSB4TWF0cml4O1xuICAgIHlJc1NhbWUgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHlNYXRyaXggPSBuZXcgTWF0cml4KHlNYXRyaXgpO1xuICB9XG4gIGlmICh4TWF0cml4LnJvd3MgIT09IHlNYXRyaXgucm93cykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JvdGggbWF0cmljZXMgbXVzdCBoYXZlIHRoZSBzYW1lIG51bWJlciBvZiByb3dzJyk7XG4gIH1cblxuICBjb25zdCB7IGNlbnRlciA9IHRydWUsIHNjYWxlID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgaWYgKGNlbnRlcikge1xuICAgIHhNYXRyaXguY2VudGVyKCdjb2x1bW4nKTtcbiAgICBpZiAoIXlJc1NhbWUpIHtcbiAgICAgIHlNYXRyaXguY2VudGVyKCdjb2x1bW4nKTtcbiAgICB9XG4gIH1cbiAgaWYgKHNjYWxlKSB7XG4gICAgeE1hdHJpeC5zY2FsZSgnY29sdW1uJyk7XG4gICAgaWYgKCF5SXNTYW1lKSB7XG4gICAgICB5TWF0cml4LnNjYWxlKCdjb2x1bW4nKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCBzZHggPSB4TWF0cml4LnN0YW5kYXJkRGV2aWF0aW9uKCdjb2x1bW4nLCB7IHVuYmlhc2VkOiB0cnVlIH0pO1xuICBjb25zdCBzZHkgPSB5SXNTYW1lXG4gICAgPyBzZHhcbiAgICA6IHlNYXRyaXguc3RhbmRhcmREZXZpYXRpb24oJ2NvbHVtbicsIHsgdW5iaWFzZWQ6IHRydWUgfSk7XG5cbiAgY29uc3QgY29yciA9IHhNYXRyaXgudHJhbnNwb3NlKCkubW11bCh5TWF0cml4KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3JyLnJvd3M7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY29yci5jb2x1bW5zOyBqKyspIHtcbiAgICAgIGNvcnIuc2V0KFxuICAgICAgICBpLFxuICAgICAgICBqLFxuICAgICAgICBjb3JyLmdldChpLCBqKSAqICgxIC8gKHNkeFtpXSAqIHNkeVtqXSkpICogKDEgLyAoeE1hdHJpeC5yb3dzIC0gMSkpLFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvcnI7XG59XG5cbmNsYXNzIEVpZ2VudmFsdWVEZWNvbXBvc2l0aW9uIHtcbiAgY29uc3RydWN0b3IobWF0cml4LCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCB7IGFzc3VtZVN5bW1ldHJpYyA9IGZhbHNlIH0gPSBvcHRpb25zO1xuXG4gICAgbWF0cml4ID0gV3JhcHBlck1hdHJpeDJELmNoZWNrTWF0cml4KG1hdHJpeCk7XG4gICAgaWYgKCFtYXRyaXguaXNTcXVhcmUoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXRyaXggaXMgbm90IGEgc3F1YXJlIG1hdHJpeCcpO1xuICAgIH1cblxuICAgIGlmIChtYXRyaXguaXNFbXB0eSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdHJpeCBtdXN0IGJlIG5vbi1lbXB0eScpO1xuICAgIH1cblxuICAgIGxldCBuID0gbWF0cml4LmNvbHVtbnM7XG4gICAgbGV0IFYgPSBuZXcgTWF0cml4KG4sIG4pO1xuICAgIGxldCBkID0gbmV3IEZsb2F0NjRBcnJheShuKTtcbiAgICBsZXQgZSA9IG5ldyBGbG9hdDY0QXJyYXkobik7XG4gICAgbGV0IHZhbHVlID0gbWF0cml4O1xuICAgIGxldCBpLCBqO1xuXG4gICAgbGV0IGlzU3ltbWV0cmljID0gZmFsc2U7XG4gICAgaWYgKGFzc3VtZVN5bW1ldHJpYykge1xuICAgICAgaXNTeW1tZXRyaWMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc1N5bW1ldHJpYyA9IG1hdHJpeC5pc1N5bW1ldHJpYygpO1xuICAgIH1cblxuICAgIGlmIChpc1N5bW1ldHJpYykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgbjsgaisrKSB7XG4gICAgICAgICAgVi5zZXQoaSwgaiwgdmFsdWUuZ2V0KGksIGopKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdHJlZDIobiwgZSwgZCwgVik7XG4gICAgICB0cWwyKG4sIGUsIGQsIFYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgSCA9IG5ldyBNYXRyaXgobiwgbik7XG4gICAgICBsZXQgb3J0ID0gbmV3IEZsb2F0NjRBcnJheShuKTtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgIEguc2V0KGksIGosIHZhbHVlLmdldChpLCBqKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9ydGhlcyhuLCBILCBvcnQsIFYpO1xuICAgICAgaHFyMihuLCBlLCBkLCBWLCBIKTtcbiAgICB9XG5cbiAgICB0aGlzLm4gPSBuO1xuICAgIHRoaXMuZSA9IGU7XG4gICAgdGhpcy5kID0gZDtcbiAgICB0aGlzLlYgPSBWO1xuICB9XG5cbiAgZ2V0IHJlYWxFaWdlbnZhbHVlcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmQpO1xuICB9XG5cbiAgZ2V0IGltYWdpbmFyeUVpZ2VudmFsdWVzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuZSk7XG4gIH1cblxuICBnZXQgZWlnZW52ZWN0b3JNYXRyaXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuVjtcbiAgfVxuXG4gIGdldCBkaWFnb25hbE1hdHJpeCgpIHtcbiAgICBsZXQgbiA9IHRoaXMubjtcbiAgICBsZXQgZSA9IHRoaXMuZTtcbiAgICBsZXQgZCA9IHRoaXMuZDtcbiAgICBsZXQgWCA9IG5ldyBNYXRyaXgobiwgbik7XG4gICAgbGV0IGksIGo7XG4gICAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgICAgICBYLnNldChpLCBqLCAwKTtcbiAgICAgIH1cbiAgICAgIFguc2V0KGksIGksIGRbaV0pO1xuICAgICAgaWYgKGVbaV0gPiAwKSB7XG4gICAgICAgIFguc2V0KGksIGkgKyAxLCBlW2ldKTtcbiAgICAgIH0gZWxzZSBpZiAoZVtpXSA8IDApIHtcbiAgICAgICAgWC5zZXQoaSwgaSAtIDEsIGVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gWDtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cmVkMihuLCBlLCBkLCBWKSB7XG4gIGxldCBmLCBnLCBoLCBpLCBqLCBrLCBoaCwgc2NhbGU7XG5cbiAgZm9yIChqID0gMDsgaiA8IG47IGorKykge1xuICAgIGRbal0gPSBWLmdldChuIC0gMSwgaik7XG4gIH1cblxuICBmb3IgKGkgPSBuIC0gMTsgaSA+IDA7IGktLSkge1xuICAgIHNjYWxlID0gMDtcbiAgICBoID0gMDtcbiAgICBmb3IgKGsgPSAwOyBrIDwgaTsgaysrKSB7XG4gICAgICBzY2FsZSA9IHNjYWxlICsgTWF0aC5hYnMoZFtrXSk7XG4gICAgfVxuXG4gICAgaWYgKHNjYWxlID09PSAwKSB7XG4gICAgICBlW2ldID0gZFtpIC0gMV07XG4gICAgICBmb3IgKGogPSAwOyBqIDwgaTsgaisrKSB7XG4gICAgICAgIGRbal0gPSBWLmdldChpIC0gMSwgaik7XG4gICAgICAgIFYuc2V0KGksIGosIDApO1xuICAgICAgICBWLnNldChqLCBpLCAwKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChrID0gMDsgayA8IGk7IGsrKykge1xuICAgICAgICBkW2tdIC89IHNjYWxlO1xuICAgICAgICBoICs9IGRba10gKiBkW2tdO1xuICAgICAgfVxuXG4gICAgICBmID0gZFtpIC0gMV07XG4gICAgICBnID0gTWF0aC5zcXJ0KGgpO1xuICAgICAgaWYgKGYgPiAwKSB7XG4gICAgICAgIGcgPSAtZztcbiAgICAgIH1cblxuICAgICAgZVtpXSA9IHNjYWxlICogZztcbiAgICAgIGggPSBoIC0gZiAqIGc7XG4gICAgICBkW2kgLSAxXSA9IGYgLSBnO1xuICAgICAgZm9yIChqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgICBlW2pdID0gMDtcbiAgICAgIH1cblxuICAgICAgZm9yIChqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgICBmID0gZFtqXTtcbiAgICAgICAgVi5zZXQoaiwgaSwgZik7XG4gICAgICAgIGcgPSBlW2pdICsgVi5nZXQoaiwgaikgKiBmO1xuICAgICAgICBmb3IgKGsgPSBqICsgMTsgayA8PSBpIC0gMTsgaysrKSB7XG4gICAgICAgICAgZyArPSBWLmdldChrLCBqKSAqIGRba107XG4gICAgICAgICAgZVtrXSArPSBWLmdldChrLCBqKSAqIGY7XG4gICAgICAgIH1cbiAgICAgICAgZVtqXSA9IGc7XG4gICAgICB9XG5cbiAgICAgIGYgPSAwO1xuICAgICAgZm9yIChqID0gMDsgaiA8IGk7IGorKykge1xuICAgICAgICBlW2pdIC89IGg7XG4gICAgICAgIGYgKz0gZVtqXSAqIGRbal07XG4gICAgICB9XG5cbiAgICAgIGhoID0gZiAvIChoICsgaCk7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgaTsgaisrKSB7XG4gICAgICAgIGVbal0gLT0gaGggKiBkW2pdO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGogPSAwOyBqIDwgaTsgaisrKSB7XG4gICAgICAgIGYgPSBkW2pdO1xuICAgICAgICBnID0gZVtqXTtcbiAgICAgICAgZm9yIChrID0gajsgayA8PSBpIC0gMTsgaysrKSB7XG4gICAgICAgICAgVi5zZXQoaywgaiwgVi5nZXQoaywgaikgLSAoZiAqIGVba10gKyBnICogZFtrXSkpO1xuICAgICAgICB9XG4gICAgICAgIGRbal0gPSBWLmdldChpIC0gMSwgaik7XG4gICAgICAgIFYuc2V0KGksIGosIDApO1xuICAgICAgfVxuICAgIH1cbiAgICBkW2ldID0gaDtcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBuIC0gMTsgaSsrKSB7XG4gICAgVi5zZXQobiAtIDEsIGksIFYuZ2V0KGksIGkpKTtcbiAgICBWLnNldChpLCBpLCAxKTtcbiAgICBoID0gZFtpICsgMV07XG4gICAgaWYgKGggIT09IDApIHtcbiAgICAgIGZvciAoayA9IDA7IGsgPD0gaTsgaysrKSB7XG4gICAgICAgIGRba10gPSBWLmdldChrLCBpICsgMSkgLyBoO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGogPSAwOyBqIDw9IGk7IGorKykge1xuICAgICAgICBnID0gMDtcbiAgICAgICAgZm9yIChrID0gMDsgayA8PSBpOyBrKyspIHtcbiAgICAgICAgICBnICs9IFYuZ2V0KGssIGkgKyAxKSAqIFYuZ2V0KGssIGopO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoayA9IDA7IGsgPD0gaTsgaysrKSB7XG4gICAgICAgICAgVi5zZXQoaywgaiwgVi5nZXQoaywgaikgLSBnICogZFtrXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGsgPSAwOyBrIDw9IGk7IGsrKykge1xuICAgICAgVi5zZXQoaywgaSArIDEsIDApO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICBkW2pdID0gVi5nZXQobiAtIDEsIGopO1xuICAgIFYuc2V0KG4gLSAxLCBqLCAwKTtcbiAgfVxuXG4gIFYuc2V0KG4gLSAxLCBuIC0gMSwgMSk7XG4gIGVbMF0gPSAwO1xufVxuXG5mdW5jdGlvbiB0cWwyKG4sIGUsIGQsIFYpIHtcbiAgbGV0IGcsIGgsIGksIGosIGssIGwsIG0sIHAsIHIsIGRsMSwgYywgYzIsIGMzLCBlbDEsIHMsIHMyO1xuXG4gIGZvciAoaSA9IDE7IGkgPCBuOyBpKyspIHtcbiAgICBlW2kgLSAxXSA9IGVbaV07XG4gIH1cblxuICBlW24gLSAxXSA9IDA7XG5cbiAgbGV0IGYgPSAwO1xuICBsZXQgdHN0MSA9IDA7XG4gIGxldCBlcHMgPSBOdW1iZXIuRVBTSUxPTjtcblxuICBmb3IgKGwgPSAwOyBsIDwgbjsgbCsrKSB7XG4gICAgdHN0MSA9IE1hdGgubWF4KHRzdDEsIE1hdGguYWJzKGRbbF0pICsgTWF0aC5hYnMoZVtsXSkpO1xuICAgIG0gPSBsO1xuICAgIHdoaWxlIChtIDwgbikge1xuICAgICAgaWYgKE1hdGguYWJzKGVbbV0pIDw9IGVwcyAqIHRzdDEpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBtKys7XG4gICAgfVxuXG4gICAgaWYgKG0gPiBsKSB7XG4gICAgICBkbyB7XG5cbiAgICAgICAgZyA9IGRbbF07XG4gICAgICAgIHAgPSAoZFtsICsgMV0gLSBnKSAvICgyICogZVtsXSk7XG4gICAgICAgIHIgPSBoeXBvdGVudXNlKHAsIDEpO1xuICAgICAgICBpZiAocCA8IDApIHtcbiAgICAgICAgICByID0gLXI7XG4gICAgICAgIH1cblxuICAgICAgICBkW2xdID0gZVtsXSAvIChwICsgcik7XG4gICAgICAgIGRbbCArIDFdID0gZVtsXSAqIChwICsgcik7XG4gICAgICAgIGRsMSA9IGRbbCArIDFdO1xuICAgICAgICBoID0gZyAtIGRbbF07XG4gICAgICAgIGZvciAoaSA9IGwgKyAyOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgZFtpXSAtPSBoO1xuICAgICAgICB9XG5cbiAgICAgICAgZiA9IGYgKyBoO1xuXG4gICAgICAgIHAgPSBkW21dO1xuICAgICAgICBjID0gMTtcbiAgICAgICAgYzIgPSBjO1xuICAgICAgICBjMyA9IGM7XG4gICAgICAgIGVsMSA9IGVbbCArIDFdO1xuICAgICAgICBzID0gMDtcbiAgICAgICAgczIgPSAwO1xuICAgICAgICBmb3IgKGkgPSBtIC0gMTsgaSA+PSBsOyBpLS0pIHtcbiAgICAgICAgICBjMyA9IGMyO1xuICAgICAgICAgIGMyID0gYztcbiAgICAgICAgICBzMiA9IHM7XG4gICAgICAgICAgZyA9IGMgKiBlW2ldO1xuICAgICAgICAgIGggPSBjICogcDtcbiAgICAgICAgICByID0gaHlwb3RlbnVzZShwLCBlW2ldKTtcbiAgICAgICAgICBlW2kgKyAxXSA9IHMgKiByO1xuICAgICAgICAgIHMgPSBlW2ldIC8gcjtcbiAgICAgICAgICBjID0gcCAvIHI7XG4gICAgICAgICAgcCA9IGMgKiBkW2ldIC0gcyAqIGc7XG4gICAgICAgICAgZFtpICsgMV0gPSBoICsgcyAqIChjICogZyArIHMgKiBkW2ldKTtcblxuICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBuOyBrKyspIHtcbiAgICAgICAgICAgIGggPSBWLmdldChrLCBpICsgMSk7XG4gICAgICAgICAgICBWLnNldChrLCBpICsgMSwgcyAqIFYuZ2V0KGssIGkpICsgYyAqIGgpO1xuICAgICAgICAgICAgVi5zZXQoaywgaSwgYyAqIFYuZ2V0KGssIGkpIC0gcyAqIGgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHAgPSAoLXMgKiBzMiAqIGMzICogZWwxICogZVtsXSkgLyBkbDE7XG4gICAgICAgIGVbbF0gPSBzICogcDtcbiAgICAgICAgZFtsXSA9IGMgKiBwO1xuICAgICAgfSB3aGlsZSAoTWF0aC5hYnMoZVtsXSkgPiBlcHMgKiB0c3QxKTtcbiAgICB9XG4gICAgZFtsXSA9IGRbbF0gKyBmO1xuICAgIGVbbF0gPSAwO1xuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IG4gLSAxOyBpKyspIHtcbiAgICBrID0gaTtcbiAgICBwID0gZFtpXTtcbiAgICBmb3IgKGogPSBpICsgMTsgaiA8IG47IGorKykge1xuICAgICAgaWYgKGRbal0gPCBwKSB7XG4gICAgICAgIGsgPSBqO1xuICAgICAgICBwID0gZFtqXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoayAhPT0gaSkge1xuICAgICAgZFtrXSA9IGRbaV07XG4gICAgICBkW2ldID0gcDtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgICAgcCA9IFYuZ2V0KGosIGkpO1xuICAgICAgICBWLnNldChqLCBpLCBWLmdldChqLCBrKSk7XG4gICAgICAgIFYuc2V0KGosIGssIHApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvcnRoZXMobiwgSCwgb3J0LCBWKSB7XG4gIGxldCBsb3cgPSAwO1xuICBsZXQgaGlnaCA9IG4gLSAxO1xuICBsZXQgZiwgZywgaCwgaSwgaiwgbTtcbiAgbGV0IHNjYWxlO1xuXG4gIGZvciAobSA9IGxvdyArIDE7IG0gPD0gaGlnaCAtIDE7IG0rKykge1xuICAgIHNjYWxlID0gMDtcbiAgICBmb3IgKGkgPSBtOyBpIDw9IGhpZ2g7IGkrKykge1xuICAgICAgc2NhbGUgPSBzY2FsZSArIE1hdGguYWJzKEguZ2V0KGksIG0gLSAxKSk7XG4gICAgfVxuXG4gICAgaWYgKHNjYWxlICE9PSAwKSB7XG4gICAgICBoID0gMDtcbiAgICAgIGZvciAoaSA9IGhpZ2g7IGkgPj0gbTsgaS0tKSB7XG4gICAgICAgIG9ydFtpXSA9IEguZ2V0KGksIG0gLSAxKSAvIHNjYWxlO1xuICAgICAgICBoICs9IG9ydFtpXSAqIG9ydFtpXTtcbiAgICAgIH1cblxuICAgICAgZyA9IE1hdGguc3FydChoKTtcbiAgICAgIGlmIChvcnRbbV0gPiAwKSB7XG4gICAgICAgIGcgPSAtZztcbiAgICAgIH1cblxuICAgICAgaCA9IGggLSBvcnRbbV0gKiBnO1xuICAgICAgb3J0W21dID0gb3J0W21dIC0gZztcblxuICAgICAgZm9yIChqID0gbTsgaiA8IG47IGorKykge1xuICAgICAgICBmID0gMDtcbiAgICAgICAgZm9yIChpID0gaGlnaDsgaSA+PSBtOyBpLS0pIHtcbiAgICAgICAgICBmICs9IG9ydFtpXSAqIEguZ2V0KGksIGopO1xuICAgICAgICB9XG5cbiAgICAgICAgZiA9IGYgLyBoO1xuICAgICAgICBmb3IgKGkgPSBtOyBpIDw9IGhpZ2g7IGkrKykge1xuICAgICAgICAgIEguc2V0KGksIGosIEguZ2V0KGksIGopIC0gZiAqIG9ydFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8PSBoaWdoOyBpKyspIHtcbiAgICAgICAgZiA9IDA7XG4gICAgICAgIGZvciAoaiA9IGhpZ2g7IGogPj0gbTsgai0tKSB7XG4gICAgICAgICAgZiArPSBvcnRbal0gKiBILmdldChpLCBqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGYgPSBmIC8gaDtcbiAgICAgICAgZm9yIChqID0gbTsgaiA8PSBoaWdoOyBqKyspIHtcbiAgICAgICAgICBILnNldChpLCBqLCBILmdldChpLCBqKSAtIGYgKiBvcnRbal0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9ydFttXSA9IHNjYWxlICogb3J0W21dO1xuICAgICAgSC5zZXQobSwgbSAtIDEsIHNjYWxlICogZyk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IG47IGkrKykge1xuICAgIGZvciAoaiA9IDA7IGogPCBuOyBqKyspIHtcbiAgICAgIFYuc2V0KGksIGosIGkgPT09IGogPyAxIDogMCk7XG4gICAgfVxuICB9XG5cbiAgZm9yIChtID0gaGlnaCAtIDE7IG0gPj0gbG93ICsgMTsgbS0tKSB7XG4gICAgaWYgKEguZ2V0KG0sIG0gLSAxKSAhPT0gMCkge1xuICAgICAgZm9yIChpID0gbSArIDE7IGkgPD0gaGlnaDsgaSsrKSB7XG4gICAgICAgIG9ydFtpXSA9IEguZ2V0KGksIG0gLSAxKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChqID0gbTsgaiA8PSBoaWdoOyBqKyspIHtcbiAgICAgICAgZyA9IDA7XG4gICAgICAgIGZvciAoaSA9IG07IGkgPD0gaGlnaDsgaSsrKSB7XG4gICAgICAgICAgZyArPSBvcnRbaV0gKiBWLmdldChpLCBqKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGcgPSBnIC8gb3J0W21dIC8gSC5nZXQobSwgbSAtIDEpO1xuICAgICAgICBmb3IgKGkgPSBtOyBpIDw9IGhpZ2g7IGkrKykge1xuICAgICAgICAgIFYuc2V0KGksIGosIFYuZ2V0KGksIGopICsgZyAqIG9ydFtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaHFyMihubiwgZSwgZCwgViwgSCkge1xuICBsZXQgbiA9IG5uIC0gMTtcbiAgbGV0IGxvdyA9IDA7XG4gIGxldCBoaWdoID0gbm4gLSAxO1xuICBsZXQgZXBzID0gTnVtYmVyLkVQU0lMT047XG4gIGxldCBleHNoaWZ0ID0gMDtcbiAgbGV0IG5vcm0gPSAwO1xuICBsZXQgcCA9IDA7XG4gIGxldCBxID0gMDtcbiAgbGV0IHIgPSAwO1xuICBsZXQgcyA9IDA7XG4gIGxldCB6ID0gMDtcbiAgbGV0IGl0ZXIgPSAwO1xuICBsZXQgaSwgaiwgaywgbCwgbSwgdCwgdywgeCwgeTtcbiAgbGV0IHJhLCBzYSwgdnIsIHZpO1xuICBsZXQgbm90bGFzdCwgY2RpdnJlcztcblxuICBmb3IgKGkgPSAwOyBpIDwgbm47IGkrKykge1xuICAgIGlmIChpIDwgbG93IHx8IGkgPiBoaWdoKSB7XG4gICAgICBkW2ldID0gSC5nZXQoaSwgaSk7XG4gICAgICBlW2ldID0gMDtcbiAgICB9XG5cbiAgICBmb3IgKGogPSBNYXRoLm1heChpIC0gMSwgMCk7IGogPCBubjsgaisrKSB7XG4gICAgICBub3JtID0gbm9ybSArIE1hdGguYWJzKEguZ2V0KGksIGopKTtcbiAgICB9XG4gIH1cblxuICB3aGlsZSAobiA+PSBsb3cpIHtcbiAgICBsID0gbjtcbiAgICB3aGlsZSAobCA+IGxvdykge1xuICAgICAgcyA9IE1hdGguYWJzKEguZ2V0KGwgLSAxLCBsIC0gMSkpICsgTWF0aC5hYnMoSC5nZXQobCwgbCkpO1xuICAgICAgaWYgKHMgPT09IDApIHtcbiAgICAgICAgcyA9IG5vcm07XG4gICAgICB9XG4gICAgICBpZiAoTWF0aC5hYnMoSC5nZXQobCwgbCAtIDEpKSA8IGVwcyAqIHMpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBsLS07XG4gICAgfVxuXG4gICAgaWYgKGwgPT09IG4pIHtcbiAgICAgIEguc2V0KG4sIG4sIEguZ2V0KG4sIG4pICsgZXhzaGlmdCk7XG4gICAgICBkW25dID0gSC5nZXQobiwgbik7XG4gICAgICBlW25dID0gMDtcbiAgICAgIG4tLTtcbiAgICAgIGl0ZXIgPSAwO1xuICAgIH0gZWxzZSBpZiAobCA9PT0gbiAtIDEpIHtcbiAgICAgIHcgPSBILmdldChuLCBuIC0gMSkgKiBILmdldChuIC0gMSwgbik7XG4gICAgICBwID0gKEguZ2V0KG4gLSAxLCBuIC0gMSkgLSBILmdldChuLCBuKSkgLyAyO1xuICAgICAgcSA9IHAgKiBwICsgdztcbiAgICAgIHogPSBNYXRoLnNxcnQoTWF0aC5hYnMocSkpO1xuICAgICAgSC5zZXQobiwgbiwgSC5nZXQobiwgbikgKyBleHNoaWZ0KTtcbiAgICAgIEguc2V0KG4gLSAxLCBuIC0gMSwgSC5nZXQobiAtIDEsIG4gLSAxKSArIGV4c2hpZnQpO1xuICAgICAgeCA9IEguZ2V0KG4sIG4pO1xuXG4gICAgICBpZiAocSA+PSAwKSB7XG4gICAgICAgIHogPSBwID49IDAgPyBwICsgeiA6IHAgLSB6O1xuICAgICAgICBkW24gLSAxXSA9IHggKyB6O1xuICAgICAgICBkW25dID0gZFtuIC0gMV07XG4gICAgICAgIGlmICh6ICE9PSAwKSB7XG4gICAgICAgICAgZFtuXSA9IHggLSB3IC8gejtcbiAgICAgICAgfVxuICAgICAgICBlW24gLSAxXSA9IDA7XG4gICAgICAgIGVbbl0gPSAwO1xuICAgICAgICB4ID0gSC5nZXQobiwgbiAtIDEpO1xuICAgICAgICBzID0gTWF0aC5hYnMoeCkgKyBNYXRoLmFicyh6KTtcbiAgICAgICAgcCA9IHggLyBzO1xuICAgICAgICBxID0geiAvIHM7XG4gICAgICAgIHIgPSBNYXRoLnNxcnQocCAqIHAgKyBxICogcSk7XG4gICAgICAgIHAgPSBwIC8gcjtcbiAgICAgICAgcSA9IHEgLyByO1xuXG4gICAgICAgIGZvciAoaiA9IG4gLSAxOyBqIDwgbm47IGorKykge1xuICAgICAgICAgIHogPSBILmdldChuIC0gMSwgaik7XG4gICAgICAgICAgSC5zZXQobiAtIDEsIGosIHEgKiB6ICsgcCAqIEguZ2V0KG4sIGopKTtcbiAgICAgICAgICBILnNldChuLCBqLCBxICogSC5nZXQobiwgaikgLSBwICogeik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSAwOyBpIDw9IG47IGkrKykge1xuICAgICAgICAgIHogPSBILmdldChpLCBuIC0gMSk7XG4gICAgICAgICAgSC5zZXQoaSwgbiAtIDEsIHEgKiB6ICsgcCAqIEguZ2V0KGksIG4pKTtcbiAgICAgICAgICBILnNldChpLCBuLCBxICogSC5nZXQoaSwgbikgLSBwICogeik7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSBsb3c7IGkgPD0gaGlnaDsgaSsrKSB7XG4gICAgICAgICAgeiA9IFYuZ2V0KGksIG4gLSAxKTtcbiAgICAgICAgICBWLnNldChpLCBuIC0gMSwgcSAqIHogKyBwICogVi5nZXQoaSwgbikpO1xuICAgICAgICAgIFYuc2V0KGksIG4sIHEgKiBWLmdldChpLCBuKSAtIHAgKiB6KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZFtuIC0gMV0gPSB4ICsgcDtcbiAgICAgICAgZFtuXSA9IHggKyBwO1xuICAgICAgICBlW24gLSAxXSA9IHo7XG4gICAgICAgIGVbbl0gPSAtejtcbiAgICAgIH1cblxuICAgICAgbiA9IG4gLSAyO1xuICAgICAgaXRlciA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSBILmdldChuLCBuKTtcbiAgICAgIHkgPSAwO1xuICAgICAgdyA9IDA7XG4gICAgICBpZiAobCA8IG4pIHtcbiAgICAgICAgeSA9IEguZ2V0KG4gLSAxLCBuIC0gMSk7XG4gICAgICAgIHcgPSBILmdldChuLCBuIC0gMSkgKiBILmdldChuIC0gMSwgbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChpdGVyID09PSAxMCkge1xuICAgICAgICBleHNoaWZ0ICs9IHg7XG4gICAgICAgIGZvciAoaSA9IGxvdzsgaSA8PSBuOyBpKyspIHtcbiAgICAgICAgICBILnNldChpLCBpLCBILmdldChpLCBpKSAtIHgpO1xuICAgICAgICB9XG4gICAgICAgIHMgPSBNYXRoLmFicyhILmdldChuLCBuIC0gMSkpICsgTWF0aC5hYnMoSC5nZXQobiAtIDEsIG4gLSAyKSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tdWx0aS1hc3NpZ25cbiAgICAgICAgeCA9IHkgPSAwLjc1ICogcztcbiAgICAgICAgdyA9IC0wLjQzNzUgKiBzICogcztcbiAgICAgIH1cblxuICAgICAgaWYgKGl0ZXIgPT09IDMwKSB7XG4gICAgICAgIHMgPSAoeSAtIHgpIC8gMjtcbiAgICAgICAgcyA9IHMgKiBzICsgdztcbiAgICAgICAgaWYgKHMgPiAwKSB7XG4gICAgICAgICAgcyA9IE1hdGguc3FydChzKTtcbiAgICAgICAgICBpZiAoeSA8IHgpIHtcbiAgICAgICAgICAgIHMgPSAtcztcbiAgICAgICAgICB9XG4gICAgICAgICAgcyA9IHggLSB3IC8gKCh5IC0geCkgLyAyICsgcyk7XG4gICAgICAgICAgZm9yIChpID0gbG93OyBpIDw9IG47IGkrKykge1xuICAgICAgICAgICAgSC5zZXQoaSwgaSwgSC5nZXQoaSwgaSkgLSBzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXhzaGlmdCArPSBzO1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1tdWx0aS1hc3NpZ25cbiAgICAgICAgICB4ID0geSA9IHcgPSAwLjk2NDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpdGVyID0gaXRlciArIDE7XG5cbiAgICAgIG0gPSBuIC0gMjtcbiAgICAgIHdoaWxlIChtID49IGwpIHtcbiAgICAgICAgeiA9IEguZ2V0KG0sIG0pO1xuICAgICAgICByID0geCAtIHo7XG4gICAgICAgIHMgPSB5IC0gejtcbiAgICAgICAgcCA9IChyICogcyAtIHcpIC8gSC5nZXQobSArIDEsIG0pICsgSC5nZXQobSwgbSArIDEpO1xuICAgICAgICBxID0gSC5nZXQobSArIDEsIG0gKyAxKSAtIHogLSByIC0gcztcbiAgICAgICAgciA9IEguZ2V0KG0gKyAyLCBtICsgMSk7XG4gICAgICAgIHMgPSBNYXRoLmFicyhwKSArIE1hdGguYWJzKHEpICsgTWF0aC5hYnMocik7XG4gICAgICAgIHAgPSBwIC8gcztcbiAgICAgICAgcSA9IHEgLyBzO1xuICAgICAgICByID0gciAvIHM7XG4gICAgICAgIGlmIChtID09PSBsKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIE1hdGguYWJzKEguZ2V0KG0sIG0gLSAxKSkgKiAoTWF0aC5hYnMocSkgKyBNYXRoLmFicyhyKSkgPFxuICAgICAgICAgIGVwcyAqXG4gICAgICAgICAgICAoTWF0aC5hYnMocCkgKlxuICAgICAgICAgICAgICAoTWF0aC5hYnMoSC5nZXQobSAtIDEsIG0gLSAxKSkgK1xuICAgICAgICAgICAgICAgIE1hdGguYWJzKHopICtcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhILmdldChtICsgMSwgbSArIDEpKSkpXG4gICAgICAgICkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG0tLTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gbSArIDI7IGkgPD0gbjsgaSsrKSB7XG4gICAgICAgIEguc2V0KGksIGkgLSAyLCAwKTtcbiAgICAgICAgaWYgKGkgPiBtICsgMikge1xuICAgICAgICAgIEguc2V0KGksIGkgLSAzLCAwKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGsgPSBtOyBrIDw9IG4gLSAxOyBrKyspIHtcbiAgICAgICAgbm90bGFzdCA9IGsgIT09IG4gLSAxO1xuICAgICAgICBpZiAoayAhPT0gbSkge1xuICAgICAgICAgIHAgPSBILmdldChrLCBrIC0gMSk7XG4gICAgICAgICAgcSA9IEguZ2V0KGsgKyAxLCBrIC0gMSk7XG4gICAgICAgICAgciA9IG5vdGxhc3QgPyBILmdldChrICsgMiwgayAtIDEpIDogMDtcbiAgICAgICAgICB4ID0gTWF0aC5hYnMocCkgKyBNYXRoLmFicyhxKSArIE1hdGguYWJzKHIpO1xuICAgICAgICAgIGlmICh4ICE9PSAwKSB7XG4gICAgICAgICAgICBwID0gcCAvIHg7XG4gICAgICAgICAgICBxID0gcSAvIHg7XG4gICAgICAgICAgICByID0gciAvIHg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHggPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHMgPSBNYXRoLnNxcnQocCAqIHAgKyBxICogcSArIHIgKiByKTtcbiAgICAgICAgaWYgKHAgPCAwKSB7XG4gICAgICAgICAgcyA9IC1zO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHMgIT09IDApIHtcbiAgICAgICAgICBpZiAoayAhPT0gbSkge1xuICAgICAgICAgICAgSC5zZXQoaywgayAtIDEsIC1zICogeCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChsICE9PSBtKSB7XG4gICAgICAgICAgICBILnNldChrLCBrIC0gMSwgLUguZ2V0KGssIGsgLSAxKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcCA9IHAgKyBzO1xuICAgICAgICAgIHggPSBwIC8gcztcbiAgICAgICAgICB5ID0gcSAvIHM7XG4gICAgICAgICAgeiA9IHIgLyBzO1xuICAgICAgICAgIHEgPSBxIC8gcDtcbiAgICAgICAgICByID0gciAvIHA7XG5cbiAgICAgICAgICBmb3IgKGogPSBrOyBqIDwgbm47IGorKykge1xuICAgICAgICAgICAgcCA9IEguZ2V0KGssIGopICsgcSAqIEguZ2V0KGsgKyAxLCBqKTtcbiAgICAgICAgICAgIGlmIChub3RsYXN0KSB7XG4gICAgICAgICAgICAgIHAgPSBwICsgciAqIEguZ2V0KGsgKyAyLCBqKTtcbiAgICAgICAgICAgICAgSC5zZXQoayArIDIsIGosIEguZ2V0KGsgKyAyLCBqKSAtIHAgKiB6KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgSC5zZXQoaywgaiwgSC5nZXQoaywgaikgLSBwICogeCk7XG4gICAgICAgICAgICBILnNldChrICsgMSwgaiwgSC5nZXQoayArIDEsIGopIC0gcCAqIHkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPD0gTWF0aC5taW4obiwgayArIDMpOyBpKyspIHtcbiAgICAgICAgICAgIHAgPSB4ICogSC5nZXQoaSwgaykgKyB5ICogSC5nZXQoaSwgayArIDEpO1xuICAgICAgICAgICAgaWYgKG5vdGxhc3QpIHtcbiAgICAgICAgICAgICAgcCA9IHAgKyB6ICogSC5nZXQoaSwgayArIDIpO1xuICAgICAgICAgICAgICBILnNldChpLCBrICsgMiwgSC5nZXQoaSwgayArIDIpIC0gcCAqIHIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBILnNldChpLCBrLCBILmdldChpLCBrKSAtIHApO1xuICAgICAgICAgICAgSC5zZXQoaSwgayArIDEsIEguZ2V0KGksIGsgKyAxKSAtIHAgKiBxKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKGkgPSBsb3c7IGkgPD0gaGlnaDsgaSsrKSB7XG4gICAgICAgICAgICBwID0geCAqIFYuZ2V0KGksIGspICsgeSAqIFYuZ2V0KGksIGsgKyAxKTtcbiAgICAgICAgICAgIGlmIChub3RsYXN0KSB7XG4gICAgICAgICAgICAgIHAgPSBwICsgeiAqIFYuZ2V0KGksIGsgKyAyKTtcbiAgICAgICAgICAgICAgVi5zZXQoaSwgayArIDIsIFYuZ2V0KGksIGsgKyAyKSAtIHAgKiByKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgVi5zZXQoaSwgaywgVi5nZXQoaSwgaykgLSBwKTtcbiAgICAgICAgICAgIFYuc2V0KGksIGsgKyAxLCBWLmdldChpLCBrICsgMSkgLSBwICogcSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKG5vcm0gPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBmb3IgKG4gPSBubiAtIDE7IG4gPj0gMDsgbi0tKSB7XG4gICAgcCA9IGRbbl07XG4gICAgcSA9IGVbbl07XG5cbiAgICBpZiAocSA9PT0gMCkge1xuICAgICAgbCA9IG47XG4gICAgICBILnNldChuLCBuLCAxKTtcbiAgICAgIGZvciAoaSA9IG4gLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB3ID0gSC5nZXQoaSwgaSkgLSBwO1xuICAgICAgICByID0gMDtcbiAgICAgICAgZm9yIChqID0gbDsgaiA8PSBuOyBqKyspIHtcbiAgICAgICAgICByID0gciArIEguZ2V0KGksIGopICogSC5nZXQoaiwgbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZVtpXSA8IDApIHtcbiAgICAgICAgICB6ID0gdztcbiAgICAgICAgICBzID0gcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsID0gaTtcbiAgICAgICAgICBpZiAoZVtpXSA9PT0gMCkge1xuICAgICAgICAgICAgSC5zZXQoaSwgbiwgdyAhPT0gMCA/IC1yIC8gdyA6IC1yIC8gKGVwcyAqIG5vcm0pKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeCA9IEguZ2V0KGksIGkgKyAxKTtcbiAgICAgICAgICAgIHkgPSBILmdldChpICsgMSwgaSk7XG4gICAgICAgICAgICBxID0gKGRbaV0gLSBwKSAqIChkW2ldIC0gcCkgKyBlW2ldICogZVtpXTtcbiAgICAgICAgICAgIHQgPSAoeCAqIHMgLSB6ICogcikgLyBxO1xuICAgICAgICAgICAgSC5zZXQoaSwgbiwgdCk7XG4gICAgICAgICAgICBILnNldChcbiAgICAgICAgICAgICAgaSArIDEsXG4gICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgIE1hdGguYWJzKHgpID4gTWF0aC5hYnMoeikgPyAoLXIgLSB3ICogdCkgLyB4IDogKC1zIC0geSAqIHQpIC8geixcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdCA9IE1hdGguYWJzKEguZ2V0KGksIG4pKTtcbiAgICAgICAgICBpZiAoZXBzICogdCAqIHQgPiAxKSB7XG4gICAgICAgICAgICBmb3IgKGogPSBpOyBqIDw9IG47IGorKykge1xuICAgICAgICAgICAgICBILnNldChqLCBuLCBILmdldChqLCBuKSAvIHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocSA8IDApIHtcbiAgICAgIGwgPSBuIC0gMTtcblxuICAgICAgaWYgKE1hdGguYWJzKEguZ2V0KG4sIG4gLSAxKSkgPiBNYXRoLmFicyhILmdldChuIC0gMSwgbikpKSB7XG4gICAgICAgIEguc2V0KG4gLSAxLCBuIC0gMSwgcSAvIEguZ2V0KG4sIG4gLSAxKSk7XG4gICAgICAgIEguc2V0KG4gLSAxLCBuLCAtKEguZ2V0KG4sIG4pIC0gcCkgLyBILmdldChuLCBuIC0gMSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2RpdnJlcyA9IGNkaXYoMCwgLUguZ2V0KG4gLSAxLCBuKSwgSC5nZXQobiAtIDEsIG4gLSAxKSAtIHAsIHEpO1xuICAgICAgICBILnNldChuIC0gMSwgbiAtIDEsIGNkaXZyZXNbMF0pO1xuICAgICAgICBILnNldChuIC0gMSwgbiwgY2RpdnJlc1sxXSk7XG4gICAgICB9XG5cbiAgICAgIEguc2V0KG4sIG4gLSAxLCAwKTtcbiAgICAgIEguc2V0KG4sIG4sIDEpO1xuICAgICAgZm9yIChpID0gbiAtIDI7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHJhID0gMDtcbiAgICAgICAgc2EgPSAwO1xuICAgICAgICBmb3IgKGogPSBsOyBqIDw9IG47IGorKykge1xuICAgICAgICAgIHJhID0gcmEgKyBILmdldChpLCBqKSAqIEguZ2V0KGosIG4gLSAxKTtcbiAgICAgICAgICBzYSA9IHNhICsgSC5nZXQoaSwgaikgKiBILmdldChqLCBuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHcgPSBILmdldChpLCBpKSAtIHA7XG5cbiAgICAgICAgaWYgKGVbaV0gPCAwKSB7XG4gICAgICAgICAgeiA9IHc7XG4gICAgICAgICAgciA9IHJhO1xuICAgICAgICAgIHMgPSBzYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsID0gaTtcbiAgICAgICAgICBpZiAoZVtpXSA9PT0gMCkge1xuICAgICAgICAgICAgY2RpdnJlcyA9IGNkaXYoLXJhLCAtc2EsIHcsIHEpO1xuICAgICAgICAgICAgSC5zZXQoaSwgbiAtIDEsIGNkaXZyZXNbMF0pO1xuICAgICAgICAgICAgSC5zZXQoaSwgbiwgY2RpdnJlc1sxXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHggPSBILmdldChpLCBpICsgMSk7XG4gICAgICAgICAgICB5ID0gSC5nZXQoaSArIDEsIGkpO1xuICAgICAgICAgICAgdnIgPSAoZFtpXSAtIHApICogKGRbaV0gLSBwKSArIGVbaV0gKiBlW2ldIC0gcSAqIHE7XG4gICAgICAgICAgICB2aSA9IChkW2ldIC0gcCkgKiAyICogcTtcbiAgICAgICAgICAgIGlmICh2ciA9PT0gMCAmJiB2aSA9PT0gMCkge1xuICAgICAgICAgICAgICB2ciA9XG4gICAgICAgICAgICAgICAgZXBzICpcbiAgICAgICAgICAgICAgICBub3JtICpcbiAgICAgICAgICAgICAgICAoTWF0aC5hYnModykgK1xuICAgICAgICAgICAgICAgICAgTWF0aC5hYnMocSkgK1xuICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoeCkgK1xuICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoeSkgK1xuICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoeikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2RpdnJlcyA9IGNkaXYoXG4gICAgICAgICAgICAgIHggKiByIC0geiAqIHJhICsgcSAqIHNhLFxuICAgICAgICAgICAgICB4ICogcyAtIHogKiBzYSAtIHEgKiByYSxcbiAgICAgICAgICAgICAgdnIsXG4gICAgICAgICAgICAgIHZpLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIEguc2V0KGksIG4gLSAxLCBjZGl2cmVzWzBdKTtcbiAgICAgICAgICAgIEguc2V0KGksIG4sIGNkaXZyZXNbMV0pO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHgpID4gTWF0aC5hYnMoeikgKyBNYXRoLmFicyhxKSkge1xuICAgICAgICAgICAgICBILnNldChcbiAgICAgICAgICAgICAgICBpICsgMSxcbiAgICAgICAgICAgICAgICBuIC0gMSxcbiAgICAgICAgICAgICAgICAoLXJhIC0gdyAqIEguZ2V0KGksIG4gLSAxKSArIHEgKiBILmdldChpLCBuKSkgLyB4LFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBILnNldChcbiAgICAgICAgICAgICAgICBpICsgMSxcbiAgICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICAgICgtc2EgLSB3ICogSC5nZXQoaSwgbikgLSBxICogSC5nZXQoaSwgbiAtIDEpKSAvIHgsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjZGl2cmVzID0gY2RpdihcbiAgICAgICAgICAgICAgICAtciAtIHkgKiBILmdldChpLCBuIC0gMSksXG4gICAgICAgICAgICAgICAgLXMgLSB5ICogSC5nZXQoaSwgbiksXG4gICAgICAgICAgICAgICAgeixcbiAgICAgICAgICAgICAgICBxLFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBILnNldChpICsgMSwgbiAtIDEsIGNkaXZyZXNbMF0pO1xuICAgICAgICAgICAgICBILnNldChpICsgMSwgbiwgY2RpdnJlc1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdCA9IE1hdGgubWF4KE1hdGguYWJzKEguZ2V0KGksIG4gLSAxKSksIE1hdGguYWJzKEguZ2V0KGksIG4pKSk7XG4gICAgICAgICAgaWYgKGVwcyAqIHQgKiB0ID4gMSkge1xuICAgICAgICAgICAgZm9yIChqID0gaTsgaiA8PSBuOyBqKyspIHtcbiAgICAgICAgICAgICAgSC5zZXQoaiwgbiAtIDEsIEguZ2V0KGosIG4gLSAxKSAvIHQpO1xuICAgICAgICAgICAgICBILnNldChqLCBuLCBILmdldChqLCBuKSAvIHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCBubjsgaSsrKSB7XG4gICAgaWYgKGkgPCBsb3cgfHwgaSA+IGhpZ2gpIHtcbiAgICAgIGZvciAoaiA9IGk7IGogPCBubjsgaisrKSB7XG4gICAgICAgIFYuc2V0KGksIGosIEguZ2V0KGksIGopKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKGogPSBubiAtIDE7IGogPj0gbG93OyBqLS0pIHtcbiAgICBmb3IgKGkgPSBsb3c7IGkgPD0gaGlnaDsgaSsrKSB7XG4gICAgICB6ID0gMDtcbiAgICAgIGZvciAoayA9IGxvdzsgayA8PSBNYXRoLm1pbihqLCBoaWdoKTsgaysrKSB7XG4gICAgICAgIHogPSB6ICsgVi5nZXQoaSwgaykgKiBILmdldChrLCBqKTtcbiAgICAgIH1cbiAgICAgIFYuc2V0KGksIGosIHopO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjZGl2KHhyLCB4aSwgeXIsIHlpKSB7XG4gIGxldCByLCBkO1xuICBpZiAoTWF0aC5hYnMoeXIpID4gTWF0aC5hYnMoeWkpKSB7XG4gICAgciA9IHlpIC8geXI7XG4gICAgZCA9IHlyICsgciAqIHlpO1xuICAgIHJldHVybiBbKHhyICsgciAqIHhpKSAvIGQsICh4aSAtIHIgKiB4cikgLyBkXTtcbiAgfSBlbHNlIHtcbiAgICByID0geXIgLyB5aTtcbiAgICBkID0geWkgKyByICogeXI7XG4gICAgcmV0dXJuIFsociAqIHhyICsgeGkpIC8gZCwgKHIgKiB4aSAtIHhyKSAvIGRdO1xuICB9XG59XG5cbmNsYXNzIENob2xlc2t5RGVjb21wb3NpdGlvbiB7XG4gIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgdmFsdWUgPSBXcmFwcGVyTWF0cml4MkQuY2hlY2tNYXRyaXgodmFsdWUpO1xuICAgIGlmICghdmFsdWUuaXNTeW1tZXRyaWMoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXRyaXggaXMgbm90IHN5bW1ldHJpYycpO1xuICAgIH1cblxuICAgIGxldCBhID0gdmFsdWU7XG4gICAgbGV0IGRpbWVuc2lvbiA9IGEucm93cztcbiAgICBsZXQgbCA9IG5ldyBNYXRyaXgoZGltZW5zaW9uLCBkaW1lbnNpb24pO1xuICAgIGxldCBwb3NpdGl2ZURlZmluaXRlID0gdHJ1ZTtcbiAgICBsZXQgaSwgaiwgaztcblxuICAgIGZvciAoaiA9IDA7IGogPCBkaW1lbnNpb247IGorKykge1xuICAgICAgbGV0IGQgPSAwO1xuICAgICAgZm9yIChrID0gMDsgayA8IGo7IGsrKykge1xuICAgICAgICBsZXQgcyA9IDA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICAgICAgICBzICs9IGwuZ2V0KGssIGkpICogbC5nZXQoaiwgaSk7XG4gICAgICAgIH1cbiAgICAgICAgcyA9IChhLmdldChqLCBrKSAtIHMpIC8gbC5nZXQoaywgayk7XG4gICAgICAgIGwuc2V0KGosIGssIHMpO1xuICAgICAgICBkID0gZCArIHMgKiBzO1xuICAgICAgfVxuXG4gICAgICBkID0gYS5nZXQoaiwgaikgLSBkO1xuXG4gICAgICBwb3NpdGl2ZURlZmluaXRlICYmPSBkID4gMDtcbiAgICAgIGwuc2V0KGosIGosIE1hdGguc3FydChNYXRoLm1heChkLCAwKSkpO1xuICAgICAgZm9yIChrID0gaiArIDE7IGsgPCBkaW1lbnNpb247IGsrKykge1xuICAgICAgICBsLnNldChqLCBrLCAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLkwgPSBsO1xuICAgIHRoaXMucG9zaXRpdmVEZWZpbml0ZSA9IHBvc2l0aXZlRGVmaW5pdGU7XG4gIH1cblxuICBpc1Bvc2l0aXZlRGVmaW5pdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9zaXRpdmVEZWZpbml0ZTtcbiAgfVxuXG4gIHNvbHZlKHZhbHVlKSB7XG4gICAgdmFsdWUgPSBXcmFwcGVyTWF0cml4MkQuY2hlY2tNYXRyaXgodmFsdWUpO1xuXG4gICAgbGV0IGwgPSB0aGlzLkw7XG4gICAgbGV0IGRpbWVuc2lvbiA9IGwucm93cztcblxuICAgIGlmICh2YWx1ZS5yb3dzICE9PSBkaW1lbnNpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWF0cml4IGRpbWVuc2lvbnMgZG8gbm90IG1hdGNoJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzUG9zaXRpdmVEZWZpbml0ZSgpID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNYXRyaXggaXMgbm90IHBvc2l0aXZlIGRlZmluaXRlJyk7XG4gICAgfVxuXG4gICAgbGV0IGNvdW50ID0gdmFsdWUuY29sdW1ucztcbiAgICBsZXQgQiA9IHZhbHVlLmNsb25lKCk7XG4gICAgbGV0IGksIGosIGs7XG5cbiAgICBmb3IgKGsgPSAwOyBrIDwgZGltZW5zaW9uOyBrKyspIHtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBjb3VudDsgaisrKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrOyBpKyspIHtcbiAgICAgICAgICBCLnNldChrLCBqLCBCLmdldChrLCBqKSAtIEIuZ2V0KGksIGopICogbC5nZXQoaywgaSkpO1xuICAgICAgICB9XG4gICAgICAgIEIuc2V0KGssIGosIEIuZ2V0KGssIGopIC8gbC5nZXQoaywgaykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoayA9IGRpbWVuc2lvbiAtIDE7IGsgPj0gMDsgay0tKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgY291bnQ7IGorKykge1xuICAgICAgICBmb3IgKGkgPSBrICsgMTsgaSA8IGRpbWVuc2lvbjsgaSsrKSB7XG4gICAgICAgICAgQi5zZXQoaywgaiwgQi5nZXQoaywgaikgLSBCLmdldChpLCBqKSAqIGwuZ2V0KGksIGspKTtcbiAgICAgICAgfVxuICAgICAgICBCLnNldChrLCBqLCBCLmdldChrLCBqKSAvIGwuZ2V0KGssIGspKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQjtcbiAgfVxuXG4gIGdldCBsb3dlclRyaWFuZ3VsYXJNYXRyaXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuTDtcbiAgfVxufVxuXG5jbGFzcyBuaXBhbHMge1xuICBjb25zdHJ1Y3RvcihYLCBvcHRpb25zID0ge30pIHtcbiAgICBYID0gV3JhcHBlck1hdHJpeDJELmNoZWNrTWF0cml4KFgpO1xuICAgIGxldCB7IFkgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qge1xuICAgICAgc2NhbGVTY29yZXMgPSBmYWxzZSxcbiAgICAgIG1heEl0ZXJhdGlvbnMgPSAxMDAwLFxuICAgICAgdGVybWluYXRpb25Dcml0ZXJpYSA9IDFlLTEwLFxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgbGV0IHU7XG4gICAgaWYgKFkpIHtcbiAgICAgIGlmIChpc0FueUFycmF5LmlzQW55QXJyYXkoWSkgJiYgdHlwZW9mIFlbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIFkgPSBNYXRyaXguY29sdW1uVmVjdG9yKFkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgWSA9IFdyYXBwZXJNYXRyaXgyRC5jaGVja01hdHJpeChZKTtcbiAgICAgIH1cbiAgICAgIGlmIChZLnJvd3MgIT09IFgucm93cykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1kgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHJvd3MgYXMgWCcpO1xuICAgICAgfVxuICAgICAgdSA9IFkuZ2V0Q29sdW1uVmVjdG9yKDApO1xuICAgIH0gZWxzZSB7XG4gICAgICB1ID0gWC5nZXRDb2x1bW5WZWN0b3IoMCk7XG4gICAgfVxuXG4gICAgbGV0IGRpZmYgPSAxO1xuICAgIGxldCB0LCBxLCB3LCB0T2xkO1xuXG4gICAgZm9yIChcbiAgICAgIGxldCBjb3VudGVyID0gMDtcbiAgICAgIGNvdW50ZXIgPCBtYXhJdGVyYXRpb25zICYmIGRpZmYgPiB0ZXJtaW5hdGlvbkNyaXRlcmlhO1xuICAgICAgY291bnRlcisrXG4gICAgKSB7XG4gICAgICB3ID0gWC50cmFuc3Bvc2UoKS5tbXVsKHUpLmRpdih1LnRyYW5zcG9zZSgpLm1tdWwodSkuZ2V0KDAsIDApKTtcbiAgICAgIHcgPSB3LmRpdih3Lm5vcm0oKSk7XG5cbiAgICAgIHQgPSBYLm1tdWwodykuZGl2KHcudHJhbnNwb3NlKCkubW11bCh3KS5nZXQoMCwgMCkpO1xuXG4gICAgICBpZiAoY291bnRlciA+IDApIHtcbiAgICAgICAgZGlmZiA9IHQuY2xvbmUoKS5zdWIodE9sZCkucG93KDIpLnN1bSgpO1xuICAgICAgfVxuICAgICAgdE9sZCA9IHQuY2xvbmUoKTtcblxuICAgICAgaWYgKFkpIHtcbiAgICAgICAgcSA9IFkudHJhbnNwb3NlKCkubW11bCh0KS5kaXYodC50cmFuc3Bvc2UoKS5tbXVsKHQpLmdldCgwLCAwKSk7XG4gICAgICAgIHEgPSBxLmRpdihxLm5vcm0oKSk7XG5cbiAgICAgICAgdSA9IFkubW11bChxKS5kaXYocS50cmFuc3Bvc2UoKS5tbXVsKHEpLmdldCgwLCAwKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1ID0gdDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoWSkge1xuICAgICAgbGV0IHAgPSBYLnRyYW5zcG9zZSgpLm1tdWwodCkuZGl2KHQudHJhbnNwb3NlKCkubW11bCh0KS5nZXQoMCwgMCkpO1xuICAgICAgcCA9IHAuZGl2KHAubm9ybSgpKTtcbiAgICAgIGxldCB4UmVzaWR1YWwgPSBYLmNsb25lKCkuc3ViKHQuY2xvbmUoKS5tbXVsKHAudHJhbnNwb3NlKCkpKTtcbiAgICAgIGxldCByZXNpZHVhbCA9IHUudHJhbnNwb3NlKCkubW11bCh0KS5kaXYodC50cmFuc3Bvc2UoKS5tbXVsKHQpLmdldCgwLCAwKSk7XG4gICAgICBsZXQgeVJlc2lkdWFsID0gWS5jbG9uZSgpLnN1YihcbiAgICAgICAgdC5jbG9uZSgpLm11bFMocmVzaWR1YWwuZ2V0KDAsIDApKS5tbXVsKHEudHJhbnNwb3NlKCkpLFxuICAgICAgKTtcblxuICAgICAgdGhpcy50ID0gdDtcbiAgICAgIHRoaXMucCA9IHAudHJhbnNwb3NlKCk7XG4gICAgICB0aGlzLncgPSB3LnRyYW5zcG9zZSgpO1xuICAgICAgdGhpcy5xID0gcTtcbiAgICAgIHRoaXMudSA9IHU7XG4gICAgICB0aGlzLnMgPSB0LnRyYW5zcG9zZSgpLm1tdWwodCk7XG4gICAgICB0aGlzLnhSZXNpZHVhbCA9IHhSZXNpZHVhbDtcbiAgICAgIHRoaXMueVJlc2lkdWFsID0geVJlc2lkdWFsO1xuICAgICAgdGhpcy5iZXRhcyA9IHJlc2lkdWFsO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLncgPSB3LnRyYW5zcG9zZSgpO1xuICAgICAgdGhpcy5zID0gdC50cmFuc3Bvc2UoKS5tbXVsKHQpLnNxcnQoKTtcbiAgICAgIGlmIChzY2FsZVNjb3Jlcykge1xuICAgICAgICB0aGlzLnQgPSB0LmNsb25lKCkuZGl2KHRoaXMucy5nZXQoMCwgMCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50ID0gdDtcbiAgICAgIH1cbiAgICAgIHRoaXMueFJlc2lkdWFsID0gWC5zdWIodC5tbXVsKHcudHJhbnNwb3NlKCkpKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0cy5BYnN0cmFjdE1hdHJpeCA9IEFic3RyYWN0TWF0cml4O1xuZXhwb3J0cy5DSE8gPSBDaG9sZXNreURlY29tcG9zaXRpb247XG5leHBvcnRzLkNob2xlc2t5RGVjb21wb3NpdGlvbiA9IENob2xlc2t5RGVjb21wb3NpdGlvbjtcbmV4cG9ydHMuRGlzdGFuY2VNYXRyaXggPSBEaXN0YW5jZU1hdHJpeDtcbmV4cG9ydHMuRVZEID0gRWlnZW52YWx1ZURlY29tcG9zaXRpb247XG5leHBvcnRzLkVpZ2VudmFsdWVEZWNvbXBvc2l0aW9uID0gRWlnZW52YWx1ZURlY29tcG9zaXRpb247XG5leHBvcnRzLkxVID0gTHVEZWNvbXBvc2l0aW9uO1xuZXhwb3J0cy5MdURlY29tcG9zaXRpb24gPSBMdURlY29tcG9zaXRpb247XG5leHBvcnRzLk1hdHJpeCA9IE1hdHJpeDtcbmV4cG9ydHMuTWF0cml4Q29sdW1uU2VsZWN0aW9uVmlldyA9IE1hdHJpeENvbHVtblNlbGVjdGlvblZpZXc7XG5leHBvcnRzLk1hdHJpeENvbHVtblZpZXcgPSBNYXRyaXhDb2x1bW5WaWV3O1xuZXhwb3J0cy5NYXRyaXhGbGlwQ29sdW1uVmlldyA9IE1hdHJpeEZsaXBDb2x1bW5WaWV3O1xuZXhwb3J0cy5NYXRyaXhGbGlwUm93VmlldyA9IE1hdHJpeEZsaXBSb3dWaWV3O1xuZXhwb3J0cy5NYXRyaXhSb3dTZWxlY3Rpb25WaWV3ID0gTWF0cml4Um93U2VsZWN0aW9uVmlldztcbmV4cG9ydHMuTWF0cml4Um93VmlldyA9IE1hdHJpeFJvd1ZpZXc7XG5leHBvcnRzLk1hdHJpeFNlbGVjdGlvblZpZXcgPSBNYXRyaXhTZWxlY3Rpb25WaWV3O1xuZXhwb3J0cy5NYXRyaXhTdWJWaWV3ID0gTWF0cml4U3ViVmlldztcbmV4cG9ydHMuTWF0cml4VHJhbnNwb3NlVmlldyA9IE1hdHJpeFRyYW5zcG9zZVZpZXc7XG5leHBvcnRzLk5JUEFMUyA9IG5pcGFscztcbmV4cG9ydHMuTmlwYWxzID0gbmlwYWxzO1xuZXhwb3J0cy5RUiA9IFFyRGVjb21wb3NpdGlvbjtcbmV4cG9ydHMuUXJEZWNvbXBvc2l0aW9uID0gUXJEZWNvbXBvc2l0aW9uO1xuZXhwb3J0cy5TVkQgPSBTaW5ndWxhclZhbHVlRGVjb21wb3NpdGlvbjtcbmV4cG9ydHMuU2luZ3VsYXJWYWx1ZURlY29tcG9zaXRpb24gPSBTaW5ndWxhclZhbHVlRGVjb21wb3NpdGlvbjtcbmV4cG9ydHMuU3ltbWV0cmljTWF0cml4ID0gU3ltbWV0cmljTWF0cml4O1xuZXhwb3J0cy5XcmFwcGVyTWF0cml4MUQgPSBXcmFwcGVyTWF0cml4MUQ7XG5leHBvcnRzLldyYXBwZXJNYXRyaXgyRCA9IFdyYXBwZXJNYXRyaXgyRDtcbmV4cG9ydHMuY29ycmVsYXRpb24gPSBjb3JyZWxhdGlvbjtcbmV4cG9ydHMuY292YXJpYW5jZSA9IGNvdmFyaWFuY2U7XG5leHBvcnRzLmRlZmF1bHQgPSBNYXRyaXg7XG5leHBvcnRzLmRldGVybWluYW50ID0gZGV0ZXJtaW5hbnQ7XG5leHBvcnRzLmludmVyc2UgPSBpbnZlcnNlO1xuZXhwb3J0cy5saW5lYXJEZXBlbmRlbmNpZXMgPSBsaW5lYXJEZXBlbmRlbmNpZXM7XG5leHBvcnRzLnBzZXVkb0ludmVyc2UgPSBwc2V1ZG9JbnZlcnNlO1xuZXhwb3J0cy5zb2x2ZSA9IHNvbHZlO1xuZXhwb3J0cy53cmFwID0gd3JhcDtcbiIsImltcG9ydCAqIGFzIG1hdHJpeCBmcm9tICcuL21hdHJpeC5qcyc7XG5cbmV4cG9ydCBjb25zdCBBYnN0cmFjdE1hdHJpeCA9IG1hdHJpeC5BYnN0cmFjdE1hdHJpeDtcbmV4cG9ydCBjb25zdCBDSE8gPSBtYXRyaXguQ0hPO1xuZXhwb3J0IGNvbnN0IENob2xlc2t5RGVjb21wb3NpdGlvbiA9IG1hdHJpeC5DaG9sZXNreURlY29tcG9zaXRpb247XG5leHBvcnQgY29uc3QgRGlzdGFuY2VNYXRyaXggPSBtYXRyaXguRGlzdGFuY2VNYXRyaXg7XG5leHBvcnQgY29uc3QgRVZEID0gbWF0cml4LkVWRDtcbmV4cG9ydCBjb25zdCBFaWdlbnZhbHVlRGVjb21wb3NpdGlvbiA9IG1hdHJpeC5FaWdlbnZhbHVlRGVjb21wb3NpdGlvbjtcbmV4cG9ydCBjb25zdCBMVSA9IG1hdHJpeC5MVTtcbmV4cG9ydCBjb25zdCBMdURlY29tcG9zaXRpb24gPSBtYXRyaXguTHVEZWNvbXBvc2l0aW9uO1xuZXhwb3J0IGNvbnN0IE1hdHJpeCA9IG1hdHJpeC5NYXRyaXg7XG5leHBvcnQgY29uc3QgTWF0cml4Q29sdW1uU2VsZWN0aW9uVmlldyA9IG1hdHJpeC5NYXRyaXhDb2x1bW5TZWxlY3Rpb25WaWV3O1xuZXhwb3J0IGNvbnN0IE1hdHJpeENvbHVtblZpZXcgPSBtYXRyaXguTWF0cml4Q29sdW1uVmlldztcbmV4cG9ydCBjb25zdCBNYXRyaXhGbGlwQ29sdW1uVmlldyA9IG1hdHJpeC5NYXRyaXhGbGlwQ29sdW1uVmlldztcbmV4cG9ydCBjb25zdCBNYXRyaXhGbGlwUm93VmlldyA9IG1hdHJpeC5NYXRyaXhGbGlwUm93VmlldztcbmV4cG9ydCBjb25zdCBNYXRyaXhSb3dTZWxlY3Rpb25WaWV3ID0gbWF0cml4Lk1hdHJpeFJvd1NlbGVjdGlvblZpZXc7XG5leHBvcnQgY29uc3QgTWF0cml4Um93VmlldyA9IG1hdHJpeC5NYXRyaXhSb3dWaWV3O1xuZXhwb3J0IGNvbnN0IE1hdHJpeFNlbGVjdGlvblZpZXcgPSBtYXRyaXguTWF0cml4U2VsZWN0aW9uVmlldztcbmV4cG9ydCBjb25zdCBNYXRyaXhTdWJWaWV3ID0gbWF0cml4Lk1hdHJpeFN1YlZpZXc7XG5leHBvcnQgY29uc3QgTWF0cml4VHJhbnNwb3NlVmlldyA9IG1hdHJpeC5NYXRyaXhUcmFuc3Bvc2VWaWV3O1xuZXhwb3J0IGNvbnN0IE5JUEFMUyA9IG1hdHJpeC5OSVBBTFM7XG5leHBvcnQgY29uc3QgTmlwYWxzID0gbWF0cml4Lk5pcGFscztcbmV4cG9ydCBjb25zdCBRUiA9IG1hdHJpeC5RUjtcbmV4cG9ydCBjb25zdCBRckRlY29tcG9zaXRpb24gPSBtYXRyaXguUXJEZWNvbXBvc2l0aW9uO1xuZXhwb3J0IGNvbnN0IFNWRCA9IG1hdHJpeC5TVkQ7XG5leHBvcnQgY29uc3QgU2luZ3VsYXJWYWx1ZURlY29tcG9zaXRpb24gPSBtYXRyaXguU2luZ3VsYXJWYWx1ZURlY29tcG9zaXRpb247XG5leHBvcnQgY29uc3QgU3ltbWV0cmljTWF0cml4ID0gbWF0cml4LlN5bW1ldHJpY01hdHJpeDtcbmV4cG9ydCBjb25zdCBXcmFwcGVyTWF0cml4MUQgPSBtYXRyaXguV3JhcHBlck1hdHJpeDFEO1xuZXhwb3J0IGNvbnN0IFdyYXBwZXJNYXRyaXgyRCA9IG1hdHJpeC5XcmFwcGVyTWF0cml4MkQ7XG5leHBvcnQgY29uc3QgY29ycmVsYXRpb24gPSBtYXRyaXguY29ycmVsYXRpb247XG5leHBvcnQgY29uc3QgY292YXJpYW5jZSA9IG1hdHJpeC5jb3ZhcmlhbmNlO1xuZXhwb3J0IGRlZmF1bHQgbWF0cml4LmRlZmF1bHQuTWF0cml4ID8gbWF0cml4LmRlZmF1bHQuTWF0cml4IDogbWF0cml4Lk1hdHJpeDtcbmV4cG9ydCBjb25zdCBkZXRlcm1pbmFudCA9IG1hdHJpeC5kZXRlcm1pbmFudDtcbmV4cG9ydCBjb25zdCBpbnZlcnNlID0gbWF0cml4LmludmVyc2U7XG5leHBvcnQgY29uc3QgbGluZWFyRGVwZW5kZW5jaWVzID0gbWF0cml4LmxpbmVhckRlcGVuZGVuY2llcztcbmV4cG9ydCBjb25zdCBwc2V1ZG9JbnZlcnNlID0gbWF0cml4LnBzZXVkb0ludmVyc2U7XG5leHBvcnQgY29uc3Qgc29sdmUgPSBtYXRyaXguc29sdmU7XG5leHBvcnQgY29uc3Qgd3JhcCA9IG1hdHJpeC53cmFwO1xuIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG5cblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1Jcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sLCBJdGVyYXRvciAqL1xuXG52YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uKGQsIGIpIHtcbiAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcbiAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbn1cblxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IGZ1bmN0aW9uKCkge1xuICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xuICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHQ7XG4gIH1cbiAgcmV0dXJuIF9fYXNzaWduLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xuICB2YXIgdCA9IHt9O1xuICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcbiAgICAgIHRbcF0gPSBzW3BdO1xuICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxuICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcbiAgICAgIH1cbiAgcmV0dXJuIHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2RlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3BhcmFtKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xuICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fZXNEZWNvcmF0ZShjdG9yLCBkZXNjcmlwdG9ySW4sIGRlY29yYXRvcnMsIGNvbnRleHRJbiwgaW5pdGlhbGl6ZXJzLCBleHRyYUluaXRpYWxpemVycykge1xuICBmdW5jdGlvbiBhY2NlcHQoZikgeyBpZiAoZiAhPT0gdm9pZCAwICYmIHR5cGVvZiBmICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGdW5jdGlvbiBleHBlY3RlZFwiKTsgcmV0dXJuIGY7IH1cbiAgdmFyIGtpbmQgPSBjb250ZXh0SW4ua2luZCwga2V5ID0ga2luZCA9PT0gXCJnZXR0ZXJcIiA/IFwiZ2V0XCIgOiBraW5kID09PSBcInNldHRlclwiID8gXCJzZXRcIiA6IFwidmFsdWVcIjtcbiAgdmFyIHRhcmdldCA9ICFkZXNjcmlwdG9ySW4gJiYgY3RvciA/IGNvbnRleHRJbltcInN0YXRpY1wiXSA/IGN0b3IgOiBjdG9yLnByb3RvdHlwZSA6IG51bGw7XG4gIHZhciBkZXNjcmlwdG9yID0gZGVzY3JpcHRvckluIHx8ICh0YXJnZXQgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgY29udGV4dEluLm5hbWUpIDoge30pO1xuICB2YXIgXywgZG9uZSA9IGZhbHNlO1xuICBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGNvbnRleHQgPSB7fTtcbiAgICAgIGZvciAodmFyIHAgaW4gY29udGV4dEluKSBjb250ZXh0W3BdID0gcCA9PT0gXCJhY2Nlc3NcIiA/IHt9IDogY29udGV4dEluW3BdO1xuICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4uYWNjZXNzKSBjb250ZXh0LmFjY2Vzc1twXSA9IGNvbnRleHRJbi5hY2Nlc3NbcF07XG4gICAgICBjb250ZXh0LmFkZEluaXRpYWxpemVyID0gZnVuY3Rpb24gKGYpIHsgaWYgKGRvbmUpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgYWRkIGluaXRpYWxpemVycyBhZnRlciBkZWNvcmF0aW9uIGhhcyBjb21wbGV0ZWRcIik7IGV4dHJhSW5pdGlhbGl6ZXJzLnB1c2goYWNjZXB0KGYgfHwgbnVsbCkpOyB9O1xuICAgICAgdmFyIHJlc3VsdCA9ICgwLCBkZWNvcmF0b3JzW2ldKShraW5kID09PSBcImFjY2Vzc29yXCIgPyB7IGdldDogZGVzY3JpcHRvci5nZXQsIHNldDogZGVzY3JpcHRvci5zZXQgfSA6IGRlc2NyaXB0b3Jba2V5XSwgY29udGV4dCk7XG4gICAgICBpZiAoa2luZCA9PT0gXCJhY2Nlc3NvclwiKSB7XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdm9pZCAwKSBjb250aW51ZTtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSBudWxsIHx8IHR5cGVvZiByZXN1bHQgIT09IFwib2JqZWN0XCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWRcIik7XG4gICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmdldCkpIGRlc2NyaXB0b3IuZ2V0ID0gXztcbiAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuc2V0KSkgZGVzY3JpcHRvci5zZXQgPSBfO1xuICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5pbml0KSkgaW5pdGlhbGl6ZXJzLnVuc2hpZnQoXyk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChfID0gYWNjZXB0KHJlc3VsdCkpIHtcbiAgICAgICAgICBpZiAoa2luZCA9PT0gXCJmaWVsZFwiKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgICAgICBlbHNlIGRlc2NyaXB0b3Jba2V5XSA9IF87XG4gICAgICB9XG4gIH1cbiAgaWYgKHRhcmdldCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgY29udGV4dEluLm5hbWUsIGRlc2NyaXB0b3IpO1xuICBkb25lID0gdHJ1ZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3J1bkluaXRpYWxpemVycyh0aGlzQXJnLCBpbml0aWFsaXplcnMsIHZhbHVlKSB7XG4gIHZhciB1c2VWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGluaXRpYWxpemVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWUgPSB1c2VWYWx1ZSA/IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcsIHZhbHVlKSA6IGluaXRpYWxpemVyc1tpXS5jYWxsKHRoaXNBcmcpO1xuICB9XG4gIHJldHVybiB1c2VWYWx1ZSA/IHZhbHVlIDogdm9pZCAwO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fcHJvcEtleSh4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gXCJzeW1ib2xcIiA/IHggOiBcIlwiLmNvbmNhdCh4KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3NldEZ1bmN0aW9uTmFtZShmLCBuYW1lLCBwcmVmaXgpIHtcbiAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN5bWJvbFwiKSBuYW1lID0gbmFtZS5kZXNjcmlwdGlvbiA/IFwiW1wiLmNvbmNhdChuYW1lLmRlc2NyaXB0aW9uLCBcIl1cIikgOiBcIlwiO1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGYsIFwibmFtZVwiLCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSwgdmFsdWU6IHByZWZpeCA/IFwiXCIuY29uY2F0KHByZWZpeCwgXCIgXCIsIG5hbWUpIDogbmFtZSB9KTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX21ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XG4gIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGcgPSBPYmplY3QuY3JlYXRlKCh0eXBlb2YgSXRlcmF0b3IgPT09IFwiZnVuY3Rpb25cIiA/IEl0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpO1xuICByZXR1cm4gZy5uZXh0ID0gdmVyYigwKSwgZ1tcInRocm93XCJdID0gdmVyYigxKSwgZ1tcInJldHVyblwiXSA9IHZlcmIoMiksIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgIHdoaWxlIChnICYmIChnID0gMCwgb3BbMF0gJiYgKF8gPSAwKSksIF8pIHRyeSB7XG4gICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcbiAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgfVxufVxuXG5leHBvcnQgdmFyIF9fY3JlYXRlQmluZGluZyA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgb1trMl0gPSBtW2tdO1xufSk7XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xuICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XG4gIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICB9XG4gIH07XG4gIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XG4gIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgaWYgKCFtKSByZXR1cm4gbztcbiAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gIHRyeSB7XG4gICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgfVxuICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgfVxuICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gIH1cbiAgcmV0dXJuIGFyO1xufVxuXG4vKiogQGRlcHJlY2F0ZWQgKi9cbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZCgpIHtcbiAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXG4gICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XG4gIHJldHVybiBhcjtcbn1cblxuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XG4gIGZvciAodmFyIHMgPSAwLCBpID0gMCwgaWwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWw7IGkrKykgcyArPSBhcmd1bWVudHNbaV0ubGVuZ3RoO1xuICBmb3IgKHZhciByID0gQXJyYXkocyksIGsgPSAwLCBpID0gMDsgaSA8IGlsOyBpKyspXG4gICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcbiAgICAgICAgICByW2tdID0gYVtqXTtcbiAgcmV0dXJuIHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XG4gIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICB9XG4gIH1cbiAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcbiAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xuICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xuICByZXR1cm4gaSA9IE9iamVjdC5jcmVhdGUoKHR5cGVvZiBBc3luY0l0ZXJhdG9yID09PSBcImZ1bmN0aW9uXCIgPyBBc3luY0l0ZXJhdG9yIDogT2JqZWN0KS5wcm90b3R5cGUpLCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIsIGF3YWl0UmV0dXJuKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICBmdW5jdGlvbiBhd2FpdFJldHVybihmKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHYpLnRoZW4oZiwgcmVqZWN0KTsgfTsgfVxuICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaWYgKGdbbl0pIHsgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAoYSwgYikgeyBxLnB1c2goW24sIHYsIGEsIGJdKSA+IDEgfHwgcmVzdW1lKG4sIHYpOyB9KTsgfTsgaWYgKGYpIGlbbl0gPSBmKGlbbl0pOyB9IH1cbiAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxuICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cbiAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxuICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XG4gIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xuICB2YXIgaSwgcDtcbiAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogZmFsc2UgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xuICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xuICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XG4gIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cbiAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcbiAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cbiAgcmV0dXJuIGNvb2tlZDtcbn07XG5cbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gIG9bXCJkZWZhdWx0XCJdID0gdjtcbn07XG5cbnZhciBvd25LZXlzID0gZnVuY3Rpb24obykge1xuICBvd25LZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gKG8pIHtcbiAgICB2YXIgYXIgPSBbXTtcbiAgICBmb3IgKHZhciBrIGluIG8pIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobywgaykpIGFyW2FyLmxlbmd0aF0gPSBrO1xuICAgIHJldHVybiBhcjtcbiAgfTtcbiAgcmV0dXJuIG93bktleXMobyk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnRTdGFyKG1vZCkge1xuICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICB2YXIgcmVzdWx0ID0ge307XG4gIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayA9IG93bktleXMobW9kKSwgaSA9IDA7IGkgPCBrLmxlbmd0aDsgaSsrKSBpZiAoa1tpXSAhPT0gXCJkZWZhdWx0XCIpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwga1tpXSk7XG4gIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XG4gIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZFNldChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRJbihzdGF0ZSwgcmVjZWl2ZXIpIHtcbiAgaWYgKHJlY2VpdmVyID09PSBudWxsIHx8ICh0eXBlb2YgcmVjZWl2ZXIgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHJlY2VpdmVyICE9PSBcImZ1bmN0aW9uXCIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHVzZSAnaW4nIG9wZXJhdG9yIG9uIG5vbi1vYmplY3RcIik7XG4gIHJldHVybiB0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyID09PSBzdGF0ZSA6IHN0YXRlLmhhcyhyZWNlaXZlcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZShlbnYsIHZhbHVlLCBhc3luYykge1xuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHZvaWQgMCkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIHZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJPYmplY3QgZXhwZWN0ZWQuXCIpO1xuICAgIHZhciBkaXNwb3NlLCBpbm5lcjtcbiAgICBpZiAoYXN5bmMpIHtcbiAgICAgIGlmICghU3ltYm9sLmFzeW5jRGlzcG9zZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0Rpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5hc3luY0Rpc3Bvc2VdO1xuICAgIH1cbiAgICBpZiAoZGlzcG9zZSA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAoIVN5bWJvbC5kaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmRpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgZGlzcG9zZSA9IHZhbHVlW1N5bWJvbC5kaXNwb3NlXTtcbiAgICAgIGlmIChhc3luYykgaW5uZXIgPSBkaXNwb3NlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRpc3Bvc2UgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBub3QgZGlzcG9zYWJsZS5cIik7XG4gICAgaWYgKGlubmVyKSBkaXNwb3NlID0gZnVuY3Rpb24oKSB7IHRyeSB7IGlubmVyLmNhbGwodGhpcyk7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIFByb21pc2UucmVqZWN0KGUpOyB9IH07XG4gICAgZW52LnN0YWNrLnB1c2goeyB2YWx1ZTogdmFsdWUsIGRpc3Bvc2U6IGRpc3Bvc2UsIGFzeW5jOiBhc3luYyB9KTtcbiAgfVxuICBlbHNlIGlmIChhc3luYykge1xuICAgIGVudi5zdGFjay5wdXNoKHsgYXN5bmM6IHRydWUgfSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG52YXIgX1N1cHByZXNzZWRFcnJvciA9IHR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xuICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2Rpc3Bvc2VSZXNvdXJjZXMoZW52KSB7XG4gIGZ1bmN0aW9uIGZhaWwoZSkge1xuICAgIGVudi5lcnJvciA9IGVudi5oYXNFcnJvciA/IG5ldyBfU3VwcHJlc3NlZEVycm9yKGUsIGVudi5lcnJvciwgXCJBbiBlcnJvciB3YXMgc3VwcHJlc3NlZCBkdXJpbmcgZGlzcG9zYWwuXCIpIDogZTtcbiAgICBlbnYuaGFzRXJyb3IgPSB0cnVlO1xuICB9XG4gIHZhciByLCBzID0gMDtcbiAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB3aGlsZSAociA9IGVudi5zdGFjay5wb3AoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFyLmFzeW5jICYmIHMgPT09IDEpIHJldHVybiBzID0gMCwgZW52LnN0YWNrLnB1c2gociksIFByb21pc2UucmVzb2x2ZSgpLnRoZW4obmV4dCk7XG4gICAgICAgIGlmIChyLmRpc3Bvc2UpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gci5kaXNwb3NlLmNhbGwoci52YWx1ZSk7XG4gICAgICAgICAgaWYgKHIuYXN5bmMpIHJldHVybiBzIHw9IDIsIFByb21pc2UucmVzb2x2ZShyZXN1bHQpLnRoZW4obmV4dCwgZnVuY3Rpb24oZSkgeyBmYWlsKGUpOyByZXR1cm4gbmV4dCgpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHMgfD0gMTtcbiAgICAgIH1cbiAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGZhaWwoZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzID09PSAxKSByZXR1cm4gZW52Lmhhc0Vycm9yID8gUHJvbWlzZS5yZWplY3QoZW52LmVycm9yKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIGlmIChlbnYuaGFzRXJyb3IpIHRocm93IGVudi5lcnJvcjtcbiAgfVxuICByZXR1cm4gbmV4dCgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19yZXdyaXRlUmVsYXRpdmVJbXBvcnRFeHRlbnNpb24ocGF0aCwgcHJlc2VydmVKc3gpIHtcbiAgaWYgKHR5cGVvZiBwYXRoID09PSBcInN0cmluZ1wiICYmIC9eXFwuXFwuP1xcLy8udGVzdChwYXRoKSkge1xuICAgICAgcmV0dXJuIHBhdGgucmVwbGFjZSgvXFwuKHRzeCkkfCgoPzpcXC5kKT8pKCg/OlxcLlteLi9dKz8pPylcXC4oW2NtXT8pdHMkL2ksIGZ1bmN0aW9uIChtLCB0c3gsIGQsIGV4dCwgY20pIHtcbiAgICAgICAgICByZXR1cm4gdHN4ID8gcHJlc2VydmVKc3ggPyBcIi5qc3hcIiA6IFwiLmpzXCIgOiBkICYmICghZXh0IHx8ICFjbSkgPyBtIDogKGQgKyBleHQgKyBcIi5cIiArIGNtLnRvTG93ZXJDYXNlKCkgKyBcImpzXCIpO1xuICAgICAgfSk7XG4gIH1cbiAgcmV0dXJuIHBhdGg7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgX19leHRlbmRzLFxuICBfX2Fzc2lnbixcbiAgX19yZXN0LFxuICBfX2RlY29yYXRlLFxuICBfX3BhcmFtLFxuICBfX2VzRGVjb3JhdGUsXG4gIF9fcnVuSW5pdGlhbGl6ZXJzLFxuICBfX3Byb3BLZXksXG4gIF9fc2V0RnVuY3Rpb25OYW1lLFxuICBfX21ldGFkYXRhLFxuICBfX2F3YWl0ZXIsXG4gIF9fZ2VuZXJhdG9yLFxuICBfX2NyZWF0ZUJpbmRpbmcsXG4gIF9fZXhwb3J0U3RhcixcbiAgX192YWx1ZXMsXG4gIF9fcmVhZCxcbiAgX19zcHJlYWQsXG4gIF9fc3ByZWFkQXJyYXlzLFxuICBfX3NwcmVhZEFycmF5LFxuICBfX2F3YWl0LFxuICBfX2FzeW5jR2VuZXJhdG9yLFxuICBfX2FzeW5jRGVsZWdhdG9yLFxuICBfX2FzeW5jVmFsdWVzLFxuICBfX21ha2VUZW1wbGF0ZU9iamVjdCxcbiAgX19pbXBvcnRTdGFyLFxuICBfX2ltcG9ydERlZmF1bHQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRHZXQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRTZXQsXG4gIF9fY2xhc3NQcml2YXRlRmllbGRJbixcbiAgX19hZGREaXNwb3NhYmxlUmVzb3VyY2UsXG4gIF9fZGlzcG9zZVJlc291cmNlcyxcbiAgX19yZXdyaXRlUmVsYXRpdmVJbXBvcnRFeHRlbnNpb24sXG59O1xuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHRpZDogbW9kdWxlSWQsXG5cdFx0bG9hZGVkOiBmYWxzZSxcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG5cdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm5tZCA9IChtb2R1bGUpID0+IHtcblx0bW9kdWxlLnBhdGhzID0gW107XG5cdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0cmV0dXJuIG1vZHVsZTtcbn07IiwiaW1wb3J0IHsgX19hd2FpdGVyIH0gZnJvbSBcInRzbGliXCI7XG5pbXBvcnQgeyBHcmFwaCB9IGZyb20gXCJAYW50di9ncmFwaGxpYlwiO1xuaW1wb3J0ICogYXMgQ29tbGluayBmcm9tIFwiY29tbGlua1wiO1xuaW1wb3J0IHsgcmVnaXN0cnkgfSBmcm9tIFwiLi9yZWdpc3RyeVwiO1xuaW1wb3J0IHsgaXNMYXlvdXRXaXRoSXRlcmF0aW9ucyB9IGZyb20gXCIuL3R5cGVzXCI7XG5sZXQgY3VycmVudExheW91dDtcbmNvbnN0IG9iaiA9IHtcbiAgICBzdG9wTGF5b3V0KCkge1xuICAgICAgICBpZiAoY3VycmVudExheW91dCA9PT0gbnVsbCB8fCBjdXJyZW50TGF5b3V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50TGF5b3V0LnN0b3ApIHtcbiAgICAgICAgICAgIGN1cnJlbnRMYXlvdXQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBjYWxjdWxhdGVMYXlvdXQocGF5bG9hZCwgdHJhbnNmZXJhYmxlcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBsYXlvdXQ6IHsgaWQsIG9wdGlvbnMsIGl0ZXJhdGlvbnMgfSwgbm9kZXMsIGVkZ2VzLCB9ID0gcGF5bG9hZDtcbiAgICAgICAgICAgIC8vIFN5bmMgZ3JhcGggb24gdGhlIHdvcmtlciBzaWRlLlxuICAgICAgICAgICAgLy8gVE9ETzogVXNlIHRyYW5zZmVyYWJsZSBvYmplY3RzIGxpa2UgQXJyYXlCdWZmZXIgZm9yIG5vZGVzICYgZWRnZXMsXG4gICAgICAgICAgICAvLyBpbiB3aGljaCBjYXNlIHdlIGRvbid0IG5lZWQgdGhlIHdob2xlIGdyYXBoLlxuICAgICAgICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vZ3JhcGhvbG9neS9ncmFwaG9sb2d5L2Jsb2IvbWFzdGVyL3NyYy9sYXlvdXQtbm92ZXJsYXAvd2Vid29ya2VyLnRwbC5qcyNMMzJcbiAgICAgICAgICAgIGNvbnN0IGdyYXBoID0gbmV3IEdyYXBoKHtcbiAgICAgICAgICAgICAgICBub2RlcyxcbiAgICAgICAgICAgICAgICBlZGdlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGUgbGF5b3V0IGluc3RhbmNlIG9uIHRoZSB3b3JrZXIgc2lkZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgbGF5b3V0Q3RvciA9IHJlZ2lzdHJ5W2lkXTtcbiAgICAgICAgICAgIGlmIChsYXlvdXRDdG9yKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudExheW91dCA9IG5ldyBsYXlvdXRDdG9yKG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGxheW91dCBpZDogJHtpZH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwb3NpdGlvbnMgPSB5aWVsZCBjdXJyZW50TGF5b3V0LmV4ZWN1dGUoZ3JhcGgpO1xuICAgICAgICAgICAgaWYgKGlzTGF5b3V0V2l0aEl0ZXJhdGlvbnMoY3VycmVudExheW91dCkpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TGF5b3V0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbnMgPSBjdXJyZW50TGF5b3V0LnRpY2soaXRlcmF0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW3Bvc2l0aW9ucywgdHJhbnNmZXJhYmxlc107XG4gICAgICAgIH0pO1xuICAgIH0sXG59O1xuQ29tbGluay5leHBvc2Uob2JqKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmtlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=